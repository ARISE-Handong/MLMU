[new, Gaussian, ., Parametric, (, ), {, @, Override, public, double, value, (, double, x, ,, double, ..., p, ), {, double, v, =, Double, ., POSITIVE_INFINITY, ;, try, {, v, =, super, ., value, (, x, ,, p, ), ;, }, catch, (, NotStrictlyPositiveException, e, ), {, }, return, v, ;, }, @, Override, public, double, [, ], gradient, (, double, x, ,, double, ..., p, ), {, double, [, ], v, =, {, Double, ., POSITIVE_INFINITY, ,, Double, ., POSITIVE_INFINITY, ,, Double, ., POSITIVE_INFINITY, }, ;, try, {, v, =, super, ., gradient, (, x, ,, p, ), ;, }, catch, (, NotStrictlyPositiveException, e, ), {, }, return, v, ;, }, }]
[Double, ., POSITIVE_INFINITY]
[Double]
[v]
[super, ., value, (, x, ,, p, )]
[super]
[x]
[p]
[v]
[{, Double, ., POSITIVE_INFINITY, ,, Double, ., POSITIVE_INFINITY, ,, Double, ., POSITIVE_INFINITY, }]
[Double, ., POSITIVE_INFINITY]
[Double]
[Double, ., POSITIVE_INFINITY]
[Double]
[Double, ., POSITIVE_INFINITY]
[Double]
[v]
[super, ., gradient, (, x, ,, p, )]
[super]
[x]
[p]
[v]
[this, ., initialGuess]
[this]
[initialGuess]
[this, ., maxIter]
[this]
[maxIter]
[new, GaussianCurveFitter, (, null, ,, Integer, ., MAX_VALUE, )]
[null]
[Integer, ., MAX_VALUE]
[Integer]
[new, GaussianCurveFitter, (, start, ., clone, (, ), ,, maxIter, )]
[start, ., clone, (, )]
[start]
[maxIter]
[new, GaussianCurveFitter, (, initialGuess, ,, max, )]
[initialGuess]
[max]
[observations, ., size, (, )]
[observations]
[new, double, [, len, ]]
[len]
[new, double, [, len, ]]
[len]
[0]
[observations]
[target, [, i, ]]
[target]
[i]
[obs, ., getY, (, )]
[obs]
[weights, [, i, ]]
[weights]
[i]
[obs, ., getWeight, (, )]
[obs]
[++, i]
[i]
[new, AbstractCurveFitter, ., TheoreticalValuesFunction, (, FUNCTION, ,, observations, )]
[FUNCTION]
[observations]
[initialGuess, !=, null, ?, initialGuess, :, new, ParameterGuesser, (, observations, ), ., guess, (, )]
[initialGuess, !=, null]
[initialGuess]
[null]
[initialGuess]
[new, ParameterGuesser, (, observations, ), ., guess, (, )]
[new, ParameterGuesser, (, observations, )]
[observations]
[LevenbergMarquardtOptimizer, ., create, (, ), ., withMaxEvaluations, (, Integer, ., MAX_VALUE, ), ., withMaxIterations, (, maxIter, ), ., withStartPoint, (, startPoint, ), ., withTarget, (, target, ), ., withWeight, (, new, DiagonalMatrix, (, weights, ), ), ., withModelAndJacobian, (, model, ., getModelFunction, (, ), ,, model, ., getModelFunctionJacobian, (, ), )]
[LevenbergMarquardtOptimizer, ., create, (, ), ., withMaxEvaluations, (, Integer, ., MAX_VALUE, ), ., withMaxIterations, (, maxIter, ), ., withStartPoint, (, startPoint, ), ., withTarget, (, target, ), ., withWeight, (, new, DiagonalMatrix, (, weights, ), )]
[LevenbergMarquardtOptimizer, ., create, (, ), ., withMaxEvaluations, (, Integer, ., MAX_VALUE, ), ., withMaxIterations, (, maxIter, ), ., withStartPoint, (, startPoint, ), ., withTarget, (, target, )]
[LevenbergMarquardtOptimizer, ., create, (, ), ., withMaxEvaluations, (, Integer, ., MAX_VALUE, ), ., withMaxIterations, (, maxIter, ), ., withStartPoint, (, startPoint, )]
[LevenbergMarquardtOptimizer, ., create, (, ), ., withMaxEvaluations, (, Integer, ., MAX_VALUE, ), ., withMaxIterations, (, maxIter, )]
[LevenbergMarquardtOptimizer, ., create, (, ), ., withMaxEvaluations, (, Integer, ., MAX_VALUE, )]
[LevenbergMarquardtOptimizer, ., create, (, )]
[LevenbergMarquardtOptimizer]
[Integer, ., MAX_VALUE]
[Integer]
[maxIter]
[startPoint]
[target]
[new, DiagonalMatrix, (, weights, )]
[weights]
[model, ., getModelFunction, (, )]
[model]
[model, ., getModelFunctionJacobian, (, )]
[model]
[observations, ==, null]
[observations]
[null]
[new, NullArgumentException, (, LocalizedFormats, ., INPUT_ARRAY, )]
[LocalizedFormats, ., INPUT_ARRAY]
[LocalizedFormats]
[observations, ., size, (, ), <, 3]
[observations, ., size, (, )]
[observations]
[3]
[new, NumberIsTooSmallException, (, observations, ., size, (, ), ,, 3, ,, true, )]
[observations, ., size, (, )]
[observations]
[3]
[true]
[sortObservations, (, observations, )]
[observations]
[basicGuess, (, sorted, ., toArray, (, new, WeightedObservedPoint, [, 0, ], ), )]
[sorted, ., toArray, (, new, WeightedObservedPoint, [, 0, ], )]
[sorted]
[new, WeightedObservedPoint, [, 0, ]]
[0]
[norm]
[params, [, 0, ]]
[params]
[0]
[mean]
[params, [, 1, ]]
[params]
[1]
[sigma]
[params, [, 2, ]]
[params]
[2]
[new, double, [, ], {, norm, ,, mean, ,, sigma, }]
[{, norm, ,, mean, ,, sigma, }]
[norm]
[mean]
[sigma]
[new, ArrayList, <, WeightedObservedPoint, >, (, unsorted, )]
[unsorted]
[new, Comparator, <, WeightedObservedPoint, >, (, ), {, public, int, compare, (, WeightedObservedPoint, p1, ,, WeightedObservedPoint, p2, ), {, if, (, p1, ==, null, &&, p2, ==, null, ), {, return, 0, ;, }, if, (, p1, ==, null, ), {, return, -, 1, ;, }, if, (, p2, ==, null, ), {, return, 1, ;, }, if, (, p1, ., getX, (, ), <, p2, ., getX, (, ), ), {, return, -, 1, ;, }, if, (, p1, ., getX, (, ), >, p2, ., getX, (, ), ), {, return, 1, ;, }, if, (, p1, ., getY, (, ), <, p2, ., getY, (, ), ), {, return, -, 1, ;, }, if, (, p1, ., getY, (, ), >, p2, ., getY, (, ), ), {, return, 1, ;, }, if, (, p1, ., getWeight, (, ), <, p2, ., getWeight, (, ), ), {, return, -, 1, ;, }, if, (, p1, ., getWeight, (, ), >, p2, ., getWeight, (, ), ), {, return, 1, ;, }, return, 0, ;, }, }]
[p1, ==, null, &&, p2, ==, null]
[p1, ==, null]
[p1]
[null]
[p2, ==, null]
[p2]
[null]
[0]
[p1, ==, null]
[p1]
[null]
[-, 1]
[1]
[p2, ==, null]
[p2]
[null]
[1]
[p1, ., getX, (, ), <, p2, ., getX, (, )]
[p1, ., getX, (, )]
[p1]
[p2, ., getX, (, )]
[p2]
[-, 1]
[1]
[p1, ., getX, (, ), >, p2, ., getX, (, )]
[p1, ., getX, (, )]
[p1]
[p2, ., getX, (, )]
[p2]
[1]
[p1, ., getY, (, ), <, p2, ., getY, (, )]
[p1, ., getY, (, )]
[p1]
[p2, ., getY, (, )]
[p2]
[-, 1]
[1]
[p1, ., getY, (, ), >, p2, ., getY, (, )]
[p1, ., getY, (, )]
[p1]
[p2, ., getY, (, )]
[p2]
[1]
[p1, ., getWeight, (, ), <, p2, ., getWeight, (, )]
[p1, ., getWeight, (, )]
[p1]
[p2, ., getWeight, (, )]
[p2]
[-, 1]
[1]
[p1, ., getWeight, (, ), >, p2, ., getWeight, (, )]
[p1, ., getWeight, (, )]
[p1]
[p2, ., getWeight, (, )]
[p2]
[1]
[0]
[Collections, ., sort, (, observations, ,, cmp, )]
[Collections]
[observations]
[cmp]
[observations]
[findMaxY, (, points, )]
[points]
[points, [, maxYIdx, ], ., getY, (, )]
[points, [, maxYIdx, ]]
[points]
[maxYIdx]
[points, [, maxYIdx, ], ., getX, (, )]
[points, [, maxYIdx, ]]
[points]
[maxYIdx]
[n, +, (, (, m, -, n, ), /, 2, )]
[n]
[(, (, m, -, n, ), /, 2, )]
[(, m, -, n, ), /, 2]
[(, m, -, n, )]
[m, -, n]
[m]
[n]
[2]
[interpolateXAtY, (, points, ,, maxYIdx, ,, -, 1, ,, halfY, )]
[points]
[maxYIdx]
[-, 1]
[1]
[halfY]
[interpolateXAtY, (, points, ,, maxYIdx, ,, 1, ,, halfY, )]
[points]
[maxYIdx]
[1]
[halfY]
[fwhmApprox]
[fwhmX2, -, fwhmX1]
[fwhmX2]
[fwhmX1]
[fwhmApprox]
[points, [, points, ., length, -, 1, ], ., getX, (, ), -, points, [, 0, ], ., getX, (, )]
[points, [, points, ., length, -, 1, ], ., getX, (, )]
[points, [, points, ., length, -, 1, ]]
[points]
[points, ., length, -, 1]
[points, ., length]
[points]
[1]
[points, [, 0, ], ., getX, (, )]
[points, [, 0, ]]
[points]
[0]
[fwhmApprox, /, (, 2, *, FastMath, ., sqrt, (, 2, *, FastMath, ., log, (, 2, ), ), )]
[fwhmApprox]
[(, 2, *, FastMath, ., sqrt, (, 2, *, FastMath, ., log, (, 2, ), ), )]
[2, *, FastMath, ., sqrt, (, 2, *, FastMath, ., log, (, 2, ), )]
[2]
[FastMath, ., sqrt, (, 2, *, FastMath, ., log, (, 2, ), )]
[FastMath]
[2, *, FastMath, ., log, (, 2, )]
[2]
[FastMath, ., log, (, 2, )]
[FastMath]
[2]
[new, double, [, ], {, n, ,, m, ,, s, }]
[{, n, ,, m, ,, s, }]
[n]
[m]
[s]
[0]
[1]
[i, <, points, ., length]
[i]
[points, ., length]
[points]
[i, ++]
[i]
[points, [, i, ], ., getY, (, ), >, points, [, maxYIdx, ], ., getY, (, )]
[points, [, i, ], ., getY, (, )]
[points, [, i, ]]
[points]
[i]
[points, [, maxYIdx, ], ., getY, (, )]
[points, [, maxYIdx, ]]
[points]
[maxYIdx]
[maxYIdx]
[i]
[maxYIdx]
[idxStep, ==, 0]
[idxStep]
[0]
[new, ZeroException, (, )]
[getInterpolationPointsForY, (, points, ,, startIdx, ,, idxStep, ,, y, )]
[points]
[startIdx]
[idxStep]
[y]
[twoPoints, [, 0, ]]
[twoPoints]
[0]
[twoPoints, [, 1, ]]
[twoPoints]
[1]
[p1, ., getY, (, ), ==, y]
[p1, ., getY, (, )]
[p1]
[y]
[p1, ., getX, (, )]
[p1]
[p2, ., getY, (, ), ==, y]
[p2, ., getY, (, )]
[p2]
[y]
[p2, ., getX, (, )]
[p2]
[p1, ., getX, (, ), +, (, (, (, y, -, p1, ., getY, (, ), ), *, (, p2, ., getX, (, ), -, p1, ., getX, (, ), ), ), /, (, p2, ., getY, (, ), -, p1, ., getY, (, ), ), )]
[p1, ., getX, (, )]
[p1]
[(, (, (, y, -, p1, ., getY, (, ), ), *, (, p2, ., getX, (, ), -, p1, ., getX, (, ), ), ), /, (, p2, ., getY, (, ), -, p1, ., getY, (, ), ), )]
[(, (, y, -, p1, ., getY, (, ), ), *, (, p2, ., getX, (, ), -, p1, ., getX, (, ), ), ), /, (, p2, ., getY, (, ), -, p1, ., getY, (, ), )]
[(, (, y, -, p1, ., getY, (, ), ), *, (, p2, ., getX, (, ), -, p1, ., getX, (, ), ), )]
[(, y, -, p1, ., getY, (, ), ), *, (, p2, ., getX, (, ), -, p1, ., getX, (, ), )]
[(, y, -, p1, ., getY, (, ), )]
[y, -, p1, ., getY, (, )]
[y]
[p1, ., getY, (, )]
[p1]
[(, p2, ., getX, (, ), -, p1, ., getX, (, ), )]
[p2, ., getX, (, ), -, p1, ., getX, (, )]
[p2, ., getX, (, )]
[p2]
[p1, ., getX, (, )]
[p1]
[(, p2, ., getY, (, ), -, p1, ., getY, (, ), )]
[p2, ., getY, (, ), -, p1, ., getY, (, )]
[p2, ., getY, (, )]
[p2]
[p1, ., getY, (, )]
[p1]
[idxStep, ==, 0]
[idxStep]
[0]
[new, ZeroException, (, )]
[startIdx]
[idxStep, <, 0, ?, i, +, idxStep, >=, 0, :, i, +, idxStep, <, points, ., length]
[idxStep, <, 0]
[idxStep]
[0]
[i, +, idxStep, >=, 0]
[i, +, idxStep]
[i]
[idxStep]
[0]
[i, +, idxStep, <, points, ., length]
[i, +, idxStep]
[i]
[idxStep]
[points, ., length]
[points]
[i]
[idxStep]
[points, [, i, ]]
[points]
[i]
[points, [, i, +, idxStep, ]]
[points]
[i, +, idxStep]
[i]
[idxStep]
[isBetween, (, y, ,, p1, ., getY, (, ), ,, p2, ., getY, (, ), )]
[y]
[p1, ., getY, (, )]
[p1]
[p2, ., getY, (, )]
[p2]
[idxStep, <, 0]
[idxStep]
[0]
[new, WeightedObservedPoint, [, ], {, p2, ,, p1, }]
[{, p2, ,, p1, }]
[p2]
[p1]
[new, WeightedObservedPoint, [, ], {, p1, ,, p2, }]
[{, p1, ,, p2, }]
[p1]
[p2]
[new, OutOfRangeException, (, y, ,, Double, ., NEGATIVE_INFINITY, ,, Double, ., POSITIVE_INFINITY, )]
[y]
[Double, ., NEGATIVE_INFINITY]
[Double]
[Double, ., POSITIVE_INFINITY]
[Double]
[(, value, >=, boundary1, &&, value, <=, boundary2, ), ||, (, value, >=, boundary2, &&, value, <=, boundary1, )]
[(, value, >=, boundary1, &&, value, <=, boundary2, )]
[value, >=, boundary1, &&, value, <=, boundary2]
[value, >=, boundary1]
[value]
[boundary1]
[value, <=, boundary2]
[value]
[boundary2]
[(, value, >=, boundary2, &&, value, <=, boundary1, )]
[value, >=, boundary2, &&, value, <=, boundary1]
[value, >=, boundary2]
[value]
[boundary2]
[value, <=, boundary1]
[value]
[boundary1]
