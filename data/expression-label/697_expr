[Preconditions, ., checkNotNull, (, compiler, )]
[Preconditions]
[compiler]
[Preconditions, ., checkNotNull, (, safeNameIdSupplier, )]
[Preconditions]
[safeNameIdSupplier]
[Preconditions, ., checkNotNull, (, constNames, )]
[Preconditions]
[constNames]
[this, ., compiler]
[this]
[compiler]
[this, ., safeNameIdSupplier]
[this]
[safeNameIdSupplier]
[this, ., knownConstants]
[this]
[constNames]
[100]
[0]
[DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression, (, expression, )]
[DecompositionType, ., DECOMPOSABLE]
[DecompositionType]
[canExposeExpression, (, expression, )]
[expression]
[exposeExpression, (, expression, )]
[expression]
[i, ++]
[i]
[i, >, MAX_INTERATIONS]
[i]
[MAX_INTERATIONS]
[new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +, expression, ., toStringTree, (, ), )]
["DecomposeExpression depth exceeded on :\n", +, expression, ., toStringTree, (, )]
["DecomposeExpression depth exceeded on :\n"]
[expression, ., toStringTree, (, )]
[expression]
[findExpressionRoot, (, expression, )]
[expression]
[Preconditions, ., checkState, (, expressionRoot, !=, null, )]
[Preconditions]
[expressionRoot, !=, null]
[expressionRoot]
[null]
[exposeExpression, (, expressionRoot, ,, expression, )]
[expressionRoot]
[expression]
[compiler, ., reportCodeChange, (, )]
[compiler]
[getResultValueName, (, )]
[findInjectionPoint, (, expression, )]
[expression]
[Preconditions, ., checkNotNull, (, injectionPoint, )]
[Preconditions]
[injectionPoint]
[injectionPoint, ., getParent, (, )]
[injectionPoint]
[Preconditions, ., checkNotNull, (, injectionPointParent, )]
[Preconditions]
[injectionPointParent]
[Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), )]
[Preconditions]
[NodeUtil, ., isStatementBlock, (, injectionPointParent, )]
[NodeUtil]
[injectionPointParent]
[expression, ., getParent, (, )]
[expression]
[expressionParent, ., replaceChild, (, expression, ,, IR, ., name, (, resultName, ), )]
[expressionParent]
[expression]
[IR, ., name, (, resultName, )]
[IR]
[resultName]
[NodeUtil, ., newVarNode, (, resultName, ,, expression, )]
[NodeUtil]
[resultName]
[expression]
[injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,, injectionPoint, )]
[injectionPointParent]
[newExpressionRoot]
[injectionPoint]
[compiler, ., reportCodeChange, (, )]
[compiler]
[findNonconditionalParent, (, subExpression, ,, expressionRoot, )]
[subExpression]
[expressionRoot]
[NodeUtil, ., mayHaveSideEffects, (, nonconditionalExpr, ,, compiler, )]
[NodeUtil]
[nonconditionalExpr]
[compiler]
[findInjectionPoint, (, nonconditionalExpr, )]
[nonconditionalExpr]
[new, DecompositionState, (, )]
[state, ., sideEffects]
[state]
[hasFollowingSideEffects]
[state, ., extractBeforeStatement]
[state]
[exprInjectionPoint]
[null]
[nonconditionalExpr]
[child, ., getParent, (, )]
[child]
[parent, !=, expressionRoot]
[parent]
[expressionRoot]
[grandchild]
[child]
[child]
[parent]
[parent]
[child, ., getParent, (, )]
[child]
[parent, ., getType, (, )]
[parent]
[Preconditions, ., checkState, (, !, isConditionalOp, (, parent, ), ||, child, ==, parent, ., getFirstChild, (, ), )]
[Preconditions]
[!, isConditionalOp, (, parent, ), ||, child, ==, parent, ., getFirstChild, (, )]
[!, isConditionalOp, (, parent, )]
[isConditionalOp, (, parent, )]
[parent]
[child, ==, parent, ., getFirstChild, (, )]
[child]
[parent, ., getFirstChild, (, )]
[parent]
[parentType, ==, Token, ., ASSIGN]
[parentType]
[Token, ., ASSIGN]
[Token]
[isSafeAssign, (, parent, ,, state, ., sideEffects, )]
[parent]
[state, ., sideEffects]
[state]
[parent, ., getFirstChild, (, )]
[parent]
[left, ., getType, (, )]
[left]
[left, !=, child]
[left]
[child]
[Preconditions, ., checkState, (, NodeUtil, ., isGet, (, left, ), )]
[Preconditions]
[NodeUtil, ., isGet, (, left, )]
[NodeUtil]
[left]
[type, ==, Token, ., GETELEM]
[type]
[Token, ., GETELEM]
[Token]
[decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,, state, )]
[left, ., getLastChild, (, )]
[left]
[null]
[state]
[decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null, ,, state, )]
[left, ., getFirstChild, (, )]
[left]
[null]
[state]
[parentType, ==, Token, ., CALL, &&, NodeUtil, ., isGet, (, parent, ., getFirstChild, (, ), )]
[parentType, ==, Token, ., CALL]
[parentType]
[Token, ., CALL]
[Token]
[NodeUtil, ., isGet, (, parent, ., getFirstChild, (, ), )]
[NodeUtil]
[parent, ., getFirstChild, (, )]
[parent]
[parent, ., getFirstChild, (, )]
[parent]
[decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child, ,, state, )]
[functionExpression, ., getNext, (, )]
[functionExpression]
[child]
[state]
[isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild]
[isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, )]
[functionExpression]
[state, ., sideEffects]
[state]
[functionExpression, ., getFirstChild, (, ), !=, grandchild]
[functionExpression, ., getFirstChild, (, )]
[functionExpression]
[grandchild]
[Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", )]
[Preconditions]
[allowObjectCallDecomposing, (, )]
["Object method calls can not be decomposed."]
[state, ., sideEffects]
[state]
[true]
[rewriteCallExpression, (, parent, ,, state, )]
[parent]
[state]
[parent]
[replacement]
[parentType, ==, Token, ., OBJECTLIT]
[parentType]
[Token, ., OBJECTLIT]
[Token]
[decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,, child, ,, state, )]
[parent, ., getFirstChild, (, )]
[parent]
[child]
[state]
[decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,, child, ,, state, )]
[parent, ., getFirstChild, (, )]
[parent]
[child]
[state]
[nonconditionalExpr, ==, subExpression]
[nonconditionalExpr]
[subExpression]
[nonconditionalExpr, ., getParent, (, )]
[nonconditionalExpr]
[!, parent, ., isExprResult, (, )]
[parent, ., isExprResult, (, )]
[parent]
[extractConditional, (, nonconditionalExpr, ,, exprInjectionPoint, ,, needResult, )]
[nonconditionalExpr]
[exprInjectionPoint]
[needResult]
[false]
[true]
[subExpression]
[subExpression]
[child, ., getParent, (, )]
[child]
[parent, !=, expressionRoot]
[parent]
[expressionRoot]
[child]
[parent]
[parent]
[child, ., getParent, (, )]
[child]
[isConditionalOp, (, parent, )]
[parent]
[child, !=, parent, ., getFirstChild, (, )]
[child]
[parent, ., getFirstChild, (, )]
[parent]
[result]
[parent]
[result]
[key, ==, null, ||, key, ==, stopNode]
[key, ==, null]
[key]
[null]
[key, ==, stopNode]
[key]
[stopNode]
[decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state, )]
[key, ., getNext, (, )]
[key]
[stopNode]
[state]
[decomposeSubExpressions, (, key, ., getFirstChild, (, ), ,, stopNode, ,, state, )]
[key, ., getFirstChild, (, )]
[key]
[stopNode]
[state]
[n, ==, null, ||, n, ==, stopNode]
[n, ==, null]
[n]
[null]
[n, ==, stopNode]
[n]
[stopNode]
[Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (, ), ), )]
[Preconditions]
[!, NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (, ), )]
[NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (, ), )]
[NodeUtil]
[n]
[n, ., getParent, (, )]
[n]
[decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, )]
[n, ., getNext, (, )]
[n]
[stopNode]
[state]
[isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, )]
[n]
[state, ., sideEffects]
[state]
[state, ., sideEffects]
[state]
[true]
[state, ., extractBeforeStatement]
[state]
[extractExpression, (, n, ,, state, ., extractBeforeStatement, )]
[n]
[state, ., extractBeforeStatement]
[state]
[expr, ., getParent, (, )]
[expr]
[getTempValueName, (, )]
[expr, ., getFirstChild, (, )]
[expr]
[first, ., getNext, (, )]
[first]
[expr, ., getLastChild, (, )]
[expr]
[expr, ., detachChildren, (, )]
[expr]
[null]
[IR, ., block, (, ), ., srcref, (, expr, )]
[IR, ., block, (, )]
[IR]
[expr]
[IR, ., block, (, ), ., srcref, (, expr, )]
[IR, ., block, (, )]
[IR]
[expr]
[expr, ., getType, (, )]
[expr]
[Token, ., HOOK]
[Token]
[cond]
[first]
[trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), ), )]
[trueExpr]
[NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), )]
[NodeUtil]
[buildResultExpression, (, second, ,, needResult, ,, tempName, )]
[second]
[needResult]
[tempName]
[falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), )]
[falseExpr]
[NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), )]
[NodeUtil]
[buildResultExpression, (, last, ,, needResult, ,, tempName, )]
[last]
[needResult]
[tempName]
[Token, ., AND]
[Token]
[cond]
[buildResultExpression, (, first, ,, needResult, ,, tempName, )]
[first]
[needResult]
[tempName]
[trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), )]
[trueExpr]
[NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), )]
[NodeUtil]
[buildResultExpression, (, last, ,, needResult, ,, tempName, )]
[last]
[needResult]
[tempName]
[Token, ., OR]
[Token]
[cond]
[buildResultExpression, (, first, ,, needResult, ,, tempName, )]
[first]
[needResult]
[tempName]
[falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), )]
[falseExpr]
[NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), )]
[NodeUtil]
[buildResultExpression, (, last, ,, needResult, ,, tempName, )]
[last]
[needResult]
[tempName]
[new, IllegalStateException, (, "Unexpected.", )]
["Unexpected."]
[falseExpr, ., hasChildren, (, )]
[falseExpr]
[ifNode]
[IR, ., ifNode, (, cond, ,, trueExpr, ,, falseExpr, )]
[IR]
[cond]
[trueExpr]
[falseExpr]
[ifNode]
[IR, ., ifNode, (, cond, ,, trueExpr, )]
[IR]
[cond]
[trueExpr]
[ifNode, ., copyInformationFrom, (, expr, )]
[ifNode]
[expr]
[needResult]
[NodeUtil, ., newVarNode, (, tempName, ,, null, ), ., copyInformationFromForTree, (, expr, )]
[NodeUtil, ., newVarNode, (, tempName, ,, null, )]
[NodeUtil]
[tempName]
[null]
[expr]
[injectionPoint, ., getParent, (, )]
[injectionPoint]
[injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, )]
[injectionPointParent]
[tempVarNode]
[injectionPoint]
[injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, )]
[injectionPointParent]
[ifNode]
[tempVarNode]
[IR, ., name, (, tempName, )]
[IR]
[tempName]
[parent, ., replaceChild, (, expr, ,, replacementValueNode, )]
[parent]
[expr]
[replacementValueNode]
[Preconditions, ., checkArgument, (, parent, ., isExprResult, (, ), )]
[Preconditions]
[parent, ., isExprResult, (, )]
[parent]
[parent, ., getParent, (, )]
[parent]
[gramps, ., replaceChild, (, parent, ,, ifNode, )]
[gramps]
[parent]
[ifNode]
[ifNode]
[needResult]
[IR, ., assign, (, IR, ., name, (, tempName, ), ,, expr, ), ., srcrefTree, (, expr, )]
[IR, ., assign, (, IR, ., name, (, tempName, ), ,, expr, )]
[IR]
[IR, ., name, (, tempName, )]
[IR]
[tempName]
[expr]
[expr]
[expr]
[n, ., isName, (, ), &&, (, NodeUtil, ., isConstantName, (, n, ), ||, knownConstants, ., contains, (, n, ., getString, (, ), ), )]
[n, ., isName, (, )]
[n]
[(, NodeUtil, ., isConstantName, (, n, ), ||, knownConstants, ., contains, (, n, ., getString, (, ), ), )]
[NodeUtil, ., isConstantName, (, n, ), ||, knownConstants, ., contains, (, n, ., getString, (, ), )]
[NodeUtil, ., isConstantName, (, n, )]
[NodeUtil]
[n]
[knownConstants, ., contains, (, n, ., getString, (, ), )]
[knownConstants]
[n, ., getString, (, )]
[n]
[expr, ., getParent, (, )]
[expr]
[NodeUtil, ., isAssignmentOp, (, parent, ), &&, !, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, expr]
[NodeUtil, ., isAssignmentOp, (, parent, ), &&, !, parent, ., isAssign, (, )]
[NodeUtil, ., isAssignmentOp, (, parent, )]
[NodeUtil]
[parent]
[!, parent, ., isAssign, (, )]
[parent, ., isAssign, (, )]
[parent]
[parent, ., getFirstChild, (, ), ==, expr]
[parent, ., getFirstChild, (, )]
[parent]
[expr]
[null]
[isLhsOfAssignOp, &&, NodeUtil, ., isGet, (, expr, )]
[isLhsOfAssignOp]
[NodeUtil, ., isGet, (, expr, )]
[NodeUtil]
[expr]
[expr, ., children, (, )]
[expr]
[!, n, ., isString, (, ), &&, !, isConstantName, (, n, ,, knownConstants, )]
[!, n, ., isString, (, )]
[n, ., isString, (, )]
[n]
[!, isConstantName, (, n, ,, knownConstants, )]
[isConstantName, (, n, ,, knownConstants, )]
[n]
[knownConstants]
[extractExpression, (, n, ,, injectionPoint, )]
[n]
[injectionPoint]
[firstExtractedNode, ==, null]
[firstExtractedNode]
[null]
[firstExtractedNode]
[extractedNode]
[getTempConstantValueName, (, )]
[IR, ., name, (, tempName, ), ., srcref, (, expr, )]
[IR, ., name, (, tempName, )]
[IR]
[tempName]
[expr]
[isLhsOfAssignOp]
[Preconditions, ., checkState, (, expr, ., isName, (, ), ||, NodeUtil, ., isGet, (, expr, ), )]
[Preconditions]
[expr, ., isName, (, ), ||, NodeUtil, ., isGet, (, expr, )]
[expr, ., isName, (, )]
[expr]
[NodeUtil, ., isGet, (, expr, )]
[NodeUtil]
[expr]
[new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent, )]
[new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), )]
[NodeUtil, ., getOpFromAssignmentOp, (, parent, )]
[NodeUtil]
[parent]
[parent]
[parent, ., getLastChild, (, )]
[parent]
[parent, ., setType, (, Token, ., ASSIGN, )]
[parent]
[Token, ., ASSIGN]
[Token]
[parent, ., replaceChild, (, rightOperand, ,, opNode, )]
[parent]
[rightOperand]
[opNode]
[opNode, ., addChildToFront, (, replacementValueNode, )]
[opNode]
[replacementValueNode]
[opNode, ., addChildToBack, (, rightOperand, )]
[opNode]
[rightOperand]
[tempNameValue]
[expr, ., cloneTree, (, )]
[expr]
[parent, ., replaceChild, (, expr, ,, replacementValueNode, )]
[parent]
[expr]
[replacementValueNode]
[tempNameValue]
[expr]
[NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, )]
[NodeUtil]
[tempName]
[tempNameValue]
[injectionPoint, ., getParent, (, )]
[injectionPoint]
[injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, )]
[injectionPointParent]
[tempVarNode]
[injectionPoint]
[firstExtractedNode, ==, null]
[firstExtractedNode]
[null]
[firstExtractedNode]
[tempVarNode]
[firstExtractedNode]
[Preconditions, ., checkArgument, (, call, ., isCall, (, ), )]
[Preconditions]
[call, ., isCall, (, )]
[call]
[call, ., getFirstChild, (, )]
[call]
[Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, first, ), )]
[Preconditions]
[NodeUtil, ., isGet, (, first, )]
[NodeUtil]
[first]
[extractExpression, (, first, ,, state, ., extractBeforeStatement, )]
[first]
[state, ., extractBeforeStatement]
[state]
[state, ., extractBeforeStatement]
[state]
[getVarNode]
[getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, )]
[getVarNode, ., getFirstChild, (, )]
[getVarNode]
[Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, getExprNode, ), )]
[Preconditions]
[NodeUtil, ., isGet, (, getExprNode, )]
[NodeUtil]
[getExprNode]
[extractExpression, (, getExprNode, ., getFirstChild, (, ), ,, state, ., extractBeforeStatement, )]
[getExprNode, ., getFirstChild, (, )]
[getExprNode]
[state, ., extractBeforeStatement]
[state]
[state, ., extractBeforeStatement]
[state]
[thisVarNode]
[thisVarNode, ., getFirstChild, (, )]
[thisVarNode]
[getVarNode, ., getFirstChild, (, )]
[getVarNode]
[IR, ., call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,, IR, ., string, (, "call", ), ), ,, thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, )]
[IR, ., call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,, IR, ., string, (, "call", ), ), ,, thisNameNode, ., cloneNode, (, ), )]
[IR]
[IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,, IR, ., string, (, "call", ), )]
[IR]
[functionNameNode, ., cloneNode, (, )]
[functionNameNode]
[IR, ., string, (, "call", )]
[IR]
["call"]
[thisNameNode, ., cloneNode, (, )]
[thisNameNode]
[call]
[call, ., removeFirstChild, (, )]
[call]
[call, ., hasChildren, (, )]
[call]
[newCall, ., addChildrenToBack, (, call, ., removeChildren, (, ), )]
[newCall]
[call, ., removeChildren, (, )]
[call]
[call, ., getParent, (, )]
[call]
[callParent, ., replaceChild, (, call, ,, newCall, )]
[callParent]
[call]
[newCall]
[newCall]
["JSCompiler_temp"]
["JSCompiler_inline_result"]
[this, ., tempNamePrefix]
[this]
[prefix]
[tempNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, )]
[tempNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR]
[tempNamePrefix]
[ContextualRenamer, ., UNIQUE_ID_SEPARATOR]
[ContextualRenamer]
[safeNameIdSupplier, ., get, (, )]
[safeNameIdSupplier]
[this, ., resultNamePrefix]
[this]
[prefix]
[resultNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, )]
[resultNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR]
[resultNamePrefix]
[ContextualRenamer, ., UNIQUE_ID_SEPARATOR]
[ContextualRenamer]
[safeNameIdSupplier, ., get, (, )]
[safeNameIdSupplier]
[tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, )]
[tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR]
[tempNamePrefix, +, "_const"]
[tempNamePrefix]
["_const"]
[ContextualRenamer, ., UNIQUE_ID_SEPARATOR]
[ContextualRenamer]
[safeNameIdSupplier, ., get, (, )]
[safeNameIdSupplier]
[this, ., knownConstants, ., add, (, name, )]
[this, ., knownConstants]
[this]
[name]
[name]
[findExpressionRoot, (, subExpression, )]
[subExpression]
[Preconditions, ., checkNotNull, (, expressionRoot, )]
[Preconditions]
[expressionRoot]
[expressionRoot]
[injectionPoint, ., getParent, (, )]
[injectionPoint]
[parent, ., isLabel, (, )]
[parent]
[injectionPoint]
[parent]
[parent]
[injectionPoint, ., getParent, (, )]
[injectionPoint]
[Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPoint, ., getParent, (, ), ), )]
[Preconditions]
[NodeUtil, ., isStatementBlock, (, injectionPoint, ., getParent, (, ), )]
[NodeUtil]
[injectionPoint, ., getParent, (, )]
[injectionPoint]
[injectionPoint]
[n, ., getType, (, )]
[n]
[Token, ., HOOK]
[Token]
[Token, ., AND]
[Token]
[Token, ., OR]
[Token]
[true]
[false]
[subExpression]
[child, ., getAncestors, (, )]
[child]
[parent, ., getType, (, )]
[parent]
[parentType]
[Token, ., EXPR_RESULT]
[Token]
[Token, ., IF]
[Token]
[Token, ., SWITCH]
[Token]
[Token, ., RETURN]
[Token]
[Token, ., VAR]
[Token]
[Preconditions, ., checkState, (, child, ==, parent, ., getFirstChild, (, ), )]
[Preconditions]
[child, ==, parent, ., getFirstChild, (, )]
[child]
[parent, ., getFirstChild, (, )]
[parent]
[parent]
[Token, ., SCRIPT]
[Token]
[Token, ., BLOCK]
[Token]
[Token, ., LABEL]
[Token]
[Token, ., CASE]
[Token]
[Token, ., DEFAULT_CASE]
[Token]
[null]
[child]
[parent]
[new, IllegalStateException, (, "Unexpected AST structure.", )]
["Unexpected AST structure."]
[findExpressionRoot, (, subExpression, )]
[subExpression]
[expressionRoot, !=, null]
[expressionRoot]
[null]
[isSubexpressionMovable, (, expressionRoot, ,, subExpression, )]
[expressionRoot]
[subExpression]
[DecompositionType, ., UNDECOMPOSABLE]
[DecompositionType]
[false]
[NodeUtil, ., mayHaveSideEffects, (, subExpression, ,, compiler, )]
[NodeUtil]
[subExpression]
[compiler]
[subExpression]
[child, ., getAncestors, (, )]
[child]
[parent, ==, expressionRoot]
[parent]
[expressionRoot]
[requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :, DecompositionType, ., MOVABLE]
[requiresDecomposition]
[DecompositionType, ., DECOMPOSABLE]
[DecompositionType]
[DecompositionType, ., MOVABLE]
[DecompositionType]
[parent, ., getType, (, )]
[parent]
[isConditionalOp, (, parent, )]
[parent]
[child, !=, parent, ., getFirstChild, (, )]
[child]
[parent, ., getFirstChild, (, )]
[parent]
[requiresDecomposition]
[true]
[isSafeAssign, (, parent, ,, seenSideEffects, )]
[parent]
[seenSideEffects]
[parent, ., children, (, )]
[parent]
[n, ==, child]
[n]
[child]
[isExpressionTreeUnsafe, (, n, ,, seenSideEffects, )]
[n]
[seenSideEffects]
[seenSideEffects]
[true]
[requiresDecomposition]
[true]
[parent, ., getFirstChild, (, )]
[parent]
[requiresDecomposition, &&, parent, ., isCall, (, ), &&, NodeUtil, ., isGet, (, first, )]
[requiresDecomposition, &&, parent, ., isCall, (, )]
[requiresDecomposition]
[parent, ., isCall, (, )]
[parent]
[NodeUtil, ., isGet, (, first, )]
[NodeUtil]
[first]
[maybeExternMethod, (, first, )]
[first]
[DecompositionType, ., UNDECOMPOSABLE]
[DecompositionType]
[DecompositionType, ., DECOMPOSABLE]
[DecompositionType]
[child]
[parent]
[new, IllegalStateException, (, "Unexpected.", )]
["Unexpected."]
[n, ., isAssign, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[lhs, ., getType, (, )]
[lhs]
[Token, ., NAME]
[Token]
[true]
[Token, ., GETPROP]
[Token]
[!, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, )]
[isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, )]
[lhs, ., getFirstChild, (, )]
[lhs]
[seenSideEffects]
[Token, ., GETELEM]
[Token]
[!, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&, !, isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,, seenSideEffects, )]
[!, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, )]
[isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, )]
[lhs, ., getFirstChild, (, )]
[lhs]
[seenSideEffects]
[!, isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,, seenSideEffects, )]
[isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,, seenSideEffects, )]
[lhs, ., getLastChild, (, )]
[lhs]
[seenSideEffects]
[false]
[followingSideEffectsExist]
[NodeUtil, ., canBeSideEffected, (, n, ,, this, ., knownConstants, )]
[NodeUtil]
[n]
[this, ., knownConstants]
[this]
[NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, )]
[NodeUtil]
[n]
[compiler]
