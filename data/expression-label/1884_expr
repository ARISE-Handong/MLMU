["\\x3c"]
["\\x3e"]
[Maps, ., newHashMap, (, )]
[Maps]
[{, '0', ,, '1', ,, '2', ,, '3', ,, '4', ,, '5', ,, '6', ,, '7', ,, '8', ,, '9', ,, 'a', ,, 'b', ,, 'c', ,, 'd', ,, 'e', ,, 'f', }]
['0']
['1']
['2']
['3']
['4']
['5']
['6']
['7']
['8']
['9']
['a']
['b']
['c']
['d']
['e']
['f']
[cc]
[consumer]
[outputCharsetEncoder]
[null]
[preferSingleQuotes]
[false]
[trustedStrings]
[true]
[new, CodeGenerator, (, consumer, )]
[consumer]
[cc]
[consumer]
[options, ., getOutputCharset, (, )]
[options]
[outputCharset, ==, null, ||, outputCharset, ==, Charsets, ., US_ASCII]
[outputCharset, ==, null]
[outputCharset]
[null]
[outputCharset, ==, Charsets, ., US_ASCII]
[outputCharset]
[Charsets, ., US_ASCII]
[Charsets]
[this, ., outputCharsetEncoder]
[this]
[null]
[this, ., outputCharsetEncoder]
[this]
[outputCharset, ., newEncoder, (, )]
[outputCharset]
[this, ., preferSingleQuotes]
[this]
[options, ., preferSingleQuotes]
[options]
[this, ., trustedStrings]
[this]
[options, ., trustedStrings]
[options]
[add, (, "'use strict';", )]
["'use strict';"]
[cc, ., add, (, str, )]
[cc]
[str]
[cc, ., addIdentifier, (, identifierEscape, (, identifier, ), )]
[cc]
[identifierEscape, (, identifier, )]
[identifier]
[add, (, n, ,, Context, ., OTHER, )]
[n]
[Context, ., OTHER]
[Context]
[!, cc, ., continueProcessing, (, )]
[cc, ., continueProcessing, (, )]
[cc]
[n, ., getType, (, )]
[n]
[NodeUtil, ., opToStr, (, type, )]
[NodeUtil]
[type]
[n, ., getChildCount, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[n, ., getLastChild, (, )]
[n]
[opstr, !=, null, &&, first, !=, last]
[opstr, !=, null]
[opstr]
[null]
[first, !=, last]
[first]
[last]
[Preconditions, ., checkState, (, childCount, ==, 2, ,, "Bad binary operator \"%s\": expected 2 arguments but got %s", ,, opstr, ,, childCount, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
["Bad binary operator \"%s\": expected 2 arguments but got %s"]
[opstr]
[childCount]
[NodeUtil, ., precedence, (, type, )]
[NodeUtil]
[type]
[getContextForNoInOperator, (, context, )]
[context]
[last, ., getType, (, ), ==, type, &&, NodeUtil, ., isAssociative, (, type, )]
[last, ., getType, (, ), ==, type]
[last, ., getType, (, )]
[last]
[type]
[NodeUtil, ., isAssociative, (, type, )]
[NodeUtil]
[type]
[addExpr, (, first, ,, p, ,, context, )]
[first]
[p]
[context]
[cc, ., addOp, (, opstr, ,, true, )]
[cc]
[opstr]
[true]
[addExpr, (, last, ,, p, ,, rhsContext, )]
[last]
[p]
[rhsContext]
[NodeUtil, ., isAssignmentOp, (, n, ), &&, NodeUtil, ., isAssignmentOp, (, last, )]
[NodeUtil, ., isAssignmentOp, (, n, )]
[NodeUtil]
[n]
[NodeUtil, ., isAssignmentOp, (, last, )]
[NodeUtil]
[last]
[addExpr, (, first, ,, p, ,, context, )]
[first]
[p]
[context]
[cc, ., addOp, (, opstr, ,, true, )]
[cc]
[opstr]
[true]
[addExpr, (, last, ,, p, ,, rhsContext, )]
[last]
[p]
[rhsContext]
[unrollBinaryOperator, (, n, ,, type, ,, opstr, ,, context, ,, rhsContext, ,, p, ,, p, +, 1, )]
[n]
[type]
[opstr]
[context]
[rhsContext]
[p]
[p, +, 1]
[p]
[1]
[cc, ., startSourceMapping, (, n, )]
[cc]
[n]
[type]
[Token, ., TRY]
[Token]
[Preconditions, ., checkState, (, first, ., getNext, (, ), ., isBlock, (, ), &&, !, first, ., getNext, (, ), ., hasMoreThanOneChild, (, ), )]
[Preconditions]
[first, ., getNext, (, ), ., isBlock, (, ), &&, !, first, ., getNext, (, ), ., hasMoreThanOneChild, (, )]
[first, ., getNext, (, ), ., isBlock, (, )]
[first, ., getNext, (, )]
[first]
[!, first, ., getNext, (, ), ., hasMoreThanOneChild, (, )]
[first, ., getNext, (, ), ., hasMoreThanOneChild, (, )]
[first, ., getNext, (, )]
[first]
[Preconditions, ., checkState, (, childCount, >=, 2, &&, childCount, <=, 3, )]
[Preconditions]
[childCount, >=, 2, &&, childCount, <=, 3]
[childCount, >=, 2]
[childCount]
[2]
[childCount, <=, 3]
[childCount]
[3]
[add, (, "try", )]
["try"]
[add, (, first, ,, Context, ., PRESERVE_BLOCK, )]
[first]
[Context, ., PRESERVE_BLOCK]
[Context]
[first, ., getNext, (, ), ., getFirstChild, (, )]
[first, ., getNext, (, )]
[first]
[catchblock, !=, null]
[catchblock]
[null]
[add, (, catchblock, )]
[catchblock]
[childCount, ==, 3]
[childCount]
[3]
[add, (, "finally", )]
["finally"]
[add, (, last, ,, Context, ., PRESERVE_BLOCK, )]
[last]
[Context, ., PRESERVE_BLOCK]
[Context]
[Token, ., CATCH]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 2, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
[add, (, "catch(", )]
["catch("]
[add, (, first, )]
[first]
[add, (, ")", )]
[")"]
[add, (, last, ,, Context, ., PRESERVE_BLOCK, )]
[last]
[Context, ., PRESERVE_BLOCK]
[Context]
[Token, ., THROW]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[add, (, "throw", )]
["throw"]
[add, (, first, )]
[first]
[cc, ., endStatement, (, true, )]
[cc]
[true]
[Token, ., RETURN]
[Token]
[add, (, "return", )]
["return"]
[childCount, ==, 1]
[childCount]
[1]
[add, (, first, )]
[first]
[Preconditions, ., checkState, (, childCount, ==, 0, )]
[Preconditions]
[childCount, ==, 0]
[childCount]
[0]
[cc, ., endStatement, (, )]
[cc]
[Token, ., VAR]
[Token]
[first, !=, null]
[first]
[null]
[add, (, "var ", )]
["var "]
[addList, (, first, ,, false, ,, getContextForNoInOperator, (, context, ), )]
[first]
[false]
[getContextForNoInOperator, (, context, )]
[context]
[Token, ., LABEL_NAME]
[Token]
[Preconditions, ., checkState, (, !, n, ., getString, (, ), ., isEmpty, (, ), )]
[Preconditions]
[!, n, ., getString, (, ), ., isEmpty, (, )]
[n, ., getString, (, ), ., isEmpty, (, )]
[n, ., getString, (, )]
[n]
[addIdentifier, (, n, ., getString, (, ), )]
[n, ., getString, (, )]
[n]
[Token, ., NAME]
[Token]
[first, ==, null, ||, first, ., isEmpty, (, )]
[first, ==, null]
[first]
[null]
[first, ., isEmpty, (, )]
[first]
[addIdentifier, (, n, ., getString, (, ), )]
[n, ., getString, (, )]
[n]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[addIdentifier, (, n, ., getString, (, ), )]
[n, ., getString, (, )]
[n]
[cc, ., addOp, (, "=", ,, true, )]
[cc]
["="]
[true]
[first, ., isComma, (, )]
[first]
[addExpr, (, first, ,, NodeUtil, ., precedence, (, Token, ., ASSIGN, ), ,, Context, ., OTHER, )]
[first]
[NodeUtil, ., precedence, (, Token, ., ASSIGN, )]
[NodeUtil]
[Token, ., ASSIGN]
[Token]
[Context, ., OTHER]
[Context]
[addExpr, (, first, ,, 0, ,, getContextForNoInOperator, (, context, ), )]
[first]
[0]
[getContextForNoInOperator, (, context, )]
[context]
[Token, ., ARRAYLIT]
[Token]
[add, (, "[", )]
["["]
[addArrayList, (, first, )]
[first]
[add, (, "]", )]
["]"]
[Token, ., PARAM_LIST]
[Token]
[add, (, "(", )]
["("]
[addList, (, first, )]
[first]
[add, (, ")", )]
[")"]
[Token, ., COMMA]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 2, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
[unrollBinaryOperator, (, n, ,, Token, ., COMMA, ,, ",", ,, context, ,, Context, ., OTHER, ,, 0, ,, 0, )]
[n]
[Token, ., COMMA]
[Token]
[","]
[context]
[Context, ., OTHER]
[Context]
[0]
[0]
[Token, ., NUMBER]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 0, )]
[Preconditions]
[childCount, ==, 0]
[childCount]
[0]
[cc, ., addNumber, (, n, ., getDouble, (, ), )]
[cc]
[n, ., getDouble, (, )]
[n]
[Token, ., TYPEOF]
[Token]
[Token, ., VOID]
[Token]
[Token, ., NOT]
[Token]
[Token, ., BITNOT]
[Token]
[Token, ., POS]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[cc, ., addOp, (, NodeUtil, ., opToStrNoFail, (, type, ), ,, false, )]
[cc]
[NodeUtil, ., opToStrNoFail, (, type, )]
[NodeUtil]
[type]
[false]
[addExpr, (, first, ,, NodeUtil, ., precedence, (, type, ), ,, Context, ., OTHER, )]
[first]
[NodeUtil, ., precedence, (, type, )]
[NodeUtil]
[type]
[Context, ., OTHER]
[Context]
[Token, ., NEG]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[n, ., getFirstChild, (, ), ., isNumber, (, )]
[n, ., getFirstChild, (, )]
[n]
[cc, ., addNumber, (, -, n, ., getFirstChild, (, ), ., getDouble, (, ), )]
[cc]
[-, n, ., getFirstChild, (, ), ., getDouble, (, )]
[n, ., getFirstChild, (, ), ., getDouble, (, )]
[n, ., getFirstChild, (, )]
[n]
[cc, ., addOp, (, NodeUtil, ., opToStrNoFail, (, type, ), ,, false, )]
[cc]
[NodeUtil, ., opToStrNoFail, (, type, )]
[NodeUtil]
[type]
[false]
[addExpr, (, first, ,, NodeUtil, ., precedence, (, type, ), ,, Context, ., OTHER, )]
[first]
[NodeUtil, ., precedence, (, type, )]
[NodeUtil]
[type]
[Context, ., OTHER]
[Context]
[Token, ., HOOK]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 3, )]
[Preconditions]
[childCount, ==, 3]
[childCount]
[3]
[NodeUtil, ., precedence, (, type, )]
[NodeUtil]
[type]
[addExpr, (, first, ,, p, +, 1, ,, context, )]
[first]
[p, +, 1]
[p]
[1]
[context]
[cc, ., addOp, (, "?", ,, true, )]
[cc]
["?"]
[true]
[addExpr, (, first, ., getNext, (, ), ,, 1, ,, Context, ., OTHER, )]
[first, ., getNext, (, )]
[first]
[1]
[Context, ., OTHER]
[Context]
[cc, ., addOp, (, ":", ,, true, )]
[cc]
[":"]
[true]
[addExpr, (, last, ,, 1, ,, Context, ., OTHER, )]
[last]
[1]
[Context, ., OTHER]
[Context]
[Token, ., REGEXP]
[Token]
[!, first, ., isString, (, ), ||, !, last, ., isString, (, )]
[!, first, ., isString, (, )]
[first, ., isString, (, )]
[first]
[!, last, ., isString, (, )]
[last, ., isString, (, )]
[last]
[new, Error, (, "Expected children to be strings", )]
["Expected children to be strings"]
[regexpEscape, (, first, ., getString, (, ), ,, outputCharsetEncoder, )]
[first, ., getString, (, )]
[first]
[outputCharsetEncoder]
[childCount, ==, 2]
[childCount]
[2]
[add, (, regexp, +, last, ., getString, (, ), )]
[regexp, +, last, ., getString, (, )]
[regexp]
[last, ., getString, (, )]
[last]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[add, (, regexp, )]
[regexp]
[Token, ., FUNCTION]
[Token]
[n, ., getClass, (, ), !=, Node, ., class]
[n, ., getClass, (, )]
[n]
[Node, ., class]
[new, Error, (, "Unexpected Node subclass.", )]
["Unexpected Node subclass."]
[Preconditions, ., checkState, (, childCount, ==, 3, )]
[Preconditions]
[childCount, ==, 3]
[childCount]
[3]
[(, context, ==, Context, ., START_OF_EXPR, )]
[context, ==, Context, ., START_OF_EXPR]
[context]
[Context, ., START_OF_EXPR]
[Context]
[funcNeedsParens]
[add, (, "(", )]
["("]
[add, (, "function", )]
["function"]
[add, (, first, )]
[first]
[add, (, first, ., getNext, (, ), )]
[first, ., getNext, (, )]
[first]
[add, (, last, ,, Context, ., PRESERVE_BLOCK, )]
[last]
[Context, ., PRESERVE_BLOCK]
[Context]
[cc, ., endFunction, (, context, ==, Context, ., STATEMENT, )]
[cc]
[context, ==, Context, ., STATEMENT]
[context]
[Context, ., STATEMENT]
[Context]
[funcNeedsParens]
[add, (, ")", )]
[")"]
[Token, ., GETTER_DEF]
[Token]
[Token, ., SETTER_DEF]
[Token]
[Preconditions, ., checkState, (, n, ., getParent, (, ), ., isObjectLit, (, ), )]
[Preconditions]
[n, ., getParent, (, ), ., isObjectLit, (, )]
[n, ., getParent, (, )]
[n]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[Preconditions, ., checkState, (, first, ., isFunction, (, ), )]
[Preconditions]
[first, ., isFunction, (, )]
[first]
[Preconditions, ., checkState, (, first, ., getFirstChild, (, ), ., getString, (, ), ., isEmpty, (, ), )]
[Preconditions]
[first, ., getFirstChild, (, ), ., getString, (, ), ., isEmpty, (, )]
[first, ., getFirstChild, (, ), ., getString, (, )]
[first, ., getFirstChild, (, )]
[first]
[type, ==, Token, ., GETTER_DEF]
[type]
[Token, ., GETTER_DEF]
[Token]
[Preconditions, ., checkState, (, !, first, ., getChildAtIndex, (, 1, ), ., hasChildren, (, ), )]
[Preconditions]
[!, first, ., getChildAtIndex, (, 1, ), ., hasChildren, (, )]
[first, ., getChildAtIndex, (, 1, ), ., hasChildren, (, )]
[first, ., getChildAtIndex, (, 1, )]
[first]
[1]
[add, (, "get ", )]
["get "]
[Preconditions, ., checkState, (, first, ., getChildAtIndex, (, 1, ), ., hasOneChild, (, ), )]
[Preconditions]
[first, ., getChildAtIndex, (, 1, ), ., hasOneChild, (, )]
[first, ., getChildAtIndex, (, 1, )]
[first]
[1]
[add, (, "set ", )]
["set "]
[n, ., getString, (, )]
[n]
[first]
[fn, ., getChildAtIndex, (, 1, )]
[fn]
[1]
[fn, ., getLastChild, (, )]
[fn]
[!, n, ., isQuotedString, (, ), &&, TokenStream, ., isJSIdentifier, (, name, ), &&, NodeUtil, ., isLatin, (, name, )]
[!, n, ., isQuotedString, (, ), &&, TokenStream, ., isJSIdentifier, (, name, )]
[!, n, ., isQuotedString, (, )]
[n, ., isQuotedString, (, )]
[n]
[TokenStream, ., isJSIdentifier, (, name, )]
[TokenStream]
[name]
[NodeUtil, ., isLatin, (, name, )]
[NodeUtil]
[name]
[add, (, name, )]
[name]
[getSimpleNumber, (, name, )]
[name]
[!, Double, ., isNaN, (, d, )]
[Double, ., isNaN, (, d, )]
[Double]
[d]
[cc, ., addNumber, (, d, )]
[cc]
[d]
[addJsString, (, n, )]
[n]
[add, (, parameters, )]
[parameters]
[add, (, body, ,, Context, ., PRESERVE_BLOCK, )]
[body]
[Context, ., PRESERVE_BLOCK]
[Context]
[Token, ., SCRIPT]
[Token]
[Token, ., BLOCK]
[Token]
[n, ., getClass, (, ), !=, Node, ., class]
[n, ., getClass, (, )]
[n]
[Node, ., class]
[new, Error, (, "Unexpected Node subclass.", )]
["Unexpected Node subclass."]
[context, ==, Context, ., PRESERVE_BLOCK]
[context]
[Context, ., PRESERVE_BLOCK]
[Context]
[preserveBlock]
[cc, ., beginBlock, (, )]
[cc]
[type, ==, Token, ., SCRIPT, ||, (, type, ==, Token, ., BLOCK, &&, !, preserveBlock, &&, n, ., getParent, (, ), !=, null, &&, n, ., getParent, (, ), ., isScript, (, ), )]
[type, ==, Token, ., SCRIPT]
[type]
[Token, ., SCRIPT]
[Token]
[(, type, ==, Token, ., BLOCK, &&, !, preserveBlock, &&, n, ., getParent, (, ), !=, null, &&, n, ., getParent, (, ), ., isScript, (, ), )]
[type, ==, Token, ., BLOCK, &&, !, preserveBlock, &&, n, ., getParent, (, ), !=, null, &&, n, ., getParent, (, ), ., isScript, (, )]
[type, ==, Token, ., BLOCK, &&, !, preserveBlock, &&, n, ., getParent, (, ), !=, null]
[type, ==, Token, ., BLOCK, &&, !, preserveBlock]
[type, ==, Token, ., BLOCK]
[type]
[Token, ., BLOCK]
[Token]
[!, preserveBlock]
[preserveBlock]
[n, ., getParent, (, ), !=, null]
[n, ., getParent, (, )]
[n]
[null]
[n, ., getParent, (, ), ., isScript, (, )]
[n, ., getParent, (, )]
[n]
[first]
[c, !=, null]
[c]
[null]
[c]
[c, ., getNext, (, )]
[c]
[add, (, c, ,, Context, ., STATEMENT, )]
[c]
[Context, ., STATEMENT]
[Context]
[c, ., isVar, (, )]
[c]
[cc, ., endStatement, (, )]
[cc]
[c, ., isFunction, (, )]
[c]
[cc, ., maybeLineBreak, (, )]
[cc]
[preferLineBreaks]
[cc, ., notePreferredLineBreak, (, )]
[cc]
[preserveBlock]
[cc, ., endBlock, (, cc, ., breakAfterBlockFor, (, n, ,, context, ==, Context, ., STATEMENT, ), )]
[cc]
[cc, ., breakAfterBlockFor, (, n, ,, context, ==, Context, ., STATEMENT, )]
[cc]
[n]
[context, ==, Context, ., STATEMENT]
[context]
[Context, ., STATEMENT]
[Context]
[Token, ., FOR]
[Token]
[childCount, ==, 4]
[childCount]
[4]
[add, (, "for(", )]
["for("]
[first, ., isVar, (, )]
[first]
[add, (, first, ,, Context, ., IN_FOR_INIT_CLAUSE, )]
[first]
[Context, ., IN_FOR_INIT_CLAUSE]
[Context]
[addExpr, (, first, ,, 0, ,, Context, ., IN_FOR_INIT_CLAUSE, )]
[first]
[0]
[Context, ., IN_FOR_INIT_CLAUSE]
[Context]
[add, (, ";", )]
[";"]
[add, (, first, ., getNext, (, ), )]
[first, ., getNext, (, )]
[first]
[add, (, ";", )]
[";"]
[add, (, first, ., getNext, (, ), ., getNext, (, ), )]
[first, ., getNext, (, ), ., getNext, (, )]
[first, ., getNext, (, )]
[first]
[add, (, ")", )]
[")"]
[addNonEmptyStatement, (, last, ,, getContextForNonEmptyExpression, (, context, ), ,, false, )]
[last]
[getContextForNonEmptyExpression, (, context, )]
[context]
[false]
[Preconditions, ., checkState, (, childCount, ==, 3, )]
[Preconditions]
[childCount, ==, 3]
[childCount]
[3]
[add, (, "for(", )]
["for("]
[add, (, first, )]
[first]
[add, (, "in", )]
["in"]
[add, (, first, ., getNext, (, ), )]
[first, ., getNext, (, )]
[first]
[add, (, ")", )]
[")"]
[addNonEmptyStatement, (, last, ,, getContextForNonEmptyExpression, (, context, ), ,, false, )]
[last]
[getContextForNonEmptyExpression, (, context, )]
[context]
[false]
[Token, ., DO]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 2, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
[add, (, "do", )]
["do"]
[addNonEmptyStatement, (, first, ,, Context, ., OTHER, ,, false, )]
[first]
[Context, ., OTHER]
[Context]
[false]
[add, (, "while(", )]
["while("]
[add, (, last, )]
[last]
[add, (, ")", )]
[")"]
[cc, ., endStatement, (, )]
[cc]
[Token, ., WHILE]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 2, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
[add, (, "while(", )]
["while("]
[add, (, first, )]
[first]
[add, (, ")", )]
[")"]
[addNonEmptyStatement, (, last, ,, getContextForNonEmptyExpression, (, context, ), ,, false, )]
[last]
[getContextForNonEmptyExpression, (, context, )]
[context]
[false]
[Token, ., EMPTY]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 0, )]
[Preconditions]
[childCount, ==, 0]
[childCount]
[0]
[Token, ., GETPROP]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 2, ,, "Bad GETPROP: expected 2 children, but got %s", ,, childCount, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
["Bad GETPROP: expected 2 children, but got %s"]
[childCount]
[Preconditions, ., checkState, (, last, ., isString, (, ), ,, "Bad GETPROP: RHS should be STRING", )]
[Preconditions]
[last, ., isString, (, )]
[last]
["Bad GETPROP: RHS should be STRING"]
[(, first, ., isNumber, (, ), )]
[first, ., isNumber, (, )]
[first]
[needsParens]
[add, (, "(", )]
["("]
[addExpr, (, first, ,, NodeUtil, ., precedence, (, type, ), ,, context, )]
[first]
[NodeUtil, ., precedence, (, type, )]
[NodeUtil]
[type]
[context]
[needsParens]
[add, (, ")", )]
[")"]
[add, (, ".", )]
["."]
[addIdentifier, (, last, ., getString, (, ), )]
[last, ., getString, (, )]
[last]
[Token, ., GETELEM]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 2, ,, "Bad GETELEM: expected 2 children but got %s", ,, childCount, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
["Bad GETELEM: expected 2 children but got %s"]
[childCount]
[addExpr, (, first, ,, NodeUtil, ., precedence, (, type, ), ,, context, )]
[first]
[NodeUtil, ., precedence, (, type, )]
[NodeUtil]
[type]
[context]
[add, (, "[", )]
["["]
[add, (, first, ., getNext, (, ), )]
[first, ., getNext, (, )]
[first]
[add, (, "]", )]
["]"]
[Token, ., WITH]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 2, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
[add, (, "with(", )]
["with("]
[add, (, first, )]
[first]
[add, (, ")", )]
[")"]
[addNonEmptyStatement, (, last, ,, getContextForNonEmptyExpression, (, context, ), ,, false, )]
[last]
[getContextForNonEmptyExpression, (, context, )]
[context]
[false]
[Token, ., INC]
[Token]
[Token, ., DEC]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[type, ==, Token, ., INC, ?, "++", :, "--"]
[type, ==, Token, ., INC]
[type]
[Token, ., INC]
[Token]
["++"]
["--"]
[n, ., getIntProp, (, Node, ., INCRDECR_PROP, )]
[n]
[Node, ., INCRDECR_PROP]
[Node]
[postProp, !=, 0]
[postProp]
[0]
[addExpr, (, first, ,, NodeUtil, ., precedence, (, type, ), ,, context, )]
[first]
[NodeUtil, ., precedence, (, type, )]
[NodeUtil]
[type]
[context]
[cc, ., addOp, (, o, ,, false, )]
[cc]
[o]
[false]
[cc, ., addOp, (, o, ,, false, )]
[cc]
[o]
[false]
[add, (, first, )]
[first]
[Token, ., CALL]
[Token]
[isIndirectEval, (, first, ), ||, n, ., getBooleanProp, (, Node, ., FREE_CALL, ), &&, NodeUtil, ., isGet, (, first, )]
[isIndirectEval, (, first, )]
[first]
[n, ., getBooleanProp, (, Node, ., FREE_CALL, ), &&, NodeUtil, ., isGet, (, first, )]
[n, ., getBooleanProp, (, Node, ., FREE_CALL, )]
[n]
[Node, ., FREE_CALL]
[Node]
[NodeUtil, ., isGet, (, first, )]
[NodeUtil]
[first]
[add, (, "(0,", )]
["(0,"]
[addExpr, (, first, ,, NodeUtil, ., precedence, (, Token, ., COMMA, ), ,, Context, ., OTHER, )]
[first]
[NodeUtil, ., precedence, (, Token, ., COMMA, )]
[NodeUtil]
[Token, ., COMMA]
[Token]
[Context, ., OTHER]
[Context]
[add, (, ")", )]
[")"]
[addExpr, (, first, ,, NodeUtil, ., precedence, (, type, ), ,, context, )]
[first]
[NodeUtil, ., precedence, (, type, )]
[NodeUtil]
[type]
[context]
[add, (, "(", )]
["("]
[addList, (, first, ., getNext, (, ), )]
[first, ., getNext, (, )]
[first]
[add, (, ")", )]
[")"]
[Token, ., IF]
[Token]
[childCount, ==, 3]
[childCount]
[3]
[context, ==, Context, ., BEFORE_DANGLING_ELSE, &&, !, hasElse]
[context, ==, Context, ., BEFORE_DANGLING_ELSE]
[context]
[Context, ., BEFORE_DANGLING_ELSE]
[Context]
[!, hasElse]
[hasElse]
[ambiguousElseClause]
[cc, ., beginBlock, (, )]
[cc]
[add, (, "if(", )]
["if("]
[add, (, first, )]
[first]
[add, (, ")", )]
[")"]
[hasElse]
[addNonEmptyStatement, (, first, ., getNext, (, ), ,, Context, ., BEFORE_DANGLING_ELSE, ,, false, )]
[first, ., getNext, (, )]
[first]
[Context, ., BEFORE_DANGLING_ELSE]
[Context]
[false]
[add, (, "else", )]
["else"]
[addNonEmptyStatement, (, last, ,, getContextForNonEmptyExpression, (, context, ), ,, false, )]
[last]
[getContextForNonEmptyExpression, (, context, )]
[context]
[false]
[addNonEmptyStatement, (, first, ., getNext, (, ), ,, Context, ., OTHER, ,, false, )]
[first, ., getNext, (, )]
[first]
[Context, ., OTHER]
[Context]
[false]
[Preconditions, ., checkState, (, childCount, ==, 2, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
[ambiguousElseClause]
[cc, ., endBlock, (, )]
[cc]
[Token, ., NULL]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 0, )]
[Preconditions]
[childCount, ==, 0]
[childCount]
[0]
[cc, ., addConstant, (, "null", )]
[cc]
["null"]
[Token, ., THIS]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 0, )]
[Preconditions]
[childCount, ==, 0]
[childCount]
[0]
[add, (, "this", )]
["this"]
[Token, ., FALSE]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 0, )]
[Preconditions]
[childCount, ==, 0]
[childCount]
[0]
[cc, ., addConstant, (, "false", )]
[cc]
["false"]
[Token, ., TRUE]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 0, )]
[Preconditions]
[childCount, ==, 0]
[childCount]
[0]
[cc, ., addConstant, (, "true", )]
[cc]
["true"]
[Token, ., CONTINUE]
[Token]
[Preconditions, ., checkState, (, childCount, <=, 1, )]
[Preconditions]
[childCount, <=, 1]
[childCount]
[1]
[add, (, "continue", )]
["continue"]
[childCount, ==, 1]
[childCount]
[1]
[!, first, ., isLabelName, (, )]
[first, ., isLabelName, (, )]
[first]
[new, Error, (, "Unexpected token type. Should be LABEL_NAME.", )]
["Unexpected token type. Should be LABEL_NAME."]
[add, (, " ", )]
[" "]
[add, (, first, )]
[first]
[cc, ., endStatement, (, )]
[cc]
[Token, ., DEBUGGER]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 0, )]
[Preconditions]
[childCount, ==, 0]
[childCount]
[0]
[add, (, "debugger", )]
["debugger"]
[cc, ., endStatement, (, )]
[cc]
[Token, ., BREAK]
[Token]
[Preconditions, ., checkState, (, childCount, <=, 1, )]
[Preconditions]
[childCount, <=, 1]
[childCount]
[1]
[add, (, "break", )]
["break"]
[childCount, ==, 1]
[childCount]
[1]
[!, first, ., isLabelName, (, )]
[first, ., isLabelName, (, )]
[first]
[new, Error, (, "Unexpected token type. Should be LABEL_NAME.", )]
["Unexpected token type. Should be LABEL_NAME."]
[add, (, " ", )]
[" "]
[add, (, first, )]
[first]
[cc, ., endStatement, (, )]
[cc]
[Token, ., EXPR_RESULT]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[add, (, first, ,, Context, ., START_OF_EXPR, )]
[first]
[Context, ., START_OF_EXPR]
[Context]
[cc, ., endStatement, (, )]
[cc]
[Token, ., NEW]
[Token]
[add, (, "new ", )]
["new "]
[NodeUtil, ., precedence, (, type, )]
[NodeUtil]
[type]
[NodeUtil, ., containsType, (, first, ,, Token, ., CALL, ,, NodeUtil, ., MATCH_NOT_FUNCTION, )]
[NodeUtil]
[first]
[Token, ., CALL]
[Token]
[NodeUtil, ., MATCH_NOT_FUNCTION]
[NodeUtil]
[precedence]
[NodeUtil, ., precedence, (, first, ., getType, (, ), ), +, 1]
[NodeUtil, ., precedence, (, first, ., getType, (, ), )]
[NodeUtil]
[first, ., getType, (, )]
[first]
[1]
[addExpr, (, first, ,, precedence, ,, Context, ., OTHER, )]
[first]
[precedence]
[Context, ., OTHER]
[Context]
[first, ., getNext, (, )]
[first]
[next, !=, null]
[next]
[null]
[add, (, "(", )]
["("]
[addList, (, next, )]
[next]
[add, (, ")", )]
[")"]
[Token, ., STRING_KEY]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 1, ,, "Object lit key must have 1 child", )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
["Object lit key must have 1 child"]
[addJsString, (, n, )]
[n]
[Token, ., STRING]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 0, ,, "A string may not have children", )]
[Preconditions]
[childCount, ==, 0]
[childCount]
[0]
["A string may not have children"]
[addJsString, (, n, )]
[n]
[Token, ., DELPROP]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[add, (, "delete ", )]
["delete "]
[add, (, first, )]
[first]
[Token, ., OBJECTLIT]
[Token]
[(, context, ==, Context, ., START_OF_EXPR, )]
[context, ==, Context, ., START_OF_EXPR]
[context]
[Context, ., START_OF_EXPR]
[Context]
[needsParens]
[add, (, "(", )]
["("]
[add, (, "{", )]
["{"]
[first]
[c, !=, null]
[c]
[null]
[c]
[c, ., getNext, (, )]
[c]
[c, !=, first]
[c]
[first]
[cc, ., listSeparator, (, )]
[cc]
[c, ., isGetterDef, (, ), ||, c, ., isSetterDef, (, )]
[c, ., isGetterDef, (, )]
[c]
[c, ., isSetterDef, (, )]
[c]
[add, (, c, )]
[c]
[Preconditions, ., checkState, (, c, ., isStringKey, (, ), )]
[Preconditions]
[c, ., isStringKey, (, )]
[c]
[c, ., getString, (, )]
[c]
[!, c, ., isQuotedString, (, ), &&, !, TokenStream, ., isKeyword, (, key, ), &&, TokenStream, ., isJSIdentifier, (, key, ), &&, NodeUtil, ., isLatin, (, key, )]
[!, c, ., isQuotedString, (, ), &&, !, TokenStream, ., isKeyword, (, key, ), &&, TokenStream, ., isJSIdentifier, (, key, )]
[!, c, ., isQuotedString, (, ), &&, !, TokenStream, ., isKeyword, (, key, )]
[!, c, ., isQuotedString, (, )]
[c, ., isQuotedString, (, )]
[c]
[!, TokenStream, ., isKeyword, (, key, )]
[TokenStream, ., isKeyword, (, key, )]
[TokenStream]
[key]
[TokenStream, ., isJSIdentifier, (, key, )]
[TokenStream]
[key]
[NodeUtil, ., isLatin, (, key, )]
[NodeUtil]
[key]
[add, (, key, )]
[key]
[getSimpleNumber, (, key, )]
[key]
[!, Double, ., isNaN, (, d, )]
[Double, ., isNaN, (, d, )]
[Double]
[d]
[cc, ., addNumber, (, d, )]
[cc]
[d]
[addExpr, (, c, ,, 1, ,, Context, ., OTHER, )]
[c]
[1]
[Context, ., OTHER]
[Context]
[add, (, ":", )]
[":"]
[addExpr, (, c, ., getFirstChild, (, ), ,, 1, ,, Context, ., OTHER, )]
[c, ., getFirstChild, (, )]
[c]
[1]
[Context, ., OTHER]
[Context]
[add, (, "}", )]
["}"]
[needsParens]
[add, (, ")", )]
[")"]
[Token, ., SWITCH]
[Token]
[add, (, "switch(", )]
["switch("]
[add, (, first, )]
[first]
[add, (, ")", )]
[")"]
[cc, ., beginBlock, (, )]
[cc]
[addAllSiblings, (, first, ., getNext, (, ), )]
[first, ., getNext, (, )]
[first]
[cc, ., endBlock, (, context, ==, Context, ., STATEMENT, )]
[cc]
[context, ==, Context, ., STATEMENT]
[context]
[Context, ., STATEMENT]
[Context]
[Token, ., CASE]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 2, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
[add, (, "case ", )]
["case "]
[add, (, first, )]
[first]
[addCaseBody, (, last, )]
[last]
[Token, ., DEFAULT_CASE]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 1, )]
[Preconditions]
[childCount, ==, 1]
[childCount]
[1]
[add, (, "default", )]
["default"]
[addCaseBody, (, first, )]
[first]
[Token, ., LABEL]
[Token]
[Preconditions, ., checkState, (, childCount, ==, 2, )]
[Preconditions]
[childCount, ==, 2]
[childCount]
[2]
[!, first, ., isLabelName, (, )]
[first, ., isLabelName, (, )]
[first]
[new, Error, (, "Unexpected token type. Should be LABEL_NAME.", )]
["Unexpected token type. Should be LABEL_NAME."]
[add, (, first, )]
[first]
[add, (, ":", )]
[":"]
[addNonEmptyStatement, (, last, ,, getContextForNonEmptyExpression, (, context, ), ,, true, )]
[last]
[getContextForNonEmptyExpression, (, context, )]
[context]
[true]
[Token, ., CAST]
[Token]
[add, (, "(", )]
["("]
[add, (, first, )]
[first]
[add, (, ")", )]
[")"]
[new, Error, (, "Unknown type ", +, type, +, "\n", +, n, ., toStringTree, (, ), )]
["Unknown type ", +, type, +, "\n", +, n, ., toStringTree, (, )]
["Unknown type ", +, type, +, "\n"]
["Unknown type ", +, type]
["Unknown type "]
[type]
["\n"]
[n, ., toStringTree, (, )]
[n]
[cc, ., endSourceMapping, (, n, )]
[cc]
[n]
[n, ., getFirstChild, (, )]
[n]
[firstNonOperator, ., getType, (, ), ==, op]
[firstNonOperator, ., getType, (, )]
[firstNonOperator]
[op]
[firstNonOperator]
[firstNonOperator, ., getFirstChild, (, )]
[firstNonOperator]
[addExpr, (, firstNonOperator, ,, leftPrecedence, ,, context, )]
[firstNonOperator]
[leftPrecedence]
[context]
[firstNonOperator]
[current]
[current, ., getParent, (, )]
[current]
[cc, ., addOp, (, opStr, ,, true, )]
[cc]
[opStr]
[true]
[addExpr, (, current, ., getFirstChild, (, ), ., getNext, (, ), ,, rightPrecedence, ,, rhsContext, )]
[current, ., getFirstChild, (, ), ., getNext, (, )]
[current, ., getFirstChild, (, )]
[current]
[rightPrecedence]
[rhsContext]
[current, !=, n]
[current]
[n]
[s, ., length, (, )]
[s]
[0]
[index, <, len]
[index]
[len]
[index, ++]
[index]
[s, ., charAt, (, index, )]
[s]
[index]
[c, <, '0', ||, c, >, '9']
[c, <, '0']
[c]
['0']
[c, >, '9']
[c]
['9']
[false]
[len, >, 0, &&, s, ., charAt, (, 0, ), !=, '0']
[len, >, 0]
[len]
[0]
[s, ., charAt, (, 0, ), !=, '0']
[s, ., charAt, (, 0, )]
[s]
[0]
['0']
[isSimpleNumber, (, s, )]
[s]
[Long, ., parseLong, (, s, )]
[Long]
[s]
[l, <, NodeUtil, ., MAX_POSITIVE_INTEGER_NUMBER]
[l]
[NodeUtil, ., MAX_POSITIVE_INTEGER_NUMBER]
[NodeUtil]
[l]
[Double, ., NaN]
[Double]
[n, ., isName, (, ), &&, "eval", ., equals, (, n, ., getString, (, ), ), &&, !, n, ., getBooleanProp, (, Node, ., DIRECT_EVAL, )]
[n, ., isName, (, ), &&, "eval", ., equals, (, n, ., getString, (, ), )]
[n, ., isName, (, )]
[n]
["eval", ., equals, (, n, ., getString, (, ), )]
["eval"]
[n, ., getString, (, )]
[n]
[!, n, ., getBooleanProp, (, Node, ., DIRECT_EVAL, )]
[n, ., getBooleanProp, (, Node, ., DIRECT_EVAL, )]
[n]
[Node, ., DIRECT_EVAL]
[Node]
[n]
[!, allowNonBlockChild, &&, !, n, ., isBlock, (, )]
[!, allowNonBlockChild]
[allowNonBlockChild]
[!, n, ., isBlock, (, )]
[n, ., isBlock, (, )]
[n]
[new, Error, (, "Missing BLOCK child.", )]
["Missing BLOCK child."]
[n, ., isBlock, (, )]
[n]
[getNonEmptyChildCount, (, n, ,, 2, )]
[n]
[2]
[count, ==, 0]
[count]
[0]
[cc, ., shouldPreserveExtraBlocks, (, )]
[cc]
[cc, ., beginBlock, (, )]
[cc]
[cc, ., endBlock, (, cc, ., breakAfterBlockFor, (, n, ,, context, ==, Context, ., STATEMENT, ), )]
[cc]
[cc, ., breakAfterBlockFor, (, n, ,, context, ==, Context, ., STATEMENT, )]
[cc]
[n]
[context, ==, Context, ., STATEMENT]
[context]
[Context, ., STATEMENT]
[Context]
[cc, ., endStatement, (, true, )]
[cc]
[true]
[count, ==, 1]
[count]
[1]
[getFirstNonEmptyChild, (, n, )]
[n]
[cc, ., shouldPreserveExtraBlocks, (, )]
[cc]
[alwaysWrapInBlock, ||, isOneExactlyFunctionOrDo, (, firstAndOnlyChild, )]
[alwaysWrapInBlock]
[isOneExactlyFunctionOrDo, (, firstAndOnlyChild, )]
[firstAndOnlyChild]
[cc, ., beginBlock, (, )]
[cc]
[add, (, firstAndOnlyChild, ,, Context, ., STATEMENT, )]
[firstAndOnlyChild]
[Context, ., STATEMENT]
[Context]
[cc, ., maybeLineBreak, (, )]
[cc]
[cc, ., endBlock, (, cc, ., breakAfterBlockFor, (, n, ,, context, ==, Context, ., STATEMENT, ), )]
[cc]
[cc, ., breakAfterBlockFor, (, n, ,, context, ==, Context, ., STATEMENT, )]
[cc]
[n]
[context, ==, Context, ., STATEMENT]
[context]
[Context, ., STATEMENT]
[Context]
[nodeToProcess]
[firstAndOnlyChild]
[count, >, 1]
[count]
[1]
[context]
[Context, ., PRESERVE_BLOCK]
[Context]
[nodeToProcess, ., isEmpty, (, )]
[nodeToProcess]
[cc, ., endStatement, (, true, )]
[cc]
[true]
[add, (, nodeToProcess, ,, context, )]
[nodeToProcess]
[context]
[nodeToProcess, ., isVar, (, )]
[nodeToProcess]
[cc, ., endStatement, (, )]
[cc]
[n, ., isLabel, (, )]
[n]
[n, ., getLastChild, (, )]
[n]
[!, labeledStatement, ., isBlock, (, )]
[labeledStatement, ., isBlock, (, )]
[labeledStatement]
[isOneExactlyFunctionOrDo, (, labeledStatement, )]
[labeledStatement]
[getNonEmptyChildCount, (, n, ,, 2, ), ==, 1]
[getNonEmptyChildCount, (, n, ,, 2, )]
[n]
[2]
[1]
[isOneExactlyFunctionOrDo, (, getFirstNonEmptyChild, (, n, ), )]
[getFirstNonEmptyChild, (, n, )]
[n]
[false]
[(, n, ., isFunction, (, ), ||, n, ., isDo, (, ), )]
[n, ., isFunction, (, ), ||, n, ., isDo, (, )]
[n, ., isFunction, (, )]
[n]
[n, ., isDo, (, )]
[n]
[(, NodeUtil, ., precedence, (, n, ., getType, (, ), ), <, minPrecedence, ), ||, (, (, context, ==, Context, ., IN_FOR_INIT_CLAUSE, ), &&, n, ., isIn, (, ), )]
[(, NodeUtil, ., precedence, (, n, ., getType, (, ), ), <, minPrecedence, )]
[NodeUtil, ., precedence, (, n, ., getType, (, ), ), <, minPrecedence]
[NodeUtil, ., precedence, (, n, ., getType, (, ), )]
[NodeUtil]
[n, ., getType, (, )]
[n]
[minPrecedence]
[(, (, context, ==, Context, ., IN_FOR_INIT_CLAUSE, ), &&, n, ., isIn, (, ), )]
[(, context, ==, Context, ., IN_FOR_INIT_CLAUSE, ), &&, n, ., isIn, (, )]
[(, context, ==, Context, ., IN_FOR_INIT_CLAUSE, )]
[context, ==, Context, ., IN_FOR_INIT_CLAUSE]
[context]
[Context, ., IN_FOR_INIT_CLAUSE]
[Context]
[n, ., isIn, (, )]
[n]
[add, (, "(", )]
["("]
[add, (, n, ,, Context, ., OTHER, )]
[n]
[Context, ., OTHER]
[Context]
[add, (, ")", )]
[")"]
[add, (, n, ,, context, )]
[n]
[context]
[addList, (, firstInList, ,, true, ,, Context, ., OTHER, )]
[firstInList]
[true]
[Context, ., OTHER]
[Context]
[addList, (, firstInList, ,, isArrayOrFunctionArgument, ,, Context, ., OTHER, )]
[firstInList]
[isArrayOrFunctionArgument]
[Context, ., OTHER]
[Context]
[firstInList]
[n, !=, null]
[n]
[null]
[n]
[n, ., getNext, (, )]
[n]
[n, ==, firstInList]
[n]
[firstInList]
[isFirst]
[addExpr, (, n, ,, isArrayOrFunctionArgument, ?, 1, :, 0, ,, lhsContext, )]
[n]
[isArrayOrFunctionArgument, ?, 1, :, 0]
[isArrayOrFunctionArgument]
[1]
[0]
[lhsContext]
[cc, ., listSeparator, (, )]
[cc]
[addExpr, (, n, ,, isArrayOrFunctionArgument, ?, 1, :, 0, ,, Context, ., OTHER, )]
[n]
[isArrayOrFunctionArgument, ?, 1, :, 0]
[isArrayOrFunctionArgument]
[1]
[0]
[Context, ., OTHER]
[Context]
[false]
[firstInList]
[n, !=, null]
[n]
[null]
[n]
[n, ., getNext, (, )]
[n]
[n, !=, firstInList]
[n]
[firstInList]
[cc, ., listSeparator, (, )]
[cc]
[addExpr, (, n, ,, 1, ,, Context, ., OTHER, )]
[n]
[1]
[Context, ., OTHER]
[Context]
[lastWasEmpty]
[n, ., isEmpty, (, )]
[n]
[lastWasEmpty]
[cc, ., listSeparator, (, )]
[cc]
[cc, ., beginCaseBody, (, )]
[cc]
[add, (, caseBody, )]
[caseBody]
[cc, ., endCaseBody, (, )]
[cc]
[n]
[c, !=, null]
[c]
[null]
[c]
[c, ., getNext, (, )]
[c]
[add, (, c, )]
[c]
[n, ., getString, (, )]
[n]
[n, ., getBooleanProp, (, Node, ., SLASH_V, )]
[n]
[Node, ., SLASH_V]
[Node]
[useSlashV]
[add, (, jsString, (, n, ., getString, (, ), ,, useSlashV, ), )]
[jsString, (, n, ., getString, (, ), ,, useSlashV, )]
[n, ., getString, (, )]
[n]
[useSlashV]
[ESCAPED_JS_STRINGS, ., get, (, s, )]
[ESCAPED_JS_STRINGS]
[s]
[cached, ==, null]
[cached]
[null]
[cached]
[jsString, (, n, ., getString, (, ), ,, useSlashV, )]
[n, ., getString, (, )]
[n]
[useSlashV]
[ESCAPED_JS_STRINGS, ., put, (, s, ,, cached, )]
[ESCAPED_JS_STRINGS]
[s]
[cached]
[add, (, cached, )]
[cached]
[0]
[0]
[0]
[i, <, s, ., length, (, )]
[i]
[s, ., length, (, )]
[s]
[i, ++]
[i]
[s, ., charAt, (, i, )]
[s]
[i]
['"']
[doubleq, ++]
[doubleq]
['\'']
[singleq, ++]
[singleq]
[preferSingleQuotes, ?, (, singleq, <=, doubleq, ), :, (, singleq, <, doubleq, )]
[preferSingleQuotes]
[(, singleq, <=, doubleq, )]
[singleq, <=, doubleq]
[singleq]
[doubleq]
[(, singleq, <, doubleq, )]
[singleq, <, doubleq]
[singleq]
[doubleq]
[quote]
['\'']
[doublequote]
["\""]
[singlequote]
["\\\'"]
[quote]
['\"']
[doublequote]
["\\\""]
[singlequote]
["\'"]
[strEscape, (, s, ,, quote, ,, doublequote, ,, singlequote, ,, "\\\\", ,, outputCharsetEncoder, ,, useSlashV, ,, false, )]
[s]
[quote]
[doublequote]
[singlequote]
["\\\\"]
[outputCharsetEncoder]
[useSlashV]
[false]
[strEscape, (, s, ,, '/', ,, "\"", ,, "'", ,, "\\", ,, outputCharsetEncoder, ,, false, ,, true, )]
[s]
['/']
["\""]
["'"]
["\\"]
[outputCharsetEncoder]
[false]
[true]
[strEscape, (, s, ,, '"', ,, "\\\"", ,, "\'", ,, "\\\\", ,, null, ,, false, ,, false, )]
[s]
['"']
["\\\""]
["\'"]
["\\\\"]
[null]
[false]
[false]
[regexpEscape, (, s, ,, null, )]
[s]
[null]
[new, StringBuilder, (, s, ., length, (, ), +, 2, )]
[s, ., length, (, ), +, 2]
[s, ., length, (, )]
[s]
[2]
[sb, ., append, (, quote, )]
[sb]
[quote]
[0]
[i, <, s, ., length, (, )]
[i]
[s, ., length, (, )]
[s]
[i, ++]
[i]
[s, ., charAt, (, i, )]
[s]
[i]
[c]
['\0']
[sb, ., append, (, "\\x00", )]
[sb]
["\\x00"]
['\u000B']
[useSlashV]
[sb, ., append, (, "\\v", )]
[sb]
["\\v"]
[sb, ., append, (, "\\x0B", )]
[sb]
["\\x0B"]
['\b']
[sb, ., append, (, "\\b", )]
[sb]
["\\b"]
['\f']
[sb, ., append, (, "\\f", )]
[sb]
["\\f"]
['\n']
[sb, ., append, (, "\\n", )]
[sb]
["\\n"]
['\r']
[sb, ., append, (, "\\r", )]
[sb]
["\\r"]
['\t']
[sb, ., append, (, "\\t", )]
[sb]
["\\t"]
['\\']
[sb, ., append, (, backslashEscape, )]
[sb]
[backslashEscape]
['\"']
[sb, ., append, (, doublequoteEscape, )]
[sb]
[doublequoteEscape]
['\'']
[sb, ., append, (, singlequoteEscape, )]
[sb]
[singlequoteEscape]
['\u2028']
[sb, ., append, (, "\\u2028", )]
[sb]
["\\u2028"]
['\u2029']
[sb, ., append, (, "\\u2029", )]
[sb]
["\\u2029"]
['=']
[trustedStrings, ||, isRegexp]
[trustedStrings]
[isRegexp]
[sb, ., append, (, c, )]
[sb]
[c]
[sb, ., append, (, "\\x3d", )]
[sb]
["\\x3d"]
['&']
[trustedStrings, ||, isRegexp]
[trustedStrings]
[isRegexp]
[sb, ., append, (, c, )]
[sb]
[c]
[sb, ., append, (, "\\x26", )]
[sb]
["\\x26"]
['>']
[!, trustedStrings, &&, !, isRegexp]
[!, trustedStrings]
[trustedStrings]
[!, isRegexp]
[isRegexp]
[sb, ., append, (, GT_ESCAPED, )]
[sb]
[GT_ESCAPED]
[i, >=, 2, &&, (, (, s, ., charAt, (, i, -, 1, ), ==, '-', &&, s, ., charAt, (, i, -, 2, ), ==, '-', ), ||, (, s, ., charAt, (, i, -, 1, ), ==, ']', &&, s, ., charAt, (, i, -, 2, ), ==, ']', ), )]
[i, >=, 2]
[i]
[2]
[(, (, s, ., charAt, (, i, -, 1, ), ==, '-', &&, s, ., charAt, (, i, -, 2, ), ==, '-', ), ||, (, s, ., charAt, (, i, -, 1, ), ==, ']', &&, s, ., charAt, (, i, -, 2, ), ==, ']', ), )]
[(, s, ., charAt, (, i, -, 1, ), ==, '-', &&, s, ., charAt, (, i, -, 2, ), ==, '-', ), ||, (, s, ., charAt, (, i, -, 1, ), ==, ']', &&, s, ., charAt, (, i, -, 2, ), ==, ']', )]
[(, s, ., charAt, (, i, -, 1, ), ==, '-', &&, s, ., charAt, (, i, -, 2, ), ==, '-', )]
[s, ., charAt, (, i, -, 1, ), ==, '-', &&, s, ., charAt, (, i, -, 2, ), ==, '-']
[s, ., charAt, (, i, -, 1, ), ==, '-']
[s, ., charAt, (, i, -, 1, )]
[s]
[i, -, 1]
[i]
[1]
['-']
[s, ., charAt, (, i, -, 2, ), ==, '-']
[s, ., charAt, (, i, -, 2, )]
[s]
[i, -, 2]
[i]
[2]
['-']
[(, s, ., charAt, (, i, -, 1, ), ==, ']', &&, s, ., charAt, (, i, -, 2, ), ==, ']', )]
[s, ., charAt, (, i, -, 1, ), ==, ']', &&, s, ., charAt, (, i, -, 2, ), ==, ']']
[s, ., charAt, (, i, -, 1, ), ==, ']']
[s, ., charAt, (, i, -, 1, )]
[s]
[i, -, 1]
[i]
[1]
[']']
[s, ., charAt, (, i, -, 2, ), ==, ']']
[s, ., charAt, (, i, -, 2, )]
[s]
[i, -, 2]
[i]
[2]
[']']
[sb, ., append, (, GT_ESCAPED, )]
[sb]
[GT_ESCAPED]
[sb, ., append, (, c, )]
[sb]
[c]
['<']
[!, trustedStrings, &&, !, isRegexp]
[!, trustedStrings]
[trustedStrings]
[!, isRegexp]
[isRegexp]
[sb, ., append, (, LT_ESCAPED, )]
[sb]
[LT_ESCAPED]
["/script"]
["!--"]
[s, ., regionMatches, (, true, ,, i, +, 1, ,, END_SCRIPT, ,, 0, ,, END_SCRIPT, ., length, (, ), )]
[s]
[true]
[i, +, 1]
[i]
[1]
[END_SCRIPT]
[0]
[END_SCRIPT, ., length, (, )]
[END_SCRIPT]
[sb, ., append, (, LT_ESCAPED, )]
[sb]
[LT_ESCAPED]
[s, ., regionMatches, (, false, ,, i, +, 1, ,, START_COMMENT, ,, 0, ,, START_COMMENT, ., length, (, ), )]
[s]
[false]
[i, +, 1]
[i]
[1]
[START_COMMENT]
[0]
[START_COMMENT, ., length, (, )]
[START_COMMENT]
[sb, ., append, (, LT_ESCAPED, )]
[sb]
[LT_ESCAPED]
[sb, ., append, (, c, )]
[sb]
[c]
[outputCharsetEncoder, !=, null]
[outputCharsetEncoder]
[null]
[outputCharsetEncoder, ., canEncode, (, c, )]
[outputCharsetEncoder]
[c]
[sb, ., append, (, c, )]
[sb]
[c]
[appendHexJavaScriptRepresentation, (, sb, ,, c, )]
[sb]
[c]
[c, >, 0x1f, &&, c, <, 0x7f]
[c, >, 0x1f]
[c]
[0x1f]
[c, <, 0x7f]
[c]
[0x7f]
[sb, ., append, (, c, )]
[sb]
[c]
[appendHexJavaScriptRepresentation, (, sb, ,, c, )]
[sb]
[c]
[sb, ., append, (, quote, )]
[sb]
[quote]
[sb, ., toString, (, )]
[sb]
[NodeUtil, ., isLatin, (, s, )]
[NodeUtil]
[s]
[s]
[new, StringBuilder, (, )]
[0]
[i, <, s, ., length, (, )]
[i]
[s, ., length, (, )]
[s]
[i, ++]
[i]
[s, ., charAt, (, i, )]
[s]
[i]
[c, >, 0x1F, &&, c, <, 0x7F]
[c, >, 0x1F]
[c]
[0x1F]
[c, <, 0x7F]
[c]
[0x7F]
[sb, ., append, (, c, )]
[sb]
[c]
[appendHexJavaScriptRepresentation, (, sb, ,, c, )]
[sb]
[c]
[sb, ., toString, (, )]
[sb]
[0]
[n, ., getFirstChild, (, )]
[n]
[c, !=, null, &&, i, <, maxCount]
[c, !=, null]
[c]
[null]
[i, <, maxCount]
[i]
[maxCount]
[c]
[c, ., getNext, (, )]
[c]
[c, ., isBlock, (, )]
[c]
[i]
[getNonEmptyChildCount, (, c, ,, maxCount, -, i, )]
[c]
[maxCount, -, i]
[maxCount]
[i]
[!, c, ., isEmpty, (, )]
[c, ., isEmpty, (, )]
[c]
[i, ++]
[i]
[i]
[n, ., getFirstChild, (, )]
[n]
[c, !=, null]
[c]
[null]
[c]
[c, ., getNext, (, )]
[c]
[c, ., isBlock, (, )]
[c]
[getFirstNonEmptyChild, (, c, )]
[c]
[result, !=, null]
[result]
[null]
[result]
[!, c, ., isEmpty, (, )]
[c, ., isEmpty, (, )]
[c]
[c]
[null]
[currentContext, ==, Context, ., BEFORE_DANGLING_ELSE, ?, Context, ., BEFORE_DANGLING_ELSE, :, Context, ., OTHER]
[currentContext, ==, Context, ., BEFORE_DANGLING_ELSE]
[currentContext]
[Context, ., BEFORE_DANGLING_ELSE]
[Context]
[Context, ., BEFORE_DANGLING_ELSE]
[Context]
[Context, ., OTHER]
[Context]
[(, context, ==, Context, ., IN_FOR_INIT_CLAUSE, ?, Context, ., IN_FOR_INIT_CLAUSE, :, Context, ., OTHER, )]
[context, ==, Context, ., IN_FOR_INIT_CLAUSE, ?, Context, ., IN_FOR_INIT_CLAUSE, :, Context, ., OTHER]
[context, ==, Context, ., IN_FOR_INIT_CLAUSE]
[context]
[Context, ., IN_FOR_INIT_CLAUSE]
[Context]
[Context, ., IN_FOR_INIT_CLAUSE]
[Context]
[Context, ., OTHER]
[Context]
[appendHexJavaScriptRepresentation, (, c, ,, sb, )]
[c]
[sb]
[new, RuntimeException, (, ex, )]
[ex]
[Character, ., isSupplementaryCodePoint, (, codePoint, )]
[Character]
[codePoint]
[Character, ., toChars, (, codePoint, )]
[Character]
[codePoint]
[appendHexJavaScriptRepresentation, (, surrogates, [, 0, ], ,, out, )]
[surrogates, [, 0, ]]
[surrogates]
[0]
[out]
[appendHexJavaScriptRepresentation, (, surrogates, [, 1, ], ,, out, )]
[surrogates, [, 1, ]]
[surrogates]
[1]
[out]
[out, ., append, (, "\\u", ), ., append, (, HEX_CHARS, [, (, codePoint, >, >, >, 12, ), &, 0xf, ], ), ., append, (, HEX_CHARS, [, (, codePoint, >, >, >, 8, ), &, 0xf, ], ), ., append, (, HEX_CHARS, [, (, codePoint, >, >, >, 4, ), &, 0xf, ], ), ., append, (, HEX_CHARS, [, codePoint, &, 0xf, ], )]
[out, ., append, (, "\\u", ), ., append, (, HEX_CHARS, [, (, codePoint, >, >, >, 12, ), &, 0xf, ], ), ., append, (, HEX_CHARS, [, (, codePoint, >, >, >, 8, ), &, 0xf, ], ), ., append, (, HEX_CHARS, [, (, codePoint, >, >, >, 4, ), &, 0xf, ], )]
[out, ., append, (, "\\u", ), ., append, (, HEX_CHARS, [, (, codePoint, >, >, >, 12, ), &, 0xf, ], ), ., append, (, HEX_CHARS, [, (, codePoint, >, >, >, 8, ), &, 0xf, ], )]
[out, ., append, (, "\\u", ), ., append, (, HEX_CHARS, [, (, codePoint, >, >, >, 12, ), &, 0xf, ], )]
[out, ., append, (, "\\u", )]
[out]
["\\u"]
[HEX_CHARS, [, (, codePoint, >, >, >, 12, ), &, 0xf, ]]
[HEX_CHARS]
[(, codePoint, >, >, >, 12, ), &, 0xf]
[(, codePoint, >, >, >, 12, )]
[codePoint, >, >, >, 12]
[codePoint]
[12]
[0xf]
[HEX_CHARS, [, (, codePoint, >, >, >, 8, ), &, 0xf, ]]
[HEX_CHARS]
[(, codePoint, >, >, >, 8, ), &, 0xf]
[(, codePoint, >, >, >, 8, )]
[codePoint, >, >, >, 8]
[codePoint]
[8]
[0xf]
[HEX_CHARS, [, (, codePoint, >, >, >, 4, ), &, 0xf, ]]
[HEX_CHARS]
[(, codePoint, >, >, >, 4, ), &, 0xf]
[(, codePoint, >, >, >, 4, )]
[codePoint, >, >, >, 4]
[codePoint]
[4]
[0xf]
[HEX_CHARS, [, codePoint, &, 0xf, ]]
[HEX_CHARS]
[codePoint, &, 0xf]
[codePoint]
[0xf]
