[NodeUtil, ., precedence, (, Token, ., AND, )]
[NodeUtil]
[Token, ., AND]
[Token]
[NodeUtil, ., precedence, (, Token, ., OR, )]
[NodeUtil]
[Token, ., OR]
[Token]
[NodeUtil, ., precedence, (, Token, ., NOT, )]
[NodeUtil]
[Token, ., NOT]
[Token]
[CodeGenerator, ., forCostEstimation, (, null, )]
[CodeGenerator]
[null]
[".split('.')", ., length, (, )]
[".split('.')"]
[DiagnosticType, ., warning, (, "JSC_INVALID_REGULAR_EXPRESSION_FLAGS", ,, "Invalid flags to RegExp constructor: {0}", )]
[DiagnosticType]
["JSC_INVALID_REGULAR_EXPRESSION_FLAGS"]
["Invalid flags to RegExp constructor: {0}"]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, !, input, ., isFunction, (, ), ;, }, }]
[!, input, ., isFunction, (, )]
[input, ., isFunction, (, )]
[input]
[this, ., late]
[this]
[late]
[@, SuppressWarnings, (, "fallthrough", )]
["fallthrough"]
[node, ., getType, (, )]
[node]
[Token, ., RETURN]
[Token]
[tryRemoveRedundantExit, (, node, )]
[node]
[result, !=, node]
[result]
[node]
[result]
[result]
[tryReplaceExitWithBreak, (, node, )]
[node]
[result, !=, node]
[result]
[node]
[result]
[tryReduceReturn, (, node, )]
[node]
[Token, ., THROW]
[Token]
[tryRemoveRedundantExit, (, node, )]
[node]
[result, !=, node]
[result]
[node]
[result]
[tryReplaceExitWithBreak, (, node, )]
[node]
[Token, ., NOT]
[Token]
[tryMinimizeCondition, (, node, ., getFirstChild, (, ), )]
[node, ., getFirstChild, (, )]
[node]
[tryMinimizeNot, (, node, )]
[node]
[Token, ., IF]
[Token]
[tryMinimizeCondition, (, node, ., getFirstChild, (, ), )]
[node, ., getFirstChild, (, )]
[node]
[tryMinimizeIf, (, node, )]
[node]
[Token, ., EXPR_RESULT]
[Token]
[tryMinimizeCondition, (, node, ., getFirstChild, (, ), )]
[node, ., getFirstChild, (, )]
[node]
[node]
[Token, ., HOOK]
[Token]
[tryMinimizeCondition, (, node, ., getFirstChild, (, ), )]
[node, ., getFirstChild, (, )]
[node]
[node]
[Token, ., WHILE]
[Token]
[Token, ., DO]
[Token]
[tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), )]
[NodeUtil, ., getConditionExpression, (, node, )]
[NodeUtil]
[node]
[node]
[Token, ., FOR]
[Token]
[!, NodeUtil, ., isForIn, (, node, )]
[NodeUtil, ., isForIn, (, node, )]
[NodeUtil]
[node]
[tryJoinForCondition, (, node, )]
[node]
[tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), )]
[NodeUtil, ., getConditionExpression, (, node, )]
[NodeUtil]
[node]
[node]
[Token, ., TRUE]
[Token]
[Token, ., FALSE]
[Token]
[reduceTrueFalse, (, node, )]
[node]
[Token, ., NEW]
[Token]
[node]
[tryFoldStandardConstructors, (, node, )]
[node]
[!, node, ., isCall, (, )]
[node, ., isCall, (, )]
[node]
[node]
[Token, ., CALL]
[Token]
[tryFoldLiteralConstructor, (, node, )]
[node]
[result, ==, node]
[result]
[node]
[result]
[tryFoldSimpleFunctionCall, (, node, )]
[node]
[result, ==, node]
[result]
[node]
[result]
[tryFoldImmediateCallToBoundFunction, (, node, )]
[node]
[result]
[Token, ., COMMA]
[Token]
[trySplitComma, (, node, )]
[node]
[Token, ., NAME]
[Token]
[tryReplaceUndefined, (, node, )]
[node]
[Token, ., BLOCK]
[Token]
[tryReplaceIf, (, node, )]
[node]
[Token, ., ARRAYLIT]
[Token]
[tryMinimizeArrayLiteral, (, node, )]
[node]
[node]
[!, late]
[late]
[n, ., getLastChild, (, )]
[n]
[block, ., getFirstChild, (, )]
[block]
[maybeIf, !=, null, &&, maybeIf, ., isIf, (, )]
[maybeIf, !=, null]
[maybeIf]
[null]
[maybeIf, ., isIf, (, )]
[maybeIf]
[maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, )]
[maybeIf, ., getChildAtIndex, (, 1, )]
[maybeIf]
[1]
[maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, )]
[maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, )]
[maybeBreak, !=, null]
[maybeBreak]
[null]
[maybeBreak, ., isBreak, (, )]
[maybeBreak]
[!, maybeBreak, ., hasChildren, (, )]
[maybeBreak, ., hasChildren, (, )]
[maybeBreak]
[maybeIf, ., getChildCount, (, ), ==, 3]
[maybeIf, ., getChildCount, (, )]
[maybeIf]
[3]
[block, ., replaceChild, (, maybeIf, ,, maybeIf, ., getLastChild, (, ), ., detachFromParent, (, ), )]
[block]
[maybeIf]
[maybeIf, ., getLastChild, (, ), ., detachFromParent, (, )]
[maybeIf, ., getLastChild, (, )]
[maybeIf]
[block, ., removeFirstChild, (, )]
[block]
[maybeIf, ., removeFirstChild, (, )]
[maybeIf]
[IR, ., not, (, ifCondition, ), ., srcref, (, ifCondition, )]
[IR, ., not, (, ifCondition, )]
[IR]
[ifCondition]
[ifCondition]
[NodeUtil, ., getConditionExpression, (, n, )]
[NodeUtil]
[n]
[forCondition, ., isEmpty, (, )]
[forCondition]
[n, ., replaceChild, (, forCondition, ,, fixedIfCondition, )]
[n]
[forCondition]
[fixedIfCondition]
[new, Node, (, Token, ., AND, )]
[Token, ., AND]
[Token]
[n, ., replaceChild, (, forCondition, ,, replacement, )]
[n]
[forCondition]
[replacement]
[replacement, ., addChildToBack, (, forCondition, )]
[replacement]
[forCondition]
[replacement, ., addChildToBack, (, fixedIfCondition, )]
[replacement]
[fixedIfCondition]
[reportCodeChange, (, )]
[Preconditions, ., checkState, (, n, ., isCall, (, ), )]
[Preconditions]
[n, ., isCall, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[callTarget, !=, null, &&, callTarget, ., isName, (, ), &&, callTarget, ., getString, (, ), ., equals, (, "String", )]
[callTarget, !=, null, &&, callTarget, ., isName, (, )]
[callTarget, !=, null]
[callTarget]
[null]
[callTarget, ., isName, (, )]
[callTarget]
[callTarget, ., getString, (, ), ., equals, (, "String", )]
[callTarget, ., getString, (, )]
[callTarget]
["String"]
[callTarget, ., getNext, (, )]
[callTarget]
[value, !=, null, &&, value, ., getNext, (, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, )]
[value, !=, null, &&, value, ., getNext, (, ), ==, null]
[value, !=, null]
[value]
[null]
[value, ., getNext, (, ), ==, null]
[value, ., getNext, (, )]
[value]
[null]
[NodeUtil, ., isImmutableValue, (, value, )]
[NodeUtil]
[value]
[IR, ., add, (, IR, ., string, (, "", ), ., srcref, (, callTarget, ), ,, value, ., detachFromParent, (, ), )]
[IR]
[IR, ., string, (, "", ), ., srcref, (, callTarget, )]
[IR, ., string, (, "", )]
[IR]
[""]
[callTarget]
[value, ., detachFromParent, (, )]
[value]
[n, ., getParent, (, ), ., replaceChild, (, n, ,, addition, )]
[n, ., getParent, (, )]
[n]
[n]
[addition]
[reportCodeChange, (, )]
[addition]
[n]
[Preconditions, ., checkState, (, n, ., isCall, (, ), )]
[Preconditions]
[n, ., isCall, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,, false, )]
[getCodingConvention, (, )]
[callTarget]
[false]
[bind, !=, null]
[bind]
[null]
[bind, ., target, ., detachFromParent, (, )]
[bind, ., target]
[bind]
[n, ., replaceChild, (, callTarget, ,, bind, ., target, )]
[n]
[callTarget]
[bind, ., target]
[bind]
[callTarget]
[bind, ., target]
[bind]
[addParameterAfter, (, bind, ., parameters, ,, callTarget, )]
[bind, ., parameters]
[bind]
[callTarget]
[bind, ., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, )]
[bind, ., thisValue, !=, null]
[bind, ., thisValue]
[bind]
[null]
[!, NodeUtil, ., isUndefined, (, bind, ., thisValue, )]
[NodeUtil, ., isUndefined, (, bind, ., thisValue, )]
[NodeUtil]
[bind, ., thisValue]
[bind]
[IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,, IR, ., string, (, "call", ), ., srcref, (, callTarget, ), )]
[IR]
[callTarget, ., cloneTree, (, )]
[callTarget]
[IR, ., string, (, "call", ), ., srcref, (, callTarget, )]
[IR, ., string, (, "call", )]
[IR]
["call"]
[callTarget]
[n, ., replaceChild, (, callTarget, ,, newCallTarget, )]
[n]
[callTarget]
[newCallTarget]
[n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, )]
[n]
[bind, ., thisValue, ., cloneTree, (, )]
[bind, ., thisValue]
[bind]
[newCallTarget]
[n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, )]
[n]
[Node, ., FREE_CALL]
[Node]
[false]
[n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, )]
[n]
[Node, ., FREE_CALL]
[Node]
[true]
[reportCodeChange, (, )]
[n]
[parameterList, !=, null]
[parameterList]
[null]
[addParameterAfter, (, parameterList, ., getNext, (, ), ,, after, )]
[parameterList, ., getNext, (, )]
[parameterList]
[after]
[after, ., getParent, (, ), ., addChildAfter, (, parameterList, ., cloneTree, (, ), ,, after, )]
[after, ., getParent, (, )]
[after]
[parameterList, ., cloneTree, (, )]
[parameterList]
[after]
[late]
[n]
[n, ., getParent, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[n, ., getLastChild, (, )]
[n]
[parent, ., isExprResult, (, ), &&, !, parent, ., getParent, (, ), ., isLabel, (, )]
[parent, ., isExprResult, (, )]
[parent]
[!, parent, ., getParent, (, ), ., isLabel, (, )]
[parent, ., getParent, (, ), ., isLabel, (, )]
[parent, ., getParent, (, )]
[parent]
[n, ., detachChildren, (, )]
[n]
[parent, ., replaceChild, (, n, ,, left, )]
[parent]
[n]
[left]
[IR, ., exprResult, (, right, )]
[IR]
[right]
[newStatement, ., copyInformationFrom, (, n, )]
[newStatement]
[n]
[parent, ., getParent, (, ), ., addChildAfter, (, newStatement, ,, parent, )]
[parent, ., getParent, (, )]
[parent]
[newStatement]
[parent]
[reportCodeChange, (, )]
[left]
[n]
[n, ., getFirstChild, (, )]
[n]
[child, !=, null]
[child]
[null]
[child]
[child, ., getNext, (, )]
[child]
[child, ., isIf, (, )]
[child]
[child, ., getFirstChild, (, )]
[child]
[cond, ., getNext, (, )]
[cond]
[thenBranch, ., getNext, (, )]
[thenBranch]
[child, ., getNext, (, )]
[child]
[nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, )]
[nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, )]
[nextNode, !=, null, &&, elseBranch, ==, null]
[nextNode, !=, null]
[nextNode]
[null]
[elseBranch, ==, null]
[elseBranch]
[null]
[isReturnBlock, (, thenBranch, )]
[thenBranch]
[nextNode, ., isIf, (, )]
[nextNode]
[nextNode, ., getFirstChild, (, )]
[nextNode]
[nextCond, ., getNext, (, )]
[nextCond]
[nextThen, ., getNext, (, )]
[nextThen]
[thenBranch, ., isEquivalentToTyped, (, nextThen, )]
[thenBranch]
[nextThen]
[child, ., detachFromParent, (, )]
[child]
[child, ., detachChildren, (, )]
[child]
[new, Node, (, Token, ., OR, ,, cond, )]
[Token, ., OR]
[Token]
[cond]
[nextNode, ., replaceChild, (, nextCond, ,, newCond, )]
[nextNode]
[nextCond]
[newCond]
[newCond, ., addChildToBack, (, nextCond, )]
[newCond]
[nextCond]
[reportCodeChange, (, )]
[nextElse, !=, null, &&, thenBranch, ., isEquivalentToTyped, (, nextElse, )]
[nextElse, !=, null]
[nextElse]
[null]
[thenBranch, ., isEquivalentToTyped, (, nextElse, )]
[thenBranch]
[nextElse]
[child, ., detachFromParent, (, )]
[child]
[child, ., detachChildren, (, )]
[child]
[new, Node, (, Token, ., AND, ,, IR, ., not, (, cond, ), ., srcref, (, cond, ), )]
[Token, ., AND]
[Token]
[IR, ., not, (, cond, ), ., srcref, (, cond, )]
[IR, ., not, (, cond, )]
[IR]
[cond]
[cond]
[nextNode, ., replaceChild, (, nextCond, ,, newCond, )]
[nextNode]
[nextCond]
[newCond]
[newCond, ., addChildToBack, (, nextCond, )]
[newCond]
[nextCond]
[reportCodeChange, (, )]
[nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, )]
[nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, )]
[nextNode, !=, null, &&, elseBranch, ==, null]
[nextNode, !=, null]
[nextNode]
[null]
[elseBranch, ==, null]
[elseBranch]
[null]
[isReturnBlock, (, thenBranch, )]
[thenBranch]
[isReturnExpression, (, nextNode, )]
[nextNode]
[null]
[isReturnExpressBlock, (, thenBranch, )]
[thenBranch]
[thenExpr]
[getBlockReturnExpression, (, thenBranch, )]
[thenBranch]
[thenExpr, ., detachFromParent, (, )]
[thenExpr]
[thenExpr]
[NodeUtil, ., newUndefinedNode, (, child, )]
[NodeUtil]
[child]
[nextNode, ., getFirstChild, (, )]
[nextNode]
[cond, ., detachFromParent, (, )]
[cond]
[elseExpr, ., detachFromParent, (, )]
[elseExpr]
[IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, child, ), )]
[IR]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, child, )]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, )]
[IR]
[cond]
[thenExpr]
[elseExpr]
[child]
[n, ., replaceChild, (, child, ,, returnNode, )]
[n]
[child]
[returnNode]
[n, ., removeChild, (, nextNode, )]
[n]
[nextNode]
[reportCodeChange, (, )]
[elseBranch, !=, null, &&, statementMustExitParent, (, thenBranch, )]
[elseBranch, !=, null]
[elseBranch]
[null]
[statementMustExitParent, (, thenBranch, )]
[thenBranch]
[child, ., removeChild, (, elseBranch, )]
[child]
[elseBranch]
[n, ., addChildAfter, (, elseBranch, ,, child, )]
[n]
[elseBranch]
[child]
[reportCodeChange, (, )]
[n]
[n, ., getType, (, )]
[n]
[Token, ., THROW]
[Token]
[Token, ., RETURN]
[Token]
[true]
[Token, ., BLOCK]
[Token]
[n, ., hasChildren, (, )]
[n]
[n, ., getLastChild, (, )]
[n]
[statementMustExitParent, (, child, )]
[child]
[false]
[Token, ., FUNCTION]
[Token]
[false]
[isASTNormalized, (, ), &&, NodeUtil, ., isUndefined, (, n, ), &&, !, NodeUtil, ., isLValue, (, n, )]
[isASTNormalized, (, ), &&, NodeUtil, ., isUndefined, (, n, )]
[isASTNormalized, (, )]
[NodeUtil, ., isUndefined, (, n, )]
[NodeUtil]
[n]
[!, NodeUtil, ., isLValue, (, n, )]
[NodeUtil, ., isLValue, (, n, )]
[NodeUtil]
[n]
[NodeUtil, ., newUndefinedNode, (, n, )]
[NodeUtil]
[n]
[n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, )]
[n, ., getParent, (, )]
[n]
[n]
[replacement]
[reportCodeChange, (, )]
[replacement]
[n]
[n, ., getFirstChild, (, )]
[n]
[result, !=, null]
[result]
[null]
[result, ., getType, (, )]
[result]
[Token, ., VOID]
[Token]
[result, ., getFirstChild, (, )]
[result]
[!, mayHaveSideEffects, (, operand, )]
[mayHaveSideEffects, (, operand, )]
[operand]
[n, ., removeFirstChild, (, )]
[n]
[reportCodeChange, (, )]
[Token, ., NAME]
[Token]
[result, ., getString, (, )]
[result]
[name, ., equals, (, "undefined", )]
[name]
["undefined"]
[n, ., removeFirstChild, (, )]
[n]
[reportCodeChange, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[n]
[!, ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, )]
[ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, )]
[ControlFlowAnalysis]
[breakTarget]
[null]
[breakTarget]
[breakTarget, ., getParent, (, )]
[breakTarget]
[breakTarget, ., isFunction, (, ), ||, breakTarget, ., isScript, (, )]
[breakTarget, ., isFunction, (, )]
[breakTarget]
[breakTarget, ., isScript, (, )]
[breakTarget]
[n]
[ControlFlowAnalysis, ., computeFollowNode, (, breakTarget, )]
[ControlFlowAnalysis]
[breakTarget]
[follow]
[follow]
[skipFinallyNodes, (, follow, )]
[follow]
[prefinallyFollows, !=, follow]
[prefinallyFollows]
[follow]
[!, isPure, (, result, )]
[isPure, (, result, )]
[result]
[n]
[follow, ==, null, &&, (, n, ., isThrow, (, ), ||, result, !=, null, )]
[follow, ==, null]
[follow]
[null]
[(, n, ., isThrow, (, ), ||, result, !=, null, )]
[n, ., isThrow, (, ), ||, result, !=, null]
[n, ., isThrow, (, )]
[n]
[result, !=, null]
[result]
[null]
[n]
[follow, ==, null, ||, areMatchingExits, (, n, ,, follow, )]
[follow, ==, null]
[follow]
[null]
[areMatchingExits, (, n, ,, follow, )]
[n]
[follow]
[IR, ., breakNode, (, )]
[IR]
[n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, )]
[n, ., getParent, (, )]
[n]
[n]
[replacement]
[this, ., reportCodeChange, (, )]
[this]
[replacement]
[n]
[n, ., getFirstChild, (, )]
[n]
[ControlFlowAnalysis, ., computeFollowNode, (, n, )]
[ControlFlowAnalysis]
[n]
[follow]
[follow]
[skipFinallyNodes, (, follow, )]
[follow]
[prefinallyFollows, !=, follow]
[prefinallyFollows]
[follow]
[!, isPure, (, exitExpr, )]
[isPure, (, exitExpr, )]
[exitExpr]
[n]
[follow, ==, null, &&, (, n, ., isThrow, (, ), ||, exitExpr, !=, null, )]
[follow, ==, null]
[follow]
[null]
[(, n, ., isThrow, (, ), ||, exitExpr, !=, null, )]
[n, ., isThrow, (, ), ||, exitExpr, !=, null]
[n, ., isThrow, (, )]
[n]
[exitExpr, !=, null]
[exitExpr]
[null]
[n]
[follow, ==, null, ||, areMatchingExits, (, n, ,, follow, )]
[follow, ==, null]
[follow]
[null]
[areMatchingExits, (, n, ,, follow, )]
[n]
[follow]
[n, ., detachFromParent, (, )]
[n]
[reportCodeChange, (, )]
[null]
[n]
[n, ==, null, ||, (, !, NodeUtil, ., canBeSideEffected, (, n, ), &&, !, mayHaveSideEffects, (, n, ), )]
[n, ==, null]
[n]
[null]
[(, !, NodeUtil, ., canBeSideEffected, (, n, ), &&, !, mayHaveSideEffects, (, n, ), )]
[!, NodeUtil, ., canBeSideEffected, (, n, ), &&, !, mayHaveSideEffects, (, n, )]
[!, NodeUtil, ., canBeSideEffected, (, n, )]
[NodeUtil, ., canBeSideEffected, (, n, )]
[NodeUtil]
[n]
[!, mayHaveSideEffects, (, n, )]
[mayHaveSideEffects, (, n, )]
[n]
[n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, )]
[n, !=, null]
[n]
[null]
[NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, )]
[NodeUtil]
[n, ., getParent, (, )]
[n]
[n]
[n]
[ControlFlowAnalysis, ., computeFollowNode, (, n, )]
[ControlFlowAnalysis]
[n]
[n]
[nodeThis, ., isEquivalentTo, (, nodeThat, ), &&, (, !, isExceptionPossible, (, nodeThis, ), ||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, ), )]
[nodeThis, ., isEquivalentTo, (, nodeThat, )]
[nodeThis]
[nodeThat]
[(, !, isExceptionPossible, (, nodeThis, ), ||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, ), )]
[!, isExceptionPossible, (, nodeThis, ), ||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, )]
[!, isExceptionPossible, (, nodeThis, )]
[isExceptionPossible, (, nodeThis, )]
[nodeThis]
[getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, )]
[getExceptionHandler, (, nodeThis, )]
[nodeThis]
[getExceptionHandler, (, nodeThat, )]
[nodeThat]
[Preconditions, ., checkState, (, n, ., isReturn, (, ), ||, n, ., isThrow, (, ), )]
[Preconditions]
[n, ., isReturn, (, ), ||, n, ., isThrow, (, )]
[n, ., isReturn, (, )]
[n]
[n, ., isThrow, (, )]
[n]
[n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (, n, ., getLastChild, (, ), ,, true, ), )]
[n, ., isThrow, (, )]
[n]
[(, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (, n, ., getLastChild, (, ), ,, true, ), )]
[n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (, n, ., getLastChild, (, ), ,, true, )]
[n, ., hasChildren, (, )]
[n]
[!, NodeUtil, ., isLiteralValue, (, n, ., getLastChild, (, ), ,, true, )]
[NodeUtil, ., isLiteralValue, (, n, ., getLastChild, (, ), ,, true, )]
[NodeUtil]
[n, ., getLastChild, (, )]
[n]
[true]
[ControlFlowAnalysis, ., getExceptionHandler, (, n, )]
[ControlFlowAnalysis]
[n]
[n, ., getParent, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[notChild, ., getType, (, )]
[notChild]
[Token, ., EQ]
[Token]
[complementOperator]
[Token, ., NE]
[Token]
[Token, ., NE]
[Token]
[complementOperator]
[Token, ., EQ]
[Token]
[Token, ., SHEQ]
[Token]
[complementOperator]
[Token, ., SHNE]
[Token]
[Token, ., SHNE]
[Token]
[complementOperator]
[Token, ., SHEQ]
[Token]
[n]
[n, ., removeFirstChild, (, )]
[n]
[newOperator, ., setType, (, complementOperator, )]
[newOperator]
[complementOperator]
[parent, ., replaceChild, (, n, ,, newOperator, )]
[parent]
[n]
[newOperator]
[reportCodeChange, (, )]
[newOperator]
[n, ., getParent, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[NodeUtil, ., isLiteralValue, (, cond, ,, true, )]
[NodeUtil]
[cond]
[true]
[n]
[cond, ., getNext, (, )]
[cond]
[thenBranch, ., getNext, (, )]
[thenBranch]
[elseBranch, ==, null]
[elseBranch]
[null]
[isFoldableExpressBlock, (, thenBranch, )]
[thenBranch]
[getBlockExpression, (, thenBranch, )]
[thenBranch]
[!, late, &&, isPropertyAssignmentInExpression, (, expr, )]
[!, late]
[late]
[isPropertyAssignmentInExpression, (, expr, )]
[expr]
[n]
[cond, ., isNot, (, )]
[cond]
[isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE, )]
[isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, )]
[cond]
[OR_PRECEDENCE]
[isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE, )]
[expr, ., getFirstChild, (, )]
[expr]
[OR_PRECEDENCE]
[n]
[IR, ., or, (, cond, ., removeFirstChild, (, ), ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, )]
[IR, ., or, (, cond, ., removeFirstChild, (, ), ,, expr, ., removeFirstChild, (, ), )]
[IR]
[cond, ., removeFirstChild, (, )]
[cond]
[expr, ., removeFirstChild, (, )]
[expr]
[n]
[NodeUtil, ., newExpr, (, or, )]
[NodeUtil]
[or]
[parent, ., replaceChild, (, n, ,, newExpr, )]
[parent]
[n]
[newExpr]
[reportCodeChange, (, )]
[newExpr]
[isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE, )]
[isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, )]
[cond]
[AND_PRECEDENCE]
[isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE, )]
[expr, ., getFirstChild, (, )]
[expr]
[AND_PRECEDENCE]
[n]
[n, ., removeChild, (, cond, )]
[n]
[cond]
[IR, ., and, (, cond, ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, )]
[IR, ., and, (, cond, ,, expr, ., removeFirstChild, (, ), )]
[IR]
[cond]
[expr, ., removeFirstChild, (, )]
[expr]
[n]
[NodeUtil, ., newExpr, (, and, )]
[NodeUtil]
[and]
[parent, ., replaceChild, (, n, ,, newExpr, )]
[parent]
[n]
[newExpr]
[reportCodeChange, (, )]
[newExpr]
[NodeUtil, ., isStatementBlock, (, thenBranch, ), &&, thenBranch, ., hasOneChild, (, )]
[NodeUtil, ., isStatementBlock, (, thenBranch, )]
[NodeUtil]
[thenBranch]
[thenBranch, ., hasOneChild, (, )]
[thenBranch]
[thenBranch, ., getFirstChild, (, )]
[thenBranch]
[innerIf, ., isIf, (, )]
[innerIf]
[innerIf, ., getFirstChild, (, )]
[innerIf]
[innerCond, ., getNext, (, )]
[innerCond]
[innerThenBranch, ., getNext, (, )]
[innerThenBranch]
[innerElseBranch, ==, null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), )]
[innerElseBranch, ==, null]
[innerElseBranch]
[null]
[!, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), )]
[(, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), )]
[isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, )]
[isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, )]
[cond]
[AND_PRECEDENCE]
[isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, )]
[innerCond]
[AND_PRECEDENCE]
[n, ., detachChildren, (, )]
[n]
[n, ., addChildToBack, (, IR, ., and, (, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), )]
[n]
[IR, ., and, (, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (, cond, )]
[IR, ., and, (, cond, ,, innerCond, ., detachFromParent, (, ), )]
[IR]
[cond]
[innerCond, ., detachFromParent, (, )]
[innerCond]
[cond]
[n, ., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (, ), )]
[n]
[innerThenBranch, ., detachFromParent, (, )]
[innerThenBranch]
[reportCodeChange, (, )]
[n]
[n]
[tryRemoveRepeatedStatements, (, n, )]
[n]
[cond, ., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, )]
[cond, ., isNot, (, )]
[cond]
[!, consumesDanglingElse, (, elseBranch, )]
[consumesDanglingElse, (, elseBranch, )]
[elseBranch]
[n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), )]
[n]
[cond]
[cond, ., removeFirstChild, (, )]
[cond]
[n, ., removeChild, (, thenBranch, )]
[n]
[thenBranch]
[n, ., addChildToBack, (, thenBranch, )]
[n]
[thenBranch]
[reportCodeChange, (, )]
[n]
[isReturnExpressBlock, (, thenBranch, ), &&, isReturnExpressBlock, (, elseBranch, )]
[isReturnExpressBlock, (, thenBranch, )]
[thenBranch]
[isReturnExpressBlock, (, elseBranch, )]
[elseBranch]
[getBlockReturnExpression, (, thenBranch, )]
[thenBranch]
[getBlockReturnExpression, (, elseBranch, )]
[elseBranch]
[n, ., removeChild, (, cond, )]
[n]
[cond]
[thenExpr, ., detachFromParent, (, )]
[thenExpr]
[elseExpr, ., detachFromParent, (, )]
[elseExpr]
[IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), )]
[IR]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, )]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, )]
[IR]
[cond]
[thenExpr]
[elseExpr]
[n]
[parent, ., replaceChild, (, n, ,, returnNode, )]
[parent]
[n]
[returnNode]
[reportCodeChange, (, )]
[returnNode]
[isFoldableExpressBlock, (, thenBranch, )]
[thenBranch]
[isFoldableExpressBlock, (, elseBranch, )]
[elseBranch]
[thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock]
[thenBranchIsExpressionBlock]
[elseBranchIsExpressionBlock]
[getBlockExpression, (, thenBranch, ), ., getFirstChild, (, )]
[getBlockExpression, (, thenBranch, )]
[thenBranch]
[getBlockExpression, (, elseBranch, ), ., getFirstChild, (, )]
[getBlockExpression, (, elseBranch, )]
[elseBranch]
[thenOp, ., getType, (, ), ==, elseOp, ., getType, (, )]
[thenOp, ., getType, (, )]
[thenOp]
[elseOp, ., getType, (, )]
[elseOp]
[NodeUtil, ., isAssignmentOp, (, thenOp, )]
[NodeUtil]
[thenOp]
[thenOp, ., getFirstChild, (, )]
[thenOp]
[areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild, (, ), ), &&, !, mayEffectMutableState, (, lhs, )]
[areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild, (, ), )]
[lhs]
[elseOp, ., getFirstChild, (, )]
[elseOp]
[!, mayEffectMutableState, (, lhs, )]
[mayEffectMutableState, (, lhs, )]
[lhs]
[n, ., removeChild, (, cond, )]
[n]
[cond]
[thenOp, ., removeFirstChild, (, )]
[thenOp]
[thenOp, ., removeFirstChild, (, )]
[thenOp]
[elseOp, ., getLastChild, (, )]
[elseOp]
[elseOp, ., removeChild, (, elseExpr, )]
[elseOp]
[elseExpr]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, )]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, )]
[IR]
[cond]
[thenExpr]
[elseExpr]
[n]
[new, Node, (, thenOp, ., getType, (, ), ,, assignName, ,, hookNode, ), ., srcref, (, thenOp, )]
[new, Node, (, thenOp, ., getType, (, ), ,, assignName, ,, hookNode, )]
[thenOp, ., getType, (, )]
[thenOp]
[assignName]
[hookNode]
[thenOp]
[NodeUtil, ., newExpr, (, assign, )]
[NodeUtil]
[assign]
[parent, ., replaceChild, (, n, ,, expr, )]
[parent]
[n]
[expr]
[reportCodeChange, (, )]
[expr]
[n, ., removeChild, (, cond, )]
[n]
[cond]
[thenOp, ., detachFromParent, (, )]
[thenOp]
[elseOp, ., detachFromParent, (, )]
[elseOp]
[IR, ., exprResult, (, IR, ., hook, (, cond, ,, thenOp, ,, elseOp, ), ., srcref, (, n, ), )]
[IR]
[IR, ., hook, (, cond, ,, thenOp, ,, elseOp, ), ., srcref, (, n, )]
[IR, ., hook, (, cond, ,, thenOp, ,, elseOp, )]
[IR]
[cond]
[thenOp]
[elseOp]
[n]
[parent, ., replaceChild, (, n, ,, expr, )]
[parent]
[n]
[expr]
[reportCodeChange, (, )]
[expr]
[isVarBlock, (, thenBranch, )]
[thenBranch]
[isVarBlock, (, elseBranch, )]
[elseBranch]
[thenBranchIsVar, &&, elseBranchIsExpressionBlock, &&, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ., isAssign, (, )]
[thenBranchIsVar, &&, elseBranchIsExpressionBlock]
[thenBranchIsVar]
[elseBranchIsExpressionBlock]
[getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ., isAssign, (, )]
[getBlockExpression, (, elseBranch, ), ., getFirstChild, (, )]
[getBlockExpression, (, elseBranch, )]
[elseBranch]
[getBlockVar, (, thenBranch, )]
[thenBranch]
[getBlockExpression, (, elseBranch, ), ., getFirstChild, (, )]
[getBlockExpression, (, elseBranch, )]
[elseBranch]
[var, ., getFirstChild, (, )]
[var]
[elseAssign, ., getFirstChild, (, )]
[elseAssign]
[name1, ., hasChildren, (, ), &&, maybeName2, ., isName, (, ), &&, name1, ., getString, (, ), ., equals, (, maybeName2, ., getString, (, ), )]
[name1, ., hasChildren, (, ), &&, maybeName2, ., isName, (, )]
[name1, ., hasChildren, (, )]
[name1]
[maybeName2, ., isName, (, )]
[maybeName2]
[name1, ., getString, (, ), ., equals, (, maybeName2, ., getString, (, ), )]
[name1, ., getString, (, )]
[name1]
[maybeName2, ., getString, (, )]
[maybeName2]
[name1, ., removeChildren, (, )]
[name1]
[elseAssign, ., getLastChild, (, ), ., detachFromParent, (, )]
[elseAssign, ., getLastChild, (, )]
[elseAssign]
[cond, ., detachFromParent, (, )]
[cond]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, )]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, )]
[IR]
[cond]
[thenExpr]
[elseExpr]
[n]
[var, ., detachFromParent, (, )]
[var]
[name1, ., addChildrenToBack, (, hookNode, )]
[name1]
[hookNode]
[parent, ., replaceChild, (, n, ,, var, )]
[parent]
[n]
[var]
[reportCodeChange, (, )]
[var]
[elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ., isAssign, (, )]
[elseBranchIsVar, &&, thenBranchIsExpressionBlock]
[elseBranchIsVar]
[thenBranchIsExpressionBlock]
[getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ., isAssign, (, )]
[getBlockExpression, (, thenBranch, ), ., getFirstChild, (, )]
[getBlockExpression, (, thenBranch, )]
[thenBranch]
[getBlockVar, (, elseBranch, )]
[elseBranch]
[getBlockExpression, (, thenBranch, ), ., getFirstChild, (, )]
[getBlockExpression, (, thenBranch, )]
[thenBranch]
[thenAssign, ., getFirstChild, (, )]
[thenAssign]
[var, ., getFirstChild, (, )]
[var]
[name2, ., hasChildren, (, ), &&, maybeName1, ., isName, (, ), &&, maybeName1, ., getString, (, ), ., equals, (, name2, ., getString, (, ), )]
[name2, ., hasChildren, (, ), &&, maybeName1, ., isName, (, )]
[name2, ., hasChildren, (, )]
[name2]
[maybeName1, ., isName, (, )]
[maybeName1]
[maybeName1, ., getString, (, ), ., equals, (, name2, ., getString, (, ), )]
[maybeName1, ., getString, (, )]
[maybeName1]
[name2, ., getString, (, )]
[name2]
[thenAssign, ., getLastChild, (, ), ., detachFromParent, (, )]
[thenAssign, ., getLastChild, (, )]
[thenAssign]
[name2, ., removeChildren, (, )]
[name2]
[cond, ., detachFromParent, (, )]
[cond]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, )]
[IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, )]
[IR]
[cond]
[thenExpr]
[elseExpr]
[n]
[var, ., detachFromParent, (, )]
[var]
[name2, ., addChildrenToBack, (, hookNode, )]
[name2]
[hookNode]
[parent, ., replaceChild, (, n, ,, var, )]
[parent]
[n]
[var]
[reportCodeChange, (, )]
[var]
[n]
[Preconditions, ., checkState, (, n, ., isIf, (, ), )]
[Preconditions]
[n, ., isIf, (, )]
[n]
[n, ., getParent, (, )]
[n]
[!, NodeUtil, ., isStatementBlock, (, parent, )]
[NodeUtil, ., isStatementBlock, (, parent, )]
[NodeUtil]
[parent]
[n, ., getFirstChild, (, )]
[n]
[cond, ., getNext, (, )]
[cond]
[trueBranch, ., getNext, (, )]
[trueBranch]
[Preconditions, ., checkNotNull, (, trueBranch, )]
[Preconditions]
[trueBranch]
[Preconditions, ., checkNotNull, (, falseBranch, )]
[Preconditions]
[falseBranch]
[true]
[trueBranch, ., getLastChild, (, )]
[trueBranch]
[falseBranch, ., getLastChild, (, )]
[falseBranch]
[lastTrue, ==, null, ||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, )]
[lastTrue, ==, null, ||, lastFalse, ==, null]
[lastTrue, ==, null]
[lastTrue]
[null]
[lastFalse, ==, null]
[lastFalse]
[null]
[!, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, )]
[areNodesEqualForInlining, (, lastTrue, ,, lastFalse, )]
[lastTrue]
[lastFalse]
[lastTrue, ., detachFromParent, (, )]
[lastTrue]
[lastFalse, ., detachFromParent, (, )]
[lastFalse]
[parent, ., addChildAfter, (, lastTrue, ,, n, )]
[parent]
[lastTrue]
[n]
[reportCodeChange, (, )]
[n, ., isBlock, (, )]
[n]
[n, ., hasOneChild, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[maybeExpr, ., isExprResult, (, )]
[maybeExpr]
[maybeExpr, ., getFirstChild, (, ), ., isCall, (, )]
[maybeExpr, ., getFirstChild, (, )]
[maybeExpr]
[maybeExpr, ., getFirstChild, (, ), ., getFirstChild, (, )]
[maybeExpr, ., getFirstChild, (, )]
[maybeExpr]
[calledFn, ., isGetElem, (, )]
[calledFn]
[false]
[calledFn, ., isGetProp, (, ), &&, calledFn, ., getLastChild, (, ), ., getString, (, ), ., startsWith, (, "on", )]
[calledFn, ., isGetProp, (, )]
[calledFn]
[calledFn, ., getLastChild, (, ), ., getString, (, ), ., startsWith, (, "on", )]
[calledFn, ., getLastChild, (, ), ., getString, (, )]
[calledFn, ., getLastChild, (, )]
[calledFn]
["on"]
[false]
[true]
[false]
[false]
[Preconditions, ., checkState, (, isFoldableExpressBlock, (, n, ), )]
[Preconditions]
[isFoldableExpressBlock, (, n, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[n, ., isBlock, (, )]
[n]
[n, ., hasOneChild, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[first, ., isReturn, (, )]
[first]
[false]
[n, ., isBlock, (, )]
[n]
[n, ., hasOneChild, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[first, ., isReturn, (, )]
[first]
[first, ., hasOneChild, (, )]
[first]
[false]
[n, ., isReturn, (, )]
[n]
[n, ., hasOneChild, (, )]
[n]
[false]
[Preconditions, ., checkState, (, isReturnExpressBlock, (, n, ), )]
[Preconditions]
[isReturnExpressBlock, (, n, )]
[n]
[n, ., getFirstChild, (, ), ., getFirstChild, (, )]
[n, ., getFirstChild, (, )]
[n]
[n, ., isBlock, (, )]
[n]
[n, ., hasOneChild, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[first, ., isVar, (, )]
[first]
[first, ., hasOneChild, (, )]
[first]
[false]
[Preconditions, ., checkState, (, isVarBlock, (, n, ), )]
[Preconditions]
[isVarBlock, (, n, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[true]
[n, ., getType, (, )]
[n]
[Token, ., IF]
[Token]
[n, ., getChildCount, (, ), <, 3]
[n, ., getChildCount, (, )]
[n]
[3]
[true]
[n]
[n, ., getLastChild, (, )]
[n]
[Token, ., WITH]
[Token]
[Token, ., WHILE]
[Token]
[Token, ., FOR]
[Token]
[n]
[n, ., getLastChild, (, )]
[n]
[false]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, NodeUtil, ., precedence, (, input, ., getType, (, ), ), <, precedence, ;, }, }]
[NodeUtil, ., precedence, (, input, ., getType, (, ), ), <, precedence]
[NodeUtil, ., precedence, (, input, ., getType, (, ), )]
[NodeUtil]
[input, ., getType, (, )]
[input]
[precedence]
[NodeUtil, ., has, (, n, ,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, )]
[NodeUtil]
[n]
[isLowerPrecedencePredicate]
[DONT_TRAVERSE_FUNCTIONS_PREDICATE]
[NodeUtil, ., precedence, (, n, ., getType, (, ), ), <, precedence]
[NodeUtil, ., precedence, (, n, ., getType, (, ), )]
[NodeUtil]
[n, ., getType, (, )]
[n]
[precedence]
[NodeUtil, ., precedence, (, n, ., getType, (, ), ), >, precedence]
[NodeUtil, ., precedence, (, n, ., getType, (, ), )]
[NodeUtil]
[n, ., getType, (, )]
[n]
[precedence]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, (, input, ., isGetProp, (, ), &&, input, ., getParent, (, ), ., isAssign, (, ), ), ;, }, }]
[(, input, ., isGetProp, (, ), &&, input, ., getParent, (, ), ., isAssign, (, ), )]
[input, ., isGetProp, (, ), &&, input, ., getParent, (, ), ., isAssign, (, )]
[input, ., isGetProp, (, )]
[input]
[input, ., getParent, (, ), ., isAssign, (, )]
[input, ., getParent, (, )]
[input]
[NodeUtil, ., has, (, n, ,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, )]
[NodeUtil]
[n]
[isPropertyAssignmentInExpressionPredicate]
[DONT_TRAVERSE_FUNCTIONS_PREDICATE]
[n, ., getParent, (, )]
[n]
[n, ., getType, (, )]
[n]
[Token, ., NOT]
[Token]
[n, ., getFirstChild, (, )]
[n]
[first, ., getType, (, )]
[first]
[Token, ., NOT]
[Token]
[first, ., removeFirstChild, (, )]
[first]
[parent, ., replaceChild, (, n, ,, newRoot, )]
[parent]
[n]
[newRoot]
[reportCodeChange, (, )]
[newRoot]
[Token, ., AND]
[Token]
[Token, ., OR]
[Token]
[first, ., getFirstChild, (, )]
[first]
[first, ., getLastChild, (, )]
[first]
[!, leftParent, ., isNot, (, ), &&, !, rightParent, ., isNot, (, )]
[!, leftParent, ., isNot, (, )]
[leftParent, ., isNot, (, )]
[leftParent]
[!, rightParent, ., isNot, (, )]
[rightParent, ., isNot, (, )]
[rightParent]
[NodeUtil, ., precedence, (, first, ., getType, (, ), )]
[NodeUtil]
[first, ., getType, (, )]
[first]
[(, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), )]
[(, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), )]
[isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, )]
[isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, )]
[leftParent]
[NOT_PRECEDENCE]
[isHigherPrecedence, (, leftParent, ,, op_precedence, )]
[leftParent]
[op_precedence]
[(, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), )]
[isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, )]
[isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, )]
[rightParent]
[NOT_PRECEDENCE]
[isHigherPrecedence, (, rightParent, ,, op_precedence, )]
[rightParent]
[op_precedence]
[n]
[leftParent, ., isNot, (, )]
[leftParent]
[left]
[leftParent, ., removeFirstChild, (, )]
[leftParent]
[leftParent, ., detachFromParent, (, )]
[leftParent]
[left]
[IR, ., not, (, leftParent, ), ., srcref, (, leftParent, )]
[IR, ., not, (, leftParent, )]
[IR]
[leftParent]
[leftParent]
[rightParent, ., isNot, (, )]
[rightParent]
[right]
[rightParent, ., removeFirstChild, (, )]
[rightParent]
[rightParent, ., detachFromParent, (, )]
[rightParent]
[right]
[IR, ., not, (, rightParent, ), ., srcref, (, rightParent, )]
[IR, ., not, (, rightParent, )]
[IR]
[rightParent]
[rightParent]
[(, first, ., isAnd, (, ), ), ?, Token, ., OR, :, Token, ., AND]
[(, first, ., isAnd, (, ), )]
[first, ., isAnd, (, )]
[first]
[Token, ., OR]
[Token]
[Token, ., AND]
[Token]
[new, Node, (, newOp, ,, left, ,, right, )]
[newOp]
[left]
[right]
[parent, ., replaceChild, (, n, ,, newRoot, )]
[parent]
[n]
[newRoot]
[reportCodeChange, (, )]
[newRoot]
[NodeUtil, ., getPureBooleanValue, (, first, )]
[NodeUtil]
[first]
[nVal, !=, TernaryValue, ., UNKNOWN]
[nVal]
[TernaryValue, ., UNKNOWN]
[TernaryValue]
[nVal, ., not, (, ), ., toBoolean, (, true, )]
[nVal, ., not, (, )]
[nVal]
[true]
[result, ?, 1, :, 0]
[result]
[1]
[0]
[maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, )]
[n]
[parent]
[equivalentResult]
[n]
[Token, ., OR]
[Token]
[Token, ., AND]
[Token]
[n, ., getFirstChild, (, )]
[n]
[n, ., getLastChild, (, )]
[n]
[left]
[tryMinimizeCondition, (, left, )]
[left]
[right]
[tryMinimizeCondition, (, right, )]
[right]
[NodeUtil, ., getPureBooleanValue, (, right, )]
[NodeUtil]
[right]
[NodeUtil, ., getPureBooleanValue, (, right, ), !=, TernaryValue, ., UNKNOWN]
[NodeUtil, ., getPureBooleanValue, (, right, )]
[NodeUtil]
[right]
[TernaryValue, ., UNKNOWN]
[TernaryValue]
[n, ., getType, (, )]
[n]
[null]
[rightVal, ., toBoolean, (, true, )]
[rightVal]
[true]
[type, ==, Token, ., OR, &&, !, rval, ||, type, ==, Token, ., AND, &&, rval]
[type, ==, Token, ., OR, &&, !, rval]
[type, ==, Token, ., OR]
[type]
[Token, ., OR]
[Token]
[!, rval]
[rval]
[type, ==, Token, ., AND, &&, rval]
[type, ==, Token, ., AND]
[type]
[Token, ., AND]
[Token]
[rval]
[replacement]
[left]
[!, mayHaveSideEffects, (, left, )]
[mayHaveSideEffects, (, left, )]
[left]
[replacement]
[right]
[replacement, !=, null]
[replacement]
[null]
[n, ., detachChildren, (, )]
[n]
[parent, ., replaceChild, (, n, ,, replacement, )]
[parent]
[n]
[replacement]
[reportCodeChange, (, )]
[replacement]
[n]
[Token, ., HOOK]
[Token]
[n, ., getFirstChild, (, )]
[n]
[n, ., getFirstChild, (, ), ., getNext, (, )]
[n, ., getFirstChild, (, )]
[n]
[n, ., getLastChild, (, )]
[n]
[trueNode]
[tryMinimizeCondition, (, trueNode, )]
[trueNode]
[falseNode]
[tryMinimizeCondition, (, falseNode, )]
[falseNode]
[null]
[NodeUtil, ., getPureBooleanValue, (, trueNode, )]
[NodeUtil]
[trueNode]
[NodeUtil, ., getPureBooleanValue, (, falseNode, )]
[NodeUtil]
[falseNode]
[trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE]
[trueNodeVal, ==, TernaryValue, ., TRUE]
[trueNodeVal]
[TernaryValue, ., TRUE]
[TernaryValue]
[falseNodeVal, ==, TernaryValue, ., FALSE]
[falseNodeVal]
[TernaryValue, ., FALSE]
[TernaryValue]
[condition, ., detachFromParent, (, )]
[condition]
[replacement]
[condition]
[trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE]
[trueNodeVal, ==, TernaryValue, ., FALSE]
[trueNodeVal]
[TernaryValue, ., FALSE]
[TernaryValue]
[falseNodeVal, ==, TernaryValue, ., TRUE]
[falseNodeVal]
[TernaryValue, ., TRUE]
[TernaryValue]
[condition, ., detachFromParent, (, )]
[condition]
[replacement]
[IR, ., not, (, condition, )]
[IR]
[condition]
[trueNodeVal, ==, TernaryValue, ., TRUE]
[trueNodeVal]
[TernaryValue, ., TRUE]
[TernaryValue]
[n, ., detachChildren, (, )]
[n]
[replacement]
[IR, ., or, (, condition, ,, falseNode, )]
[IR]
[condition]
[falseNode]
[falseNodeVal, ==, TernaryValue, ., FALSE]
[falseNodeVal]
[TernaryValue, ., FALSE]
[TernaryValue]
[n, ., detachChildren, (, )]
[n]
[replacement]
[IR, ., and, (, condition, ,, trueNode, )]
[IR]
[condition]
[trueNode]
[replacement, !=, null]
[replacement]
[null]
[parent, ., replaceChild, (, n, ,, replacement, )]
[parent]
[n]
[replacement]
[n]
[replacement]
[reportCodeChange, (, )]
[n]
[NodeUtil, ., getPureBooleanValue, (, n, )]
[NodeUtil]
[n]
[nVal, !=, TernaryValue, ., UNKNOWN]
[nVal]
[TernaryValue, ., UNKNOWN]
[TernaryValue]
[nVal, ., toBoolean, (, true, )]
[nVal]
[true]
[result, ?, 1, :, 0]
[result]
[1]
[0]
[maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, )]
[n]
[parent]
[equivalentResult]
[n]
[IR, ., number, (, num, )]
[IR]
[num]
[!, newNode, ., isEquivalentTo, (, n, )]
[newNode, ., isEquivalentTo, (, n, )]
[newNode]
[n]
[parent, ., replaceChild, (, n, ,, newNode, )]
[parent]
[n]
[newNode]
[reportCodeChange, (, )]
[newNode]
[n]
[ImmutableSet, ., of, (, "Object", ,, "Array", ,, "RegExp", ,, "Error", )]
[ImmutableSet]
["Object"]
["Array"]
["RegExp"]
["Error"]
[Preconditions, ., checkState, (, n, ., isNew, (, ), )]
[Preconditions]
[n, ., isNew, (, )]
[n]
[isASTNormalized, (, )]
[n, ., getFirstChild, (, ), ., isName, (, )]
[n, ., getFirstChild, (, )]
[n]
[n, ., getFirstChild, (, ), ., getString, (, )]
[n, ., getFirstChild, (, )]
[n]
[STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, )]
[STANDARD_OBJECT_CONSTRUCTORS]
[className]
[n, ., setType, (, Token, ., CALL, )]
[n]
[Token, ., CALL]
[Token]
[n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, )]
[n]
[Node, ., FREE_CALL]
[Node]
[true]
[reportCodeChange, (, )]
[n]
[Preconditions, ., checkArgument, (, n, ., isCall, (, ), ||, n, ., isNew, (, ), )]
[Preconditions]
[n, ., isCall, (, ), ||, n, ., isNew, (, )]
[n, ., isCall, (, )]
[n]
[n, ., isNew, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[null]
[isASTNormalized, (, ), &&, Token, ., NAME, ==, constructorNameNode, ., getType, (, )]
[isASTNormalized, (, )]
[Token, ., NAME, ==, constructorNameNode, ., getType, (, )]
[Token, ., NAME]
[Token]
[constructorNameNode, ., getType, (, )]
[constructorNameNode]
[constructorNameNode, ., getString, (, )]
[constructorNameNode]
["RegExp", ., equals, (, className, )]
["RegExp"]
[className]
[tryFoldRegularExpressionConstructor, (, n, )]
[n]
[constructorNameNode, ., getNext, (, ), !=, null]
[constructorNameNode, ., getNext, (, )]
[constructorNameNode]
[null]
["Object", ., equals, (, className, ), &&, !, constructorHasArgs]
["Object", ., equals, (, className, )]
["Object"]
[className]
[!, constructorHasArgs]
[constructorHasArgs]
[newLiteralNode]
[IR, ., objectlit, (, )]
[IR]
["Array", ., equals, (, className, )]
["Array"]
[className]
[constructorNameNode, ., getNext, (, )]
[constructorNameNode]
[isSafeToFoldArrayConstructor, (, arg0, )]
[arg0]
[action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS]
[action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS]
[action]
[FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS]
[FoldArrayAction]
[action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS]
[action]
[FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS]
[FoldArrayAction]
[newLiteralNode]
[IR, ., arraylit, (, )]
[IR]
[n, ., removeChildren, (, )]
[n]
[action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS]
[action]
[FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS]
[FoldArrayAction]
[newLiteralNode, ., addChildrenToFront, (, arg0, )]
[newLiteralNode]
[arg0]
[newLiteralNode, !=, null]
[newLiteralNode]
[null]
[n, ., getParent, (, ), ., replaceChild, (, n, ,, newLiteralNode, )]
[n, ., getParent, (, )]
[n]
[n]
[newLiteralNode]
[reportCodeChange, (, )]
[newLiteralNode]
[n]
[FoldArrayAction, ., NOT_SAFE_TO_FOLD]
[FoldArrayAction]
[arg, ==, null]
[arg]
[null]
[action]
[FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS]
[FoldArrayAction]
[arg, ., getNext, (, ), !=, null]
[arg, ., getNext, (, )]
[arg]
[null]
[action]
[FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS]
[FoldArrayAction]
[arg, ., getType, (, )]
[arg]
[Token, ., STRING]
[Token]
[action]
[FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS]
[FoldArrayAction]
[Token, ., NUMBER]
[Token]
[arg, ., getDouble, (, ), ==, 0]
[arg, ., getDouble, (, )]
[arg]
[0]
[action]
[FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS]
[FoldArrayAction]
[Token, ., ARRAYLIT]
[Token]
[action]
[FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS]
[FoldArrayAction]
[action]
[n, ., getParent, (, )]
[n]
[n, ., getFirstChild, (, )]
[n]
[constructor, ., getNext, (, )]
[constructor]
[null, !=, pattern, ?, pattern, ., getNext, (, ), :, null]
[null, !=, pattern]
[null]
[pattern]
[pattern, ., getNext, (, )]
[pattern]
[null]
[null, ==, pattern, ||, (, null, !=, flags, &&, null, !=, flags, ., getNext, (, ), )]
[null, ==, pattern]
[null]
[pattern]
[(, null, !=, flags, &&, null, !=, flags, ., getNext, (, ), )]
[null, !=, flags, &&, null, !=, flags, ., getNext, (, )]
[null, !=, flags]
[null]
[flags]
[null, !=, flags, ., getNext, (, )]
[null]
[flags, ., getNext, (, )]
[flags]
[n]
[pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), )]
[pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, ., isString, (, ), )]
[pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100]
[pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, ), )]
[pattern, ., isString, (, )]
[pattern]
[!, "", ., equals, (, pattern, ., getString, (, ), )]
["", ., equals, (, pattern, ., getString, (, ), )]
[""]
[pattern, ., getString, (, )]
[pattern]
[pattern, ., getString, (, ), ., length, (, ), <, 100]
[pattern, ., getString, (, ), ., length, (, )]
[pattern, ., getString, (, )]
[pattern]
[100]
[(, null, ==, flags, ||, flags, ., isString, (, ), )]
[null, ==, flags, ||, flags, ., isString, (, )]
[null, ==, flags]
[null]
[flags]
[flags, ., isString, (, )]
[flags]
[(, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), )]
[isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), )]
[isEcmaScript5OrGreater, (, )]
[!, containsUnicodeEscape, (, pattern, ., getString, (, ), )]
[containsUnicodeEscape, (, pattern, ., getString, (, ), )]
[pattern, ., getString, (, )]
[pattern]
[pattern]
[makeForwardSlashBracketSafe, (, pattern, )]
[pattern]
[null, ==, flags, ||, "", ., equals, (, flags, ., getString, (, ), )]
[null, ==, flags]
[null]
[flags]
["", ., equals, (, flags, ., getString, (, ), )]
[""]
[flags, ., getString, (, )]
[flags]
[regexLiteral]
[IR, ., regexp, (, pattern, )]
[IR]
[pattern]
[!, areValidRegexpFlags, (, flags, ., getString, (, ), )]
[areValidRegexpFlags, (, flags, ., getString, (, ), )]
[flags, ., getString, (, )]
[flags]
[report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, )]
[INVALID_REGULAR_EXPRESSION_FLAGS]
[flags]
[n]
[!, areSafeFlagsToFold, (, flags, ., getString, (, ), )]
[areSafeFlagsToFold, (, flags, ., getString, (, ), )]
[flags, ., getString, (, )]
[flags]
[n]
[n, ., removeChild, (, flags, )]
[n]
[flags]
[regexLiteral]
[IR, ., regexp, (, pattern, ,, flags, )]
[IR]
[pattern]
[flags]
[parent, ., replaceChild, (, n, ,, regexLiteral, )]
[parent]
[n]
[regexLiteral]
[reportCodeChange, (, )]
[regexLiteral]
[n]
[late]
[IR, ., not, (, IR, ., number, (, n, ., isTrue, (, ), ?, 0, :, 1, ), )]
[IR]
[IR, ., number, (, n, ., isTrue, (, ), ?, 0, :, 1, )]
[IR]
[n, ., isTrue, (, ), ?, 0, :, 1]
[n, ., isTrue, (, )]
[n]
[0]
[1]
[not, ., copyInformationFromForTree, (, n, )]
[not]
[n]
[n, ., getParent, (, ), ., replaceChild, (, n, ,, not, )]
[n, ., getParent, (, )]
[n]
[n]
[not]
[reportCodeChange, (, )]
[not]
[n]
[true]
[n, ., getFirstChild, (, )]
[n]
[cur, !=, null]
[cur]
[null]
[cur]
[cur, ., getNext, (, )]
[cur]
[!, cur, ., isString, (, )]
[cur, ., isString, (, )]
[cur]
[allStrings]
[false]
[allStrings]
[tryMinimizeStringArrayLiteral, (, n, )]
[n]
[n]
[!, late]
[late]
[n]
[n, ., getChildCount, (, )]
[n]
[numElements, *, 2, -, STRING_SPLIT_OVERHEAD]
[numElements, *, 2]
[numElements]
[2]
[STRING_SPLIT_OVERHEAD]
[saving, <=, 0]
[saving]
[0]
[n]
[new, String, [, n, ., getChildCount, (, ), ]]
[n, ., getChildCount, (, )]
[n]
[0]
[n, ., getFirstChild, (, )]
[n]
[cur, !=, null]
[cur]
[null]
[cur]
[cur, ., getNext, (, )]
[cur]
[strings, [, idx, ++, ]]
[strings]
[idx, ++]
[idx]
[cur, ., getString, (, )]
[cur]
[pickDelimiter, (, strings, )]
[strings]
[delimiter, !=, null]
[delimiter]
[null]
[Joiner, ., on, (, delimiter, ), ., join, (, strings, )]
[Joiner, ., on, (, delimiter, )]
[Joiner]
[delimiter]
[strings]
[IR, ., call, (, IR, ., getprop, (, IR, ., string, (, template, ), ,, IR, ., string, (, "split", ), ), ,, IR, ., string, (, "", +, delimiter, ), )]
[IR]
[IR, ., getprop, (, IR, ., string, (, template, ), ,, IR, ., string, (, "split", ), )]
[IR]
[IR, ., string, (, template, )]
[IR]
[template]
[IR, ., string, (, "split", )]
[IR]
["split"]
[IR, ., string, (, "", +, delimiter, )]
[IR]
["", +, delimiter]
[""]
[delimiter]
[call, ., copyInformationFromForTree, (, n, )]
[call]
[n]
[n, ., getParent, (, ), ., replaceChild, (, n, ,, call, )]
[n, ., getParent, (, )]
[n]
[n]
[call]
[reportCodeChange, (, )]
[call]
[n]
[true]
[strings]
[s, ., length, (, ), !=, 1]
[s, ., length, (, )]
[s]
[1]
[allLength1]
[false]
[allLength1]
[""]
[new, String, [, ], {, " ", ,, ";", ,, ",", ,, "{", ,, "}", ,, null, }]
[{, " ", ,, ";", ,, ",", ,, "{", ,, "}", ,, null, }]
[" "]
[";"]
[","]
["{"]
["}"]
[null]
[0]
[delimiters, [, i, ], !=, null]
[delimiters, [, i, ]]
[delimiters]
[i]
[null]
[i, ++]
[i]
[strings]
[cur, ., contains, (, delimiters, [, i, ], )]
[cur]
[delimiters, [, i, ]]
[delimiters]
[i]
[delimiters, [, i, ]]
[delimiters]
[i]
[Pattern, ., compile, (, "^[gmi]*$", )]
[Pattern]
["^[gmi]*$"]
[REGEXP_FLAGS_RE, ., matcher, (, flags, ), ., matches, (, )]
[REGEXP_FLAGS_RE, ., matcher, (, flags, )]
[REGEXP_FLAGS_RE]
[flags]
[isEcmaScript5OrGreater, (, ), ||, flags, ., indexOf, (, 'g', ), <, 0]
[isEcmaScript5OrGreater, (, )]
[flags, ., indexOf, (, 'g', ), <, 0]
[flags, ., indexOf, (, 'g', )]
[flags]
['g']
[0]
[n, ., getString, (, )]
[n]
[null]
[0]
[false]
[false]
[0]
[i, <, s, ., length, (, )]
[i]
[s, ., length, (, )]
[s]
[++, i]
[i]
[s, ., charAt, (, i, )]
[s]
[i]
[ch]
['\\']
[isEscaped]
[!, isEscaped]
[isEscaped]
['/']
[!, isEscaped, &&, !, inCharset]
[!, isEscaped]
[isEscaped]
[!, inCharset]
[inCharset]
[null, ==, sb]
[null]
[sb]
[sb]
[new, StringBuilder, (, s, ., length, (, ), +, 16, )]
[s, ., length, (, ), +, 16]
[s, ., length, (, )]
[s]
[16]
[sb, ., append, (, s, ,, pos, ,, i, ), ., append, (, '\\', )]
[sb, ., append, (, s, ,, pos, ,, i, )]
[sb]
[s]
[pos]
[i]
['\\']
[pos]
[i]
['[']
[!, isEscaped]
[isEscaped]
[inCharset]
[true]
[']']
[!, isEscaped]
[isEscaped]
[inCharset]
[false]
['\r']
['\n']
['\u2028']
['\u2029']
[null, ==, sb]
[null]
[sb]
[sb]
[new, StringBuilder, (, s, ., length, (, ), +, 16, )]
[s, ., length, (, ), +, 16]
[s, ., length, (, )]
[s]
[16]
[isEscaped]
[sb, ., append, (, s, ,, pos, ,, i, -, 1, )]
[sb]
[s]
[pos]
[i, -, 1]
[i]
[1]
[sb, ., append, (, s, ,, pos, ,, i, )]
[sb]
[s]
[pos]
[i]
[ch]
['\r']
[sb, ., append, (, "\\r", )]
[sb]
["\\r"]
['\n']
[sb, ., append, (, "\\n", )]
[sb]
["\\n"]
['\u2028']
[sb, ., append, (, "\\u2028", )]
[sb]
["\\u2028"]
['\u2029']
[sb, ., append, (, "\\u2029", )]
[sb]
["\\u2029"]
[pos]
[i, +, 1]
[i]
[1]
[isEscaped]
[false]
[null, ==, sb]
[null]
[sb]
[n, ., cloneTree, (, )]
[n]
[sb, ., append, (, s, ,, pos, ,, s, ., length, (, ), )]
[sb]
[s]
[pos]
[s, ., length, (, )]
[s]
[IR, ., string, (, sb, ., toString, (, ), ), ., srcref, (, n, )]
[IR, ., string, (, sb, ., toString, (, ), )]
[IR]
[sb, ., toString, (, )]
[sb]
[n]
[REGEXP_ESCAPER, ., regexpEscape, (, s, )]
[REGEXP_ESCAPER]
[s]
[-, 1]
[1]
[(, i, =, esc, ., indexOf, (, "\\u", ,, i, +, 1, ), ), >=, 0]
[(, i, =, esc, ., indexOf, (, "\\u", ,, i, +, 1, ), )]
[i]
[esc, ., indexOf, (, "\\u", ,, i, +, 1, )]
[esc]
["\\u"]
[i, +, 1]
[i]
[1]
[0]
[0]
[i, -, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, )]
[i, -, nSlashes, >, 0]
[i, -, nSlashes]
[i]
[nSlashes]
[0]
['\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, )]
['\\']
[esc, ., charAt, (, i, -, nSlashes, -, 1, )]
[esc]
[i, -, nSlashes, -, 1]
[i, -, nSlashes]
[i]
[nSlashes]
[1]
[++, nSlashes]
[nSlashes]
[0, ==, (, nSlashes, &, 1, )]
[0]
[(, nSlashes, &, 1, )]
[nSlashes, &, 1]
[nSlashes]
[1]
[true]
[false]
