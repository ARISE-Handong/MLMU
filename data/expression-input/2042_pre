[., Set, ;, import, javax, ., annotation, ., Nullable, ;, public, final, class, NodeUtil, {, static, final, long, MAX_POSITIVE_INTEGER_NUMBER, =]
[import, javax, ., annotation, ., Nullable, ;, public, final, class, NodeUtil, {, static, final, long, MAX_POSITIVE_INTEGER_NUMBER, =, (, long, )]
[import, javax, ., annotation, ., Nullable, ;, public, final, class, NodeUtil, {, static, final, long, MAX_POSITIVE_INTEGER_NUMBER, =, (, long, )]
[., Nullable, ;, public, final, class, NodeUtil, {, static, final, long, MAX_POSITIVE_INTEGER_NUMBER, =, (, long, ), Math, ., pow, (]
[;, public, final, class, NodeUtil, {, static, final, long, MAX_POSITIVE_INTEGER_NUMBER, =, (, long, ), Math, ., pow, (, 2, ,]
[long, MAX_POSITIVE_INTEGER_NUMBER, =, (, long, ), Math, ., pow, (, 2, ,, 53, ), ;, static, final, String, JSC_PROPERTY_NAME_FN, =]
[., pow, (, 2, ,, 53, ), ;, static, final, String, JSC_PROPERTY_NAME_FN, =, "JSCompiler_renameProperty", ;, static, final, char, LARGEST_BASIC_LATIN, =]
[JSC_PROPERTY_NAME_FN, =, "JSCompiler_renameProperty", ;, static, final, char, LARGEST_BASIC_LATIN, =, 0x7f, ;, private, static, final, Set, <, String, >, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =]
[char, LARGEST_BASIC_LATIN, =, 0x7f, ;, private, static, final, Set, <, String, >, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =, new, HashSet, <, String, >, (]
[char, LARGEST_BASIC_LATIN, =, 0x7f, ;, private, static, final, Set, <, String, >, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =, new, HashSet, <, String, >, (]
[;, private, static, final, Set, <, String, >, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =, new, HashSet, <, String, >, (, Arrays, ., asList, (]
[static, final, Set, <, String, >, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =, new, HashSet, <, String, >, (, Arrays, ., asList, (, "Array", ,]
[Set, <, String, >, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =, new, HashSet, <, String, >, (, Arrays, ., asList, (, "Array", ,, "Date", ,]
[String, >, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =, new, HashSet, <, String, >, (, Arrays, ., asList, (, "Array", ,, "Date", ,, "Error", ,]
[CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =, new, HashSet, <, String, >, (, Arrays, ., asList, (, "Array", ,, "Date", ,, "Error", ,, "Object", ,]
[new, HashSet, <, String, >, (, Arrays, ., asList, (, "Array", ,, "Date", ,, "Error", ,, "Object", ,, "RegExp", ,]
["XMLHttpRequest", ), ), ;, private, NodeUtil, (, ), {, }, static, TernaryValue, getImpureBooleanValue, (, Node, n, ), {, switch, (]
["XMLHttpRequest", ), ), ;, private, NodeUtil, (, ), {, }, static, TernaryValue, getImpureBooleanValue, (, Node, n, ), {, switch, (]
[{, }, static, TernaryValue, getImpureBooleanValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[{, }, static, TernaryValue, getImpureBooleanValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return]
[n, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, getImpureBooleanValue, (]
[n, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, getImpureBooleanValue, (]
[Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, case]
[Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, case]
[COMMA, :, return, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, case, Token, ., NOT, :, TernaryValue, value, =]
[return, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, case, Token, ., NOT, :, TernaryValue, value, =, getImpureBooleanValue, (]
[return, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, case, Token, ., NOT, :, TernaryValue, value, =, getImpureBooleanValue, (]
[), ;, case, Token, ., NOT, :, TernaryValue, value, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return]
[), ;, case, Token, ., NOT, :, TernaryValue, value, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return]
[TernaryValue, value, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, value, ., not, (, ), ;, case]
[TernaryValue, value, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, value, ., not, (, ), ;, case]
[(, ), ), ;, return, value, ., not, (, ), ;, case, Token, ., AND, :, {, TernaryValue, lhs, =]
[), ;, return, value, ., not, (, ), ;, case, Token, ., AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (]
[), ;, return, value, ., not, (, ), ;, case, Token, ., AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (]
[Token, ., AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =]
[AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (]
[AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (]
[n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return]
[n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return]
[), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., and, (]
[=, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., and, (, rhs, ), ;, }, case]
[=, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., and, (, rhs, ), ;, }, case]
[), ;, return, lhs, ., and, (, rhs, ), ;, }, case, Token, ., OR, :, {, TernaryValue, lhs, =]
[return, lhs, ., and, (, rhs, ), ;, }, case, Token, ., OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (]
[return, lhs, ., and, (, rhs, ), ;, }, case, Token, ., OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (]
[Token, ., OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =]
[OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (]
[OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (]
[n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return]
[n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return]
[), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., or, (]
[=, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., or, (, rhs, ), ;, }, case]
[=, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., or, (, rhs, ), ;, }, case]
[), ;, return, lhs, ., or, (, rhs, ), ;, }, case, Token, ., HOOK, :, {, TernaryValue, trueValue, =]
[return, lhs, ., or, (, rhs, ), ;, }, case, Token, ., HOOK, :, {, TernaryValue, trueValue, =, getImpureBooleanValue, (]
[return, lhs, ., or, (, rhs, ), ;, }, case, Token, ., HOOK, :, {, TernaryValue, trueValue, =, getImpureBooleanValue, (]
[return, lhs, ., or, (, rhs, ), ;, }, case, Token, ., HOOK, :, {, TernaryValue, trueValue, =, getImpureBooleanValue, (]
[{, TernaryValue, trueValue, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ., getNext, (, ), ), ;, TernaryValue, falseValue, =]
[trueValue, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ., getNext, (, ), ), ;, TernaryValue, falseValue, =, getImpureBooleanValue, (]
[trueValue, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ., getNext, (, ), ), ;, TernaryValue, falseValue, =, getImpureBooleanValue, (]
[., getNext, (, ), ), ;, TernaryValue, falseValue, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, if, (]
[., getNext, (, ), ), ;, TernaryValue, falseValue, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, if, (]
[), ;, TernaryValue, falseValue, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, if, (, trueValue, ., equals, (]
[getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, if, (, trueValue, ., equals, (, falseValue, ), ), {, return]
[), ), ;, if, (, trueValue, ., equals, (, falseValue, ), ), {, return, trueValue, ;, }, else, {, return]
[), ), ;, if, (, trueValue, ., equals, (, falseValue, ), ), {, return, trueValue, ;, }, else, {, return]
[equals, (, falseValue, ), ), {, return, trueValue, ;, }, else, {, return, TernaryValue, ., UNKNOWN, ;, }, }, case]
[equals, (, falseValue, ), ), {, return, trueValue, ;, }, else, {, return, TernaryValue, ., UNKNOWN, ;, }, }, case]
[{, return, trueValue, ;, }, else, {, return, TernaryValue, ., UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT, :, case]
[{, return, trueValue, ;, }, else, {, return, TernaryValue, ., UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT, :, case]
[else, {, return, TernaryValue, ., UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return]
[else, {, return, TernaryValue, ., UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return]
[UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, TernaryValue, ., TRUE, ;, case]
[UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, TernaryValue, ., TRUE, ;, case]
[Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, TernaryValue, ., TRUE, ;, case, Token, ., VOID, :, return]
[Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, TernaryValue, ., TRUE, ;, case, Token, ., VOID, :, return]
[OBJECTLIT, :, return, TernaryValue, ., TRUE, ;, case, Token, ., VOID, :, return, TernaryValue, ., FALSE, ;, default, :, return]
[return, TernaryValue, ., TRUE, ;, case, Token, ., VOID, :, return, TernaryValue, ., FALSE, ;, default, :, return, getPureBooleanValue, (]
[default, :, return, getPureBooleanValue, (, n, ), ;, }, }, static, TernaryValue, getPureBooleanValue, (, Node, n, ), {, switch, (]
[default, :, return, getPureBooleanValue, (, n, ), ;, }, }, static, TernaryValue, getPureBooleanValue, (, Node, n, ), {, switch, (]
[}, }, static, TernaryValue, getPureBooleanValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, }, static, TernaryValue, getPureBooleanValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, return]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, return]
[{, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, return, TernaryValue, ., forBoolean, (]
[{, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, return, TernaryValue, ., forBoolean, (]
[{, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, return, TernaryValue, ., forBoolean, (]
[{, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, return, TernaryValue, ., forBoolean, (]
[case, Token, ., STRING, :, return, TernaryValue, ., forBoolean, (, n, ., getString, (, ), ., length, (, ), >]
[:, return, TernaryValue, ., forBoolean, (, n, ., getString, (, ), ., length, (, ), >, 0, ), ;, case]
[:, return, TernaryValue, ., forBoolean, (, n, ., getString, (, ), ., length, (, ), >, 0, ), ;, case]
[(, n, ., getString, (, ), ., length, (, ), >, 0, ), ;, case, Token, ., NUMBER, :, return]
[(, n, ., getString, (, ), ., length, (, ), >, 0, ), ;, case, Token, ., NUMBER, :, return]
[(, ), ., length, (, ), >, 0, ), ;, case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (]
[(, ), ., length, (, ), >, 0, ), ;, case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (]
[(, ), ., length, (, ), >, 0, ), ;, case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (]
[>, 0, ), ;, case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=]
[case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;, case]
[case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;, case]
[return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;, case, Token, ., NOT, :, return]
[return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;, case, Token, ., NOT, :, return]
[., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;, case, Token, ., NOT, :, return, getPureBooleanValue, (]
[., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;, case, Token, ., NOT, :, return, getPureBooleanValue, (]
[case, Token, ., NOT, :, return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not, (, ), ;, case]
[case, Token, ., NOT, :, return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not, (, ), ;, case]
[return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not, (, ), ;, case, Token, ., NULL, :, case]
[return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not, (, ), ;, case, Token, ., NULL, :, case]
[getLastChild, (, ), ), ., not, (, ), ;, case, Token, ., NULL, :, case, Token, ., FALSE, :, return]
[getLastChild, (, ), ), ., not, (, ), ;, case, Token, ., NULL, :, case, Token, ., FALSE, :, return]
[not, (, ), ;, case, Token, ., NULL, :, case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;, case]
[not, (, ), ;, case, Token, ., NULL, :, case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;, case]
[., NULL, :, case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;, case, Token, ., VOID, :, if, (]
[NULL, :, case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;, case, Token, ., VOID, :, if, (, !]
[case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;, case, Token, ., VOID, :, if, (, !, mayHaveSideEffects, (]
[case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;, case, Token, ., VOID, :, if, (, !, mayHaveSideEffects, (]
[;, case, Token, ., VOID, :, if, (, !, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return]
[;, case, Token, ., VOID, :, if, (, !, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return]
[!, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return, TernaryValue, ., FALSE, ;, }, break, ;, case]
[!, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return, TernaryValue, ., FALSE, ;, }, break, ;, case]
[), ), ), {, return, TernaryValue, ., FALSE, ;, }, break, ;, case, Token, ., NAME, :, String, name, =]
[), ), ), {, return, TernaryValue, ., FALSE, ;, }, break, ;, case, Token, ., NAME, :, String, name, =]
[;, }, break, ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[;, }, break, ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[;, }, break, ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (]
[NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||]
[NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||]
[=, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||, "NaN", ., equals, (]
[), ;, if, (, "undefined", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return]
[), ;, if, (, "undefined", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return]
[name, ), ||, "NaN", ., equals, (, name, ), ), {, return, TernaryValue, ., FALSE, ;, }, else, if, (]
[name, ), ||, "NaN", ., equals, (, name, ), ), {, return, TernaryValue, ., FALSE, ;, }, else, if, (]
[., equals, (, name, ), ), {, return, TernaryValue, ., FALSE, ;, }, else, if, (, "Infinity", ., equals, (]
[), {, return, TernaryValue, ., FALSE, ;, }, else, if, (, "Infinity", ., equals, (, name, ), ), {, return]
[), {, return, TernaryValue, ., FALSE, ;, }, else, if, (, "Infinity", ., equals, (, name, ), ), {, return]
[else, if, (, "Infinity", ., equals, (, name, ), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, case]
[else, if, (, "Infinity", ., equals, (, name, ), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, case]
[equals, (, name, ), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, case, Token, ., TRUE, :, case]
[equals, (, name, ), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, case, Token, ., TRUE, :, case]
[{, return, TernaryValue, ., TRUE, ;, }, break, ;, case, Token, ., TRUE, :, case, Token, ., REGEXP, :, return]
[{, return, TernaryValue, ., TRUE, ;, }, break, ;, case, Token, ., TRUE, :, case, Token, ., REGEXP, :, return]
[;, }, break, ;, case, Token, ., TRUE, :, case, Token, ., REGEXP, :, return, TernaryValue, ., TRUE, ;, case]
[;, }, break, ;, case, Token, ., TRUE, :, case, Token, ., REGEXP, :, return, TernaryValue, ., TRUE, ;, case]
[Token, ., TRUE, :, case, Token, ., REGEXP, :, return, TernaryValue, ., TRUE, ;, case, Token, ., ARRAYLIT, :, case]
[Token, ., TRUE, :, case, Token, ., REGEXP, :, return, TernaryValue, ., TRUE, ;, case, Token, ., ARRAYLIT, :, case]
[., REGEXP, :, return, TernaryValue, ., TRUE, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (]
[REGEXP, :, return, TernaryValue, ., TRUE, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (, !]
[return, TernaryValue, ., TRUE, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (, !, mayHaveSideEffects, (]
[case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (, !, mayHaveSideEffects, (, n, ), ), {, return]
[case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (, !, mayHaveSideEffects, (, n, ), ), {, return]
[:, if, (, !, mayHaveSideEffects, (, n, ), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, }, return]
[:, if, (, !, mayHaveSideEffects, (, n, ), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, }, return]
[}, break, ;, }, return, TernaryValue, ., UNKNOWN, ;, }, static, String, getStringValue, (, Node, n, ), {, switch, (]
[}, break, ;, }, return, TernaryValue, ., UNKNOWN, ;, }, static, String, getStringValue, (, Node, n, ), {, switch, (]
[;, }, static, String, getStringValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, String, getStringValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, return]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, return]
[), {, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, return, n, ., getString, (, ), ;, case]
[), {, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, return, n, ., getString, (, ), ;, case]
[case, Token, ., STRING_KEY, :, return, n, ., getString, (, ), ;, case, Token, ., NAME, :, String, name, =]
[case, Token, ., STRING_KEY, :, return, n, ., getString, (, ), ;, case, Token, ., NAME, :, String, name, =]
[getString, (, ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[getString, (, ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[getString, (, ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[getString, (, ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (]
[NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||]
[NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||]
[=, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (]
[getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||]
[getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||]
[if, (, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (]
[(, name, ), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return]
[equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return, name, ;, }, break, ;, case]
[equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return, name, ;, }, break, ;, case]
["NaN", ., equals, (, name, ), ), {, return, name, ;, }, break, ;, case, Token, ., NUMBER, :, return]
[equals, (, name, ), ), {, return, name, ;, }, break, ;, case, Token, ., NUMBER, :, return, getStringValue, (]
[equals, (, name, ), ), {, return, name, ;, }, break, ;, case, Token, ., NUMBER, :, return, getStringValue, (]
[;, }, break, ;, case, Token, ., NUMBER, :, return, getStringValue, (, n, ., getDouble, (, ), ), ;, case]
[;, }, break, ;, case, Token, ., NUMBER, :, return, getStringValue, (, n, ., getDouble, (, ), ), ;, case]
[Token, ., NUMBER, :, return, getStringValue, (, n, ., getDouble, (, ), ), ;, case, Token, ., FALSE, :, return]
[:, return, getStringValue, (, n, ., getDouble, (, ), ), ;, case, Token, ., FALSE, :, return, "false", ;, case]
[:, return, getStringValue, (, n, ., getDouble, (, ), ), ;, case, Token, ., FALSE, :, return, "false", ;, case]
[., getDouble, (, ), ), ;, case, Token, ., FALSE, :, return, "false", ;, case, Token, ., TRUE, :, return]
[), ), ;, case, Token, ., FALSE, :, return, "false", ;, case, Token, ., TRUE, :, return, "true", ;, case]
[), ), ;, case, Token, ., FALSE, :, return, "false", ;, case, Token, ., TRUE, :, return, "true", ;, case]
[., FALSE, :, return, "false", ;, case, Token, ., TRUE, :, return, "true", ;, case, Token, ., NULL, :, return]
[return, "false", ;, case, Token, ., TRUE, :, return, "true", ;, case, Token, ., NULL, :, return, "null", ;, case]
[return, "false", ;, case, Token, ., TRUE, :, return, "true", ;, case, Token, ., NULL, :, return, "null", ;, case]
[., TRUE, :, return, "true", ;, case, Token, ., NULL, :, return, "null", ;, case, Token, ., VOID, :, return]
[return, "true", ;, case, Token, ., NULL, :, return, "null", ;, case, Token, ., VOID, :, return, "undefined", ;, case]
[return, "true", ;, case, Token, ., NULL, :, return, "null", ;, case, Token, ., VOID, :, return, "undefined", ;, case]
[:, return, "null", ;, case, Token, ., VOID, :, return, "undefined", ;, case, Token, ., NOT, :, TernaryValue, child, =]
["null", ;, case, Token, ., VOID, :, return, "undefined", ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (]
["null", ;, case, Token, ., VOID, :, return, "undefined", ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (]
[;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (]
[;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (]
[Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=]
[Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=]
[=, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return]
[=, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return]
[=, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return]
[., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (]
[), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?]
[;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, "false", :]
[., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, "false", :, "true", ;, }, break, ;, case]
[., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, "false", :, "true", ;, }, break, ;, case]
[child, ., toBoolean, (, true, ), ?, "false", :, "true", ;, }, break, ;, case, Token, ., ARRAYLIT, :, return]
[toBoolean, (, true, ), ?, "false", :, "true", ;, }, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString, (]
[?, "false", :, "true", ;, }, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString, (, n, ), ;, case]
[?, "false", :, "true", ;, }, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString, (, n, ), ;, case]
[}, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString, (, n, ), ;, case, Token, ., OBJECTLIT, :, return]
[Token, ., ARRAYLIT, :, return, arrayToString, (, n, ), ;, case, Token, ., OBJECTLIT, :, return, "[object Object]", ;, }, return]
[:, return, "[object Object]", ;, }, return, null, ;, }, static, String, getStringValue, (, double, value, ), {, long, longValue, =]
[;, }, return, null, ;, }, static, String, getStringValue, (, double, value, ), {, long, longValue, =, (, long, )]
[;, }, static, String, getStringValue, (, double, value, ), {, long, longValue, =, (, long, ), value, ;, if, (]
[;, }, static, String, getStringValue, (, double, value, ), {, long, longValue, =, (, long, ), value, ;, if, (]
[static, String, getStringValue, (, double, value, ), {, long, longValue, =, (, long, ), value, ;, if, (, longValue, ==]
[double, value, ), {, long, longValue, =, (, long, ), value, ;, if, (, longValue, ==, value, ), {, return]
[double, value, ), {, long, longValue, =, (, long, ), value, ;, if, (, longValue, ==, value, ), {, return]
[long, longValue, =, (, long, ), value, ;, if, (, longValue, ==, value, ), {, return, Long, ., toString, (]
[;, if, (, longValue, ==, value, ), {, return, Long, ., toString, (, longValue, ), ;, }, else, {, return]
[;, if, (, longValue, ==, value, ), {, return, Long, ., toString, (, longValue, ), ;, }, else, {, return]
[==, value, ), {, return, Long, ., toString, (, longValue, ), ;, }, else, {, return, Double, ., toString, (]
[{, return, Double, ., toString, (, value, ), ;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return]
[{, return, Double, ., toString, (, value, ), ;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return]
[return, Double, ., toString, (, value, ), ;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return, (]
[return, Double, ., toString, (, value, ), ;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return, (]
[return, Double, ., toString, (, value, ), ;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return, (]
[(, value, ), ;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return, (, NodeUtil, ., isNullOrUndefined, (]
[;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return, (, NodeUtil, ., isNullOrUndefined, (, n, ), ||]
[;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return, (, NodeUtil, ., isNullOrUndefined, (, n, ), ||]
[Node, n, ), {, return, (, NodeUtil, ., isNullOrUndefined, (, n, ), ||, n, ., isEmpty, (, ), ), ?]
[), {, return, (, NodeUtil, ., isNullOrUndefined, (, n, ), ||, n, ., isEmpty, (, ), ), ?, "", :]
[return, (, NodeUtil, ., isNullOrUndefined, (, n, ), ||, n, ., isEmpty, (, ), ), ?, "", :, getStringValue, (]
[?, "", :, getStringValue, (, n, ), ;, }, static, String, arrayToString, (, Node, literal, ), {, Node, first, =]
[?, "", :, getStringValue, (, n, ), ;, }, static, String, arrayToString, (, Node, literal, ), {, Node, first, =]
[static, String, arrayToString, (, Node, literal, ), {, Node, first, =, literal, ., getFirstChild, (, ), ;, StringBuilder, result, =]
[Node, first, =, literal, ., getFirstChild, (, ), ;, StringBuilder, result, =, new, StringBuilder, (, ), ;, int, nextSlot, =]
[getFirstChild, (, ), ;, StringBuilder, result, =, new, StringBuilder, (, ), ;, int, nextSlot, =, 0, ;, int, nextSkipSlot, =]
[new, StringBuilder, (, ), ;, int, nextSlot, =, 0, ;, int, nextSkipSlot, =, 0, ;, for, (, Node, n, =]
[(, ), ;, int, nextSlot, =, 0, ;, int, nextSkipSlot, =, 0, ;, for, (, Node, n, =, first, ;]
[(, ), ;, int, nextSlot, =, 0, ;, int, nextSkipSlot, =, 0, ;, for, (, Node, n, =, first, ;]
[;, int, nextSlot, =, 0, ;, int, nextSkipSlot, =, 0, ;, for, (, Node, n, =, first, ;, n, !=]
[nextSlot, =, 0, ;, int, nextSkipSlot, =, 0, ;, for, (, Node, n, =, first, ;, n, !=, null, ;]
[0, ;, int, nextSkipSlot, =, 0, ;, for, (, Node, n, =, first, ;, n, !=, null, ;, n, =]
[0, ;, int, nextSkipSlot, =, 0, ;, for, (, Node, n, =, first, ;, n, !=, null, ;, n, =]
[n, =, first, ;, n, !=, null, ;, n, =, n, ., getNext, (, ), ), {, String, childValue, =]
[first, ;, n, !=, null, ;, n, =, n, ., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (]
[;, n, =, n, ., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;, if, (]
[;, n, =, n, ., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;, if, (]
[=, n, ., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;, if, (, childValue, ==]
[(, ), ), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;, if, (, childValue, ==, null, ), {, return]
[childValue, =, getArrayElementStringValue, (, n, ), ;, if, (, childValue, ==, null, ), {, return, null, ;, }, if, (]
[childValue, =, getArrayElementStringValue, (, n, ), ;, if, (, childValue, ==, null, ), {, return, null, ;, }, if, (]
[getArrayElementStringValue, (, n, ), ;, if, (, childValue, ==, null, ), {, return, null, ;, }, if, (, n, !=]
[), ;, if, (, childValue, ==, null, ), {, return, null, ;, }, if, (, n, !=, first, ), {]
[), ;, if, (, childValue, ==, null, ), {, return, null, ;, }, if, (, n, !=, first, ), {]
[childValue, ==, null, ), {, return, null, ;, }, if, (, n, !=, first, ), {, result, ., append, (]
[{, return, null, ;, }, if, (, n, !=, first, ), {, result, ., append, (, ',', ), ;, }]
[{, return, null, ;, }, if, (, n, !=, first, ), {, result, ., append, (, ',', ), ;, }]
[}, if, (, n, !=, first, ), {, result, ., append, (, ',', ), ;, }, result, ., append, (]
[n, !=, first, ), {, result, ., append, (, ',', ), ;, }, result, ., append, (, childValue, ), ;]
[n, !=, first, ), {, result, ., append, (, ',', ), ;, }, result, ., append, (, childValue, ), ;]
[result, ., append, (, ',', ), ;, }, result, ., append, (, childValue, ), ;, nextSlot, ++, ;, }, return]
[result, ., append, (, ',', ), ;, }, result, ., append, (, childValue, ), ;, nextSlot, ++, ;, }, return]
[;, }, return, result, ., toString, (, ), ;, }, static, Double, getNumberValue, (, Node, n, ), {, switch, (]
[;, }, return, result, ., toString, (, ), ;, }, static, Double, getNumberValue, (, Node, n, ), {, switch, (]
[;, }, static, Double, getNumberValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, Double, getNumberValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., TRUE, :, return]
[), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., TRUE, :, return, 1.0, ;, case]
[), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., TRUE, :, return, 1.0, ;, case]
[., getType, (, ), ), {, case, Token, ., TRUE, :, return, 1.0, ;, case, Token, ., FALSE, :, case]
[., getType, (, ), ), {, case, Token, ., TRUE, :, return, 1.0, ;, case, Token, ., FALSE, :, case]
[{, case, Token, ., TRUE, :, return, 1.0, ;, case, Token, ., FALSE, :, case, Token, ., NULL, :, return]
[., TRUE, :, return, 1.0, ;, case, Token, ., FALSE, :, case, Token, ., NULL, :, return, 0.0, ;, case]
[., TRUE, :, return, 1.0, ;, case, Token, ., FALSE, :, case, Token, ., NULL, :, return, 0.0, ;, case]
[;, case, Token, ., FALSE, :, case, Token, ., NULL, :, return, 0.0, ;, case, Token, ., NUMBER, :, return]
[;, case, Token, ., FALSE, :, case, Token, ., NULL, :, return, 0.0, ;, case, Token, ., NUMBER, :, return]
[Token, ., NULL, :, return, 0.0, ;, case, Token, ., NUMBER, :, return, n, ., getDouble, (, ), ;, case]
[Token, ., NULL, :, return, 0.0, ;, case, Token, ., NUMBER, :, return, n, ., getDouble, (, ), ;, case]
[;, case, Token, ., NUMBER, :, return, n, ., getDouble, (, ), ;, case, Token, ., VOID, :, if, (]
[Token, ., NUMBER, :, return, n, ., getDouble, (, ), ;, case, Token, ., VOID, :, if, (, mayHaveSideEffects, (]
[Token, ., NUMBER, :, return, n, ., getDouble, (, ), ;, case, Token, ., VOID, :, if, (, mayHaveSideEffects, (]
[), ;, case, Token, ., VOID, :, if, (, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return]
[:, if, (, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return, null, ;, }, else, {, return]
[:, if, (, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return, null, ;, }, else, {, return]
[., getFirstChild, (, ), ), ), {, return, null, ;, }, else, {, return, Double, ., NaN, ;, }, case]
[., getFirstChild, (, ), ), ), {, return, null, ;, }, else, {, return, Double, ., NaN, ;, }, case]
[return, null, ;, }, else, {, return, Double, ., NaN, ;, }, case, Token, ., NAME, :, String, name, =]
[return, null, ;, }, else, {, return, Double, ., NaN, ;, }, case, Token, ., NAME, :, String, name, =]
[., NaN, ;, }, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[., NaN, ;, }, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals, (]
[String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals, (, "undefined", ), ), {, return]
[String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals, (, "undefined", ), ), {, return]
[), ;, if, (, name, ., equals, (, "undefined", ), ), {, return, Double, ., NaN, ;, }, if, (]
[), ;, if, (, name, ., equals, (, "undefined", ), ), {, return, Double, ., NaN, ;, }, if, (]
[name, ., equals, (, "undefined", ), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (]
[), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "NaN", ), ), {, return]
[), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "NaN", ), ), {, return]
[;, }, if, (, name, ., equals, (, "NaN", ), ), {, return, Double, ., NaN, ;, }, if, (]
[;, }, if, (, name, ., equals, (, "NaN", ), ), {, return, Double, ., NaN, ;, }, if, (]
[name, ., equals, (, "NaN", ), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (]
[), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return]
[), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return]
[NaN, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return]
[if, (, name, ., equals, (, "Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case]
[if, (, name, ., equals, (, "Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case]
["Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG, :, if, (]
["Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG, :, if, (]
["Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG, :, if, (]
["Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG, :, if, (]
["Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG, :, if, (]
[., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG, :, if, (, n, ., getChildCount, (, ), ==]
[;, }, return, null, ;, case, Token, ., NEG, :, if, (, n, ., getChildCount, (, ), ==, 1, &&]
[;, }, return, null, ;, case, Token, ., NEG, :, if, (, n, ., getChildCount, (, ), ==, 1, &&]
[;, }, return, null, ;, case, Token, ., NEG, :, if, (, n, ., getChildCount, (, ), ==, 1, &&]
[if, (, n, ., getChildCount, (, ), ==, 1, &&, n, ., getFirstChild, (, ), ., isName, (, ), &&]
[if, (, n, ., getChildCount, (, ), ==, 1, &&, n, ., getFirstChild, (, ), ., isName, (, ), &&]
[if, (, n, ., getChildCount, (, ), ==, 1, &&, n, ., getFirstChild, (, ), ., isName, (, ), &&]
[if, (, n, ., getChildCount, (, ), ==, 1, &&, n, ., getFirstChild, (, ), ., isName, (, ), &&]
[getFirstChild, (, ), ., isName, (, ), &&, n, ., getFirstChild, (, ), ., getString, (, ), ., equals, (]
[(, ), &&, n, ., getFirstChild, (, ), ., getString, (, ), ., equals, (, "Infinity", ), ), {, return]
[(, ), &&, n, ., getFirstChild, (, ), ., getString, (, ), ., equals, (, "Infinity", ), ), {, return]
[(, ), ., getString, (, ), ., equals, (, "Infinity", ), ), {, return, Double, ., NEGATIVE_INFINITY, ;, }, return]
[getString, (, ), ., equals, (, "Infinity", ), ), {, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;, case]
[getString, (, ), ., equals, (, "Infinity", ), ), {, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;, case]
[), ), {, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NOT, :, TernaryValue, child, =]
[{, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (]
[{, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (]
[;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (]
[;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (]
[Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=]
[Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=]
[=, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return]
[=, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return]
[=, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return]
[., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (]
[), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?]
[;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, 0.0, :]
[., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break, ;, case]
[., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break, ;, case]
[child, ., toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break, ;, case, Token, ., STRING, :, return]
[toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue, (]
[toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue, (]
[;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue, (, n, ., getString, (, ), ), ;, case]
[;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue, (, n, ., getString, (, ), ), ;, case]
[Token, ., STRING, :, return, getStringNumberValue, (, n, ., getString, (, ), ), ;, case, Token, ., ARRAYLIT, :, case]
[Token, ., STRING, :, return, getStringNumberValue, (, n, ., getString, (, ), ), ;, case, Token, ., ARRAYLIT, :, case]
[n, ., getString, (, ), ), ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =]
[getString, (, ), ), ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (]
[;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return]
[;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return]
[;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return]
[Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return, value, !=]
[ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return, value, !=, null, ?]
[case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return, value, !=, null, ?, getStringNumberValue, (]
[OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return, value, !=, null, ?, getStringNumberValue, (, value, ), :]
[=, getStringValue, (, n, ), ;, return, value, !=, null, ?, getStringNumberValue, (, value, ), :, null, ;, }, return]
[value, ), :, null, ;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String, rawJsString, ), {, if, (]
[value, ), :, null, ;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String, rawJsString, ), {, if, (]
[;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String, rawJsString, ), {, if, (, rawJsString, ., contains, (]
[}, static, Double, getStringNumberValue, (, String, rawJsString, ), {, if, (, rawJsString, ., contains, (, "\u000b", ), ), {, return]
[rawJsString, ), {, if, (, rawJsString, ., contains, (, "\u000b", ), ), {, return, null, ;, }, String, s, =]
[{, if, (, rawJsString, ., contains, (, "\u000b", ), ), {, return, null, ;, }, String, s, =, trimJsWhiteSpace, (]
[contains, (, "\u000b", ), ), {, return, null, ;, }, String, s, =, trimJsWhiteSpace, (, rawJsString, ), ;, if, (]
[contains, (, "\u000b", ), ), {, return, null, ;, }, String, s, =, trimJsWhiteSpace, (, rawJsString, ), ;, if, (]
[contains, (, "\u000b", ), ), {, return, null, ;, }, String, s, =, trimJsWhiteSpace, (, rawJsString, ), ;, if, (]
[return, null, ;, }, String, s, =, trimJsWhiteSpace, (, rawJsString, ), ;, if, (, s, ., length, (, ), ==]
[String, s, =, trimJsWhiteSpace, (, rawJsString, ), ;, if, (, s, ., length, (, ), ==, 0, ), {, return]
[rawJsString, ), ;, if, (, s, ., length, (, ), ==, 0, ), {, return, 0.0, ;, }, if, (]
[rawJsString, ), ;, if, (, s, ., length, (, ), ==, 0, ), {, return, 0.0, ;, }, if, (]
[rawJsString, ), ;, if, (, s, ., length, (, ), ==, 0, ), {, return, 0.0, ;, }, if, (]
[rawJsString, ), ;, if, (, s, ., length, (, ), ==, 0, ), {, return, 0.0, ;, }, if, (]
[rawJsString, ), ;, if, (, s, ., length, (, ), ==, 0, ), {, return, 0.0, ;, }, if, (]
[., length, (, ), ==, 0, ), {, return, 0.0, ;, }, if, (, s, ., length, (, ), >]
[(, ), ==, 0, ), {, return, 0.0, ;, }, if, (, s, ., length, (, ), >, 2, &&]
[(, ), ==, 0, ), {, return, 0.0, ;, }, if, (, s, ., length, (, ), >, 2, &&]
[(, ), ==, 0, ), {, return, 0.0, ;, }, if, (, s, ., length, (, ), >, 2, &&]
[), {, return, 0.0, ;, }, if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (]
[0.0, ;, }, if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (, 0, ), ==]
[}, if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (, 0, ), ==, '0', &&]
[if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (, 0, ), ==, '0', &&, (]
[if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (, 0, ), ==, '0', &&, (]
[if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (, 0, ), ==, '0', &&, (]
[if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (, 0, ), ==, '0', &&, (]
[length, (, ), >, 2, &&, s, ., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt, (]
[>, 2, &&, s, ., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt, (, 1, ), ==]
[&&, s, ., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||]
[&&, s, ., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||]
[&&, s, ., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||]
[(, 0, ), ==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||, s, ., charAt, (]
[==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||, s, ., charAt, (, 1, ), ==]
[(, 1, ), ==, 'x', ||, s, ., charAt, (, 1, ), ==, 'X', ), ), {, try, {, return]
[(, 1, ), ==, 'x', ||, s, ., charAt, (, 1, ), ==, 'X', ), ), {, try, {, return]
['x', ||, s, ., charAt, (, 1, ), ==, 'X', ), ), {, try, {, return, Double, ., valueOf, (]
['x', ||, s, ., charAt, (, 1, ), ==, 'X', ), ), {, try, {, return, Double, ., valueOf, (]
[charAt, (, 1, ), ==, 'X', ), ), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (]
[charAt, (, 1, ), ==, 'X', ), ), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (]
[==, 'X', ), ), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (, s, ., substring, (]
[), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (, s, ., substring, (, 2, ), ,]
[(, s, ., substring, (, 2, ), ,, 16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return]
[(, s, ., substring, (, 2, ), ,, 16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return]
[16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (]
[16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (]
[16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (]
[16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (]
[16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (]
[16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (]
[(, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (, s, ., length, (, ), >]
[e, ), {, return, Double, ., NaN, ;, }, }, if, (, s, ., length, (, ), >, 3, &&]
[), {, return, Double, ., NaN, ;, }, }, if, (, s, ., length, (, ), >, 3, &&, (]
[), {, return, Double, ., NaN, ;, }, }, if, (, s, ., length, (, ), >, 3, &&, (]
[), {, return, Double, ., NaN, ;, }, }, if, (, s, ., length, (, ), >, 3, &&, (]
[), {, return, Double, ., NaN, ;, }, }, if, (, s, ., length, (, ), >, 3, &&, (]
[., NaN, ;, }, }, if, (, s, ., length, (, ), >, 3, &&, (, s, ., charAt, (]
[}, }, if, (, s, ., length, (, ), >, 3, &&, (, s, ., charAt, (, 0, ), ==]
[if, (, s, ., length, (, ), >, 3, &&, (, s, ., charAt, (, 0, ), ==, '-', ||]
[if, (, s, ., length, (, ), >, 3, &&, (, s, ., charAt, (, 0, ), ==, '-', ||]
[if, (, s, ., length, (, ), >, 3, &&, (, s, ., charAt, (, 0, ), ==, '-', ||]
[length, (, ), >, 3, &&, (, s, ., charAt, (, 0, ), ==, '-', ||, s, ., charAt, (]
[>, 3, &&, (, s, ., charAt, (, 0, ), ==, '-', ||, s, ., charAt, (, 0, ), ==]
[(, s, ., charAt, (, 0, ), ==, '-', ||, s, ., charAt, (, 0, ), ==, '+', ), &&]
[(, s, ., charAt, (, 0, ), ==, '-', ||, s, ., charAt, (, 0, ), ==, '+', ), &&]
[(, s, ., charAt, (, 0, ), ==, '-', ||, s, ., charAt, (, 0, ), ==, '+', ), &&]
[(, 0, ), ==, '-', ||, s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (]
[==, '-', ||, s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==]
[||, s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&]
[s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&, (]
[s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&, (]
[s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&, (]
[s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&, (]
[0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (]
['+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==]
[&&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||]
[&&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||]
[&&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||]
[(, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||, s, ., charAt, (]
[==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||, s, ., charAt, (, 2, ), ==]
[., charAt, (, 2, ), ==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return]
[==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if, (]
[==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if, (]
[==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if, (]
[==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if, (]
[., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if, (, s, ., equals, (]
[2, ), ==, 'X', ), ), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||]
[2, ), ==, 'X', ), ), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||]
[), ), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (]
[return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (, "-infinity", ), ||]
[return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (, "-infinity", ), ||]
[if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (, "-infinity", ), ||, s, ., equals, (]
[(, "infinity", ), ||, s, ., equals, (, "-infinity", ), ||, s, ., equals, (, "+infinity", ), ), {, return]
[equals, (, "-infinity", ), ||, s, ., equals, (, "+infinity", ), ), {, return, null, ;, }, try, {, return]
[equals, (, "-infinity", ), ||, s, ., equals, (, "+infinity", ), ), {, return, null, ;, }, try, {, return]
[||, s, ., equals, (, "+infinity", ), ), {, return, null, ;, }, try, {, return, Double, ., parseDouble, (]
[;, }, try, {, return, Double, ., parseDouble, (, s, ), ;, }, catch, (, NumberFormatException, e, ), {, return]
[;, }, try, {, return, Double, ., parseDouble, (, s, ), ;, }, catch, (, NumberFormatException, e, ), {, return]
[), {, return, Double, ., NaN, ;, }, }, static, String, trimJsWhiteSpace, (, String, s, ), {, int, start, =]
[NaN, ;, }, }, static, String, trimJsWhiteSpace, (, String, s, ), {, int, start, =, 0, ;, int, end, =]
[NaN, ;, }, }, static, String, trimJsWhiteSpace, (, String, s, ), {, int, start, =, 0, ;, int, end, =]
[String, s, ), {, int, start, =, 0, ;, int, end, =, s, ., length, (, ), ;, while, (]
[String, s, ), {, int, start, =, 0, ;, int, end, =, s, ., length, (, ), ;, while, (]
[String, s, ), {, int, start, =, 0, ;, int, end, =, s, ., length, (, ), ;, while, (]
[), {, int, start, =, 0, ;, int, end, =, s, ., length, (, ), ;, while, (, end, >]
[int, start, =, 0, ;, int, end, =, s, ., length, (, ), ;, while, (, end, >, 0, &&]
[int, start, =, 0, ;, int, end, =, s, ., length, (, ), ;, while, (, end, >, 0, &&]
[=, 0, ;, int, end, =, s, ., length, (, ), ;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (]
[=, 0, ;, int, end, =, s, ., length, (, ), ;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (]
[end, =, s, ., length, (, ), ;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (]
[end, =, s, ., length, (, ), ;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (]
[s, ., length, (, ), ;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -]
[), ;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -, 1, ), ), ==]
[), ;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -, 1, ), ), ==]
[>, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {]
[>, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {]
[., charAt, (, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (]
[., charAt, (, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (]
[., charAt, (, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (]
[(, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <]
[-, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&]
[-, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&]
[), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (]
[), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (]
[., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (]
[end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==]
[end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==]
[(, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==, TernaryValue, ., TRUE, ), {]
[(, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==, TernaryValue, ., TRUE, ), {]
[isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==, TernaryValue, ., TRUE, ), {, start, ++, ;, }, return]
[isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==, TernaryValue, ., TRUE, ), {, start, ++, ;, }, return]
[charAt, (, start, ), ), ==, TernaryValue, ., TRUE, ), {, start, ++, ;, }, return, s, ., substring, (]
[start, ), ), ==, TernaryValue, ., TRUE, ), {, start, ++, ;, }, return, s, ., substring, (, start, ,]
[., substring, (, start, ,, end, ), ;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int, c, ), {, switch, (]
[,, end, ), ;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int, c, ), {, switch, (, c, ), {, case]
[;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int, c, ), {, switch, (, c, ), {, case, '\u000B', :, return]
[;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int, c, ), {, switch, (, c, ), {, case, '\u000B', :, return]
[isStrWhiteSpaceChar, (, int, c, ), {, switch, (, c, ), {, case, '\u000B', :, return, TernaryValue, ., UNKNOWN, ;, case]
[c, ), {, switch, (, c, ), {, case, '\u000B', :, return, TernaryValue, ., UNKNOWN, ;, case, ' ', :, case]
[switch, (, c, ), {, case, '\u000B', :, return, TernaryValue, ., UNKNOWN, ;, case, ' ', :, case, '\n', :, case]
[), {, case, '\u000B', :, return, TernaryValue, ., UNKNOWN, ;, case, ' ', :, case, '\n', :, case, '\r', :, case]
['\u000B', :, return, TernaryValue, ., UNKNOWN, ;, case, ' ', :, case, '\n', :, case, '\r', :, case, '\t', :, case]
[TernaryValue, ., UNKNOWN, ;, case, ' ', :, case, '\n', :, case, '\r', :, case, '\t', :, case, '\u00A0', :, case]
[;, case, ' ', :, case, '\n', :, case, '\r', :, case, '\t', :, case, '\u00A0', :, case, '\u000C', :, case]
[:, case, '\n', :, case, '\r', :, case, '\t', :, case, '\u00A0', :, case, '\u000C', :, case, '\u2028', :, case]
[:, case, '\r', :, case, '\t', :, case, '\u00A0', :, case, '\u000C', :, case, '\u2028', :, case, '\u2029', :, case]
[:, case, '\t', :, case, '\u00A0', :, case, '\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return]
[:, case, '\t', :, case, '\u00A0', :, case, '\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return]
[case, '\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return]
[case, '\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return]
['\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return, (]
['\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return, (]
['\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return, (]
[:, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return, (, Character, ., getType, (]
[:, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return, (, Character, ., getType, (, c, ), ==]
[:, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return, (, Character, ., getType, (, c, ), ==]
[TernaryValue, ., TRUE, ;, default, :, return, (, Character, ., getType, (, c, ), ==, Character, ., SPACE_SEPARATOR, ), ?]
[TernaryValue, ., TRUE, ;, default, :, return, (, Character, ., getType, (, c, ), ==, Character, ., SPACE_SEPARATOR, ), ?]
[default, :, return, (, Character, ., getType, (, c, ), ==, Character, ., SPACE_SEPARATOR, ), ?, TernaryValue, ., TRUE, :]
[default, :, return, (, Character, ., getType, (, c, ), ==, Character, ., SPACE_SEPARATOR, ), ?, TernaryValue, ., TRUE, :]
[), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {]
[), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {]
[TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {, Preconditions, ., checkState, (]
[TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {, Preconditions, ., checkState, (]
[getFunctionName, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isFunction, (, ), ), ;, Node, parent, =]
[getFunctionName, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isFunction, (, ), ), ;, Node, parent, =]
[checkState, (, n, ., isFunction, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[checkState, (, n, ., isFunction, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[;, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[;, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., NAME, :, return]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., NAME, :, return]
[parent, ., getType, (, ), ), {, case, Token, ., NAME, :, return, parent, ., getQualifiedName, (, ), ;, case]
[parent, ., getType, (, ), ), {, case, Token, ., NAME, :, return, parent, ., getQualifiedName, (, ), ;, case]
[), {, case, Token, ., NAME, :, return, parent, ., getQualifiedName, (, ), ;, case, Token, ., ASSIGN, :, return]
[), {, case, Token, ., NAME, :, return, parent, ., getQualifiedName, (, ), ;, case, Token, ., ASSIGN, :, return]
[), {, case, Token, ., NAME, :, return, parent, ., getQualifiedName, (, ), ;, case, Token, ., ASSIGN, :, return]
[Token, ., ASSIGN, :, return, parent, ., getFirstChild, (, ), ., getQualifiedName, (, ), ;, default, :, String, name, =]
[Token, ., ASSIGN, :, return, parent, ., getFirstChild, (, ), ., getQualifiedName, (, ), ;, default, :, String, name, =]
[Token, ., ASSIGN, :, return, parent, ., getFirstChild, (, ), ., getQualifiedName, (, ), ;, default, :, String, name, =]
[getQualifiedName, (, ), ;, default, :, String, name, =, n, ., getFirstChild, (, ), ., getQualifiedName, (, ), ;, return]
[getQualifiedName, (, ), ;, return, name, ;, }, }, public, static, String, getNearestFunctionName, (, Node, n, ), {, if, (]
[(, ), ;, return, name, ;, }, }, public, static, String, getNearestFunctionName, (, Node, n, ), {, if, (, !]
[(, ), ;, return, name, ;, }, }, public, static, String, getNearestFunctionName, (, Node, n, ), {, if, (, !]
[public, static, String, getNearestFunctionName, (, Node, n, ), {, if, (, !, n, ., isFunction, (, ), ), {, return]
[n, ), {, if, (, !, n, ., isFunction, (, ), ), {, return, null, ;, }, String, name, =]
[{, if, (, !, n, ., isFunction, (, ), ), {, return, null, ;, }, String, name, =, getFunctionName, (]
[., isFunction, (, ), ), {, return, null, ;, }, String, name, =, getFunctionName, (, n, ), ;, if, (]
[., isFunction, (, ), ), {, return, null, ;, }, String, name, =, getFunctionName, (, n, ), ;, if, (]
[(, ), ), {, return, null, ;, }, String, name, =, getFunctionName, (, n, ), ;, if, (, name, !=]
[return, null, ;, }, String, name, =, getFunctionName, (, n, ), ;, if, (, name, !=, null, ), {, return]
[=, getFunctionName, (, n, ), ;, if, (, name, !=, null, ), {, return, name, ;, }, Node, parent, =]
[=, getFunctionName, (, n, ), ;, if, (, name, !=, null, ), {, return, name, ;, }, Node, parent, =]
[name, !=, null, ), {, return, name, ;, }, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[name, !=, null, ), {, return, name, ;, }, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[}, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[}, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, case]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, case, Token, ., GETTER_DEF, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, case, Token, ., GETTER_DEF, :, case]
[(, ), ), {, case, Token, ., SETTER_DEF, :, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, return]
[(, ), ), {, case, Token, ., SETTER_DEF, :, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, return]
[SETTER_DEF, :, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, return, parent, ., getString, (, ), ;, case]
[SETTER_DEF, :, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, return, parent, ., getString, (, ), ;, case]
[GETTER_DEF, :, case, Token, ., STRING_KEY, :, return, parent, ., getString, (, ), ;, case, Token, ., NUMBER, :, return]
[case, Token, ., STRING_KEY, :, return, parent, ., getString, (, ), ;, case, Token, ., NUMBER, :, return, getStringValue, (]
[return, parent, ., getString, (, ), ;, case, Token, ., NUMBER, :, return, getStringValue, (, parent, ), ;, }, return]
[getStringValue, (, parent, ), ;, }, return, null, ;, }, static, boolean, isImmutableValue, (, Node, n, ), {, switch, (]
[getStringValue, (, parent, ), ;, }, return, null, ;, }, static, boolean, isImmutableValue, (, Node, n, ), {, switch, (]
[;, }, static, boolean, isImmutableValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, boolean, isImmutableValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case]
[(, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., NULL, :, case]
[(, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., NULL, :, case]
[Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., NULL, :, case, Token, ., TRUE, :, case]
[Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., NULL, :, case, Token, ., TRUE, :, case]
[Token, ., NUMBER, :, case, Token, ., NULL, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return]
[:, case, Token, ., NULL, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case]
[:, case, Token, ., NULL, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case]
[:, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., CAST, :, case]
[:, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., CAST, :, case]
[:, case, Token, ., FALSE, :, return, true, ;, case, Token, ., CAST, :, case, Token, ., NOT, :, return]
[Token, ., FALSE, :, return, true, ;, case, Token, ., CAST, :, case, Token, ., NOT, :, return, isImmutableValue, (]
[Token, ., FALSE, :, return, true, ;, case, Token, ., CAST, :, case, Token, ., NOT, :, return, isImmutableValue, (]
[Token, ., CAST, :, case, Token, ., NOT, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case]
[Token, ., CAST, :, case, Token, ., NOT, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case]
[Token, ., NOT, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., VOID, :, case]
[Token, ., NOT, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., VOID, :, case]
[isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., VOID, :, case, Token, ., NEG, :, return]
[n, ., getFirstChild, (, ), ), ;, case, Token, ., VOID, :, case, Token, ., NEG, :, return, isImmutableValue, (]
[n, ., getFirstChild, (, ), ), ;, case, Token, ., VOID, :, case, Token, ., NEG, :, return, isImmutableValue, (]
[Token, ., VOID, :, case, Token, ., NEG, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case]
[Token, ., VOID, :, case, Token, ., NEG, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case]
[NEG, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., NAME, :, String, name, =]
[NEG, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., NAME, :, String, name, =]
[getFirstChild, (, ), ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, return]
[getFirstChild, (, ), ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, return]
[getFirstChild, (, ), ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, return]
[getFirstChild, (, ), ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, return]
[;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, return, "undefined", ., equals, (]
[., NAME, :, String, name, =, n, ., getString, (, ), ;, return, "undefined", ., equals, (, name, ), ||]
[., NAME, :, String, name, =, n, ., getString, (, ), ;, return, "undefined", ., equals, (, name, ), ||]
[name, =, n, ., getString, (, ), ;, return, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (]
[., getString, (, ), ;, return, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||]
[., getString, (, ), ;, return, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||]
[;, return, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (]
[(, name, ), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ;, }, return]
[equals, (, name, ), ;, }, return, false, ;, }, static, boolean, isSymmetricOperation, (, Node, n, ), {, switch, (]
[equals, (, name, ), ;, }, return, false, ;, }, static, boolean, isSymmetricOperation, (, Node, n, ), {, switch, (]
[;, }, static, boolean, isSymmetricOperation, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, boolean, isSymmetricOperation, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., EQ, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., EQ, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[(, ), ), {, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[(, ), ), {, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case]
[Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case]
[Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., MUL, :, return]
[case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., MUL, :, return, true, ;, }, return]
[MUL, :, return, true, ;, }, return, false, ;, }, static, boolean, isRelationalOperation, (, Node, n, ), {, switch, (]
[MUL, :, return, true, ;, }, return, false, ;, }, static, boolean, isRelationalOperation, (, Node, n, ), {, switch, (]
[;, }, static, boolean, isRelationalOperation, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, boolean, isRelationalOperation, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., GT, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., GT, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., GT, :, case, Token, ., GE, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., GT, :, case, Token, ., GE, :, case]
[(, ), ), {, case, Token, ., GT, :, case, Token, ., GE, :, case, Token, ., LT, :, case]
[(, ), ), {, case, Token, ., GT, :, case, Token, ., GE, :, case, Token, ., LT, :, case]
[Token, ., GT, :, case, Token, ., GE, :, case, Token, ., LT, :, case, Token, ., LE, :, return]
[case, Token, ., GE, :, case, Token, ., LT, :, case, Token, ., LE, :, return, true, ;, }, return]
[LE, :, return, true, ;, }, return, false, ;, }, static, int, getInverseOperator, (, int, type, ), {, switch, (]
[;, }, return, false, ;, }, static, int, getInverseOperator, (, int, type, ), {, switch, (, type, ), {, case]
[;, }, return, false, ;, }, static, int, getInverseOperator, (, int, type, ), {, switch, (, type, ), {, case]
[}, static, int, getInverseOperator, (, int, type, ), {, switch, (, type, ), {, case, Token, ., GT, :, return]
[}, static, int, getInverseOperator, (, int, type, ), {, switch, (, type, ), {, case, Token, ., GT, :, return]
[int, type, ), {, switch, (, type, ), {, case, Token, ., GT, :, return, Token, ., LT, ;, case]
[int, type, ), {, switch, (, type, ), {, case, Token, ., GT, :, return, Token, ., LT, ;, case]
[(, type, ), {, case, Token, ., GT, :, return, Token, ., LT, ;, case, Token, ., LT, :, return]
[(, type, ), {, case, Token, ., GT, :, return, Token, ., LT, ;, case, Token, ., LT, :, return]
[Token, ., GT, :, return, Token, ., LT, ;, case, Token, ., LT, :, return, Token, ., GT, ;, case]
[Token, ., GT, :, return, Token, ., LT, ;, case, Token, ., LT, :, return, Token, ., GT, ;, case]
[Token, ., LT, ;, case, Token, ., LT, :, return, Token, ., GT, ;, case, Token, ., GE, :, return]
[Token, ., LT, ;, case, Token, ., LT, :, return, Token, ., GT, ;, case, Token, ., GE, :, return]
[Token, ., LT, :, return, Token, ., GT, ;, case, Token, ., GE, :, return, Token, ., LE, ;, case]
[Token, ., LT, :, return, Token, ., GT, ;, case, Token, ., GE, :, return, Token, ., LE, ;, case]
[Token, ., GT, ;, case, Token, ., GE, :, return, Token, ., LE, ;, case, Token, ., LE, :, return]
[Token, ., GT, ;, case, Token, ., GE, :, return, Token, ., LE, ;, case, Token, ., LE, :, return]
[., GE, :, return, Token, ., LE, ;, case, Token, ., LE, :, return, Token, ., GE, ;, }, return]
[., GE, :, return, Token, ., LE, ;, case, Token, ., LE, :, return, Token, ., GE, ;, }, return]
[}, return, Token, ., ERROR, ;, }, static, boolean, isLiteralValue, (, Node, n, ,, boolean, includeFunctions, ), {, switch, (]
[}, return, Token, ., ERROR, ;, }, static, boolean, isLiteralValue, (, Node, n, ,, boolean, includeFunctions, ), {, switch, (]
[boolean, isLiteralValue, (, Node, n, ,, boolean, includeFunctions, ), {, switch, (, n, ., getType, (, ), ), {, case]
[boolean, isLiteralValue, (, Node, n, ,, boolean, includeFunctions, ), {, switch, (, n, ., getType, (, ), ), {, case]
[,, boolean, includeFunctions, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, return]
[includeFunctions, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, return, isLiteralValue, (]
[includeFunctions, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, return, isLiteralValue, (]
[., getType, (, ), ), {, case, Token, ., CAST, :, return, isLiteralValue, (, n, ., getFirstChild, (, ), ,]
[), {, case, Token, ., CAST, :, return, isLiteralValue, (, n, ., getFirstChild, (, ), ,, includeFunctions, ), ;, case]
[), {, case, Token, ., CAST, :, return, isLiteralValue, (, n, ., getFirstChild, (, ), ,, includeFunctions, ), ;, case]
[(, n, ., getFirstChild, (, ), ,, includeFunctions, ), ;, case, Token, ., ARRAYLIT, :, for, (, Node, child, =]
[(, n, ., getFirstChild, (, ), ,, includeFunctions, ), ;, case, Token, ., ARRAYLIT, :, for, (, Node, child, =]
[,, includeFunctions, ), ;, case, Token, ., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[,, includeFunctions, ), ;, case, Token, ., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[), ;, case, Token, ., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=]
[case, Token, ., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;]
[., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, (]
[(, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, (, !]
[(, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, (, !]
[child, =, child, ., getNext, (, ), ), {, if, (, (, !, child, ., isEmpty, (, ), ), &&]
[=, child, ., getNext, (, ), ), {, if, (, (, !, child, ., isEmpty, (, ), ), &&, !]
[., getNext, (, ), ), {, if, (, (, !, child, ., isEmpty, (, ), ), &&, !, isLiteralValue, (]
[(, ), ), {, if, (, (, !, child, ., isEmpty, (, ), ), &&, !, isLiteralValue, (, child, ,]
[(, (, !, child, ., isEmpty, (, ), ), &&, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return]
[isEmpty, (, ), ), &&, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return]
[), &&, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case]
[), &&, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., REGEXP, :, for, (, Node, child, =]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., REGEXP, :, for, (, Node, child, =]
[}, return, true, ;, case, Token, ., REGEXP, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[}, return, true, ;, case, Token, ., REGEXP, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[true, ;, case, Token, ., REGEXP, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=]
[case, Token, ., REGEXP, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;]
[., REGEXP, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[., REGEXP, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !]
[), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (]
[child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ,]
[=, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return]
[), ), {, if, (, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return]
[if, (, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case]
[if, (, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., OBJECTLIT, :, for, (, Node, child, =]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., OBJECTLIT, :, for, (, Node, child, =]
[}, return, true, ;, case, Token, ., OBJECTLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[}, return, true, ;, case, Token, ., OBJECTLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[true, ;, case, Token, ., OBJECTLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=]
[case, Token, ., OBJECTLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;]
[., OBJECTLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[., OBJECTLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !]
[), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (]
[), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (]
[child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ., getFirstChild, (, ), ,]
[(, ), ), {, if, (, !, isLiteralValue, (, child, ., getFirstChild, (, ), ,, includeFunctions, ), ), {, return]
[(, !, isLiteralValue, (, child, ., getFirstChild, (, ), ,, includeFunctions, ), ), {, return, false, ;, }, }, return]
[(, child, ., getFirstChild, (, ), ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case]
[(, child, ., getFirstChild, (, ), ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case]
[), ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return]
[), ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return]
[includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return, includeFunctions, &&]
[), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return, includeFunctions, &&, !]
[), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return, includeFunctions, &&, !]
[false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return, includeFunctions, &&, !, NodeUtil, ., isFunctionDeclaration, (]
[;, case, Token, ., FUNCTION, :, return, includeFunctions, &&, !, NodeUtil, ., isFunctionDeclaration, (, n, ), ;, default, :, return]
[Token, ., FUNCTION, :, return, includeFunctions, &&, !, NodeUtil, ., isFunctionDeclaration, (, n, ), ;, default, :, return, isImmutableValue, (]
[), ;, }, }, static, boolean, isValidDefineValue, (, Node, val, ,, Set, <, String, >, defines, ), {, switch, (]
[), ;, }, }, static, boolean, isValidDefineValue, (, Node, val, ,, Set, <, String, >, defines, ), {, switch, (]
[Node, val, ,, Set, <, String, >, defines, ), {, switch, (, val, ., getType, (, ), ), {, case]
[Node, val, ,, Set, <, String, >, defines, ), {, switch, (, val, ., getType, (, ), ), {, case]
[String, >, defines, ), {, switch, (, val, ., getType, (, ), ), {, case, Token, ., STRING, :, case]
[String, >, defines, ), {, switch, (, val, ., getType, (, ), ), {, case, Token, ., STRING, :, case]
[switch, (, val, ., getType, (, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case]
[switch, (, val, ., getType, (, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case]
[(, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., TRUE, :, case]
[(, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., TRUE, :, case]
[Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return]
[:, case, Token, ., NUMBER, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case]
[:, case, Token, ., NUMBER, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case]
[:, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., ADD, :, case]
[:, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., ADD, :, case]
[:, case, Token, ., FALSE, :, return, true, ;, case, Token, ., ADD, :, case, Token, ., BITAND, :, case]
[:, case, Token, ., FALSE, :, return, true, ;, case, Token, ., ADD, :, case, Token, ., BITAND, :, case]
[:, return, true, ;, case, Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case]
[:, return, true, ;, case, Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case]
[Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case]
[Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case]
[Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., DIV, :, case]
[Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., DIV, :, case]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case]
[Token, ., BITXOR, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case]
[Token, ., BITXOR, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case]
[Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case]
[Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case]
[Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LSH, :, case]
[Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LSH, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case]
[Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case]
[Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case]
[Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case]
[Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case]
[Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case]
[Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case]
[Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., RSH, :, case]
[Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., RSH, :, case]
[Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case]
[Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case]
[Token, ., NE, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case]
[Token, ., NE, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case]
[Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case]
[Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case]
[Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., URSH, :, return]
[Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., URSH, :, return]
[SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., URSH, :, return, isValidDefineValue, (]
[SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., URSH, :, return, isValidDefineValue, (]
[:, case, Token, ., SUB, :, case, Token, ., URSH, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,]
[., SUB, :, case, Token, ., URSH, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), &&]
[:, case, Token, ., URSH, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), &&, isValidDefineValue, (]
[:, case, Token, ., URSH, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), &&, isValidDefineValue, (]
[return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), &&, isValidDefineValue, (, val, ., getLastChild, (, ), ,]
[., getFirstChild, (, ), ,, defines, ), &&, isValidDefineValue, (, val, ., getLastChild, (, ), ,, defines, ), ;, case]
[., getFirstChild, (, ), ,, defines, ), &&, isValidDefineValue, (, val, ., getLastChild, (, ), ,, defines, ), ;, case]
[defines, ), &&, isValidDefineValue, (, val, ., getLastChild, (, ), ,, defines, ), ;, case, Token, ., NOT, :, case]
[defines, ), &&, isValidDefineValue, (, val, ., getLastChild, (, ), ,, defines, ), ;, case, Token, ., NOT, :, case]
[val, ., getLastChild, (, ), ,, defines, ), ;, case, Token, ., NOT, :, case, Token, ., NEG, :, case]
[val, ., getLastChild, (, ), ,, defines, ), ;, case, Token, ., NOT, :, case, Token, ., NEG, :, case]
[,, defines, ), ;, case, Token, ., NOT, :, case, Token, ., NEG, :, case, Token, ., POS, :, return]
[), ;, case, Token, ., NOT, :, case, Token, ., NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (]
[), ;, case, Token, ., NOT, :, case, Token, ., NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (]
[:, case, Token, ., NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,]
[NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), ;, case]
[NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), ;, case]
[POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), ;, case, Token, ., NAME, :, case]
[POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), ;, case, Token, ., NAME, :, case]
[., getFirstChild, (, ), ,, defines, ), ;, case, Token, ., NAME, :, case, Token, ., GETPROP, :, if, (]
[., getFirstChild, (, ), ,, defines, ), ;, case, Token, ., NAME, :, case, Token, ., GETPROP, :, if, (]
[case, Token, ., NAME, :, case, Token, ., GETPROP, :, if, (, val, ., isQualifiedName, (, ), ), {, return]
[case, Token, ., NAME, :, case, Token, ., GETPROP, :, if, (, val, ., isQualifiedName, (, ), ), {, return]
[:, case, Token, ., GETPROP, :, if, (, val, ., isQualifiedName, (, ), ), {, return, defines, ., contains, (]
[:, case, Token, ., GETPROP, :, if, (, val, ., isQualifiedName, (, ), ), {, return, defines, ., contains, (]
[isQualifiedName, (, ), ), {, return, defines, ., contains, (, val, ., getQualifiedName, (, ), ), ;, }, }, return]
[(, ), ), ;, }, }, return, false, ;, }, static, boolean, isEmptyBlock, (, Node, block, ), {, if, (]
[), ), ;, }, }, return, false, ;, }, static, boolean, isEmptyBlock, (, Node, block, ), {, if, (, !]
[), ), ;, }, }, return, false, ;, }, static, boolean, isEmptyBlock, (, Node, block, ), {, if, (, !]
[}, static, boolean, isEmptyBlock, (, Node, block, ), {, if, (, !, block, ., isBlock, (, ), ), {, return]
[{, if, (, !, block, ., isBlock, (, ), ), {, return, false, ;, }, for, (, Node, n, =]
[{, if, (, !, block, ., isBlock, (, ), ), {, return, false, ;, }, for, (, Node, n, =]
[isBlock, (, ), ), {, return, false, ;, }, for, (, Node, n, =, block, ., getFirstChild, (, ), ;]
[isBlock, (, ), ), {, return, false, ;, }, for, (, Node, n, =, block, ., getFirstChild, (, ), ;]
[), ), {, return, false, ;, }, for, (, Node, n, =, block, ., getFirstChild, (, ), ;, n, !=]
[{, return, false, ;, }, for, (, Node, n, =, block, ., getFirstChild, (, ), ;, n, !=, null, ;]
[false, ;, }, for, (, Node, n, =, block, ., getFirstChild, (, ), ;, n, !=, null, ;, n, =]
[false, ;, }, for, (, Node, n, =, block, ., getFirstChild, (, ), ;, n, !=, null, ;, n, =]
[., getFirstChild, (, ), ;, n, !=, null, ;, n, =, n, ., getNext, (, ), ), {, if, (]
[getFirstChild, (, ), ;, n, !=, null, ;, n, =, n, ., getNext, (, ), ), {, if, (, !]
[getFirstChild, (, ), ;, n, !=, null, ;, n, =, n, ., getNext, (, ), ), {, if, (, !]
[n, =, n, ., getNext, (, ), ), {, if, (, !, n, ., isEmpty, (, ), ), {, return]
[(, ), ), {, if, (, !, n, ., isEmpty, (, ), ), {, return, false, ;, }, }, return]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isSimpleOperator, (, Node, n, ), {, return]
[return, false, ;, }, }, return, true, ;, }, static, boolean, isSimpleOperator, (, Node, n, ), {, return, isSimpleOperatorType, (]
[return, false, ;, }, }, return, true, ;, }, static, boolean, isSimpleOperator, (, Node, n, ), {, return, isSimpleOperatorType, (]
[isSimpleOperatorType, (, n, ., getType, (, ), ), ;, }, static, boolean, isSimpleOperatorType, (, int, type, ), {, switch, (]
[getType, (, ), ), ;, }, static, boolean, isSimpleOperatorType, (, int, type, ), {, switch, (, type, ), {, case]
[getType, (, ), ), ;, }, static, boolean, isSimpleOperatorType, (, int, type, ), {, switch, (, type, ), {, case]
[}, static, boolean, isSimpleOperatorType, (, int, type, ), {, switch, (, type, ), {, case, Token, ., ADD, :, case]
[}, static, boolean, isSimpleOperatorType, (, int, type, ), {, switch, (, type, ), {, case, Token, ., ADD, :, case]
[int, type, ), {, switch, (, type, ), {, case, Token, ., ADD, :, case, Token, ., BITAND, :, case]
[int, type, ), {, switch, (, type, ), {, case, Token, ., ADD, :, case, Token, ., BITAND, :, case]
[(, type, ), {, case, Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case]
[(, type, ), {, case, Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case]
[Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case]
[Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case]
[Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., COMMA, :, case]
[Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., COMMA, :, case]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., COMMA, :, case, Token, ., DIV, :, case]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., COMMA, :, case, Token, ., DIV, :, case]
[Token, ., BITXOR, :, case, Token, ., COMMA, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case]
[Token, ., BITXOR, :, case, Token, ., COMMA, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case]
[Token, ., COMMA, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case]
[Token, ., COMMA, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case]
[Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GETELEM, :, case]
[Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GETELEM, :, case]
[Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case]
[Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case]
[Token, ., GE, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., GT, :, case]
[Token, ., GE, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., GT, :, case]
[Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., GT, :, case, Token, ., INSTANCEOF, :, case]
[Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., GT, :, case, Token, ., INSTANCEOF, :, case]
[Token, ., GETPROP, :, case, Token, ., GT, :, case, Token, ., INSTANCEOF, :, case, Token, ., LE, :, case]
[Token, ., GETPROP, :, case, Token, ., GT, :, case, Token, ., INSTANCEOF, :, case, Token, ., LE, :, case]
[Token, ., GT, :, case, Token, ., INSTANCEOF, :, case, Token, ., LE, :, case, Token, ., LSH, :, case]
[Token, ., GT, :, case, Token, ., INSTANCEOF, :, case, Token, ., LE, :, case, Token, ., LSH, :, case]
[Token, ., INSTANCEOF, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case]
[Token, ., INSTANCEOF, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case]
[Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case]
[Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case]
[Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case]
[Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case]
[Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case]
[Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case]
[Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., NOT, :, case]
[Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., NOT, :, case]
[Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., NOT, :, case, Token, ., RSH, :, case]
[Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., NOT, :, case, Token, ., RSH, :, case]
[Token, ., NE, :, case, Token, ., NOT, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case]
[Token, ., NE, :, case, Token, ., NOT, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case]
[Token, ., NOT, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case]
[Token, ., NOT, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case]
[Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case]
[Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case]
[Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., TYPEOF, :, case]
[Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., TYPEOF, :, case]
[Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case]
[Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case]
[Token, ., SUB, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., POS, :, case]
[Token, ., SUB, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., POS, :, case]
[Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., POS, :, case, Token, ., NEG, :, case]
[Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., POS, :, case, Token, ., NEG, :, case]
[Token, ., VOID, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., URSH, :, return]
[Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., URSH, :, return, true, ;, default, :, return]
[:, return, true, ;, default, :, return, false, ;, }, }, static, Node, newExpr, (, Node, child, ), {, return]
[:, return, true, ;, default, :, return, false, ;, }, }, static, Node, newExpr, (, Node, child, ), {, return]
[:, return, true, ;, default, :, return, false, ;, }, }, static, Node, newExpr, (, Node, child, ), {, return]
[default, :, return, false, ;, }, }, static, Node, newExpr, (, Node, child, ), {, return, IR, ., exprResult, (]
[}, }, static, Node, newExpr, (, Node, child, ), {, return, IR, ., exprResult, (, child, ), ., srcref, (]
[exprResult, (, child, ), ., srcref, (, child, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ), {, return]
[child, ), ., srcref, (, child, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ), {, return, mayEffectMutableState, (]
[., srcref, (, child, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ), {, return, mayEffectMutableState, (, n, ,]
[mayEffectMutableState, (, n, ,, null, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ,, AbstractCompiler, compiler, ), {, return]
[n, ,, null, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (]
[null, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n, ,]
[;, }, static, boolean, mayEffectMutableState, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n, ,, true, ,]
[return, checkForStateChangeHelper, (, n, ,, true, ,, compiler, ), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ), {, return]
[(, n, ,, true, ,, compiler, ), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ), {, return, mayHaveSideEffects, (]
[,, true, ,, compiler, ), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ), {, return, mayHaveSideEffects, (, n, ,]
[mayHaveSideEffects, (, n, ,, null, ), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, return]
[n, ,, null, ), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (]
[null, ), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n, ,]
[;, }, static, boolean, mayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n, ,, false, ,]
[), ;, }, private, static, boolean, checkForStateChangeHelper, (, Node, n, ,, boolean, checkForNewObjects, ,, AbstractCompiler, compiler, ), {, switch, (]
[), ;, }, private, static, boolean, checkForStateChangeHelper, (, Node, n, ,, boolean, checkForNewObjects, ,, AbstractCompiler, compiler, ), {, switch, (]
[Node, n, ,, boolean, checkForNewObjects, ,, AbstractCompiler, compiler, ), {, switch, (, n, ., getType, (, ), ), {, case]
[Node, n, ,, boolean, checkForNewObjects, ,, AbstractCompiler, compiler, ), {, switch, (, n, ., getType, (, ), ), {, case]
[,, AbstractCompiler, compiler, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, case]
[,, AbstractCompiler, compiler, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, case, Token, ., AND, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, case, Token, ., AND, :, case]
[(, ), ), {, case, Token, ., CAST, :, case, Token, ., AND, :, case, Token, ., BLOCK, :, case]
[(, ), ), {, case, Token, ., CAST, :, case, Token, ., AND, :, case, Token, ., BLOCK, :, case]
[Token, ., CAST, :, case, Token, ., AND, :, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case]
[Token, ., CAST, :, case, Token, ., AND, :, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case]
[Token, ., AND, :, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case]
[Token, ., AND, :, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case]
[Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case]
[Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case]
[Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., IN, :, case]
[Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., IN, :, case]
[Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., IN, :, case, Token, ., PARAM_LIST, :, case]
[Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., IN, :, case, Token, ., PARAM_LIST, :, case]
[Token, ., IF, :, case, Token, ., IN, :, case, Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case]
[Token, ., IF, :, case, Token, ., IN, :, case, Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case]
[Token, ., IN, :, case, Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case, Token, ., OR, :, case]
[Token, ., IN, :, case, Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case, Token, ., OR, :, case]
[Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case, Token, ., OR, :, case, Token, ., THIS, :, case]
[Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case, Token, ., OR, :, case, Token, ., THIS, :, case]
[Token, ., NUMBER, :, case, Token, ., OR, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, case]
[Token, ., NUMBER, :, case, Token, ., OR, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, case]
[Token, ., OR, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case]
[Token, ., OR, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case]
[Token, ., THIS, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., NULL, :, case]
[Token, ., THIS, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., NULL, :, case]
[Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., NULL, :, case, Token, ., STRING, :, case]
[Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., NULL, :, case, Token, ., STRING, :, case]
[Token, ., FALSE, :, case, Token, ., NULL, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case]
[Token, ., FALSE, :, case, Token, ., NULL, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case]
[Token, ., NULL, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., SWITCH, :, case]
[Token, ., NULL, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., SWITCH, :, case]
[Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., SWITCH, :, case, Token, ., TRY, :, case]
[Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., SWITCH, :, case, Token, ., TRY, :, case]
[STRING_KEY, :, case, Token, ., SWITCH, :, case, Token, ., TRY, :, case, Token, ., EMPTY, :, break, ;, case]
[STRING_KEY, :, case, Token, ., SWITCH, :, case, Token, ., TRY, :, case, Token, ., EMPTY, :, break, ;, case]
[SWITCH, :, case, Token, ., TRY, :, case, Token, ., EMPTY, :, break, ;, case, Token, ., THROW, :, return]
[Token, ., TRY, :, case, Token, ., EMPTY, :, break, ;, case, Token, ., THROW, :, return, true, ;, case]
[Token, ., TRY, :, case, Token, ., EMPTY, :, break, ;, case, Token, ., THROW, :, return, true, ;, case]
[., EMPTY, :, break, ;, case, Token, ., THROW, :, return, true, ;, case, Token, ., OBJECTLIT, :, if, (]
[;, case, Token, ., THROW, :, return, true, ;, case, Token, ., OBJECTLIT, :, if, (, checkForNewObjects, ), {, return]
[;, case, Token, ., OBJECTLIT, :, if, (, checkForNewObjects, ), {, return, true, ;, }, for, (, Node, c, =]
[;, case, Token, ., OBJECTLIT, :, if, (, checkForNewObjects, ), {, return, true, ;, }, for, (, Node, c, =]
[if, (, checkForNewObjects, ), {, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[if, (, checkForNewObjects, ), {, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[checkForNewObjects, ), {, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[{, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;]
[true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[(, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (]
[(, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ., getFirstChild, (, ), ,]
[=, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ., getFirstChild, (, ), ,, checkForNewObjects, ,]
[), ), {, if, (, checkForStateChangeHelper, (, c, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return]
[checkForStateChangeHelper, (, c, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return]
[., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return, false, ;, case]
[., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return, false, ;, case]
[checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return, false, ;, case, Token, ., ARRAYLIT, :, case]
[checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return, false, ;, case, Token, ., ARRAYLIT, :, case]
[return, true, ;, }, }, return, false, ;, case, Token, ., ARRAYLIT, :, case, Token, ., REGEXP, :, if, (]
[}, return, false, ;, case, Token, ., ARRAYLIT, :, case, Token, ., REGEXP, :, if, (, checkForNewObjects, ), {, return]
[., ARRAYLIT, :, case, Token, ., REGEXP, :, if, (, checkForNewObjects, ), {, return, true, ;, }, break, ;, case]
[., ARRAYLIT, :, case, Token, ., REGEXP, :, if, (, checkForNewObjects, ), {, return, true, ;, }, break, ;, case]
[., REGEXP, :, if, (, checkForNewObjects, ), {, return, true, ;, }, break, ;, case, Token, ., VAR, :, case]
[., REGEXP, :, if, (, checkForNewObjects, ), {, return, true, ;, }, break, ;, case, Token, ., VAR, :, case]
[), {, return, true, ;, }, break, ;, case, Token, ., VAR, :, case, Token, ., NAME, :, if, (]
[), {, return, true, ;, }, break, ;, case, Token, ., VAR, :, case, Token, ., NAME, :, if, (]
[), {, return, true, ;, }, break, ;, case, Token, ., VAR, :, case, Token, ., NAME, :, if, (]
[break, ;, case, Token, ., VAR, :, case, Token, ., NAME, :, if, (, n, ., getFirstChild, (, ), !=]
[., VAR, :, case, Token, ., NAME, :, if, (, n, ., getFirstChild, (, ), !=, null, ), {, return]
[NAME, :, if, (, n, ., getFirstChild, (, ), !=, null, ), {, return, true, ;, }, break, ;, case]
[NAME, :, if, (, n, ., getFirstChild, (, ), !=, null, ), {, return, true, ;, }, break, ;, case]
[., getFirstChild, (, ), !=, null, ), {, return, true, ;, }, break, ;, case, Token, ., FUNCTION, :, return]
[., getFirstChild, (, ), !=, null, ), {, return, true, ;, }, break, ;, case, Token, ., FUNCTION, :, return]
[(, ), !=, null, ), {, return, true, ;, }, break, ;, case, Token, ., FUNCTION, :, return, checkForNewObjects, ||]
[), !=, null, ), {, return, true, ;, }, break, ;, case, Token, ., FUNCTION, :, return, checkForNewObjects, ||, !]
[null, ), {, return, true, ;, }, break, ;, case, Token, ., FUNCTION, :, return, checkForNewObjects, ||, !, isFunctionExpression, (]
[true, ;, }, break, ;, case, Token, ., FUNCTION, :, return, checkForNewObjects, ||, !, isFunctionExpression, (, n, ), ;, case]
[true, ;, }, break, ;, case, Token, ., FUNCTION, :, return, checkForNewObjects, ||, !, isFunctionExpression, (, n, ), ;, case]
[Token, ., FUNCTION, :, return, checkForNewObjects, ||, !, isFunctionExpression, (, n, ), ;, case, Token, ., NEW, :, if, (]
[return, checkForNewObjects, ||, !, isFunctionExpression, (, n, ), ;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {, return]
[(, n, ), ;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {, return, true, ;, }, if, (]
[n, ), ;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {, return, true, ;, }, if, (, !]
[;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {, return, true, ;, }, if, (, !, constructorCallHasSideEffects, (]
[checkForNewObjects, ), {, return, true, ;, }, if, (, !, constructorCallHasSideEffects, (, n, ), ), {, break, ;, }, return]
[return, true, ;, }, if, (, !, constructorCallHasSideEffects, (, n, ), ), {, break, ;, }, return, true, ;, case]
[return, true, ;, }, if, (, !, constructorCallHasSideEffects, (, n, ), ), {, break, ;, }, return, true, ;, case]
[!, constructorCallHasSideEffects, (, n, ), ), {, break, ;, }, return, true, ;, case, Token, ., CALL, :, if, (]
[constructorCallHasSideEffects, (, n, ), ), {, break, ;, }, return, true, ;, case, Token, ., CALL, :, if, (, !]
[n, ), ), {, break, ;, }, return, true, ;, case, Token, ., CALL, :, if, (, !, functionCallHasSideEffects, (]
[), {, break, ;, }, return, true, ;, case, Token, ., CALL, :, if, (, !, functionCallHasSideEffects, (, n, ,]
[case, Token, ., CALL, :, if, (, !, functionCallHasSideEffects, (, n, ,, compiler, ), ), {, break, ;, }, return]
[(, !, functionCallHasSideEffects, (, n, ,, compiler, ), ), {, break, ;, }, return, true, ;, default, :, if, (]
[functionCallHasSideEffects, (, n, ,, compiler, ), ), {, break, ;, }, return, true, ;, default, :, if, (, isSimpleOperator, (]
[;, }, return, true, ;, default, :, if, (, isSimpleOperator, (, n, ), ), {, break, ;, }, if, (]
[return, true, ;, default, :, if, (, isSimpleOperator, (, n, ), ), {, break, ;, }, if, (, isAssignmentOp, (]
[isSimpleOperator, (, n, ), ), {, break, ;, }, if, (, isAssignmentOp, (, n, ), ), {, Node, assignTarget, =]
[isSimpleOperator, (, n, ), ), {, break, ;, }, if, (, isAssignmentOp, (, n, ), ), {, Node, assignTarget, =]
[}, if, (, isAssignmentOp, (, n, ), ), {, Node, assignTarget, =, n, ., getFirstChild, (, ), ;, if, (]
[}, if, (, isAssignmentOp, (, n, ), ), {, Node, assignTarget, =, n, ., getFirstChild, (, ), ;, if, (]
[{, Node, assignTarget, =, n, ., getFirstChild, (, ), ;, if, (, assignTarget, ., isName, (, ), ), {, return]
[., getFirstChild, (, ), ;, if, (, assignTarget, ., isName, (, ), ), {, return, true, ;, }, if, (]
[., getFirstChild, (, ), ;, if, (, assignTarget, ., isName, (, ), ), {, return, true, ;, }, if, (]
[(, ), ;, if, (, assignTarget, ., isName, (, ), ), {, return, true, ;, }, if, (, checkForStateChangeHelper, (]
[(, ), ;, if, (, assignTarget, ., isName, (, ), ), {, return, true, ;, }, if, (, checkForStateChangeHelper, (]
[., isName, (, ), ), {, return, true, ;, }, if, (, checkForStateChangeHelper, (, n, ., getFirstChild, (, ), ,]
[(, ), ), {, return, true, ;, }, if, (, checkForStateChangeHelper, (, n, ., getFirstChild, (, ), ,, checkForNewObjects, ,]
[{, return, true, ;, }, if, (, checkForStateChangeHelper, (, n, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ||]
[true, ;, }, if, (, checkForStateChangeHelper, (, n, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ||, checkForStateChangeHelper, (]
[true, ;, }, if, (, checkForStateChangeHelper, (, n, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ||, checkForStateChangeHelper, (]
[(, n, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ||, checkForStateChangeHelper, (, n, ., getLastChild, (, ), ,]
[., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ||, checkForStateChangeHelper, (, n, ., getLastChild, (, ), ,, checkForNewObjects, ,]
[checkForNewObjects, ,, compiler, ), ||, checkForStateChangeHelper, (, n, ., getLastChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return]
[checkForStateChangeHelper, (, n, ., getLastChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, if, (]
[n, ., getLastChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, if, (, isGet, (]
[,, compiler, ), ), {, return, true, ;, }, if, (, isGet, (, assignTarget, ), ), {, Node, current, =]
[,, compiler, ), ), {, return, true, ;, }, if, (, isGet, (, assignTarget, ), ), {, Node, current, =]
[}, if, (, isGet, (, assignTarget, ), ), {, Node, current, =, assignTarget, ., getFirstChild, (, ), ;, if, (]
[(, isGet, (, assignTarget, ), ), {, Node, current, =, assignTarget, ., getFirstChild, (, ), ;, if, (, evaluatesToLocalValue, (]
[), {, Node, current, =, assignTarget, ., getFirstChild, (, ), ;, if, (, evaluatesToLocalValue, (, current, ), ), {, return]
[assignTarget, ., getFirstChild, (, ), ;, if, (, evaluatesToLocalValue, (, current, ), ), {, return, false, ;, }, while, (]
[getFirstChild, (, ), ;, if, (, evaluatesToLocalValue, (, current, ), ), {, return, false, ;, }, while, (, isGet, (]
[if, (, evaluatesToLocalValue, (, current, ), ), {, return, false, ;, }, while, (, isGet, (, current, ), ), {]
[evaluatesToLocalValue, (, current, ), ), {, return, false, ;, }, while, (, isGet, (, current, ), ), {, current, =]
[evaluatesToLocalValue, (, current, ), ), {, return, false, ;, }, while, (, isGet, (, current, ), ), {, current, =]
[;, }, while, (, isGet, (, current, ), ), {, current, =, current, ., getFirstChild, (, ), ;, }, return]
[}, while, (, isGet, (, current, ), ), {, current, =, current, ., getFirstChild, (, ), ;, }, return, !]
[(, isGet, (, current, ), ), {, current, =, current, ., getFirstChild, (, ), ;, }, return, !, isLiteralValue, (]
[(, current, ), ), {, current, =, current, ., getFirstChild, (, ), ;, }, return, !, isLiteralValue, (, current, ,]
[current, ., getFirstChild, (, ), ;, }, return, !, isLiteralValue, (, current, ,, true, ), ;, }, else, {, return]
[., getFirstChild, (, ), ;, }, return, !, isLiteralValue, (, current, ,, true, ), ;, }, else, {, return, !]
[(, ), ;, }, return, !, isLiteralValue, (, current, ,, true, ), ;, }, else, {, return, !, isLiteralValue, (]
[;, }, return, !, isLiteralValue, (, current, ,, true, ), ;, }, else, {, return, !, isLiteralValue, (, assignTarget, ,]
[current, ,, true, ), ;, }, else, {, return, !, isLiteralValue, (, assignTarget, ,, true, ), ;, }, }, return]
[return, !, isLiteralValue, (, assignTarget, ,, true, ), ;, }, }, return, true, ;, }, for, (, Node, c, =]
[return, !, isLiteralValue, (, assignTarget, ,, true, ), ;, }, }, return, true, ;, }, for, (, Node, c, =]
[true, ), ;, }, }, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[true, ), ;, }, }, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[;, }, }, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[}, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;]
[true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[(, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ,]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ,, checkForNewObjects, ,]
[c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ,, checkForNewObjects, ,, compiler, ), ), {, return]
[), {, if, (, checkForStateChangeHelper, (, c, ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return]
[), {, return, true, ;, }, }, return, false, ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ), {, return]
[return, true, ;, }, }, return, false, ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ), {, return, constructorCallHasSideEffects, (]
[;, }, }, return, false, ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ), {, return, constructorCallHasSideEffects, (, callNode, ,]
[(, callNode, ,, null, ), ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ,, AbstractCompiler, compiler, ), {, if, (]
[callNode, ,, null, ), ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ,, AbstractCompiler, compiler, ), {, if, (, !]
[callNode, ,, null, ), ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ,, AbstractCompiler, compiler, ), {, if, (, !]
[constructorCallHasSideEffects, (, Node, callNode, ,, AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isNew, (, ), ), {, throw]
[callNode, ,, AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isNew, (, ), ), {, throw, new, IllegalStateException, (]
[callNode, ,, AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isNew, (, ), ), {, throw, new, IllegalStateException, (]
[AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isNew, (, ), ), {, throw, new, IllegalStateException, (, "Expected NEW node, got ", +]
[AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isNew, (, ), ), {, throw, new, IllegalStateException, (, "Expected NEW node, got ", +]
[if, (, !, callNode, ., isNew, (, ), ), {, throw, new, IllegalStateException, (, "Expected NEW node, got ", +, Token, ., name, (]
[if, (, !, callNode, ., isNew, (, ), ), {, throw, new, IllegalStateException, (, "Expected NEW node, got ", +, Token, ., name, (]
[new, IllegalStateException, (, "Expected NEW node, got ", +, Token, ., name, (, callNode, ., getType, (, ), ), ), ;, }, if, (]
[new, IllegalStateException, (, "Expected NEW node, got ", +, Token, ., name, (, callNode, ., getType, (, ), ), ), ;, }, if, (]
[(, callNode, ., getType, (, ), ), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return]
[), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =]
[), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =]
[isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (]
[isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (]
[isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (]
[false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&]
[false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&]
[nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, ., contains, (]
[nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, ., contains, (]
[(, nameNode, ., isName, (, ), &&, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, ., contains, (, nameNode, ., getString, (, ), ), ), {, return]
[(, ), &&, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, ., contains, (, nameNode, ., getString, (, ), ), ), {, return, false, ;, }, return]
[), ), {, return, false, ;, }, return, true, ;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =]
[), ), {, return, false, ;, }, return, true, ;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =]
[false, ;, }, return, true, ;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (]
[}, return, true, ;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "Object", ,]
[true, ;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "Object", ,, "Array", ,]
[}, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "Object", ,, "Array", ,, "String", ,]
[static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "Object", ,, "Array", ,, "String", ,, "Number", ,]
[Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "Object", ,, "Array", ,, "String", ,, "Number", ,, "Boolean", ,]
[String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "Object", ,, "Array", ,, "String", ,, "Number", ,, "Boolean", ,, "RegExp", ,]
["String", ,, "Number", ,, "Boolean", ,, "RegExp", ,, "Error", ), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =]
["String", ,, "Number", ,, "Boolean", ,, "RegExp", ,, "Error", ), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =]
["Boolean", ,, "RegExp", ,, "Error", ), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (]
["RegExp", ,, "Error", ), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "toString", ,]
[OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "toString", ,, "valueOf", ), ;, private, static, final, Set, <, String, >, REGEXP_METHODS, =]
[OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "toString", ,, "valueOf", ), ;, private, static, final, Set, <, String, >, REGEXP_METHODS, =]
[of, (, "toString", ,, "valueOf", ), ;, private, static, final, Set, <, String, >, REGEXP_METHODS, =, ImmutableSet, ., of, (]
["toString", ,, "valueOf", ), ;, private, static, final, Set, <, String, >, REGEXP_METHODS, =, ImmutableSet, ., of, (, "test", ,]
[REGEXP_METHODS, =, ImmutableSet, ., of, (, "test", ,, "exec", ), ;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =]
[REGEXP_METHODS, =, ImmutableSet, ., of, (, "test", ,, "exec", ), ;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =]
[of, (, "test", ,, "exec", ), ;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =, ImmutableSet, ., of, (]
["test", ,, "exec", ), ;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =, ImmutableSet, ., of, (, "match", ,]
["exec", ), ;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =, ImmutableSet, ., of, (, "match", ,, "replace", ,]
[;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =, ImmutableSet, ., of, (, "match", ,, "replace", ,, "search", ,]
[of, (, "match", ,, "replace", ,, "search", ,, "split", ), ;, static, boolean, functionCallHasSideEffects, (, Node, callNode, ), {, return]
["match", ,, "replace", ,, "search", ,, "split", ), ;, static, boolean, functionCallHasSideEffects, (, Node, callNode, ), {, return, functionCallHasSideEffects, (]
["replace", ,, "search", ,, "split", ), ;, static, boolean, functionCallHasSideEffects, (, Node, callNode, ), {, return, functionCallHasSideEffects, (, callNode, ,]
[,, null, ), ;, }, static, boolean, functionCallHasSideEffects, (, Node, callNode, ,, @, Nullable, AbstractCompiler, compiler, ), {, if, (]
[null, ), ;, }, static, boolean, functionCallHasSideEffects, (, Node, callNode, ,, @, Nullable, AbstractCompiler, compiler, ), {, if, (, !]
[null, ), ;, }, static, boolean, functionCallHasSideEffects, (, Node, callNode, ,, @, Nullable, AbstractCompiler, compiler, ), {, if, (, !]
[Node, callNode, ,, @, Nullable, AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isCall, (, ), ), {, throw]
[@, Nullable, AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isCall, (, ), ), {, throw, new, IllegalStateException, (]
[@, Nullable, AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isCall, (, ), ), {, throw, new, IllegalStateException, (]
[AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isCall, (, ), ), {, throw, new, IllegalStateException, (, "Expected CALL node, got ", +]
[AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isCall, (, ), ), {, throw, new, IllegalStateException, (, "Expected CALL node, got ", +]
[if, (, !, callNode, ., isCall, (, ), ), {, throw, new, IllegalStateException, (, "Expected CALL node, got ", +, Token, ., name, (]
[if, (, !, callNode, ., isCall, (, ), ), {, throw, new, IllegalStateException, (, "Expected CALL node, got ", +, Token, ., name, (]
[new, IllegalStateException, (, "Expected CALL node, got ", +, Token, ., name, (, callNode, ., getType, (, ), ), ), ;, }, if, (]
[new, IllegalStateException, (, "Expected CALL node, got ", +, Token, ., name, (, callNode, ., getType, (, ), ), ), ;, }, if, (]
[(, callNode, ., getType, (, ), ), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return]
[), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =]
[), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =]
[isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (]
[isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (]
[nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), ), {, String, name, =]
[nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), ), {, String, name, =]
[if, (, nameNode, ., isName, (, ), ), {, String, name, =, nameNode, ., getString, (, ), ;, if, (]
[if, (, nameNode, ., isName, (, ), ), {, String, name, =, nameNode, ., getString, (, ), ;, if, (]
[isName, (, ), ), {, String, name, =, nameNode, ., getString, (, ), ;, if, (, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, ., contains, (]
[String, name, =, nameNode, ., getString, (, ), ;, if, (, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, ., contains, (, name, ), ), {, return]
[), ;, if, (, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, ., contains, (, name, ), ), {, return, false, ;, }, }, else, if, (]
[), ;, if, (, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, ., contains, (, name, ), ), {, return, false, ;, }, }, else, if, (]
[), ), {, return, false, ;, }, }, else, if, (, nameNode, ., isGetProp, (, ), ), {, if, (]
[), ), {, return, false, ;, }, }, else, if, (, nameNode, ., isGetProp, (, ), ), {, if, (]
[), ), {, return, false, ;, }, }, else, if, (, nameNode, ., isGetProp, (, ), ), {, if, (]
[}, }, else, if, (, nameNode, ., isGetProp, (, ), ), {, if, (, callNode, ., hasOneChild, (, ), &&]
[}, }, else, if, (, nameNode, ., isGetProp, (, ), ), {, if, (, callNode, ., hasOneChild, (, ), &&]
[(, nameNode, ., isGetProp, (, ), ), {, if, (, callNode, ., hasOneChild, (, ), &&, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, ., contains, (]
[(, nameNode, ., isGetProp, (, ), ), {, if, (, callNode, ., hasOneChild, (, ), &&, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, ., contains, (]
[(, nameNode, ., isGetProp, (, ), ), {, if, (, callNode, ., hasOneChild, (, ), &&, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, ., contains, (]
[(, ), &&, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return]
[contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, if, (]
[contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, if, (]
[contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, if, (]
[), ., getString, (, ), ), ), {, return, false, ;, }, if, (, callNode, ., isOnlyModifiesThisCall, (, ), &&]
[getString, (, ), ), ), {, return, false, ;, }, if, (, callNode, ., isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (]
[getString, (, ), ), ), {, return, false, ;, }, if, (, callNode, ., isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (]
[}, if, (, callNode, ., isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (, nameNode, ., getFirstChild, (, ), ), ), {, return]
[isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (, nameNode, ., getFirstChild, (, ), ), ), {, return, false, ;, }, if, (]
[isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (, nameNode, ., getFirstChild, (, ), ), ), {, return, false, ;, }, if, (]
[isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (, nameNode, ., getFirstChild, (, ), ), ), {, return, false, ;, }, if, (]
[{, return, false, ;, }, if, (, nameNode, ., getFirstChild, (, ), ., isName, (, ), ), {, if, (]
[{, return, false, ;, }, if, (, nameNode, ., getFirstChild, (, ), ., isName, (, ), ), {, if, (]
[}, if, (, nameNode, ., getFirstChild, (, ), ., isName, (, ), ), {, if, (, "Math.floor", ., equals, (]
[}, if, (, nameNode, ., getFirstChild, (, ), ., isName, (, ), ), {, if, (, "Math.floor", ., equals, (]
[isName, (, ), ), {, if, (, "Math.floor", ., equals, (, nameNode, ., getQualifiedName, (, ), ), ), {, return]
[(, "Math.floor", ., equals, (, nameNode, ., getQualifiedName, (, ), ), ), {, return, false, ;, }, }, if, (]
[(, "Math.floor", ., equals, (, nameNode, ., getQualifiedName, (, ), ), ), {, return, false, ;, }, }, if, (]
[(, "Math.floor", ., equals, (, nameNode, ., getQualifiedName, (, ), ), ), {, return, false, ;, }, }, if, (]
[., equals, (, nameNode, ., getQualifiedName, (, ), ), ), {, return, false, ;, }, }, if, (, compiler, !=]
[(, nameNode, ., getQualifiedName, (, ), ), ), {, return, false, ;, }, }, if, (, compiler, !=, null, &&]
[nameNode, ., getQualifiedName, (, ), ), ), {, return, false, ;, }, }, if, (, compiler, !=, null, &&, !]
[nameNode, ., getQualifiedName, (, ), ), ), {, return, false, ;, }, }, if, (, compiler, !=, null, &&, !]
[false, ;, }, }, if, (, compiler, !=, null, &&, !, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (]
[false, ;, }, }, if, (, compiler, !=, null, &&, !, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (]
[false, ;, }, }, if, (, compiler, !=, null, &&, !, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (]
[false, ;, }, }, if, (, compiler, !=, null, &&, !, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (]
[!, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, ), &&]
[!, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, ), &&]
[(, ), ), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, ), &&, REGEXP_METHODS, ., contains, (]
[(, ), ), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, ), &&, REGEXP_METHODS, ., contains, (]
[(, ), ), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, ), &&, REGEXP_METHODS, ., contains, (]
[(, ), &&, REGEXP_METHODS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return]
[(, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, else, if, (]
[(, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, else, if, (]
[(, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, else, if, (]
[(, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, else, if, (]
[), ), {, return, false, ;, }, else, if, (, nameNode, ., getFirstChild, (, ), ., isString, (, ), &&]
[), ), {, return, false, ;, }, else, if, (, nameNode, ., getFirstChild, (, ), ., isString, (, ), &&]
[false, ;, }, else, if, (, nameNode, ., getFirstChild, (, ), ., isString, (, ), &&, STRING_REGEXP_METHODS, ., contains, (]
[false, ;, }, else, if, (, nameNode, ., getFirstChild, (, ), ., isString, (, ), &&, STRING_REGEXP_METHODS, ., contains, (]
[false, ;, }, else, if, (, nameNode, ., getFirstChild, (, ), ., isString, (, ), &&, STRING_REGEXP_METHODS, ., contains, (]
[&&, STRING_REGEXP_METHODS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, Node, param, =]
[&&, STRING_REGEXP_METHODS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, Node, param, =]
[(, ), ., getString, (, ), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (]
[(, ), ., getString, (, ), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (]
[(, ), ., getString, (, ), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (]
[., getString, (, ), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (, param, !=]
[(, ), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (, param, !=, null, &&]
[), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (, param, !=, null, &&, (]
[), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (, param, !=, null, &&, (]
[), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (, param, !=, null, &&, (]
[=, nameNode, ., getNext, (, ), ;, if, (, param, !=, null, &&, (, param, ., isString, (, ), ||]
[=, nameNode, ., getNext, (, ), ;, if, (, param, !=, null, &&, (, param, ., isString, (, ), ||]
[param, !=, null, &&, (, param, ., isString, (, ), ||, param, ., isRegExp, (, ), ), ), {, return]
[isString, (, ), ||, param, ., isRegExp, (, ), ), ), {, return, false, ;, }, }, }, }, return]
[{, return, false, ;, }, }, }, }, return, true, ;, }, static, boolean, callHasLocalResult, (, Node, n, ), {]
[{, return, false, ;, }, }, }, }, return, true, ;, }, static, boolean, callHasLocalResult, (, Node, n, ), {]
[}, }, }, }, return, true, ;, }, static, boolean, callHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (]
[}, }, }, }, return, true, ;, }, static, boolean, callHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (]
[static, boolean, callHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, return]
[static, boolean, callHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, return]
[boolean, callHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, return, (]
[boolean, callHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, return, (]
[boolean, callHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, return, (]
[{, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, return, (, n, ., getSideEffectFlags, (, ), &]
[{, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, return, (, n, ., getSideEffectFlags, (, ), &]
[n, ., isCall, (, ), ), ;, return, (, n, ., getSideEffectFlags, (, ), &, Node, ., FLAG_LOCAL_RESULTS, ), >]
[getSideEffectFlags, (, ), &, Node, ., FLAG_LOCAL_RESULTS, ), >, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, ), {]
[getSideEffectFlags, (, ), &, Node, ., FLAG_LOCAL_RESULTS, ), >, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, ), {]
[Node, ., FLAG_LOCAL_RESULTS, ), >, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (]
[Node, ., FLAG_LOCAL_RESULTS, ), >, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (]
[static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew, (, ), ), ;, return]
[static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew, (, ), ), ;, return]
[), ), ;, return, n, ., isOnlyModifiesThisCall, (, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ), {, return]
[;, return, n, ., isOnlyModifiesThisCall, (, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ), {, return, nodeTypeMayHaveSideEffects, (]
[n, ., isOnlyModifiesThisCall, (, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ), {, return, nodeTypeMayHaveSideEffects, (, n, ,]
[(, n, ,, null, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, if, (]
[,, null, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, if, (, isAssignmentOp, (]
[static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, if, (, isAssignmentOp, (, n, ), ), {, return]
[n, ,, AbstractCompiler, compiler, ), {, if, (, isAssignmentOp, (, n, ), ), {, return, true, ;, }, switch, (]
[n, ,, AbstractCompiler, compiler, ), {, if, (, isAssignmentOp, (, n, ), ), {, return, true, ;, }, switch, (]
[isAssignmentOp, (, n, ), ), {, return, true, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[isAssignmentOp, (, n, ), ), {, return, true, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[{, return, true, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., DELPROP, :, case]
[{, return, true, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., DELPROP, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., DELPROP, :, case, Token, ., DEC, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., DELPROP, :, case, Token, ., DEC, :, case]
[(, ), ), {, case, Token, ., DELPROP, :, case, Token, ., DEC, :, case, Token, ., INC, :, case]
[(, ), ), {, case, Token, ., DELPROP, :, case, Token, ., DEC, :, case, Token, ., INC, :, case]
[Token, ., DELPROP, :, case, Token, ., DEC, :, case, Token, ., INC, :, case, Token, ., THROW, :, return]
[:, case, Token, ., DEC, :, case, Token, ., INC, :, case, Token, ., THROW, :, return, true, ;, case]
[:, case, Token, ., DEC, :, case, Token, ., INC, :, case, Token, ., THROW, :, return, true, ;, case]
[:, case, Token, ., INC, :, case, Token, ., THROW, :, return, true, ;, case, Token, ., CALL, :, return]
[:, case, Token, ., INC, :, case, Token, ., THROW, :, return, true, ;, case, Token, ., CALL, :, return]
[INC, :, case, Token, ., THROW, :, return, true, ;, case, Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (]
[case, Token, ., THROW, :, return, true, ;, case, Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,]
[:, return, true, ;, case, Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case]
[:, return, true, ;, case, Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case]
[Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NEW, :, return]
[Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NEW, :, return]
[return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (]
[., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,]
[,, compiler, ), ;, case, Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case]
[,, compiler, ), ;, case, Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case]
[Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NAME, :, return]
[Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NAME, :, return]
[n, ,, compiler, ), ;, case, Token, ., NAME, :, return, n, ., hasChildren, (, ), ;, default, :, return]
[:, return, false, ;, }, }, static, boolean, canBeSideEffected, (, Node, n, ), {, Set, <, String, >, emptySet, =]
[:, return, false, ;, }, }, static, boolean, canBeSideEffected, (, Node, n, ), {, Set, <, String, >, emptySet, =]
[boolean, canBeSideEffected, (, Node, n, ), {, Set, <, String, >, emptySet, =, Collections, ., emptySet, (, ), ;, return]
[(, Node, n, ), {, Set, <, String, >, emptySet, =, Collections, ., emptySet, (, ), ;, return, canBeSideEffected, (]
[n, ), {, Set, <, String, >, emptySet, =, Collections, ., emptySet, (, ), ;, return, canBeSideEffected, (, n, ,]
[emptySet, ), ;, }, static, boolean, canBeSideEffected, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, switch, (]
[emptySet, ), ;, }, static, boolean, canBeSideEffected, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, switch, (]
[Node, n, ,, Set, <, String, >, knownConstants, ), {, switch, (, n, ., getType, (, ), ), {, case]
[Node, n, ,, Set, <, String, >, knownConstants, ), {, switch, (, n, ., getType, (, ), ), {, case]
[String, >, knownConstants, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, case]
[String, >, knownConstants, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, case, Token, ., NEW, :, return]
[., getType, (, ), ), {, case, Token, ., CALL, :, case, Token, ., NEW, :, return, true, ;, case]
[., getType, (, ), ), {, case, Token, ., CALL, :, case, Token, ., NEW, :, return, true, ;, case]
[{, case, Token, ., CALL, :, case, Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :, return]
[{, case, Token, ., CALL, :, case, Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :, return]
[case, Token, ., CALL, :, case, Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :, return, !]
[., CALL, :, case, Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (]
[case, Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (, n, ), &&]
[Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (, n, ), &&, !]
[Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (, n, ), &&, !]
[return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (, n, ), &&, !, knownConstants, ., contains, (]
[return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (, n, ), &&, !, knownConstants, ., contains, (]
[return, !, isConstantName, (, n, ), &&, !, knownConstants, ., contains, (, n, ., getString, (, ), ), ;, case]
[return, !, isConstantName, (, n, ), &&, !, knownConstants, ., contains, (, n, ., getString, (, ), ), ;, case]
[), &&, !, knownConstants, ., contains, (, n, ., getString, (, ), ), ;, case, Token, ., GETPROP, :, case]
[), &&, !, knownConstants, ., contains, (, n, ., getString, (, ), ), ;, case, Token, ., GETPROP, :, case]
[contains, (, n, ., getString, (, ), ), ;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return]
[., getString, (, ), ), ;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case]
[., getString, (, ), ), ;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case]
[), ;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :]
[), ;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :]
[., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (]
[:, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (, isFunctionExpression, (]
[:, return, true, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (, isFunctionExpression, (, n, ), ), ;, return]
[:, Preconditions, ., checkState, (, isFunctionExpression, (, n, ), ), ;, return, false, ;, }, for, (, Node, c, =]
[:, Preconditions, ., checkState, (, isFunctionExpression, (, n, ), ), ;, return, false, ;, }, for, (, Node, c, =]
[(, n, ), ), ;, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[(, n, ), ), ;, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[), ), ;, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[;, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;]
[false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[(, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, canBeSideEffected, (]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, canBeSideEffected, (, c, ,]
[c, =, c, ., getNext, (, ), ), {, if, (, canBeSideEffected, (, c, ,, knownConstants, ), ), {, return]
[(, ), ), {, if, (, canBeSideEffected, (, c, ,, knownConstants, ), ), {, return, true, ;, }, }, return]
[{, return, true, ;, }, }, return, false, ;, }, static, int, precedence, (, int, type, ), {, switch, (]
[}, }, return, false, ;, }, static, int, precedence, (, int, type, ), {, switch, (, type, ), {, case]
[}, }, return, false, ;, }, static, int, precedence, (, int, type, ), {, switch, (, type, ), {, case]
[}, static, int, precedence, (, int, type, ), {, switch, (, type, ), {, case, Token, ., COMMA, :, return]
[precedence, (, int, type, ), {, switch, (, type, ), {, case, Token, ., COMMA, :, return, 0, ;, case]
[precedence, (, int, type, ), {, switch, (, type, ), {, case, Token, ., COMMA, :, return, 0, ;, case]
[{, switch, (, type, ), {, case, Token, ., COMMA, :, return, 0, ;, case, Token, ., ASSIGN_BITOR, :, case]
[{, switch, (, type, ), {, case, Token, ., COMMA, :, return, 0, ;, case, Token, ., ASSIGN_BITOR, :, case]
[{, case, Token, ., COMMA, :, return, 0, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case]
[{, case, Token, ., COMMA, :, return, 0, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case]
[:, return, 0, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[:, return, 0, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case]
[Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case]
[Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case]
[Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case]
[Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case]
[Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case]
[Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case]
[Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case]
[Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case]
[Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case]
[Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case]
[Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case]
[Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case]
[Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case]
[Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case]
[Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case]
[Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return]
[:, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1, ;, case]
[:, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1, ;, case]
[:, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1, ;, case, Token, ., HOOK, :, return]
[., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1, ;, case, Token, ., HOOK, :, return, 2, ;, case]
[., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1, ;, case, Token, ., HOOK, :, return, 2, ;, case]
[., ASSIGN, :, return, 1, ;, case, Token, ., HOOK, :, return, 2, ;, case, Token, ., OR, :, return]
[return, 1, ;, case, Token, ., HOOK, :, return, 2, ;, case, Token, ., OR, :, return, 3, ;, case]
[return, 1, ;, case, Token, ., HOOK, :, return, 2, ;, case, Token, ., OR, :, return, 3, ;, case]
[., HOOK, :, return, 2, ;, case, Token, ., OR, :, return, 3, ;, case, Token, ., AND, :, return]
[return, 2, ;, case, Token, ., OR, :, return, 3, ;, case, Token, ., AND, :, return, 4, ;, case]
[return, 2, ;, case, Token, ., OR, :, return, 3, ;, case, Token, ., AND, :, return, 4, ;, case]
[., OR, :, return, 3, ;, case, Token, ., AND, :, return, 4, ;, case, Token, ., BITOR, :, return]
[return, 3, ;, case, Token, ., AND, :, return, 4, ;, case, Token, ., BITOR, :, return, 5, ;, case]
[return, 3, ;, case, Token, ., AND, :, return, 4, ;, case, Token, ., BITOR, :, return, 5, ;, case]
[., AND, :, return, 4, ;, case, Token, ., BITOR, :, return, 5, ;, case, Token, ., BITXOR, :, return]
[return, 4, ;, case, Token, ., BITOR, :, return, 5, ;, case, Token, ., BITXOR, :, return, 6, ;, case]
[return, 4, ;, case, Token, ., BITOR, :, return, 5, ;, case, Token, ., BITXOR, :, return, 6, ;, case]
[., BITOR, :, return, 5, ;, case, Token, ., BITXOR, :, return, 6, ;, case, Token, ., BITAND, :, return]
[return, 5, ;, case, Token, ., BITXOR, :, return, 6, ;, case, Token, ., BITAND, :, return, 7, ;, case]
[return, 5, ;, case, Token, ., BITXOR, :, return, 6, ;, case, Token, ., BITAND, :, return, 7, ;, case]
[., BITXOR, :, return, 6, ;, case, Token, ., BITAND, :, return, 7, ;, case, Token, ., EQ, :, case]
[., BITXOR, :, return, 6, ;, case, Token, ., BITAND, :, return, 7, ;, case, Token, ., EQ, :, case]
[;, case, Token, ., BITAND, :, return, 7, ;, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[;, case, Token, ., BITAND, :, return, 7, ;, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[:, return, 7, ;, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[:, return, 7, ;, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return]
[:, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, 8, ;, case]
[:, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, 8, ;, case]
[:, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, 8, ;, case, Token, ., LT, :, case]
[:, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, 8, ;, case, Token, ., LT, :, case]
[:, case, Token, ., SHNE, :, return, 8, ;, case, Token, ., LT, :, case, Token, ., GT, :, case]
[:, case, Token, ., SHNE, :, return, 8, ;, case, Token, ., LT, :, case, Token, ., GT, :, case]
[:, return, 8, ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[:, return, 8, ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case]
[Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., INSTANCEOF, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., INSTANCEOF, :, case]
[Token, ., LE, :, case, Token, ., GE, :, case, Token, ., INSTANCEOF, :, case, Token, ., IN, :, return]
[:, case, Token, ., GE, :, case, Token, ., INSTANCEOF, :, case, Token, ., IN, :, return, 9, ;, case]
[:, case, Token, ., GE, :, case, Token, ., INSTANCEOF, :, case, Token, ., IN, :, return, 9, ;, case]
[:, case, Token, ., INSTANCEOF, :, case, Token, ., IN, :, return, 9, ;, case, Token, ., LSH, :, case]
[:, case, Token, ., INSTANCEOF, :, case, Token, ., IN, :, return, 9, ;, case, Token, ., LSH, :, case]
[:, case, Token, ., IN, :, return, 9, ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case]
[:, case, Token, ., IN, :, return, 9, ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case]
[:, return, 9, ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return]
[;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, 10, ;, case]
[;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, 10, ;, case]
[:, case, Token, ., RSH, :, case, Token, ., URSH, :, return, 10, ;, case, Token, ., SUB, :, case]
[:, case, Token, ., RSH, :, case, Token, ., URSH, :, return, 10, ;, case, Token, ., SUB, :, case]
[:, case, Token, ., URSH, :, return, 10, ;, case, Token, ., SUB, :, case, Token, ., ADD, :, return]
[., URSH, :, return, 10, ;, case, Token, ., SUB, :, case, Token, ., ADD, :, return, 11, ;, case]
[., URSH, :, return, 10, ;, case, Token, ., SUB, :, case, Token, ., ADD, :, return, 11, ;, case]
[;, case, Token, ., SUB, :, case, Token, ., ADD, :, return, 11, ;, case, Token, ., MUL, :, case]
[;, case, Token, ., SUB, :, case, Token, ., ADD, :, return, 11, ;, case, Token, ., MUL, :, case]
[:, case, Token, ., ADD, :, return, 11, ;, case, Token, ., MUL, :, case, Token, ., MOD, :, case]
[:, case, Token, ., ADD, :, return, 11, ;, case, Token, ., MUL, :, case, Token, ., MOD, :, case]
[:, return, 11, ;, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, return]
[;, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, return, 12, ;, case]
[;, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, return, 12, ;, case]
[:, case, Token, ., MOD, :, case, Token, ., DIV, :, return, 12, ;, case, Token, ., INC, :, case]
[:, case, Token, ., MOD, :, case, Token, ., DIV, :, return, 12, ;, case, Token, ., INC, :, case]
[:, case, Token, ., DIV, :, return, 12, ;, case, Token, ., INC, :, case, Token, ., DEC, :, case]
[:, case, Token, ., DIV, :, return, 12, ;, case, Token, ., INC, :, case, Token, ., DEC, :, case]
[:, return, 12, ;, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., NEW, :, case]
[:, return, 12, ;, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., NEW, :, case]
[Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., NEW, :, case, Token, ., DELPROP, :, case]
[Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., NEW, :, case, Token, ., DELPROP, :, case]
[Token, ., DEC, :, case, Token, ., NEW, :, case, Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case]
[Token, ., DEC, :, case, Token, ., NEW, :, case, Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case]
[Token, ., NEW, :, case, Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case]
[Token, ., NEW, :, case, Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case]
[Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., NOT, :, case]
[Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., NOT, :, case]
[Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., NOT, :, case, Token, ., BITNOT, :, case]
[Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., NOT, :, case, Token, ., BITNOT, :, case]
[Token, ., VOID, :, case, Token, ., NOT, :, case, Token, ., BITNOT, :, case, Token, ., POS, :, case]
[Token, ., VOID, :, case, Token, ., NOT, :, case, Token, ., BITNOT, :, case, Token, ., POS, :, case]
[Token, ., NOT, :, case, Token, ., BITNOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, return]
[:, case, Token, ., BITNOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, return, 13, ;, case]
[:, case, Token, ., BITNOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, return, 13, ;, case]
[:, case, Token, ., POS, :, case, Token, ., NEG, :, return, 13, ;, case, Token, ., CALL, :, case]
[:, case, Token, ., POS, :, case, Token, ., NEG, :, return, 13, ;, case, Token, ., CALL, :, case]
[:, case, Token, ., NEG, :, return, 13, ;, case, Token, ., CALL, :, case, Token, ., GETELEM, :, case]
[:, case, Token, ., NEG, :, return, 13, ;, case, Token, ., CALL, :, case, Token, ., GETELEM, :, case]
[:, return, 13, ;, case, Token, ., CALL, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case]
[:, return, 13, ;, case, Token, ., CALL, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case]
[Token, ., CALL, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case]
[Token, ., CALL, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case]
[Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case]
[Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case]
[Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case, Token, ., FALSE, :, case]
[Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case, Token, ., FALSE, :, case]
[Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case, Token, ., FALSE, :, case, Token, ., FUNCTION, :, case]
[Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case, Token, ., FALSE, :, case, Token, ., FUNCTION, :, case]
[Token, ., EMPTY, :, case, Token, ., FALSE, :, case, Token, ., FUNCTION, :, case, Token, ., NAME, :, case]
[Token, ., EMPTY, :, case, Token, ., FALSE, :, case, Token, ., FUNCTION, :, case, Token, ., NAME, :, case]
[Token, ., FALSE, :, case, Token, ., FUNCTION, :, case, Token, ., NAME, :, case, Token, ., NULL, :, case]
[Token, ., FALSE, :, case, Token, ., FUNCTION, :, case, Token, ., NAME, :, case, Token, ., NULL, :, case]
[Token, ., FUNCTION, :, case, Token, ., NAME, :, case, Token, ., NULL, :, case, Token, ., NUMBER, :, case]
[Token, ., FUNCTION, :, case, Token, ., NAME, :, case, Token, ., NULL, :, case, Token, ., NUMBER, :, case]
[Token, ., NAME, :, case, Token, ., NULL, :, case, Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case]
[Token, ., NAME, :, case, Token, ., NULL, :, case, Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case]
[Token, ., NULL, :, case, Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case]
[Token, ., NULL, :, case, Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case]
[Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., STRING, :, case]
[Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., STRING, :, case]
[Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case]
[Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case]
[Token, ., REGEXP, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., THIS, :, case]
[Token, ., REGEXP, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., THIS, :, case]
[Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, return]
[:, case, Token, ., STRING_KEY, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, return, 15, ;, case]
[:, case, Token, ., STRING_KEY, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, return, 15, ;, case]
[:, case, Token, ., THIS, :, case, Token, ., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return]
[:, case, Token, ., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw]
[., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (]
[., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (]
[., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (]
[., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (]
[., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (]
[:, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (, "Unknown precedence for ", +]
[:, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (, "Unknown precedence for ", +]
[case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (, "Unknown precedence for ", +, Token, ., name, (]
[CAST, :, return, 16, ;, default, :, throw, new, Error, (, "Unknown precedence for ", +, Token, ., name, (, type, ), +]
[return, 16, ;, default, :, throw, new, Error, (, "Unknown precedence for ", +, Token, ., name, (, type, ), +, " (type ", +]
[;, default, :, throw, new, Error, (, "Unknown precedence for ", +, Token, ., name, (, type, ), +, " (type ", +, type, +]
[+, " (type ", +, type, +, ")", ), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (]
[+, " (type ", +, type, +, ")", ), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (]
[}, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., VOID, :, return]
[), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., VOID, :, return, true, ;, case]
[), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., VOID, :, return, true, ;, case]
[., getType, (, ), ), {, case, Token, ., VOID, :, return, true, ;, case, Token, ., NAME, :, return]
[., getType, (, ), ), {, case, Token, ., VOID, :, return, true, ;, case, Token, ., NAME, :, return]
[., getType, (, ), ), {, case, Token, ., VOID, :, return, true, ;, case, Token, ., NAME, :, return]
[., VOID, :, return, true, ;, case, Token, ., NAME, :, return, n, ., getString, (, ), ., equals, (]
[;, case, Token, ., NAME, :, return, n, ., getString, (, ), ., equals, (, "undefined", ), ;, }, return]
[., equals, (, "undefined", ), ;, }, return, false, ;, }, static, boolean, isNullOrUndefined, (, Node, n, ), {, return]
[., equals, (, "undefined", ), ;, }, return, false, ;, }, static, boolean, isNullOrUndefined, (, Node, n, ), {, return]
[., equals, (, "undefined", ), ;, }, return, false, ;, }, static, boolean, isNullOrUndefined, (, Node, n, ), {, return]
[}, return, false, ;, }, static, boolean, isNullOrUndefined, (, Node, n, ), {, return, n, ., isNull, (, ), ||]
[false, ;, }, static, boolean, isNullOrUndefined, (, Node, n, ), {, return, n, ., isNull, (, ), ||, isUndefined, (]
[n, ., isNull, (, ), ||, isUndefined, (, n, ), ;, }, static, final, Predicate, <, Node, >, IMMUTABLE_PREDICATE, =]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return, isImmutableValue, (]
[), {, return, isImmutableValue, (, n, ), ;, }, }, ;, static, boolean, isImmutableResult, (, Node, n, ), {, return]
[return, isImmutableValue, (, n, ), ;, }, }, ;, static, boolean, isImmutableResult, (, Node, n, ), {, return, allResultsMatch, (]
[(, n, ), ;, }, }, ;, static, boolean, isImmutableResult, (, Node, n, ), {, return, allResultsMatch, (, n, ,]
[IMMUTABLE_PREDICATE, ), ;, }, static, boolean, allResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (]
[IMMUTABLE_PREDICATE, ), ;, }, static, boolean, allResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (]
[Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (, n, ., getType, (, ), ), {, case]
[Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (, n, ., getType, (, ), ), {, case]
[Node, >, p, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, return]
[p, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, return, allResultsMatch, (]
[p, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, return, allResultsMatch, (]
[., getType, (, ), ), {, case, Token, ., CAST, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,]
[), {, case, Token, ., CAST, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case]
[), {, case, Token, ., CAST, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case]
[CAST, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case]
[CAST, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case]
[n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return]
[getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch, (]
[getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch, (]
[;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, ), ,]
[ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case]
[COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case]
[n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return]
[n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return]
[getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, allResultsMatch, (]
[getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, allResultsMatch, (]
[;, case, Token, ., AND, :, case, Token, ., OR, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,]
[., AND, :, case, Token, ., OR, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), &&]
[:, case, Token, ., OR, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), &&, allResultsMatch, (]
[:, case, Token, ., OR, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), &&, allResultsMatch, (]
[return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,]
[., getFirstChild, (, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[., getFirstChild, (, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return]
[p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return]
[&&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, allResultsMatch, (]
[&&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, allResultsMatch, (]
[&&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, allResultsMatch, (]
[), ;, case, Token, ., HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,]
[Token, ., HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), &&]
[HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), &&, allResultsMatch, (]
[HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), &&, allResultsMatch, (]
[., getFirstChild, (, ), ., getNext, (, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,]
[(, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return]
[(, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return]
[), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return, p, ., apply, (]
[), ;, }, }, static, boolean, anyResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (]
[), ;, }, }, static, boolean, anyResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (]
[Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (, n, ., getType, (, ), ), {, case]
[Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (, n, ., getType, (, ), ), {, case]
[Node, >, p, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, return]
[p, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, return, anyResultsMatch, (]
[p, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CAST, :, return, anyResultsMatch, (]
[., getType, (, ), ), {, case, Token, ., CAST, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,]
[), {, case, Token, ., CAST, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case]
[), {, case, Token, ., CAST, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case]
[CAST, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case]
[CAST, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case]
[n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return]
[getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch, (]
[getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch, (]
[;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,]
[ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case]
[COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case]
[n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return]
[n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return]
[getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, anyResultsMatch, (]
[getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, anyResultsMatch, (]
[;, case, Token, ., AND, :, case, Token, ., OR, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,]
[., AND, :, case, Token, ., OR, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ||]
[:, case, Token, ., OR, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ||, anyResultsMatch, (]
[:, case, Token, ., OR, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ||, anyResultsMatch, (]
[return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,]
[., getFirstChild, (, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[., getFirstChild, (, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return]
[p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return]
[||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, anyResultsMatch, (]
[||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, anyResultsMatch, (]
[||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, anyResultsMatch, (]
[), ;, case, Token, ., HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,]
[Token, ., HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), ||]
[HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), ||, anyResultsMatch, (]
[HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), ||, anyResultsMatch, (]
[., getFirstChild, (, ), ., getNext, (, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,]
[(, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return]
[(, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return]
[), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return, p, ., apply, (]
[static, class, NumbericResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[NumbericResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return, isNumericResultHelper, (]
[boolean, apply, (, Node, n, ), {, return, isNumericResultHelper, (, n, ), ;, }, }, static, final, NumbericResultPredicate, NUMBERIC_RESULT_PREDICATE, =]
[}, static, final, NumbericResultPredicate, NUMBERIC_RESULT_PREDICATE, =, new, NumbericResultPredicate, (, ), ;, static, boolean, isNumericResult, (, Node, n, ), {, return]
[final, NumbericResultPredicate, NUMBERIC_RESULT_PREDICATE, =, new, NumbericResultPredicate, (, ), ;, static, boolean, isNumericResult, (, Node, n, ), {, return, allResultsMatch, (]
[NUMBERIC_RESULT_PREDICATE, =, new, NumbericResultPredicate, (, ), ;, static, boolean, isNumericResult, (, Node, n, ), {, return, allResultsMatch, (, n, ,]
[{, return, allResultsMatch, (, n, ,, NUMBERIC_RESULT_PREDICATE, ), ;, }, static, boolean, isNumericResultHelper, (, Node, n, ), {, switch, (]
[{, return, allResultsMatch, (, n, ,, NUMBERIC_RESULT_PREDICATE, ), ;, }, static, boolean, isNumericResultHelper, (, Node, n, ), {, switch, (]
[;, }, static, boolean, isNumericResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, boolean, isNumericResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ADD, :, return]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ADD, :, return]
[Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ADD, :, return, !]
[), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ADD, :, return, !, mayBeString, (]
[), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ADD, :, return, !, mayBeString, (]
[(, ), ), {, case, Token, ., ADD, :, return, !, mayBeString, (, n, ., getFirstChild, (, ), ), &&]
[), ), {, case, Token, ., ADD, :, return, !, mayBeString, (, n, ., getFirstChild, (, ), ), &&, !]
[{, case, Token, ., ADD, :, return, !, mayBeString, (, n, ., getFirstChild, (, ), ), &&, !, mayBeString, (]
[{, case, Token, ., ADD, :, return, !, mayBeString, (, n, ., getFirstChild, (, ), ), &&, !, mayBeString, (]
[mayBeString, (, n, ., getFirstChild, (, ), ), &&, !, mayBeString, (, n, ., getLastChild, (, ), ), ;, case]
[mayBeString, (, n, ., getFirstChild, (, ), ), &&, !, mayBeString, (, n, ., getLastChild, (, ), ), ;, case]
[(, ), ), &&, !, mayBeString, (, n, ., getLastChild, (, ), ), ;, case, Token, ., BITNOT, :, case]
[(, ), ), &&, !, mayBeString, (, n, ., getLastChild, (, ), ), ;, case, Token, ., BITNOT, :, case]
[mayBeString, (, n, ., getLastChild, (, ), ), ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case]
[mayBeString, (, n, ., getLastChild, (, ), ), ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case]
[(, ), ), ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[(, ), ), ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case]
[Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case]
[Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case]
[Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case]
[Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case]
[Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case]
[Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case]
[Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case]
[Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case]
[Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case]
[Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case]
[Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case]
[Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case]
[Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case]
[Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., INC, :, case]
[Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., INC, :, case]
[Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., INC, :, case, Token, ., DEC, :, case]
[Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., INC, :, case, Token, ., DEC, :, case]
[Token, ., DIV, :, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., POS, :, case]
[Token, ., DIV, :, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., POS, :, case]
[Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., POS, :, case, Token, ., NEG, :, case]
[Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., POS, :, case, Token, ., NEG, :, case]
[Token, ., DEC, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., NUMBER, :, return]
[:, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., NUMBER, :, return, true, ;, case]
[:, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., NUMBER, :, return, true, ;, case]
[Token, ., NEG, :, case, Token, ., NUMBER, :, return, true, ;, case, Token, ., NAME, :, String, name, =]
[Token, ., NEG, :, case, Token, ., NUMBER, :, return, true, ;, case, Token, ., NAME, :, String, name, =]
[:, return, true, ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[:, return, true, ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals, (]
[String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals, (, "NaN", ), ), {, return]
[getString, (, ), ;, if, (, name, ., equals, (, "NaN", ), ), {, return, true, ;, }, if, (]
[getString, (, ), ;, if, (, name, ., equals, (, "NaN", ), ), {, return, true, ;, }, if, (]
[if, (, name, ., equals, (, "NaN", ), ), {, return, true, ;, }, if, (, name, ., equals, (]
[(, "NaN", ), ), {, return, true, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return]
[{, return, true, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return, true, ;, }, return]
[if, (, name, ., equals, (, "Infinity", ), ), {, return, true, ;, }, return, false, ;, default, :, return]
[static, class, BooleanResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[BooleanResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return, isBooleanResultHelper, (]
[boolean, apply, (, Node, n, ), {, return, isBooleanResultHelper, (, n, ), ;, }, }, static, final, BooleanResultPredicate, BOOLEAN_RESULT_PREDICATE, =]
[}, static, final, BooleanResultPredicate, BOOLEAN_RESULT_PREDICATE, =, new, BooleanResultPredicate, (, ), ;, static, boolean, isBooleanResult, (, Node, n, ), {, return]
[final, BooleanResultPredicate, BOOLEAN_RESULT_PREDICATE, =, new, BooleanResultPredicate, (, ), ;, static, boolean, isBooleanResult, (, Node, n, ), {, return, allResultsMatch, (]
[BOOLEAN_RESULT_PREDICATE, =, new, BooleanResultPredicate, (, ), ;, static, boolean, isBooleanResult, (, Node, n, ), {, return, allResultsMatch, (, n, ,]
[{, return, allResultsMatch, (, n, ,, BOOLEAN_RESULT_PREDICATE, ), ;, }, static, boolean, isBooleanResultHelper, (, Node, n, ), {, switch, (]
[{, return, allResultsMatch, (, n, ,, BOOLEAN_RESULT_PREDICATE, ), ;, }, static, boolean, isBooleanResultHelper, (, Node, n, ), {, switch, (]
[;, }, static, boolean, isBooleanResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, boolean, isBooleanResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., TRUE, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., TRUE, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case]
[(, ), ), {, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., EQ, :, case]
[(, ), ), {, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., EQ, :, case]
[Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[Token, ., FALSE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[Token, ., FALSE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case]
[Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case]
[Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., LT, :, case]
[Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., LT, :, case]
[Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., LT, :, case, Token, ., GT, :, case]
[Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., LT, :, case, Token, ., GT, :, case]
[Token, ., SHNE, :, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[Token, ., SHNE, :, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case]
[Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., IN, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., IN, :, case]
[Token, ., LE, :, case, Token, ., GE, :, case, Token, ., IN, :, case, Token, ., INSTANCEOF, :, case]
[Token, ., LE, :, case, Token, ., GE, :, case, Token, ., IN, :, case, Token, ., INSTANCEOF, :, case]
[Token, ., GE, :, case, Token, ., IN, :, case, Token, ., INSTANCEOF, :, case, Token, ., NOT, :, case]
[Token, ., GE, :, case, Token, ., IN, :, case, Token, ., INSTANCEOF, :, case, Token, ., NOT, :, case]
[Token, ., IN, :, case, Token, ., INSTANCEOF, :, case, Token, ., NOT, :, case, Token, ., DELPROP, :, return]
[Token, ., INSTANCEOF, :, case, Token, ., NOT, :, case, Token, ., DELPROP, :, return, true, ;, default, :, return]
[static, class, MayBeStringResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[MayBeStringResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return, mayBeStringHelper, (]
[boolean, apply, (, Node, n, ), {, return, mayBeStringHelper, (, n, ), ;, }, }, static, final, MayBeStringResultPredicate, MAY_BE_STRING_PREDICATE, =]
[}, static, final, MayBeStringResultPredicate, MAY_BE_STRING_PREDICATE, =, new, MayBeStringResultPredicate, (, ), ;, static, boolean, mayBeString, (, Node, n, ), {, return]
[final, MayBeStringResultPredicate, MAY_BE_STRING_PREDICATE, =, new, MayBeStringResultPredicate, (, ), ;, static, boolean, mayBeString, (, Node, n, ), {, return, mayBeString, (]
[MAY_BE_STRING_PREDICATE, =, new, MayBeStringResultPredicate, (, ), ;, static, boolean, mayBeString, (, Node, n, ), {, return, mayBeString, (, n, ,]
[(, n, ,, true, ), ;, }, static, boolean, mayBeString, (, Node, n, ,, boolean, recurse, ), {, if, (]
[), ;, }, static, boolean, mayBeString, (, Node, n, ,, boolean, recurse, ), {, if, (, recurse, ), {, return]
[}, static, boolean, mayBeString, (, Node, n, ,, boolean, recurse, ), {, if, (, recurse, ), {, return, anyResultsMatch, (]
[boolean, mayBeString, (, Node, n, ,, boolean, recurse, ), {, if, (, recurse, ), {, return, anyResultsMatch, (, n, ,]
[recurse, ), {, if, (, recurse, ), {, return, anyResultsMatch, (, n, ,, MAY_BE_STRING_PREDICATE, ), ;, }, else, {, return]
[{, if, (, recurse, ), {, return, anyResultsMatch, (, n, ,, MAY_BE_STRING_PREDICATE, ), ;, }, else, {, return, mayBeStringHelper, (]
[}, else, {, return, mayBeStringHelper, (, n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return]
[}, else, {, return, mayBeStringHelper, (, n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return]
[}, else, {, return, mayBeStringHelper, (, n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return]
[}, else, {, return, mayBeStringHelper, (, n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return]
[else, {, return, mayBeStringHelper, (, n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return, !]
[return, mayBeStringHelper, (, n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return, !, isNumericResult, (]
[n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return, !, isNumericResult, (, n, ), &&]
[), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return, !, isNumericResult, (, n, ), &&, !]
[}, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return, !, isNumericResult, (, n, ), &&, !, isBooleanResult, (]
[boolean, mayBeStringHelper, (, Node, n, ), {, return, !, isNumericResult, (, n, ), &&, !, isBooleanResult, (, n, ), &&]
[mayBeStringHelper, (, Node, n, ), {, return, !, isNumericResult, (, n, ), &&, !, isBooleanResult, (, n, ), &&, !]
[Node, n, ), {, return, !, isNumericResult, (, n, ), &&, !, isBooleanResult, (, n, ), &&, !, isUndefined, (]
[{, return, !, isNumericResult, (, n, ), &&, !, isBooleanResult, (, n, ), &&, !, isUndefined, (, n, ), &&]
[return, !, isNumericResult, (, n, ), &&, !, isBooleanResult, (, n, ), &&, !, isUndefined, (, n, ), &&, !]
[return, !, isNumericResult, (, n, ), &&, !, isBooleanResult, (, n, ), &&, !, isUndefined, (, n, ), &&, !]
[), &&, !, n, ., isNull, (, ), ;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (]
[., isNull, (, ), ;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (, type, ), {, case]
[., isNull, (, ), ;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (, type, ), {, case]
[}, static, boolean, isAssociative, (, int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :, case]
[}, static, boolean, isAssociative, (, int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :, case]
[int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :, case, Token, ., AND, :, case]
[int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :, case, Token, ., AND, :, case]
[(, type, ), {, case, Token, ., MUL, :, case, Token, ., AND, :, case, Token, ., OR, :, case]
[(, type, ), {, case, Token, ., MUL, :, case, Token, ., AND, :, case, Token, ., OR, :, case]
[Token, ., MUL, :, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, ., BITOR, :, case]
[Token, ., MUL, :, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, ., BITOR, :, case]
[Token, ., AND, :, case, Token, ., OR, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[Token, ., AND, :, case, Token, ., OR, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[Token, ., OR, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default, :, return]
[return, true, ;, default, :, return, false, ;, }, }, static, boolean, isCommutative, (, int, type, ), {, switch, (]
[:, return, false, ;, }, }, static, boolean, isCommutative, (, int, type, ), {, switch, (, type, ), {, case]
[:, return, false, ;, }, }, static, boolean, isCommutative, (, int, type, ), {, switch, (, type, ), {, case]
[}, static, boolean, isCommutative, (, int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :, case]
[}, static, boolean, isCommutative, (, int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :, case]
[int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :, case, Token, ., BITOR, :, case]
[int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :, case, Token, ., BITOR, :, case]
[(, type, ), {, case, Token, ., MUL, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[(, type, ), {, case, Token, ., MUL, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[Token, ., MUL, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default, :, return]
[return, true, ;, default, :, return, false, ;, }, }, static, boolean, isAssignmentOp, (, Node, n, ), {, switch, (]
[return, true, ;, default, :, return, false, ;, }, }, static, boolean, isAssignmentOp, (, Node, n, ), {, switch, (]
[}, }, static, boolean, isAssignmentOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, }, static, boolean, isAssignmentOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, case, Token, ., ASSIGN_BITOR, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, case, Token, ., ASSIGN_BITOR, :, case]
[(, ), ), {, case, Token, ., ASSIGN, :, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case]
[(, ), ), {, case, Token, ., ASSIGN, :, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case]
[Token, ., ASSIGN, :, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[Token, ., ASSIGN, :, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case]
[Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case]
[Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case]
[Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case]
[Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case]
[Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case]
[Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case]
[Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case]
[Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case]
[Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case]
[Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case]
[Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case]
[Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case]
[Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case]
[Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return]
[case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, true, ;, }, return]
[ASSIGN_MOD, :, return, true, ;, }, return, false, ;, }, static, int, getOpFromAssignmentOp, (, Node, n, ), {, switch, (]
[ASSIGN_MOD, :, return, true, ;, }, return, false, ;, }, static, int, getOpFromAssignmentOp, (, Node, n, ), {, switch, (]
[;, }, static, int, getOpFromAssignmentOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, int, getOpFromAssignmentOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN_BITOR, :, return]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN_BITOR, :, return]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN_BITOR, :, return, Token, ., BITOR, ;, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., ASSIGN_BITOR, :, return, Token, ., BITOR, ;, case]
[(, ), ), {, case, Token, ., ASSIGN_BITOR, :, return, Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return]
[(, ), ), {, case, Token, ., ASSIGN_BITOR, :, return, Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return]
[Token, ., ASSIGN_BITOR, :, return, Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case]
[Token, ., ASSIGN_BITOR, :, return, Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case]
[Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return]
[Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return]
[Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case]
[Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case]
[Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return]
[Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return]
[Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case]
[Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case]
[Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return]
[Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return]
[Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case]
[Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case]
[Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return]
[Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return]
[Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case]
[Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case]
[Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return]
[Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return]
[Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case]
[Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case]
[Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return]
[Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return]
[Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case]
[Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case]
[Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return]
[Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return]
[Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case]
[Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case]
[Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return]
[Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return]
[Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return, Token, ., DIV, ;, case]
[Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return, Token, ., DIV, ;, case]
[Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD, :, return]
[Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD, :, return]
[., ASSIGN_DIV, :, return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD, :, return, Token, ., MOD, ;, }, throw]
[return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD, :, return, Token, ., MOD, ;, }, throw, new, IllegalArgumentException, (]
[return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD, :, return, Token, ., MOD, ;, }, throw, new, IllegalArgumentException, (]
[., DIV, ;, case, Token, ., ASSIGN_MOD, :, return, Token, ., MOD, ;, }, throw, new, IllegalArgumentException, (, "Not an assignment op:", +]
[}, throw, new, IllegalArgumentException, (, "Not an assignment op:", +, n, ), ;, }, static, boolean, containsFunction, (, Node, n, ), {, return]
[new, IllegalArgumentException, (, "Not an assignment op:", +, n, ), ;, }, static, boolean, containsFunction, (, Node, n, ), {, return, containsType, (]
[(, "Not an assignment op:", +, n, ), ;, }, static, boolean, containsFunction, (, Node, n, ), {, return, containsType, (, n, ,]
[(, "Not an assignment op:", +, n, ), ;, }, static, boolean, containsFunction, (, Node, n, ), {, return, containsType, (, n, ,]
[(, n, ,, Token, ., FUNCTION, ), ;, }, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =]
[(, n, ,, Token, ., FUNCTION, ), ;, }, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =]
[n, ,, Token, ., FUNCTION, ), ;, }, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =, (]
[n, ,, Token, ., FUNCTION, ), ;, }, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =, (]
[}, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =, (, n, ., isFunction, (, ), ), ?]
[}, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =, (, n, ., isFunction, (, ), ), ?]
[n, ), {, Node, start, =, (, n, ., isFunction, (, ), ), ?, n, ., getLastChild, (, ), :]
[Node, start, =, (, n, ., isFunction, (, ), ), ?, n, ., getLastChild, (, ), :, n, ;, return]
[=, (, n, ., isFunction, (, ), ), ?, n, ., getLastChild, (, ), :, n, ;, return, containsType, (]
[n, ., isFunction, (, ), ), ?, n, ., getLastChild, (, ), :, n, ;, return, containsType, (, start, ,]
[n, ., isFunction, (, ), ), ?, n, ., getLastChild, (, ), :, n, ;, return, containsType, (, start, ,]
[), ), ?, n, ., getLastChild, (, ), :, n, ;, return, containsType, (, start, ,, Token, ., THIS, ,]
[(, start, ,, Token, ., THIS, ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n, ), {, return]
[(, start, ,, Token, ., THIS, ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n, ), {, return]
[(, start, ,, Token, ., THIS, ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n, ), {, return]
[,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n, ), {, return, n, ., isGetProp, (, ), ||]
[,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n, ), {, return, n, ., isGetProp, (, ), ||]
[isGetProp, (, ), ||, n, ., isGetElem, (, ), ;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return]
[isGetProp, (, ), ||, n, ., isGetElem, (, ), ;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return]
[isGetProp, (, ), ||, n, ., isGetElem, (, ), ;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return]
[isGetElem, (, ), ;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return, n, ., isName, (, ), &&]
[isGetElem, (, ), ;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return, n, ., isName, (, ), &&]
[isGetElem, (, ), ;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return, n, ., isName, (, ), &&]
[&&, n, ., getParent, (, ), ., isVar, (, ), ;, }, static, Node, getAssignedValue, (, Node, n, ), {]
[&&, n, ., getParent, (, ), ., isVar, (, ), ;, }, static, Node, getAssignedValue, (, Node, n, ), {]
[(, ), ., isVar, (, ), ;, }, static, Node, getAssignedValue, (, Node, n, ), {, Preconditions, ., checkState, (]
[(, ), ., isVar, (, ), ;, }, static, Node, getAssignedValue, (, Node, n, ), {, Preconditions, ., checkState, (]
[getAssignedValue, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isName, (, ), ), ;, Node, parent, =]
[getAssignedValue, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isName, (, ), ), ;, Node, parent, =]
[checkState, (, n, ., isName, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[checkState, (, n, ., isName, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isVar, (, ), ), {, return]
[;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isVar, (, ), ), {, return]
[if, (, parent, ., isVar, (, ), ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (]
[if, (, parent, ., isVar, (, ), ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (]
[if, (, parent, ., isVar, (, ), ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (]
[), ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (, parent, ., isAssign, (, ), &&]
[), ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (, parent, ., isAssign, (, ), &&]
[), ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (, parent, ., isAssign, (, ), &&]
[getFirstChild, (, ), ;, }, else, if, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==]
[}, else, if, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), {, return]
[}, else, if, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), {, return]
[parent, ., getFirstChild, (, ), ==, n, ), {, return, n, ., getNext, (, ), ;, }, else, {, return]
[(, ), ;, }, else, {, return, null, ;, }, }, static, boolean, isExprAssign, (, Node, n, ), {, return]
[(, ), ;, }, else, {, return, null, ;, }, }, static, boolean, isExprAssign, (, Node, n, ), {, return]
[(, ), ;, }, else, {, return, null, ;, }, }, static, boolean, isExprAssign, (, Node, n, ), {, return]
[return, null, ;, }, }, static, boolean, isExprAssign, (, Node, n, ), {, return, n, ., isExprResult, (, ), &&]
[return, null, ;, }, }, static, boolean, isExprAssign, (, Node, n, ), {, return, n, ., isExprResult, (, ), &&]
[return, null, ;, }, }, static, boolean, isExprAssign, (, Node, n, ), {, return, n, ., isExprResult, (, ), &&]
[n, ., getFirstChild, (, ), ., isAssign, (, ), ;, }, static, boolean, isExprCall, (, Node, n, ), {, return]
[n, ., getFirstChild, (, ), ., isAssign, (, ), ;, }, static, boolean, isExprCall, (, Node, n, ), {, return]
[n, ., getFirstChild, (, ), ., isAssign, (, ), ;, }, static, boolean, isExprCall, (, Node, n, ), {, return]
[isAssign, (, ), ;, }, static, boolean, isExprCall, (, Node, n, ), {, return, n, ., isExprResult, (, ), &&]
[isAssign, (, ), ;, }, static, boolean, isExprCall, (, Node, n, ), {, return, n, ., isExprResult, (, ), &&]
[isAssign, (, ), ;, }, static, boolean, isExprCall, (, Node, n, ), {, return, n, ., isExprResult, (, ), &&]
[n, ., getFirstChild, (, ), ., isCall, (, ), ;, }, static, boolean, isForIn, (, Node, n, ), {, return]
[n, ., getFirstChild, (, ), ., isCall, (, ), ;, }, static, boolean, isForIn, (, Node, n, ), {, return]
[n, ., getFirstChild, (, ), ., isCall, (, ), ;, }, static, boolean, isForIn, (, Node, n, ), {, return]
[isCall, (, ), ;, }, static, boolean, isForIn, (, Node, n, ), {, return, n, ., isFor, (, ), &&]
[isCall, (, ), ;, }, static, boolean, isForIn, (, Node, n, ), {, return, n, ., isFor, (, ), &&]
[isCall, (, ), ;, }, static, boolean, isForIn, (, Node, n, ), {, return, n, ., isFor, (, ), &&]
[boolean, isForIn, (, Node, n, ), {, return, n, ., isFor, (, ), &&, n, ., getChildCount, (, ), ==]
[&&, n, ., getChildCount, (, ), ==, 3, ;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (]
[&&, n, ., getChildCount, (, ), ==, 3, ;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (]
[;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case]
[(, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, return]
[Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, return, true, ;, default, :, return]
[return, true, ;, default, :, return, false, ;, }, }, static, Node, getLoopCodeBlock, (, Node, n, ), {, switch, (]
[return, true, ;, default, :, return, false, ;, }, }, static, Node, getLoopCodeBlock, (, Node, n, ), {, switch, (]
[}, }, static, Node, getLoopCodeBlock, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, }, static, Node, getLoopCodeBlock, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, return]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, return]
[), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, return, n, ., getLastChild, (, ), ;, case]
[), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, return, n, ., getLastChild, (, ), ;, case]
[FOR, :, case, Token, ., WHILE, :, return, n, ., getLastChild, (, ), ;, case, Token, ., DO, :, return]
[FOR, :, case, Token, ., WHILE, :, return, n, ., getLastChild, (, ), ;, case, Token, ., DO, :, return]
[., getLastChild, (, ), ;, case, Token, ., DO, :, return, n, ., getFirstChild, (, ), ;, default, :, return]
[default, :, return, null, ;, }, }, static, boolean, isWithinLoop, (, Node, n, ), {, for, (, Node, parent, :]
[default, :, return, null, ;, }, }, static, boolean, isWithinLoop, (, Node, n, ), {, for, (, Node, parent, :]
[isWithinLoop, (, Node, n, ), {, for, (, Node, parent, :, n, ., getAncestors, (, ), ), {, if, (]
[isWithinLoop, (, Node, n, ), {, for, (, Node, parent, :, n, ., getAncestors, (, ), ), {, if, (]
[), {, for, (, Node, parent, :, n, ., getAncestors, (, ), ), {, if, (, NodeUtil, ., isLoopStructure, (]
[parent, :, n, ., getAncestors, (, ), ), {, if, (, NodeUtil, ., isLoopStructure, (, parent, ), ), {, return]
[(, ), ), {, if, (, NodeUtil, ., isLoopStructure, (, parent, ), ), {, return, true, ;, }, if, (]
[(, ), ), {, if, (, NodeUtil, ., isLoopStructure, (, parent, ), ), {, return, true, ;, }, if, (]
[), {, return, true, ;, }, if, (, parent, ., isFunction, (, ), ), {, break, ;, }, }, return]
[), {, break, ;, }, }, return, false, ;, }, static, boolean, isControlStructure, (, Node, n, ), {, switch, (]
[), {, break, ;, }, }, return, false, ;, }, static, boolean, isControlStructure, (, Node, n, ), {, switch, (]
[;, }, static, boolean, isControlStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, static, boolean, isControlStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case]
[(, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case]
[(, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case]
[Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, case]
[Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, case]
[Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, case, Token, ., IF, :, case]
[Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, case, Token, ., IF, :, case]
[Token, ., WHILE, :, case, Token, ., WITH, :, case, Token, ., IF, :, case, Token, ., LABEL, :, case]
[Token, ., WHILE, :, case, Token, ., WITH, :, case, Token, ., IF, :, case, Token, ., LABEL, :, case]
[Token, ., WITH, :, case, Token, ., IF, :, case, Token, ., LABEL, :, case, Token, ., TRY, :, case]
[Token, ., WITH, :, case, Token, ., IF, :, case, Token, ., LABEL, :, case, Token, ., TRY, :, case]
[Token, ., IF, :, case, Token, ., LABEL, :, case, Token, ., TRY, :, case, Token, ., CATCH, :, case]
[Token, ., IF, :, case, Token, ., LABEL, :, case, Token, ., TRY, :, case, Token, ., CATCH, :, case]
[Token, ., LABEL, :, case, Token, ., TRY, :, case, Token, ., CATCH, :, case, Token, ., SWITCH, :, case]
[Token, ., LABEL, :, case, Token, ., TRY, :, case, Token, ., CATCH, :, case, Token, ., SWITCH, :, case]
[Token, ., TRY, :, case, Token, ., CATCH, :, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case]
[Token, ., TRY, :, case, Token, ., CATCH, :, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case]
[Token, ., CATCH, :, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return]
[Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, return]
[default, :, return, false, ;, }, }, static, boolean, isControlStructureCodeBlock, (, Node, parent, ,, Node, n, ), {, switch, (]
[default, :, return, false, ;, }, }, static, boolean, isControlStructureCodeBlock, (, Node, parent, ,, Node, n, ), {, switch, (]
[boolean, isControlStructureCodeBlock, (, Node, parent, ,, Node, n, ), {, switch, (, parent, ., getType, (, ), ), {, case]
[boolean, isControlStructureCodeBlock, (, Node, parent, ,, Node, n, ), {, switch, (, parent, ., getType, (, ), ), {, case]
[,, Node, n, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[,, Node, n, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, case]
[(, ), ), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, case, Token, ., LABEL, :, case]
[(, ), ), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, case, Token, ., LABEL, :, case]
[Token, ., FOR, :, case, Token, ., WHILE, :, case, Token, ., LABEL, :, case, Token, ., WITH, :, return]
[Token, ., FOR, :, case, Token, ., WHILE, :, case, Token, ., LABEL, :, case, Token, ., WITH, :, return]
[Token, ., FOR, :, case, Token, ., WHILE, :, case, Token, ., LABEL, :, case, Token, ., WITH, :, return]
[., WHILE, :, case, Token, ., LABEL, :, case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==]
[case, Token, ., LABEL, :, case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case]
[case, Token, ., LABEL, :, case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case]
[case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., DO, :, return]
[case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., DO, :, return]
[case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., DO, :, return]
[parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==]
[(, ), ==, n, ;, case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==, n, ;, case]
[(, ), ==, n, ;, case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==, n, ;, case]
[case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==, n, ;, case, Token, ., IF, :, return]
[case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==, n, ;, case, Token, ., IF, :, return]
[case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==, n, ;, case, Token, ., IF, :, return]
[parent, ., getFirstChild, (, ), ==, n, ;, case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=]
[(, ), ==, n, ;, case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case]
[(, ), ==, n, ;, case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case]
[case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return]
[case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return]
[case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return]
[case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return]
[parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return, parent, ., getFirstChild, (, ), ==]
[getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||]
[getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||]
[getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||]
[case, Token, ., TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, ), ==]
[TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, ), ==, n, ;, case]
[TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, ), ==, n, ;, case]
[getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., CATCH, :, return]
[getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., CATCH, :, return]
[getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., CATCH, :, return]
[parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==]
[(, ), ==, n, ;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case]
[(, ), ==, n, ;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case]
[case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :, case]
[case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :, case]
[return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, return]
[return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, return]
[return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, return]
[==, n, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, return, parent, ., getFirstChild, (, ), !=]
[case, Token, ., SWITCH, :, case, Token, ., CASE, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case]
[case, Token, ., SWITCH, :, case, Token, ., CASE, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case]
[case, Token, ., CASE, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., DEFAULT_CASE, :, return]
[:, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :]
[:, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :]
[getFirstChild, (, ), !=, n, ;, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, Preconditions, ., checkState, (]
[), !=, n, ;, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, Preconditions, ., checkState, (, isControlStructure, (]
[Token, ., DEFAULT_CASE, :, return, true, ;, default, :, Preconditions, ., checkState, (, isControlStructure, (, parent, ), ), ;, return]
[(, parent, ), ), ;, return, false, ;, }, }, static, Node, getConditionExpression, (, Node, n, ), {, switch, (]
[(, parent, ), ), ;, return, false, ;, }, }, static, Node, getConditionExpression, (, Node, n, ), {, switch, (]
[}, }, static, Node, getConditionExpression, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, }, static, Node, getConditionExpression, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., WHILE, :, return]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., WHILE, :, return]
[), {, case, Token, ., IF, :, case, Token, ., WHILE, :, return, n, ., getFirstChild, (, ), ;, case]
[), {, case, Token, ., IF, :, case, Token, ., WHILE, :, return, n, ., getFirstChild, (, ), ;, case]
[IF, :, case, Token, ., WHILE, :, return, n, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return]
[IF, :, case, Token, ., WHILE, :, return, n, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return]
[return, n, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, ., getLastChild, (, ), ;, case]
[return, n, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, ., getLastChild, (, ), ;, case]
[;, case, Token, ., DO, :, return, n, ., getLastChild, (, ), ;, case, Token, ., FOR, :, switch, (]
[;, case, Token, ., DO, :, return, n, ., getLastChild, (, ), ;, case, Token, ., FOR, :, switch, (]
[., getLastChild, (, ), ;, case, Token, ., FOR, :, switch, (, n, ., getChildCount, (, ), ), {, case]
[), ;, case, Token, ., FOR, :, switch, (, n, ., getChildCount, (, ), ), {, case, 3, :, return]
[Token, ., FOR, :, switch, (, n, ., getChildCount, (, ), ), {, case, 3, :, return, null, ;, case]
[:, switch, (, n, ., getChildCount, (, ), ), {, case, 3, :, return, null, ;, case, 4, :, return]
[:, switch, (, n, ., getChildCount, (, ), ), {, case, 3, :, return, null, ;, case, 4, :, return]
[:, switch, (, n, ., getChildCount, (, ), ), {, case, 3, :, return, null, ;, case, 4, :, return]
[:, return, null, ;, case, 4, :, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, throw]
[;, case, 4, :, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, throw, new, IllegalArgumentException, (]
[;, case, 4, :, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, throw, new, IllegalArgumentException, (]
[4, :, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, throw, new, IllegalArgumentException, (, "malformed 'for' statement ", +]
[., getFirstChild, (, ), ., getNext, (, ), ;, }, throw, new, IllegalArgumentException, (, "malformed 'for' statement ", +, n, ), ;, case]
[., getFirstChild, (, ), ., getNext, (, ), ;, }, throw, new, IllegalArgumentException, (, "malformed 'for' statement ", +, n, ), ;, case]
[getNext, (, ), ;, }, throw, new, IllegalArgumentException, (, "malformed 'for' statement ", +, n, ), ;, case, Token, ., CASE, :, return]
[}, throw, new, IllegalArgumentException, (, "malformed 'for' statement ", +, n, ), ;, case, Token, ., CASE, :, return, null, ;, }, throw]
[IllegalArgumentException, (, "malformed 'for' statement ", +, n, ), ;, case, Token, ., CASE, :, return, null, ;, }, throw, new, IllegalArgumentException, (]
[IllegalArgumentException, (, "malformed 'for' statement ", +, n, ), ;, case, Token, ., CASE, :, return, null, ;, }, throw, new, IllegalArgumentException, (]
["malformed 'for' statement ", +, n, ), ;, case, Token, ., CASE, :, return, null, ;, }, throw, new, IllegalArgumentException, (, n, +]
[}, throw, new, IllegalArgumentException, (, n, +, " does not have a condition.", ), ;, }, static, boolean, isStatementBlock, (, Node, n, ), {, return]
[}, throw, new, IllegalArgumentException, (, n, +, " does not have a condition.", ), ;, }, static, boolean, isStatementBlock, (, Node, n, ), {, return]
[}, throw, new, IllegalArgumentException, (, n, +, " does not have a condition.", ), ;, }, static, boolean, isStatementBlock, (, Node, n, ), {, return]
[+, " does not have a condition.", ), ;, }, static, boolean, isStatementBlock, (, Node, n, ), {, return, n, ., isScript, (, ), ||]
[+, " does not have a condition.", ), ;, }, static, boolean, isStatementBlock, (, Node, n, ), {, return, n, ., isScript, (, ), ||]
[isScript, (, ), ||, n, ., isBlock, (, ), ;, }, static, boolean, isStatement, (, Node, n, ), {, return]
[), ||, n, ., isBlock, (, ), ;, }, static, boolean, isStatement, (, Node, n, ), {, return, isStatementParent, (]
[), ||, n, ., isBlock, (, ), ;, }, static, boolean, isStatement, (, Node, n, ), {, return, isStatementParent, (]
[{, return, isStatementParent, (, n, ., getParent, (, ), ), ;, }, static, boolean, isStatementParent, (, Node, parent, ), {]
[{, return, isStatementParent, (, n, ., getParent, (, ), ), ;, }, static, boolean, isStatementParent, (, Node, parent, ), {]
[n, ., getParent, (, ), ), ;, }, static, boolean, isStatementParent, (, Node, parent, ), {, Preconditions, ., checkState, (]
[n, ., getParent, (, ), ), ;, }, static, boolean, isStatementParent, (, Node, parent, ), {, Preconditions, ., checkState, (]
[getParent, (, ), ), ;, }, static, boolean, isStatementParent, (, Node, parent, ), {, Preconditions, ., checkState, (, parent, !=]
[}, static, boolean, isStatementParent, (, Node, parent, ), {, Preconditions, ., checkState, (, parent, !=, null, ), ;, switch, (]
[}, static, boolean, isStatementParent, (, Node, parent, ), {, Preconditions, ., checkState, (, parent, !=, null, ), ;, switch, (]
[{, Preconditions, ., checkState, (, parent, !=, null, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[{, Preconditions, ., checkState, (, parent, !=, null, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[parent, !=, null, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SCRIPT, :, case]
[parent, !=, null, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SCRIPT, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case]
[(, ), ), {, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, return]
[Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, return, true, ;, default, :, return]
[:, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isSwitchCase, (, Node, n, ), {, return]
[:, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isSwitchCase, (, Node, n, ), {, return]
[:, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isSwitchCase, (, Node, n, ), {, return]
[return, false, ;, }, }, static, boolean, isSwitchCase, (, Node, n, ), {, return, n, ., isCase, (, ), ||]
[return, false, ;, }, }, static, boolean, isSwitchCase, (, Node, n, ), {, return, n, ., isCase, (, ), ||]
[isCase, (, ), ||, n, ., isDefaultCase, (, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {, return]
[isCase, (, ), ||, n, ., isDefaultCase, (, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {, return]
[isCase, (, ), ||, n, ., isDefaultCase, (, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {, return]
[isDefaultCase, (, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {, return, n, ., isName, (, ), &&]
[(, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !]
[(, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !]
[(, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !]
[(, ), ., isEmpty, (, ), ;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return]
[(, ), ., isEmpty, (, ), ;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return]
[(, ), ., isEmpty, (, ), ;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return]
[(, ), ., isEmpty, (, ), ;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return]
[;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return, parent, ., isTry, (, ), &&]
[;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return, parent, ., isTry, (, ), &&]
[;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return, parent, ., isTry, (, ), &&]
[Node, parent, ,, Node, child, ), {, return, parent, ., isTry, (, ), &&, parent, ., getChildCount, (, ), ==]
[,, Node, child, ), {, return, parent, ., isTry, (, ), &&, parent, ., getChildCount, (, ), ==, 3, &&]
[,, Node, child, ), {, return, parent, ., isTry, (, ), &&, parent, ., getChildCount, (, ), ==, 3, &&]
[child, ), {, return, parent, ., isTry, (, ), &&, parent, ., getChildCount, (, ), ==, 3, &&, child, ==]
[child, ), {, return, parent, ., isTry, (, ), &&, parent, ., getChildCount, (, ), ==, 3, &&, child, ==]
[child, ==, parent, ., getLastChild, (, ), ;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =]
[child, ==, parent, ., getLastChild, (, ), ;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =]
[;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return]
[;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return]
[;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return]
[Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return, parent, ., isTry, (, ), &&]
[Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return, parent, ., isTry, (, ), &&]
[Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return, parent, ., isTry, (, ), &&]
[Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return, parent, ., isTry, (, ), &&]
[(, ), ;, return, parent, ., isTry, (, ), &&, parent, ., getFirstChild, (, ), ., getNext, (, ), ==]
[getNext, (, ), ==, n, ;, }, static, void, removeChild, (, Node, parent, ,, Node, node, ), {, if, (]
[), ==, n, ;, }, static, void, removeChild, (, Node, parent, ,, Node, node, ), {, if, (, isTryFinallyNode, (]
[n, ;, }, static, void, removeChild, (, Node, parent, ,, Node, node, ), {, if, (, isTryFinallyNode, (, parent, ,]
[(, Node, parent, ,, Node, node, ), {, if, (, isTryFinallyNode, (, parent, ,, node, ), ), {, if, (]
[(, Node, parent, ,, Node, node, ), {, if, (, isTryFinallyNode, (, parent, ,, node, ), ), {, if, (]
[Node, node, ), {, if, (, isTryFinallyNode, (, parent, ,, node, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (]
[), {, if, (, isTryFinallyNode, (, parent, ,, node, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, getCatchBlock, (]
[(, parent, ,, node, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, getCatchBlock, (, parent, ), ), ), {]
[(, parent, ,, node, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, getCatchBlock, (, parent, ), ), ), {]
[), ), {, if, (, NodeUtil, ., hasCatchHandler, (, getCatchBlock, (, parent, ), ), ), {, parent, ., removeChild, (]
[., hasCatchHandler, (, getCatchBlock, (, parent, ), ), ), {, parent, ., removeChild, (, node, ), ;, }, else, {]
[., hasCatchHandler, (, getCatchBlock, (, parent, ), ), ), {, parent, ., removeChild, (, node, ), ;, }, else, {]
[., removeChild, (, node, ), ;, }, else, {, node, ., detachChildren, (, ), ;, }, }, else, if, (]
[., removeChild, (, node, ), ;, }, else, {, node, ., detachChildren, (, ), ;, }, }, else, if, (]
[., detachChildren, (, ), ;, }, }, else, if, (, node, ., isCatch, (, ), ), {, Node, tryNode, =]
[., detachChildren, (, ), ;, }, }, else, if, (, node, ., isCatch, (, ), ), {, Node, tryNode, =]
[., detachChildren, (, ), ;, }, }, else, if, (, node, ., isCatch, (, ), ), {, Node, tryNode, =]
[node, ., isCatch, (, ), ), {, Node, tryNode, =, node, ., getParent, (, ), ., getParent, (, ), ;]
[node, ., isCatch, (, ), ), {, Node, tryNode, =, node, ., getParent, (, ), ., getParent, (, ), ;]
[), ), {, Node, tryNode, =, node, ., getParent, (, ), ., getParent, (, ), ;, Preconditions, ., checkState, (]
[), ), {, Node, tryNode, =, node, ., getParent, (, ), ., getParent, (, ), ;, Preconditions, ., checkState, (]
[tryNode, =, node, ., getParent, (, ), ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (]
[getParent, (, ), ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;]
[getParent, (, ), ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;]
[checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachFromParent, (, ), ;, }, else, if, (]
[NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachFromParent, (, ), ;, }, else, if, (, isTryCatchNodeContainer, (]
[;, node, ., detachFromParent, (, ), ;, }, else, if, (, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode, =]
[;, node, ., detachFromParent, (, ), ;, }, else, if, (, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode, =]
[;, }, else, if, (, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode, =, node, ., getParent, (, ), ;]
[;, }, else, if, (, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode, =, node, ., getParent, (, ), ;]
[(, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode, =, node, ., getParent, (, ), ;, Preconditions, ., checkState, (]
[(, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode, =, node, ., getParent, (, ), ;, Preconditions, ., checkState, (]
[), ), {, Node, tryNode, =, node, ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (]
[tryNode, =, node, ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;]
[tryNode, =, node, ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;]
[checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachChildren, (, ), ;, }, else, if, (]
[checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachChildren, (, ), ;, }, else, if, (]
[), ), ;, node, ., detachChildren, (, ), ;, }, else, if, (, node, ., isBlock, (, ), ), {]
[), ), ;, node, ., detachChildren, (, ), ;, }, else, if, (, node, ., isBlock, (, ), ), {]
[else, if, (, node, ., isBlock, (, ), ), {, node, ., detachChildren, (, ), ;, }, else, if, (]
[else, if, (, node, ., isBlock, (, ), ), {, node, ., detachChildren, (, ), ;, }, else, if, (]
[(, node, ., isBlock, (, ), ), {, node, ., detachChildren, (, ), ;, }, else, if, (, isStatementBlock, (]
[isBlock, (, ), ), {, node, ., detachChildren, (, ), ;, }, else, if, (, isStatementBlock, (, parent, ), ||]
[), ), {, node, ., detachChildren, (, ), ;, }, else, if, (, isStatementBlock, (, parent, ), ||, isSwitchCase, (]
[., detachChildren, (, ), ;, }, else, if, (, isStatementBlock, (, parent, ), ||, isSwitchCase, (, node, ), ), {]
[., detachChildren, (, ), ;, }, else, if, (, isStatementBlock, (, parent, ), ||, isSwitchCase, (, node, ), ), {]
[;, }, else, if, (, isStatementBlock, (, parent, ), ||, isSwitchCase, (, node, ), ), {, parent, ., removeChild, (]
[parent, ), ||, isSwitchCase, (, node, ), ), {, parent, ., removeChild, (, node, ), ;, }, else, if, (]
[parent, ), ||, isSwitchCase, (, node, ), ), {, parent, ., removeChild, (, node, ), ;, }, else, if, (]
[parent, ., removeChild, (, node, ), ;, }, else, if, (, parent, ., isVar, (, ), ), {, if, (]
[parent, ., removeChild, (, node, ), ;, }, else, if, (, parent, ., isVar, (, ), ), {, if, (]
[}, else, if, (, parent, ., isVar, (, ), ), {, if, (, parent, ., hasMoreThanOneChild, (, ), ), {]
[}, else, if, (, parent, ., isVar, (, ), ), {, if, (, parent, ., hasMoreThanOneChild, (, ), ), {]
[parent, ., isVar, (, ), ), {, if, (, parent, ., hasMoreThanOneChild, (, ), ), {, parent, ., removeChild, (]
[{, if, (, parent, ., hasMoreThanOneChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, }, else, {]
[{, if, (, parent, ., hasMoreThanOneChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, }, else, {]
[., hasMoreThanOneChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, }, else, {, parent, ., removeChild, (]
[), ), {, parent, ., removeChild, (, node, ), ;, }, else, {, parent, ., removeChild, (, node, ), ;]
[{, parent, ., removeChild, (, node, ), ;, }, else, {, parent, ., removeChild, (, node, ), ;, removeChild, (]
[{, parent, ., removeChild, (, node, ), ;, }, else, {, parent, ., removeChild, (, node, ), ;, removeChild, (]
[), ;, }, else, {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,]
[(, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, }, else, if, (]
[(, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, }, else, if, (]
[(, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, }, else, if, (]
[parent, ., getParent, (, ), ,, parent, ), ;, }, }, else, if, (, parent, ., isLabel, (, ), &&]
[parent, ., getParent, (, ), ,, parent, ), ;, }, }, else, if, (, parent, ., isLabel, (, ), &&]
[getParent, (, ), ,, parent, ), ;, }, }, else, if, (, parent, ., isLabel, (, ), &&, node, ==]
[getParent, (, ), ,, parent, ), ;, }, }, else, if, (, parent, ., isLabel, (, ), &&, node, ==]
[}, }, else, if, (, parent, ., isLabel, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {]
[}, }, else, if, (, parent, ., isLabel, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {]
[(, parent, ., isLabel, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (]
[isLabel, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, node, ), ;]
[), &&, node, ==, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, removeChild, (]
[), &&, node, ==, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, removeChild, (]
[getLastChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,]
[removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, else, if, (]
[removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, else, if, (]
[removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, else, if, (]
[(, parent, ., getParent, (, ), ,, parent, ), ;, }, else, if, (, parent, ., isFor, (, ), &&]
[(, parent, ., getParent, (, ), ,, parent, ), ;, }, else, if, (, parent, ., isFor, (, ), &&]
[(, parent, ., getParent, (, ), ,, parent, ), ;, }, else, if, (, parent, ., isFor, (, ), &&]
[,, parent, ), ;, }, else, if, (, parent, ., isFor, (, ), &&, parent, ., getChildCount, (, ), ==]
[;, }, else, if, (, parent, ., isFor, (, ), &&, parent, ., getChildCount, (, ), ==, 4, ), {]
[;, }, else, if, (, parent, ., isFor, (, ), &&, parent, ., getChildCount, (, ), ==, 4, ), {]
[(, parent, ., isFor, (, ), &&, parent, ., getChildCount, (, ), ==, 4, ), {, parent, ., replaceChild, (]
[., isFor, (, ), &&, parent, ., getChildCount, (, ), ==, 4, ), {, parent, ., replaceChild, (, node, ,]
[., isFor, (, ), &&, parent, ., getChildCount, (, ), ==, 4, ), {, parent, ., replaceChild, (, node, ,]
[4, ), {, parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw]
[parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (]
[parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (]
[parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (]
[parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (]
[replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: ", +]
[replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: ", +]
[empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: ", +, node, ., toString, (, ), +]
[), ), ;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: ", +, node, ., toString, (, ), +, " of ", +]
[), ), ;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: ", +, node, ., toString, (, ), +, " of ", +]
[+, " of ", +, parent, ., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {]
[+, " of ", +, parent, ., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {]
[., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {, Preconditions, ., checkState, (]
[., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {, Preconditions, ., checkState, (]
[void, maybeAddFinally, (, Node, tryNode, ), {, Preconditions, ., checkState, (, tryNode, ., isTry, (, ), ), ;, if, (]
[maybeAddFinally, (, Node, tryNode, ), {, Preconditions, ., checkState, (, tryNode, ., isTry, (, ), ), ;, if, (, !]
[maybeAddFinally, (, Node, tryNode, ), {, Preconditions, ., checkState, (, tryNode, ., isTry, (, ), ), ;, if, (, !]
[), {, Preconditions, ., checkState, (, tryNode, ., isTry, (, ), ), ;, if, (, !, NodeUtil, ., hasFinally, (]
[checkState, (, tryNode, ., isTry, (, ), ), ;, if, (, !, NodeUtil, ., hasFinally, (, tryNode, ), ), {]
[checkState, (, tryNode, ., isTry, (, ), ), ;, if, (, !, NodeUtil, ., hasFinally, (, tryNode, ), ), {]
[isTry, (, ), ), ;, if, (, !, NodeUtil, ., hasFinally, (, tryNode, ), ), {, tryNode, ., addChildrenToBack, (]
[isTry, (, ), ), ;, if, (, !, NodeUtil, ., hasFinally, (, tryNode, ), ), {, tryNode, ., addChildrenToBack, (]
[isTry, (, ), ), ;, if, (, !, NodeUtil, ., hasFinally, (, tryNode, ), ), {, tryNode, ., addChildrenToBack, (]
[NodeUtil, ., hasFinally, (, tryNode, ), ), {, tryNode, ., addChildrenToBack, (, IR, ., block, (, ), ., srcref, (]
[block, (, ), ., srcref, (, tryNode, ), ), ;, }, }, static, boolean, tryMergeBlock, (, Node, block, ), {]
[block, (, ), ., srcref, (, tryNode, ), ), ;, }, }, static, boolean, tryMergeBlock, (, Node, block, ), {]
[srcref, (, tryNode, ), ), ;, }, }, static, boolean, tryMergeBlock, (, Node, block, ), {, Preconditions, ., checkState, (]
[srcref, (, tryNode, ), ), ;, }, }, static, boolean, tryMergeBlock, (, Node, block, ), {, Preconditions, ., checkState, (]
[tryMergeBlock, (, Node, block, ), {, Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, Node, parent, =]
[tryMergeBlock, (, Node, block, ), {, Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, Node, parent, =]
[checkState, (, block, ., isBlock, (, ), ), ;, Node, parent, =, block, ., getParent, (, ), ;, if, (]
[block, ., isBlock, (, ), ), ;, Node, parent, =, block, ., getParent, (, ), ;, if, (, isStatementBlock, (]
[Node, parent, =, block, ., getParent, (, ), ;, if, (, isStatementBlock, (, parent, ), ), {, Node, previous, =]
[., getParent, (, ), ;, if, (, isStatementBlock, (, parent, ), ), {, Node, previous, =, block, ;, while, (]
[., getParent, (, ), ;, if, (, isStatementBlock, (, parent, ), ), {, Node, previous, =, block, ;, while, (]
[), ), {, Node, previous, =, block, ;, while, (, block, ., hasChildren, (, ), ), {, Node, child, =]
[), ), {, Node, previous, =, block, ;, while, (, block, ., hasChildren, (, ), ), {, Node, child, =]
[block, ;, while, (, block, ., hasChildren, (, ), ), {, Node, child, =, block, ., removeFirstChild, (, ), ;]
[block, ;, while, (, block, ., hasChildren, (, ), ), {, Node, child, =, block, ., removeFirstChild, (, ), ;]
[block, ., hasChildren, (, ), ), {, Node, child, =, block, ., removeFirstChild, (, ), ;, parent, ., addChildAfter, (]
[hasChildren, (, ), ), {, Node, child, =, block, ., removeFirstChild, (, ), ;, parent, ., addChildAfter, (, child, ,]
[), {, Node, child, =, block, ., removeFirstChild, (, ), ;, parent, ., addChildAfter, (, child, ,, previous, ), ;]
[Node, child, =, block, ., removeFirstChild, (, ), ;, parent, ., addChildAfter, (, child, ,, previous, ), ;, previous, =]
[block, ., removeFirstChild, (, ), ;, parent, ., addChildAfter, (, child, ,, previous, ), ;, previous, =, child, ;, }]
[block, ., removeFirstChild, (, ), ;, parent, ., addChildAfter, (, child, ,, previous, ), ;, previous, =, child, ;, }]
[), ;, parent, ., addChildAfter, (, child, ,, previous, ), ;, previous, =, child, ;, }, parent, ., removeChild, (]
[addChildAfter, (, child, ,, previous, ), ;, previous, =, child, ;, }, parent, ., removeChild, (, block, ), ;, return]
[;, previous, =, child, ;, }, parent, ., removeChild, (, block, ), ;, return, true, ;, }, else, {, return]
[return, true, ;, }, else, {, return, false, ;, }, }, static, boolean, isCallOrNew, (, Node, node, ), {, return]
[return, true, ;, }, else, {, return, false, ;, }, }, static, boolean, isCallOrNew, (, Node, node, ), {, return]
[return, true, ;, }, else, {, return, false, ;, }, }, static, boolean, isCallOrNew, (, Node, node, ), {, return]
[return, false, ;, }, }, static, boolean, isCallOrNew, (, Node, node, ), {, return, node, ., isCall, (, ), ||]
[return, false, ;, }, }, static, boolean, isCallOrNew, (, Node, node, ), {, return, node, ., isCall, (, ), ||]
[., isCall, (, ), ||, node, ., isNew, (, ), ;, }, static, Node, getFunctionBody, (, Node, fn, ), {]
[., isCall, (, ), ||, node, ., isNew, (, ), ;, }, static, Node, getFunctionBody, (, Node, fn, ), {]
[||, node, ., isNew, (, ), ;, }, static, Node, getFunctionBody, (, Node, fn, ), {, Preconditions, ., checkArgument, (]
[||, node, ., isNew, (, ), ;, }, static, Node, getFunctionBody, (, Node, fn, ), {, Preconditions, ., checkArgument, (]
[static, Node, getFunctionBody, (, Node, fn, ), {, Preconditions, ., checkArgument, (, fn, ., isFunction, (, ), ), ;, return]
[static, Node, getFunctionBody, (, Node, fn, ), {, Preconditions, ., checkArgument, (, fn, ., isFunction, (, ), ), ;, return]
[), ), ;, return, fn, ., getLastChild, (, ), ;, }, static, boolean, isFunctionDeclaration, (, Node, n, ), {, return]
[), ), ;, return, fn, ., getLastChild, (, ), ;, }, static, boolean, isFunctionDeclaration, (, Node, n, ), {, return]
[), ), ;, return, fn, ., getLastChild, (, ), ;, }, static, boolean, isFunctionDeclaration, (, Node, n, ), {, return]
[getLastChild, (, ), ;, }, static, boolean, isFunctionDeclaration, (, Node, n, ), {, return, n, ., isFunction, (, ), &&]
[), ;, }, static, boolean, isFunctionDeclaration, (, Node, n, ), {, return, n, ., isFunction, (, ), &&, isStatement, (]
[., isFunction, (, ), &&, isStatement, (, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return]
[., isFunction, (, ), &&, isStatement, (, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return]
[(, ), &&, isStatement, (, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (]
[isStatement, (, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), &&]
[(, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), &&, (]
[(, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), &&, (]
[(, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), &&, (]
[(, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), &&, (]
[n, ), {, return, isFunctionDeclaration, (, n, ), &&, (, n, ., getParent, (, ), ., isScript, (, ), ||]
[n, ), {, return, isFunctionDeclaration, (, n, ), &&, (, n, ., getParent, (, ), ., isScript, (, ), ||]
[n, ), {, return, isFunctionDeclaration, (, n, ), &&, (, n, ., getParent, (, ), ., isScript, (, ), ||]
[n, ), {, return, isFunctionDeclaration, (, n, ), &&, (, n, ., getParent, (, ), ., isScript, (, ), ||]
[., getParent, (, ), ., isFunction, (, ), ), ;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return]
[., getParent, (, ), ., isFunction, (, ), ), ;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return]
[., getParent, (, ), ., isFunction, (, ), ), ;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return]
[(, ), ), ;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return, n, ., isFunction, (, ), &&]
[), ), ;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return, n, ., isFunction, (, ), &&, !]
[;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return, n, ., isFunction, (, ), &&, !, isStatement, (]
[isFunction, (, ), &&, !, isStatement, (, n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return]
[isFunction, (, ), &&, !, isStatement, (, n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return]
[isFunction, (, ), &&, !, isStatement, (, n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return]
[isFunction, (, ), &&, !, isStatement, (, n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return]
[(, n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return, n, ., isName, (, ), &&]
[n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !]
[n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !]
[n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !]
[), {, return, n, ., isName, (, ), &&, !, n, ., getString, (, ), ., isEmpty, (, ), &&]
[return, n, ., isName, (, ), &&, !, n, ., getString, (, ), ., isEmpty, (, ), &&, isFunctionExpression, (]
[return, n, ., isName, (, ), &&, !, n, ., getString, (, ), ., isEmpty, (, ), &&, isFunctionExpression, (]
[&&, isFunctionExpression, (, n, ., getParent, (, ), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return]
[&&, isFunctionExpression, (, n, ., getParent, (, ), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return]
[(, n, ., getParent, (, ), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return, isFunctionExpression, (]
[getParent, (, ), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return, isFunctionExpression, (, node, ), &&]
[), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return, isFunctionExpression, (, node, ), &&, isEmptyBlock, (]
[), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return, isFunctionExpression, (, node, ), &&, isEmptyBlock, (]
[), &&, isEmptyBlock, (, node, ., getLastChild, (, ), ), ;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {]
[), &&, isEmptyBlock, (, node, ., getLastChild, (, ), ), ;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {]
[node, ., getLastChild, (, ), ), ;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {, Preconditions, ., checkArgument, (]
[node, ., getLastChild, (, ), ), ;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {, Preconditions, ., checkArgument, (]
[static, boolean, isVarArgsFunction, (, Node, function, ), {, Preconditions, ., checkArgument, (, function, ., isFunction, (, ), ), ;, return]
[isVarArgsFunction, (, Node, function, ), {, Preconditions, ., checkArgument, (, function, ., isFunction, (, ), ), ;, return, isNameReferenced, (]
[isVarArgsFunction, (, Node, function, ), {, Preconditions, ., checkArgument, (, function, ., isFunction, (, ), ), ;, return, isNameReferenced, (]
[Preconditions, ., checkArgument, (, function, ., isFunction, (, ), ), ;, return, isNameReferenced, (, function, ., getLastChild, (, ), ,]
[checkArgument, (, function, ., isFunction, (, ), ), ;, return, isNameReferenced, (, function, ., getLastChild, (, ), ,, "arguments", ,]
[,, "arguments", ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isObjectCallMethod, (, Node, callNode, ,, String, methodName, ), {, if, (]
[,, "arguments", ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isObjectCallMethod, (, Node, callNode, ,, String, methodName, ), {, if, (]
[(, Node, callNode, ,, String, methodName, ), {, if, (, callNode, ., isCall, (, ), ), {, Node, functionIndentifyingExpression, =]
[(, Node, callNode, ,, String, methodName, ), {, if, (, callNode, ., isCall, (, ), ), {, Node, functionIndentifyingExpression, =]
[if, (, callNode, ., isCall, (, ), ), {, Node, functionIndentifyingExpression, =, callNode, ., getFirstChild, (, ), ;, if, (]
[callNode, ., isCall, (, ), ), {, Node, functionIndentifyingExpression, =, callNode, ., getFirstChild, (, ), ;, if, (, isGet, (]
[Node, functionIndentifyingExpression, =, callNode, ., getFirstChild, (, ), ;, if, (, isGet, (, functionIndentifyingExpression, ), ), {, Node, last, =]
[Node, functionIndentifyingExpression, =, callNode, ., getFirstChild, (, ), ;, if, (, isGet, (, functionIndentifyingExpression, ), ), {, Node, last, =]
[;, if, (, isGet, (, functionIndentifyingExpression, ), ), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (, ), ;, if, (]
[;, if, (, isGet, (, functionIndentifyingExpression, ), ), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (, ), ;, if, (]
[;, if, (, isGet, (, functionIndentifyingExpression, ), ), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (, ), ;, if, (]
[(, isGet, (, functionIndentifyingExpression, ), ), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (, ), ;, if, (, last, !=]
[(, functionIndentifyingExpression, ), ), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (, ), ;, if, (, last, !=, null, &&]
[(, functionIndentifyingExpression, ), ), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (, ), ;, if, (, last, !=, null, &&]
[getLastChild, (, ), ;, if, (, last, !=, null, &&, last, ., isString, (, ), ), {, String, propName, =]
[getLastChild, (, ), ;, if, (, last, !=, null, &&, last, ., isString, (, ), ), {, String, propName, =]
[!=, null, &&, last, ., isString, (, ), ), {, String, propName, =, last, ., getString, (, ), ;, return]
[null, &&, last, ., isString, (, ), ), {, String, propName, =, last, ., getString, (, ), ;, return, (]
[null, &&, last, ., isString, (, ), ), {, String, propName, =, last, ., getString, (, ), ;, return, (]
[isString, (, ), ), {, String, propName, =, last, ., getString, (, ), ;, return, (, propName, ., equals, (]
[last, ., getString, (, ), ;, return, (, propName, ., equals, (, methodName, ), ), ;, }, }, }, return]
[methodName, ), ), ;, }, }, }, return, false, ;, }, static, boolean, isFunctionObjectCall, (, Node, callNode, ), {, return]
[), ;, }, }, }, return, false, ;, }, static, boolean, isFunctionObjectCall, (, Node, callNode, ), {, return, isObjectCallMethod, (]
[}, }, }, return, false, ;, }, static, boolean, isFunctionObjectCall, (, Node, callNode, ), {, return, isObjectCallMethod, (, callNode, ,]
[), {, return, isObjectCallMethod, (, callNode, ,, "call", ), ;, }, static, boolean, isFunctionObjectApply, (, Node, callNode, ), {, return]
[return, isObjectCallMethod, (, callNode, ,, "call", ), ;, }, static, boolean, isFunctionObjectApply, (, Node, callNode, ), {, return, isObjectCallMethod, (]
[(, callNode, ,, "call", ), ;, }, static, boolean, isFunctionObjectApply, (, Node, callNode, ), {, return, isObjectCallMethod, (, callNode, ,]
[isObjectCallMethod, (, callNode, ,, "apply", ), ;, }, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return]
[isObjectCallMethod, (, callNode, ,, "apply", ), ;, }, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return]
[(, callNode, ,, "apply", ), ;, }, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return, (]
[(, callNode, ,, "apply", ), ;, }, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return, (]
[(, callNode, ,, "apply", ), ;, }, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return, (]
[}, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return, (, parent, ., isAssign, (, ), &&]
[}, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return, (, parent, ., isAssign, (, ), &&]
[}, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return, (, parent, ., isAssign, (, ), &&]
[n, ,, Node, parent, ), {, return, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==]
[parent, ), {, return, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[parent, ), {, return, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[==, n, ), ||, parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {]
[==, n, ), ||, parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {]
[parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[}, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isName, (, ), ||]
[}, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isName, (, ), ||]
[Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isName, (, ), ||, n, ., isGetProp, (, ), ||]
[Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isName, (, ), ||, n, ., isGetProp, (, ), ||]
[isName, (, ), ||, n, ., isGetProp, (, ), ||, n, ., isGetElem, (, ), ), ;, Node, parent, =]
[isName, (, ), ||, n, ., isGetProp, (, ), ||, n, ., isGetElem, (, ), ), ;, Node, parent, =]
[), ||, n, ., isGetElem, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[), ||, n, ., isGetElem, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[n, ., isGetElem, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==]
[), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return]
[parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return]
[parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return]
[parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return]
[parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return]
[parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return]
[parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return]
[parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return]
[parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return]
[=, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return, (]
[=, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return, (]
[=, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return, (]
[(, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return, (, NodeUtil, ., isAssignmentOp, (]
[if, (, parent, ==, null, ), {, return, false, ;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&]
[if, (, parent, ==, null, ), {, return, false, ;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&]
[if, (, parent, ==, null, ), {, return, false, ;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&]
[{, return, false, ;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==]
[;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[}, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, (]
[}, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, (]
[}, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, (]
[., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, (, NodeUtil, ., isForIn, (]
[parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&]
[parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&]
[parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&]
[(, ), ==, n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==]
[n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||]
[(, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||, (]
[(, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||, (]
[(, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||, (]
[getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&]
[getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&]
[getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&]
[||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==]
[isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isDec, (, ), ||]
[., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isDec, (, ), ||]
[., getFirstChild, (, ), ==, n, ), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||]
[., getFirstChild, (, ), ==, n, ), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||]
[), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||]
[), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||]
[parent, ., isCatch, (, ), ;, }, static, boolean, isObjectLitKey, (, Node, node, ,, Node, parent, ), {, switch, (]
[parent, ., isCatch, (, ), ;, }, static, boolean, isObjectLitKey, (, Node, node, ,, Node, parent, ), {, switch, (]
[boolean, isObjectLitKey, (, Node, node, ,, Node, parent, ), {, switch, (, node, ., getType, (, ), ), {, case]
[boolean, isObjectLitKey, (, Node, node, ,, Node, parent, ), {, switch, (, node, ., getType, (, ), ), {, case]
[,, Node, parent, ), {, switch, (, node, ., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case]
[,, Node, parent, ), {, switch, (, node, ., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case]
[switch, (, node, ., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case]
[switch, (, node, ., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case]
[(, ), ), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return]
[case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, true, ;, }, return]
[SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static, String, getObjectLitKeyName, (, Node, key, ), {, switch, (]
[SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static, String, getObjectLitKeyName, (, Node, key, ), {, switch, (]
[;, }, static, String, getObjectLitKeyName, (, Node, key, ), {, switch, (, key, ., getType, (, ), ), {, case]
[;, }, static, String, getObjectLitKeyName, (, Node, key, ), {, switch, (, key, ., getType, (, ), ), {, case]
[(, Node, key, ), {, switch, (, key, ., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case]
[(, Node, key, ), {, switch, (, key, ., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case]
[switch, (, key, ., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case]
[switch, (, key, ., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case]
[(, ), ), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return]
[(, ), ), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return]
[:, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, key, ., getString, (, ), ;, }, throw]
[., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, key, ., getString, (, ), ;, }, throw, new, IllegalStateException, (]
[., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, key, ., getString, (, ), ;, }, throw, new, IllegalStateException, (]
[:, case, Token, ., SETTER_DEF, :, return, key, ., getString, (, ), ;, }, throw, new, IllegalStateException, (, "Unexpected node type: ", +]
[(, "Unexpected node type: ", +, key, ), ;, }, static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType, valueType, ), {, if, (]
[(, "Unexpected node type: ", +, key, ), ;, }, static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType, valueType, ), {, if, (]
[+, key, ), ;, }, static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType, valueType, ), {, if, (, valueType, !=]
[static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType, valueType, ), {, if, (, valueType, !=, null, ), {, switch, (]
[static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType, valueType, ), {, if, (, valueType, !=, null, ), {, switch, (]
[valueType, ), {, if, (, valueType, !=, null, ), {, switch, (, key, ., getType, (, ), ), {, case]
[valueType, ), {, if, (, valueType, !=, null, ), {, switch, (, key, ., getType, (, ), ), {, case]
[!=, null, ), {, switch, (, key, ., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, if, (]
[!=, null, ), {, switch, (, key, ., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, if, (]
[), ), {, case, Token, ., GETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =]
[), ), {, case, Token, ., GETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =]
[GETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;]
[if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, valueType, =]
[if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, valueType, =]
[fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, valueType, =, fntype, ., getReturnType, (, ), ;, }, else, {, return]
[), ;, valueType, =, fntype, ., getReturnType, (, ), ;, }, else, {, return, null, ;, }, break, ;, case]
[), ;, valueType, =, fntype, ., getReturnType, (, ), ;, }, else, {, return, null, ;, }, break, ;, case]
[getReturnType, (, ), ;, }, else, {, return, null, ;, }, break, ;, case, Token, ., SETTER_DEF, :, if, (]
[getReturnType, (, ), ;, }, else, {, return, null, ;, }, break, ;, case, Token, ., SETTER_DEF, :, if, (]
[}, break, ;, case, Token, ., SETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =]
[}, break, ;, case, Token, ., SETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =]
[(, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, Node, param, =]
[(, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, Node, param, =]
[(, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, Node, param, =]
[=, valueType, ., toMaybeFunctionType, (, ), ;, Node, param, =, fntype, ., getParametersNode, (, ), ., getFirstChild, (, ), ;]
[., toMaybeFunctionType, (, ), ;, Node, param, =, fntype, ., getParametersNode, (, ), ., getFirstChild, (, ), ;, valueType, =]
[., toMaybeFunctionType, (, ), ;, Node, param, =, fntype, ., getParametersNode, (, ), ., getFirstChild, (, ), ;, valueType, =]
[getParametersNode, (, ), ., getFirstChild, (, ), ;, valueType, =, param, ., getJSType, (, ), ;, }, else, {, return]
[valueType, =, param, ., getJSType, (, ), ;, }, else, {, return, null, ;, }, break, ;, }, }, return]
[;, }, break, ;, }, }, return, valueType, ;, }, static, boolean, isGetOrSetKey, (, Node, node, ), {, switch, (]
[;, }, break, ;, }, }, return, valueType, ;, }, static, boolean, isGetOrSetKey, (, Node, node, ), {, switch, (]
[;, }, static, boolean, isGetOrSetKey, (, Node, node, ), {, switch, (, node, ., getType, (, ), ), {, case]
[;, }, static, boolean, isGetOrSetKey, (, Node, node, ), {, switch, (, node, ., getType, (, ), ), {, case]
[(, Node, node, ), {, switch, (, node, ., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, case]
[(, Node, node, ), {, switch, (, node, ., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, case]
[switch, (, node, ., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return]
[getType, (, ), ), {, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, true, ;, }, return]
[SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static, String, opToStr, (, int, operator, ), {, switch, (]
[;, }, return, false, ;, }, static, String, opToStr, (, int, operator, ), {, switch, (, operator, ), {, case]
[;, }, return, false, ;, }, static, String, opToStr, (, int, operator, ), {, switch, (, operator, ), {, case]
[}, static, String, opToStr, (, int, operator, ), {, switch, (, operator, ), {, case, Token, ., BITOR, :, return]
[opToStr, (, int, operator, ), {, switch, (, operator, ), {, case, Token, ., BITOR, :, return, "|", ;, case]
[opToStr, (, int, operator, ), {, switch, (, operator, ), {, case, Token, ., BITOR, :, return, "|", ;, case]
[{, switch, (, operator, ), {, case, Token, ., BITOR, :, return, "|", ;, case, Token, ., OR, :, return]
[operator, ), {, case, Token, ., BITOR, :, return, "|", ;, case, Token, ., OR, :, return, "||", ;, case]
[operator, ), {, case, Token, ., BITOR, :, return, "|", ;, case, Token, ., OR, :, return, "||", ;, case]
[., BITOR, :, return, "|", ;, case, Token, ., OR, :, return, "||", ;, case, Token, ., BITXOR, :, return]
[return, "|", ;, case, Token, ., OR, :, return, "||", ;, case, Token, ., BITXOR, :, return, "^", ;, case]
[return, "|", ;, case, Token, ., OR, :, return, "||", ;, case, Token, ., BITXOR, :, return, "^", ;, case]
[., OR, :, return, "||", ;, case, Token, ., BITXOR, :, return, "^", ;, case, Token, ., AND, :, return]
[return, "||", ;, case, Token, ., BITXOR, :, return, "^", ;, case, Token, ., AND, :, return, "&&", ;, case]
[return, "||", ;, case, Token, ., BITXOR, :, return, "^", ;, case, Token, ., AND, :, return, "&&", ;, case]
[., BITXOR, :, return, "^", ;, case, Token, ., AND, :, return, "&&", ;, case, Token, ., BITAND, :, return]
[return, "^", ;, case, Token, ., AND, :, return, "&&", ;, case, Token, ., BITAND, :, return, "&", ;, case]
[return, "^", ;, case, Token, ., AND, :, return, "&&", ;, case, Token, ., BITAND, :, return, "&", ;, case]
[., AND, :, return, "&&", ;, case, Token, ., BITAND, :, return, "&", ;, case, Token, ., SHEQ, :, return]
[return, "&&", ;, case, Token, ., BITAND, :, return, "&", ;, case, Token, ., SHEQ, :, return, "===", ;, case]
[return, "&&", ;, case, Token, ., BITAND, :, return, "&", ;, case, Token, ., SHEQ, :, return, "===", ;, case]
[., BITAND, :, return, "&", ;, case, Token, ., SHEQ, :, return, "===", ;, case, Token, ., EQ, :, return]
[return, "&", ;, case, Token, ., SHEQ, :, return, "===", ;, case, Token, ., EQ, :, return, "==", ;, case]
[return, "&", ;, case, Token, ., SHEQ, :, return, "===", ;, case, Token, ., EQ, :, return, "==", ;, case]
[., SHEQ, :, return, "===", ;, case, Token, ., EQ, :, return, "==", ;, case, Token, ., NOT, :, return]
[return, "===", ;, case, Token, ., EQ, :, return, "==", ;, case, Token, ., NOT, :, return, "!", ;, case]
[return, "===", ;, case, Token, ., EQ, :, return, "==", ;, case, Token, ., NOT, :, return, "!", ;, case]
[., EQ, :, return, "==", ;, case, Token, ., NOT, :, return, "!", ;, case, Token, ., NE, :, return]
[return, "==", ;, case, Token, ., NOT, :, return, "!", ;, case, Token, ., NE, :, return, "!=", ;, case]
[return, "==", ;, case, Token, ., NOT, :, return, "!", ;, case, Token, ., NE, :, return, "!=", ;, case]
[., NOT, :, return, "!", ;, case, Token, ., NE, :, return, "!=", ;, case, Token, ., SHNE, :, return]
[return, "!", ;, case, Token, ., NE, :, return, "!=", ;, case, Token, ., SHNE, :, return, "!==", ;, case]
[return, "!", ;, case, Token, ., NE, :, return, "!=", ;, case, Token, ., SHNE, :, return, "!==", ;, case]
[., NE, :, return, "!=", ;, case, Token, ., SHNE, :, return, "!==", ;, case, Token, ., LSH, :, return]
[return, "!=", ;, case, Token, ., SHNE, :, return, "!==", ;, case, Token, ., LSH, :, return, "<<", ;, case]
[return, "!=", ;, case, Token, ., SHNE, :, return, "!==", ;, case, Token, ., LSH, :, return, "<<", ;, case]
[., SHNE, :, return, "!==", ;, case, Token, ., LSH, :, return, "<<", ;, case, Token, ., IN, :, return]
[return, "!==", ;, case, Token, ., LSH, :, return, "<<", ;, case, Token, ., IN, :, return, "in", ;, case]
[return, "!==", ;, case, Token, ., LSH, :, return, "<<", ;, case, Token, ., IN, :, return, "in", ;, case]
[., LSH, :, return, "<<", ;, case, Token, ., IN, :, return, "in", ;, case, Token, ., LE, :, return]
[return, "<<", ;, case, Token, ., IN, :, return, "in", ;, case, Token, ., LE, :, return, "<=", ;, case]
[return, "<<", ;, case, Token, ., IN, :, return, "in", ;, case, Token, ., LE, :, return, "<=", ;, case]
[., IN, :, return, "in", ;, case, Token, ., LE, :, return, "<=", ;, case, Token, ., LT, :, return]
[return, "in", ;, case, Token, ., LE, :, return, "<=", ;, case, Token, ., LT, :, return, "<", ;, case]
[return, "in", ;, case, Token, ., LE, :, return, "<=", ;, case, Token, ., LT, :, return, "<", ;, case]
[., LE, :, return, "<=", ;, case, Token, ., LT, :, return, "<", ;, case, Token, ., URSH, :, return]
[return, "<=", ;, case, Token, ., LT, :, return, "<", ;, case, Token, ., URSH, :, return, ">>>", ;, case]
[return, "<=", ;, case, Token, ., LT, :, return, "<", ;, case, Token, ., URSH, :, return, ">>>", ;, case]
[., LT, :, return, "<", ;, case, Token, ., URSH, :, return, ">>>", ;, case, Token, ., RSH, :, return]
[return, "<", ;, case, Token, ., URSH, :, return, ">>>", ;, case, Token, ., RSH, :, return, ">>", ;, case]
[return, "<", ;, case, Token, ., URSH, :, return, ">>>", ;, case, Token, ., RSH, :, return, ">>", ;, case]
[., URSH, :, return, ">>>", ;, case, Token, ., RSH, :, return, ">>", ;, case, Token, ., GE, :, return]
[return, ">>>", ;, case, Token, ., RSH, :, return, ">>", ;, case, Token, ., GE, :, return, ">=", ;, case]
[return, ">>>", ;, case, Token, ., RSH, :, return, ">>", ;, case, Token, ., GE, :, return, ">=", ;, case]
[., RSH, :, return, ">>", ;, case, Token, ., GE, :, return, ">=", ;, case, Token, ., GT, :, return]
[return, ">>", ;, case, Token, ., GE, :, return, ">=", ;, case, Token, ., GT, :, return, ">", ;, case]
[return, ">>", ;, case, Token, ., GE, :, return, ">=", ;, case, Token, ., GT, :, return, ">", ;, case]
[., GE, :, return, ">=", ;, case, Token, ., GT, :, return, ">", ;, case, Token, ., MUL, :, return]
[return, ">=", ;, case, Token, ., GT, :, return, ">", ;, case, Token, ., MUL, :, return, "*", ;, case]
[return, ">=", ;, case, Token, ., GT, :, return, ">", ;, case, Token, ., MUL, :, return, "*", ;, case]
[., GT, :, return, ">", ;, case, Token, ., MUL, :, return, "*", ;, case, Token, ., DIV, :, return]
[return, ">", ;, case, Token, ., MUL, :, return, "*", ;, case, Token, ., DIV, :, return, "/", ;, case]
[return, ">", ;, case, Token, ., MUL, :, return, "*", ;, case, Token, ., DIV, :, return, "/", ;, case]
[., MUL, :, return, "*", ;, case, Token, ., DIV, :, return, "/", ;, case, Token, ., MOD, :, return]
[return, "*", ;, case, Token, ., DIV, :, return, "/", ;, case, Token, ., MOD, :, return, "%", ;, case]
[return, "*", ;, case, Token, ., DIV, :, return, "/", ;, case, Token, ., MOD, :, return, "%", ;, case]
[., DIV, :, return, "/", ;, case, Token, ., MOD, :, return, "%", ;, case, Token, ., BITNOT, :, return]
[return, "/", ;, case, Token, ., MOD, :, return, "%", ;, case, Token, ., BITNOT, :, return, "~", ;, case]
[return, "/", ;, case, Token, ., MOD, :, return, "%", ;, case, Token, ., BITNOT, :, return, "~", ;, case]
[., MOD, :, return, "%", ;, case, Token, ., BITNOT, :, return, "~", ;, case, Token, ., ADD, :, return]
[return, "%", ;, case, Token, ., BITNOT, :, return, "~", ;, case, Token, ., ADD, :, return, "+", ;, case]
[return, "%", ;, case, Token, ., BITNOT, :, return, "~", ;, case, Token, ., ADD, :, return, "+", ;, case]
[., BITNOT, :, return, "~", ;, case, Token, ., ADD, :, return, "+", ;, case, Token, ., SUB, :, return]
[return, "~", ;, case, Token, ., ADD, :, return, "+", ;, case, Token, ., SUB, :, return, "-", ;, case]
[return, "~", ;, case, Token, ., ADD, :, return, "+", ;, case, Token, ., SUB, :, return, "-", ;, case]
[., ADD, :, return, "+", ;, case, Token, ., SUB, :, return, "-", ;, case, Token, ., POS, :, return]
[return, "+", ;, case, Token, ., SUB, :, return, "-", ;, case, Token, ., POS, :, return, "+", ;, case]
[return, "+", ;, case, Token, ., SUB, :, return, "-", ;, case, Token, ., POS, :, return, "+", ;, case]
[., SUB, :, return, "-", ;, case, Token, ., POS, :, return, "+", ;, case, Token, ., NEG, :, return]
[return, "-", ;, case, Token, ., POS, :, return, "+", ;, case, Token, ., NEG, :, return, "-", ;, case]
[return, "-", ;, case, Token, ., POS, :, return, "+", ;, case, Token, ., NEG, :, return, "-", ;, case]
[., POS, :, return, "+", ;, case, Token, ., NEG, :, return, "-", ;, case, Token, ., ASSIGN, :, return]
[return, "+", ;, case, Token, ., NEG, :, return, "-", ;, case, Token, ., ASSIGN, :, return, "=", ;, case]
[return, "+", ;, case, Token, ., NEG, :, return, "-", ;, case, Token, ., ASSIGN, :, return, "=", ;, case]
[., NEG, :, return, "-", ;, case, Token, ., ASSIGN, :, return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return]
[return, "-", ;, case, Token, ., ASSIGN, :, return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;, case]
[return, "-", ;, case, Token, ., ASSIGN, :, return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;, case]
[., ASSIGN, :, return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return]
[return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;, case]
[return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;, case]
[., ASSIGN_BITOR, :, return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return]
[return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;, case]
[return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;, case]
[., ASSIGN_BITXOR, :, return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return]
[return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;, case]
[return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;, case]
[., ASSIGN_BITAND, :, return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return]
[return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;, case]
[return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;, case]
[., ASSIGN_LSH, :, return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return]
[return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;, case]
[return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;, case]
[., ASSIGN_RSH, :, return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return]
[return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;, case]
[return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;, case]
[., ASSIGN_URSH, :, return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return]
[return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;, case]
[return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;, case]
[., ASSIGN_ADD, :, return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return]
[return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;, case]
[return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;, case]
[., ASSIGN_SUB, :, return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return]
[return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;, case]
[return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;, case]
[., ASSIGN_MUL, :, return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return]
[return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;, case]
[return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;, case]
[., ASSIGN_DIV, :, return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;, case, Token, ., VOID, :, return]
[return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;, case, Token, ., VOID, :, return, "void", ;, case]
[return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;, case, Token, ., VOID, :, return, "void", ;, case]
[., ASSIGN_MOD, :, return, "%=", ;, case, Token, ., VOID, :, return, "void", ;, case, Token, ., TYPEOF, :, return]
[return, "%=", ;, case, Token, ., VOID, :, return, "void", ;, case, Token, ., TYPEOF, :, return, "typeof", ;, case]
[return, "%=", ;, case, Token, ., VOID, :, return, "void", ;, case, Token, ., TYPEOF, :, return, "typeof", ;, case]
[., VOID, :, return, "void", ;, case, Token, ., TYPEOF, :, return, "typeof", ;, case, Token, ., INSTANCEOF, :, return]
[;, case, Token, ., TYPEOF, :, return, "typeof", ;, case, Token, ., INSTANCEOF, :, return, "instanceof", ;, default, :, return]
["instanceof", ;, default, :, return, null, ;, }, }, static, String, opToStrNoFail, (, int, operator, ), {, String, res, =]
[default, :, return, null, ;, }, }, static, String, opToStrNoFail, (, int, operator, ), {, String, res, =, opToStr, (]
[}, }, static, String, opToStrNoFail, (, int, operator, ), {, String, res, =, opToStr, (, operator, ), ;, if, (]
[}, }, static, String, opToStrNoFail, (, int, operator, ), {, String, res, =, opToStr, (, operator, ), ;, if, (]
[static, String, opToStrNoFail, (, int, operator, ), {, String, res, =, opToStr, (, operator, ), ;, if, (, res, ==]
[int, operator, ), {, String, res, =, opToStr, (, operator, ), ;, if, (, res, ==, null, ), {, throw]
[{, String, res, =, opToStr, (, operator, ), ;, if, (, res, ==, null, ), {, throw, new, Error, (]
[{, String, res, =, opToStr, (, operator, ), ;, if, (, res, ==, null, ), {, throw, new, Error, (]
[{, String, res, =, opToStr, (, operator, ), ;, if, (, res, ==, null, ), {, throw, new, Error, (]
[{, String, res, =, opToStr, (, operator, ), ;, if, (, res, ==, null, ), {, throw, new, Error, (]
[res, =, opToStr, (, operator, ), ;, if, (, res, ==, null, ), {, throw, new, Error, (, "Unknown op ", +]
[opToStr, (, operator, ), ;, if, (, res, ==, null, ), {, throw, new, Error, (, "Unknown op ", +, operator, +]
[operator, ), ;, if, (, res, ==, null, ), {, throw, new, Error, (, "Unknown op ", +, operator, +, ": ", +]
[operator, ), ;, if, (, res, ==, null, ), {, throw, new, Error, (, "Unknown op ", +, operator, +, ": ", +]
[(, res, ==, null, ), {, throw, new, Error, (, "Unknown op ", +, operator, +, ": ", +, Token, ., name, (]
[throw, new, Error, (, "Unknown op ", +, operator, +, ": ", +, Token, ., name, (, operator, ), ), ;, }, return]
[;, }, static, boolean, containsType, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return]
[static, boolean, containsType, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, has, (]
[containsType, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, has, (, node, ,]
[node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, has, (, node, ,, new, MatchNodeType, (]
[type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, has, (, node, ,, new, MatchNodeType, (, type, ), ,]
[(, type, ), ,, traverseChildrenPred, ), ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ), {, return]
[), ,, traverseChildrenPred, ), ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ), {, return, containsType, (]
[traverseChildrenPred, ), ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ), {, return, containsType, (, node, ,]
[;, }, static, boolean, containsType, (, Node, node, ,, int, type, ), {, return, containsType, (, node, ,, type, ,]
[;, }, static, boolean, containsType, (, Node, node, ,, int, type, ), {, return, containsType, (, node, ,, type, ,]
[alwaysTrue, (, ), ), ;, }, static, void, redeclareVarsInsideBranch, (, Node, branch, ), {, Collection, <, Node, >, vars, =]
[), ), ;, }, static, void, redeclareVarsInsideBranch, (, Node, branch, ), {, Collection, <, Node, >, vars, =, getVarsDeclaredInBranch, (]
[void, redeclareVarsInsideBranch, (, Node, branch, ), {, Collection, <, Node, >, vars, =, getVarsDeclaredInBranch, (, branch, ), ;, if, (]
[void, redeclareVarsInsideBranch, (, Node, branch, ), {, Collection, <, Node, >, vars, =, getVarsDeclaredInBranch, (, branch, ), ;, if, (]
[getVarsDeclaredInBranch, (, branch, ), ;, if, (, vars, ., isEmpty, (, ), ), {, return, ;, }, Node, parent, =]
[branch, ), ;, if, (, vars, ., isEmpty, (, ), ), {, return, ;, }, Node, parent, =, getAddingRoot, (]
[(, ), ), {, return, ;, }, Node, parent, =, getAddingRoot, (, branch, ), ;, for, (, Node, nameNode, :]
[}, Node, parent, =, getAddingRoot, (, branch, ), ;, for, (, Node, nameNode, :, vars, ), {, Node, var, =]
[}, Node, parent, =, getAddingRoot, (, branch, ), ;, for, (, Node, nameNode, :, vars, ), {, Node, var, =]
[}, Node, parent, =, getAddingRoot, (, branch, ), ;, for, (, Node, nameNode, :, vars, ), {, Node, var, =]
[getAddingRoot, (, branch, ), ;, for, (, Node, nameNode, :, vars, ), {, Node, var, =, IR, ., var, (]
[getAddingRoot, (, branch, ), ;, for, (, Node, nameNode, :, vars, ), {, Node, var, =, IR, ., var, (]
[getAddingRoot, (, branch, ), ;, for, (, Node, nameNode, :, vars, ), {, Node, var, =, IR, ., var, (]
[;, for, (, Node, nameNode, :, vars, ), {, Node, var, =, IR, ., var, (, IR, ., name, (]
[;, for, (, Node, nameNode, :, vars, ), {, Node, var, =, IR, ., var, (, IR, ., name, (]
[Node, var, =, IR, ., var, (, IR, ., name, (, nameNode, ., getString, (, ), ), ., srcref, (]
[(, IR, ., name, (, nameNode, ., getString, (, ), ), ., srcref, (, nameNode, ), ), ., srcref, (]
[name, (, nameNode, ., getString, (, ), ), ., srcref, (, nameNode, ), ), ., srcref, (, nameNode, ), ;]
[nameNode, ., getString, (, ), ), ., srcref, (, nameNode, ), ), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (]
[getString, (, ), ), ., srcref, (, nameNode, ), ), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,]
[getString, (, ), ), ., srcref, (, nameNode, ), ), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,]
[nameNode, ), ), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild, (, ), ), ;]
[nameNode, ), ), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild, (, ), ), ;]
[srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild, (, ), ), ;, parent, ., addChildToFront, (]
[addChildToFront, (, var, ), ;, }, }, static, void, copyNameAnnotations, (, Node, source, ,, Node, destination, ), {, if, (]
[addChildToFront, (, var, ), ;, }, }, static, void, copyNameAnnotations, (, Node, source, ,, Node, destination, ), {, if, (]
[;, }, }, static, void, copyNameAnnotations, (, Node, source, ,, Node, destination, ), {, if, (, source, ., getBooleanProp, (]
[;, }, }, static, void, copyNameAnnotations, (, Node, source, ,, Node, destination, ), {, if, (, source, ., getBooleanProp, (]
[(, Node, source, ,, Node, destination, ), {, if, (, source, ., getBooleanProp, (, Node, ., IS_CONSTANT_NAME, ), ), {]
[(, Node, source, ,, Node, destination, ), {, if, (, source, ., getBooleanProp, (, Node, ., IS_CONSTANT_NAME, ), ), {]
[Node, destination, ), {, if, (, source, ., getBooleanProp, (, Node, ., IS_CONSTANT_NAME, ), ), {, destination, ., putBooleanProp, (]
[Node, destination, ), {, if, (, source, ., getBooleanProp, (, Node, ., IS_CONSTANT_NAME, ), ), {, destination, ., putBooleanProp, (]
[if, (, source, ., getBooleanProp, (, Node, ., IS_CONSTANT_NAME, ), ), {, destination, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,]
[., IS_CONSTANT_NAME, ,, true, ), ;, }, }, private, static, Node, getAddingRoot, (, Node, n, ), {, Node, addingRoot, =]
[;, }, }, private, static, Node, getAddingRoot, (, Node, n, ), {, Node, addingRoot, =, null, ;, Node, ancestor, =]
[static, Node, getAddingRoot, (, Node, n, ), {, Node, addingRoot, =, null, ;, Node, ancestor, =, n, ;, while, (]
[static, Node, getAddingRoot, (, Node, n, ), {, Node, addingRoot, =, null, ;, Node, ancestor, =, n, ;, while, (]
[getAddingRoot, (, Node, n, ), {, Node, addingRoot, =, null, ;, Node, ancestor, =, n, ;, while, (, null, !=]
[(, Node, n, ), {, Node, addingRoot, =, null, ;, Node, ancestor, =, n, ;, while, (, null, !=, (]
[n, ), {, Node, addingRoot, =, null, ;, Node, ancestor, =, n, ;, while, (, null, !=, (, ancestor, =]
[n, ), {, Node, addingRoot, =, null, ;, Node, ancestor, =, n, ;, while, (, null, !=, (, ancestor, =]
[n, ;, while, (, null, !=, (, ancestor, =, ancestor, ., getParent, (, ), ), ), {, int, type, =]
[n, ;, while, (, null, !=, (, ancestor, =, ancestor, ., getParent, (, ), ), ), {, int, type, =]
[=, ancestor, ., getParent, (, ), ), ), {, int, type, =, ancestor, ., getType, (, ), ;, if, (]
[=, ancestor, ., getParent, (, ), ), ), {, int, type, =, ancestor, ., getType, (, ), ;, if, (]
[., getParent, (, ), ), ), {, int, type, =, ancestor, ., getType, (, ), ;, if, (, type, ==]
[., getParent, (, ), ), ), {, int, type, =, ancestor, ., getType, (, ), ;, if, (, type, ==]
[), {, int, type, =, ancestor, ., getType, (, ), ;, if, (, type, ==, Token, ., SCRIPT, ), {]
[int, type, =, ancestor, ., getType, (, ), ;, if, (, type, ==, Token, ., SCRIPT, ), {, addingRoot, =]
[;, if, (, type, ==, Token, ., SCRIPT, ), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (]
[;, if, (, type, ==, Token, ., SCRIPT, ), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (]
[(, type, ==, Token, ., SCRIPT, ), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (, type, ==]
[(, type, ==, Token, ., SCRIPT, ), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (, type, ==]
[SCRIPT, ), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (, type, ==, Token, ., FUNCTION, ), {]
[{, addingRoot, =, ancestor, ;, break, ;, }, else, if, (, type, ==, Token, ., FUNCTION, ), {, addingRoot, =]
[{, addingRoot, =, ancestor, ;, break, ;, }, else, if, (, type, ==, Token, ., FUNCTION, ), {, addingRoot, =]
[(, type, ==, Token, ., FUNCTION, ), {, addingRoot, =, ancestor, ., getLastChild, (, ), ;, break, ;, }, }]
[(, type, ==, Token, ., FUNCTION, ), {, addingRoot, =, ancestor, ., getLastChild, (, ), ;, break, ;, }, }]
[., FUNCTION, ), {, addingRoot, =, ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (]
[., FUNCTION, ), {, addingRoot, =, ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (]
[., FUNCTION, ), {, addingRoot, =, ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (]
[ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (, addingRoot, ., isBlock, (, ), ||]
[ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (, addingRoot, ., isBlock, (, ), ||]
[;, }, }, Preconditions, ., checkState, (, addingRoot, ., isBlock, (, ), ||, addingRoot, ., isScript, (, ), ), ;]
[;, }, }, Preconditions, ., checkState, (, addingRoot, ., isBlock, (, ), ||, addingRoot, ., isScript, (, ), ), ;]
[., checkState, (, addingRoot, ., isBlock, (, ), ||, addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (]
[., checkState, (, addingRoot, ., isBlock, (, ), ||, addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (]
[., checkState, (, addingRoot, ., isBlock, (, ), ||, addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (]
[., checkState, (, addingRoot, ., isBlock, (, ), ||, addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (]
[(, ), ||, addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==]
[||, addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||]
[addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||, !]
[addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||, !]
[addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||, !]
[., getFirstChild, (, ), ==, null, ||, !, addingRoot, ., getFirstChild, (, ), ., isScript, (, ), ), ;, return]
[;, return, addingRoot, ;, }, public, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ), {, int, endPos, =]
[;, return, addingRoot, ;, }, public, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ), {, int, endPos, =]
[}, public, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ), {, int, endPos, =, name, ., indexOf, (]
[(, CodingConvention, convention, ,, String, name, ), {, int, endPos, =, name, ., indexOf, (, '.', ), ;, if, (]
[(, CodingConvention, convention, ,, String, name, ), {, int, endPos, =, name, ., indexOf, (, '.', ), ;, if, (]
[convention, ,, String, name, ), {, int, endPos, =, name, ., indexOf, (, '.', ), ;, if, (, endPos, ==]
[,, String, name, ), {, int, endPos, =, name, ., indexOf, (, '.', ), ;, if, (, endPos, ==, -]
[{, int, endPos, =, name, ., indexOf, (, '.', ), ;, if, (, endPos, ==, -, 1, ), {, return]
[endPos, =, name, ., indexOf, (, '.', ), ;, if, (, endPos, ==, -, 1, ), {, return, newName, (]
[name, ., indexOf, (, '.', ), ;, if, (, endPos, ==, -, 1, ), {, return, newName, (, convention, ,]
[if, (, endPos, ==, -, 1, ), {, return, newName, (, convention, ,, name, ), ;, }, Node, node, =]
[endPos, ==, -, 1, ), {, return, newName, (, convention, ,, name, ), ;, }, Node, node, =, newName, (]
[-, 1, ), {, return, newName, (, convention, ,, name, ), ;, }, Node, node, =, newName, (, convention, ,]
[-, 1, ), {, return, newName, (, convention, ,, name, ), ;, }, Node, node, =, newName, (, convention, ,]
[return, newName, (, convention, ,, name, ), ;, }, Node, node, =, newName, (, convention, ,, name, ., substring, (]
[(, convention, ,, name, ), ;, }, Node, node, =, newName, (, convention, ,, name, ., substring, (, 0, ,]
[=, newName, (, convention, ,, name, ., substring, (, 0, ,, endPos, ), ), ;, int, startPos, ;, do, {]
[(, convention, ,, name, ., substring, (, 0, ,, endPos, ), ), ;, int, startPos, ;, do, {, startPos, =]
[(, convention, ,, name, ., substring, (, 0, ,, endPos, ), ), ;, int, startPos, ;, do, {, startPos, =]
[,, name, ., substring, (, 0, ,, endPos, ), ), ;, int, startPos, ;, do, {, startPos, =, endPos, +]
[., substring, (, 0, ,, endPos, ), ), ;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;]
[(, 0, ,, endPos, ), ), ;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;, endPos, =]
[(, 0, ,, endPos, ), ), ;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;, endPos, =]
[), ), ;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;, endPos, =, name, ., indexOf, (]
[;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;, endPos, =, name, ., indexOf, (, '.', ,]
[startPos, =, endPos, +, 1, ;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =]
[=, endPos, +, 1, ;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (]
[=, endPos, +, 1, ;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (]
[=, endPos, +, 1, ;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (]
[+, 1, ;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==]
[1, ;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==, -]
[endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1, ?]
[endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1, ?]
[indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1, ?, name, ., substring, (]
[,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1, ?, name, ., substring, (, startPos, ), :]
[,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1, ?, name, ., substring, (, startPos, ), :]
[String, part, =, (, endPos, ==, -, 1, ?, name, ., substring, (, startPos, ), :, name, ., substring, (]
[=, (, endPos, ==, -, 1, ?, name, ., substring, (, startPos, ), :, name, ., substring, (, startPos, ,]
[name, ., substring, (, startPos, ), :, name, ., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode, =]
[name, ., substring, (, startPos, ), :, name, ., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode, =]
[startPos, ), :, name, ., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode, =, IR, ., string, (]
[substring, (, startPos, ,, endPos, ), ), ;, Node, propNode, =, IR, ., string, (, part, ), ;, if, (]
[substring, (, startPos, ,, endPos, ), ), ;, Node, propNode, =, IR, ., string, (, part, ), ;, if, (]
[endPos, ), ), ;, Node, propNode, =, IR, ., string, (, part, ), ;, if, (, convention, ., isConstantKey, (]
[Node, propNode, =, IR, ., string, (, part, ), ;, if, (, convention, ., isConstantKey, (, part, ), ), {]
[Node, propNode, =, IR, ., string, (, part, ), ;, if, (, convention, ., isConstantKey, (, part, ), ), {]
[., string, (, part, ), ;, if, (, convention, ., isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (]
[., string, (, part, ), ;, if, (, convention, ., isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (]
[), ;, if, (, convention, ., isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,]
[convention, ., isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }]
[isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, node, =]
[isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, node, =]
[), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, node, =, IR, ., getprop, (]
[propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, node, =, IR, ., getprop, (, node, ,]
[IS_CONSTANT_NAME, ,, true, ), ;, }, node, =, IR, ., getprop, (, node, ,, propNode, ), ;, }, while, (]
[IS_CONSTANT_NAME, ,, true, ), ;, }, node, =, IR, ., getprop, (, node, ,, propNode, ), ;, }, while, (]
[true, ), ;, }, node, =, IR, ., getprop, (, node, ,, propNode, ), ;, }, while, (, endPos, !=]
[), ;, }, node, =, IR, ., getprop, (, node, ,, propNode, ), ;, }, while, (, endPos, !=, -]
[=, IR, ., getprop, (, node, ,, propNode, ), ;, }, while, (, endPos, !=, -, 1, ), ;, return]
[static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node, node, =]
[newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node, node, =, newQualifiedNameNode, (]
[CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node, node, =, newQualifiedNameNode, (, convention, ,]
[String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node, node, =, newQualifiedNameNode, (, convention, ,, name, ), ;]
[,, Node, basisNode, ,, String, originalName, ), {, Node, node, =, newQualifiedNameNode, (, convention, ,, name, ), ;, setDebugInformation, (]
[basisNode, ,, String, originalName, ), {, Node, node, =, newQualifiedNameNode, (, convention, ,, name, ), ;, setDebugInformation, (, node, ,]
[String, originalName, ), {, Node, node, =, newQualifiedNameNode, (, convention, ,, name, ), ;, setDebugInformation, (, node, ,, basisNode, ,]
[Node, node, =, newQualifiedNameNode, (, convention, ,, name, ), ;, setDebugInformation, (, node, ,, basisNode, ,, originalName, ), ;, return]
[originalName, ), ;, return, node, ;, }, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (, Node, current, =]
[;, return, node, ;, }, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (, Node, current, =, qName, ;]
[node, ;, }, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (, Node, current, =, qName, ;, true, ;]
[}, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (, Node, current, =, qName, ;, true, ;, current, =]
[}, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (, Node, current, =, qName, ;, true, ;, current, =]
[for, (, Node, current, =, qName, ;, true, ;, current, =, current, ., getFirstChild, (, ), ), {, if, (]
[for, (, Node, current, =, qName, ;, true, ;, current, =, current, ., getFirstChild, (, ), ), {, if, (]
[for, (, Node, current, =, qName, ;, true, ;, current, =, current, ., getFirstChild, (, ), ), {, if, (]
[;, true, ;, current, =, current, ., getFirstChild, (, ), ), {, if, (, current, ., isName, (, ), ||]
[;, true, ;, current, =, current, ., getFirstChild, (, ), ), {, if, (, current, ., isName, (, ), ||]
[(, ), ), {, if, (, current, ., isName, (, ), ||, current, ., isThis, (, ), ), {, return]
[{, if, (, current, ., isName, (, ), ||, current, ., isThis, (, ), ), {, return, current, ;, }]
[{, if, (, current, ., isName, (, ), ||, current, ., isThis, (, ), ), {, return, current, ;, }]
[., isName, (, ), ||, current, ., isThis, (, ), ), {, return, current, ;, }, Preconditions, ., checkState, (]
[., isName, (, ), ||, current, ., isThis, (, ), ), {, return, current, ;, }, Preconditions, ., checkState, (]
[(, ), ), ;, }, }, static, void, setDebugInformation, (, Node, node, ,, Node, basisNode, ,, String, originalName, ), {]
[(, ), ), ;, }, }, static, void, setDebugInformation, (, Node, node, ,, Node, basisNode, ,, String, originalName, ), {]
[}, }, static, void, setDebugInformation, (, Node, node, ,, Node, basisNode, ,, String, originalName, ), {, node, ., copyInformationFromForTree, (]
[void, setDebugInformation, (, Node, node, ,, Node, basisNode, ,, String, originalName, ), {, node, ., copyInformationFromForTree, (, basisNode, ), ;]
[void, setDebugInformation, (, Node, node, ,, Node, basisNode, ,, String, originalName, ), {, node, ., copyInformationFromForTree, (, basisNode, ), ;]
[node, ,, Node, basisNode, ,, String, originalName, ), {, node, ., copyInformationFromForTree, (, basisNode, ), ;, node, ., putProp, (]
[node, ,, Node, basisNode, ,, String, originalName, ), {, node, ., copyInformationFromForTree, (, basisNode, ), ;, node, ., putProp, (]
[,, String, originalName, ), {, node, ., copyInformationFromForTree, (, basisNode, ), ;, node, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,]
[,, originalName, ), ;, }, private, static, Node, newName, (, CodingConvention, convention, ,, String, name, ), {, Node, nameNode, =]
[,, originalName, ), ;, }, private, static, Node, newName, (, CodingConvention, convention, ,, String, name, ), {, Node, nameNode, =]
[}, private, static, Node, newName, (, CodingConvention, convention, ,, String, name, ), {, Node, nameNode, =, IR, ., name, (]
[(, CodingConvention, convention, ,, String, name, ), {, Node, nameNode, =, IR, ., name, (, name, ), ;, if, (]
[(, CodingConvention, convention, ,, String, name, ), {, Node, nameNode, =, IR, ., name, (, name, ), ;, if, (]
[String, name, ), {, Node, nameNode, =, IR, ., name, (, name, ), ;, if, (, convention, ., isConstant, (]
[Node, nameNode, =, IR, ., name, (, name, ), ;, if, (, convention, ., isConstant, (, name, ), ), {]
[Node, nameNode, =, IR, ., name, (, name, ), ;, if, (, convention, ., isConstant, (, name, ), ), {]
[., name, (, name, ), ;, if, (, convention, ., isConstant, (, name, ), ), {, nameNode, ., putBooleanProp, (]
[., name, (, name, ), ;, if, (, convention, ., isConstant, (, name, ), ), {, nameNode, ., putBooleanProp, (]
[), ;, if, (, convention, ., isConstant, (, name, ), ), {, nameNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,]
[., isConstant, (, name, ), ), {, nameNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, return]
[}, return, nameNode, ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, srcref, ), {, return]
[}, return, nameNode, ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, srcref, ), {, return]
[nameNode, ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, srcref, ), {, return, newName, (]
[}, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, srcref, ), {, return, newName, (, convention, ,]
[CodingConvention, convention, ,, String, name, ,, Node, srcref, ), {, return, newName, (, convention, ,, name, ), ., srcref, (]
[static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node, nameNode, =]
[newName, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node, nameNode, =, newName, (]
[CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node, nameNode, =, newName, (, convention, ,]
[,, String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node, nameNode, =, newName, (, convention, ,, name, ,]
[,, Node, basisNode, ,, String, originalName, ), {, Node, nameNode, =, newName, (, convention, ,, name, ,, basisNode, ), ;]
[,, Node, basisNode, ,, String, originalName, ), {, Node, nameNode, =, newName, (, convention, ,, name, ,, basisNode, ), ;]
[String, originalName, ), {, Node, nameNode, =, newName, (, convention, ,, name, ,, basisNode, ), ;, nameNode, ., putProp, (]
[String, originalName, ), {, Node, nameNode, =, newName, (, convention, ,, name, ,, basisNode, ), ;, nameNode, ., putProp, (]
[Node, nameNode, =, newName, (, convention, ,, name, ,, basisNode, ), ;, nameNode, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,]
[(, convention, ,, name, ,, basisNode, ), ;, nameNode, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, return]
[ORIGINALNAME_PROP, ,, originalName, ), ;, return, nameNode, ;, }, static, boolean, isLatin, (, String, s, ), {, int, len, =]
[ORIGINALNAME_PROP, ,, originalName, ), ;, return, nameNode, ;, }, static, boolean, isLatin, (, String, s, ), {, int, len, =]
[isLatin, (, String, s, ), {, int, len, =, s, ., length, (, ), ;, for, (, int, index, =]
[String, s, ), {, int, len, =, s, ., length, (, ), ;, for, (, int, index, =, 0, ;]
[String, s, ), {, int, len, =, s, ., length, (, ), ;, for, (, int, index, =, 0, ;]
[), {, int, len, =, s, ., length, (, ), ;, for, (, int, index, =, 0, ;, index, <]
[int, len, =, s, ., length, (, ), ;, for, (, int, index, =, 0, ;, index, <, len, ;]
[int, len, =, s, ., length, (, ), ;, for, (, int, index, =, 0, ;, index, <, len, ;]
[), ;, for, (, int, index, =, 0, ;, index, <, len, ;, index, ++, ), {, char, c, =]
[), ;, for, (, int, index, =, 0, ;, index, <, len, ;, index, ++, ), {, char, c, =]
[int, index, =, 0, ;, index, <, len, ;, index, ++, ), {, char, c, =, s, ., charAt, (]
[index, <, len, ;, index, ++, ), {, char, c, =, s, ., charAt, (, index, ), ;, if, (]
[index, <, len, ;, index, ++, ), {, char, c, =, s, ., charAt, (, index, ), ;, if, (]
[len, ;, index, ++, ), {, char, c, =, s, ., charAt, (, index, ), ;, if, (, c, >]
[), {, char, c, =, s, ., charAt, (, index, ), ;, if, (, c, >, LARGEST_BASIC_LATIN, ), {, return]
[s, ., charAt, (, index, ), ;, if, (, c, >, LARGEST_BASIC_LATIN, ), {, return, false, ;, }, }, return]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return]
[;, }, }, return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return, TokenStream, ., isJSIdentifier, (]
[return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return, TokenStream, ., isJSIdentifier, (, name, ), &&]
[true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return, TokenStream, ., isJSIdentifier, (, name, ), &&, !]
[true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return, TokenStream, ., isJSIdentifier, (, name, ), &&, !]
[boolean, isValidSimpleName, (, String, name, ), {, return, TokenStream, ., isJSIdentifier, (, name, ), &&, !, TokenStream, ., isKeyword, (]
[String, name, ), {, return, TokenStream, ., isJSIdentifier, (, name, ), &&, !, TokenStream, ., isKeyword, (, name, ), &&]
[), {, return, TokenStream, ., isJSIdentifier, (, name, ), &&, !, TokenStream, ., isKeyword, (, name, ), &&, isLatin, (]
[name, ), &&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (]
[name, ), &&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (]
[name, ), &&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (]
[(, name, ), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, ., endsWith, (]
[;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, ., endsWith, (, ".", ), ||]
[;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, ., endsWith, (, ".", ), ||]
[boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, ., endsWith, (, ".", ), ||, name, ., startsWith, (]
[), {, if, (, name, ., endsWith, (, ".", ), ||, name, ., startsWith, (, ".", ), ), {, return]
[".", ), ||, name, ., startsWith, (, ".", ), ), {, return, false, ;, }, String, [, ], parts, =]
[".", ), ||, name, ., startsWith, (, ".", ), ), {, return, false, ;, }, String, [, ], parts, =]
[., startsWith, (, ".", ), ), {, return, false, ;, }, String, [, ], parts, =, name, ., split, (]
[false, ;, }, String, [, ], parts, =, name, ., split, (, "\\.", ), ;, for, (, String, part, :]
[], parts, =, name, ., split, (, "\\.", ), ;, for, (, String, part, :, parts, ), {, if, (]
[parts, =, name, ., split, (, "\\.", ), ;, for, (, String, part, :, parts, ), {, if, (, !]
[name, ., split, (, "\\.", ), ;, for, (, String, part, :, parts, ), {, if, (, !, isValidSimpleName, (]
[), ;, for, (, String, part, :, parts, ), {, if, (, !, isValidSimpleName, (, part, ), ), {, return]
[part, :, parts, ), {, if, (, !, isValidSimpleName, (, part, ), ), {, return, false, ;, }, }, return]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidPropertyName, (, String, name, ), {, return]
[return, false, ;, }, }, return, true, ;, }, static, boolean, isValidPropertyName, (, String, name, ), {, return, isValidSimpleName, (]
[name, ), ;, }, private, static, class, VarCollector, implements, Visitor, {, final, Map, <, String, ,, Node, >, vars, =]
[name, ), ;, }, private, static, class, VarCollector, implements, Visitor, {, final, Map, <, String, ,, Node, >, vars, =]
[vars, =, Maps, ., newLinkedHashMap, (, ), ;, @, Override, public, void, visit, (, Node, n, ), {, if, (]
[vars, =, Maps, ., newLinkedHashMap, (, ), ;, @, Override, public, void, visit, (, Node, n, ), {, if, (]
[public, void, visit, (, Node, n, ), {, if, (, n, ., isName, (, ), ), {, Node, parent, =]
[public, void, visit, (, Node, n, ), {, if, (, n, ., isName, (, ), ), {, Node, parent, =]
[if, (, n, ., isName, (, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[if, (, n, ., isName, (, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[if, (, n, ., isName, (, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[n, ., isName, (, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, !=]
[isName, (, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, !=, null, &&]
[isName, (, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, !=, null, &&]
[getParent, (, ), ;, if, (, parent, !=, null, &&, parent, ., isVar, (, ), ), {, String, name, =]
[getParent, (, ), ;, if, (, parent, !=, null, &&, parent, ., isVar, (, ), ), {, String, name, =]
[null, &&, parent, ., isVar, (, ), ), {, String, name, =, n, ., getString, (, ), ;, if, (]
[&&, parent, ., isVar, (, ), ), {, String, name, =, n, ., getString, (, ), ;, if, (, !]
[&&, parent, ., isVar, (, ), ), {, String, name, =, n, ., getString, (, ), ;, if, (, !]
[(, ), ), {, String, name, =, n, ., getString, (, ), ;, if, (, !, vars, ., containsKey, (]
[String, name, =, n, ., getString, (, ), ;, if, (, !, vars, ., containsKey, (, name, ), ), {]
[String, name, =, n, ., getString, (, ), ;, if, (, !, vars, ., containsKey, (, name, ), ), {]
[., getString, (, ), ;, if, (, !, vars, ., containsKey, (, name, ), ), {, vars, ., put, (]
[(, ), ;, if, (, !, vars, ., containsKey, (, name, ), ), {, vars, ., put, (, name, ,]
[;, }, }, }, }, }, static, Collection, <, Node, >, getVarsDeclaredInBranch, (, Node, root, ), {, VarCollector, collector, =]
[}, static, Collection, <, Node, >, getVarsDeclaredInBranch, (, Node, root, ), {, VarCollector, collector, =, new, VarCollector, (, ), ;]
[Collection, <, Node, >, getVarsDeclaredInBranch, (, Node, root, ), {, VarCollector, collector, =, new, VarCollector, (, ), ;, visitPreOrder, (]
[Node, >, getVarsDeclaredInBranch, (, Node, root, ), {, VarCollector, collector, =, new, VarCollector, (, ), ;, visitPreOrder, (, root, ,]
[getVarsDeclaredInBranch, (, Node, root, ), {, VarCollector, collector, =, new, VarCollector, (, ), ;, visitPreOrder, (, root, ,, collector, ,]
[), {, VarCollector, collector, =, new, VarCollector, (, ), ;, visitPreOrder, (, root, ,, collector, ,, MATCH_NOT_FUNCTION, ), ;, return]
[), {, VarCollector, collector, =, new, VarCollector, (, ), ;, visitPreOrder, (, root, ,, collector, ,, MATCH_NOT_FUNCTION, ), ;, return]
[), {, VarCollector, collector, =, new, VarCollector, (, ), ;, visitPreOrder, (, root, ,, collector, ,, MATCH_NOT_FUNCTION, ), ;, return]
[return, collector, ., vars, ., values, (, ), ;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n, ), {, if, (]
[collector, ., vars, ., values, (, ), ;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n, ), {, if, (, !]
[vars, ., values, (, ), ;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n, ), {, if, (, !, isExprAssign, (]
[;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n, ), {, if, (, !, isExprAssign, (, n, ), ), {, return]
[isPrototypePropertyDeclaration, (, Node, n, ), {, if, (, !, isExprAssign, (, n, ), ), {, return, false, ;, }, return]
[Node, n, ), {, if, (, !, isExprAssign, (, n, ), ), {, return, false, ;, }, return, isPrototypeProperty, (]
[Node, n, ), {, if, (, !, isExprAssign, (, n, ), ), {, return, false, ;, }, return, isPrototypeProperty, (]
[Node, n, ), {, if, (, !, isExprAssign, (, n, ), ), {, return, false, ;, }, return, isPrototypeProperty, (]
[(, ), ., getFirstChild, (, ), ), ;, }, static, boolean, isPrototypeProperty, (, Node, n, ), {, String, lhsString, =]
[(, ), ., getFirstChild, (, ), ), ;, }, static, boolean, isPrototypeProperty, (, Node, n, ), {, String, lhsString, =]
[}, static, boolean, isPrototypeProperty, (, Node, n, ), {, String, lhsString, =, n, ., getQualifiedName, (, ), ;, if, (]
[}, static, boolean, isPrototypeProperty, (, Node, n, ), {, String, lhsString, =, n, ., getQualifiedName, (, ), ;, if, (]
[boolean, isPrototypeProperty, (, Node, n, ), {, String, lhsString, =, n, ., getQualifiedName, (, ), ;, if, (, lhsString, ==]
[n, ), {, String, lhsString, =, n, ., getQualifiedName, (, ), ;, if, (, lhsString, ==, null, ), {, return]
[n, ., getQualifiedName, (, ), ;, if, (, lhsString, ==, null, ), {, return, false, ;, }, int, prototypeIdx, =]
[n, ., getQualifiedName, (, ), ;, if, (, lhsString, ==, null, ), {, return, false, ;, }, int, prototypeIdx, =]
[), ;, if, (, lhsString, ==, null, ), {, return, false, ;, }, int, prototypeIdx, =, lhsString, ., indexOf, (]
[lhsString, ==, null, ), {, return, false, ;, }, int, prototypeIdx, =, lhsString, ., indexOf, (, ".prototype.", ), ;, return]
[lhsString, ==, null, ), {, return, false, ;, }, int, prototypeIdx, =, lhsString, ., indexOf, (, ".prototype.", ), ;, return]
[null, ), {, return, false, ;, }, int, prototypeIdx, =, lhsString, ., indexOf, (, ".prototype.", ), ;, return, prototypeIdx, !=]
[), {, return, false, ;, }, int, prototypeIdx, =, lhsString, ., indexOf, (, ".prototype.", ), ;, return, prototypeIdx, !=, -]
[), ;, return, prototypeIdx, !=, -, 1, ;, }, static, Node, getPrototypeClassName, (, Node, qName, ), {, Node, cur, =]
[!=, -, 1, ;, }, static, Node, getPrototypeClassName, (, Node, qName, ), {, Node, cur, =, qName, ;, while, (]
[!=, -, 1, ;, }, static, Node, getPrototypeClassName, (, Node, qName, ), {, Node, cur, =, qName, ;, while, (]
[Node, qName, ), {, Node, cur, =, qName, ;, while, (, cur, ., isGetProp, (, ), ), {, if, (]
[Node, qName, ), {, Node, cur, =, qName, ;, while, (, cur, ., isGetProp, (, ), ), {, if, (]
[Node, qName, ), {, Node, cur, =, qName, ;, while, (, cur, ., isGetProp, (, ), ), {, if, (]
[Node, qName, ), {, Node, cur, =, qName, ;, while, (, cur, ., isGetProp, (, ), ), {, if, (]
[., isGetProp, (, ), ), {, if, (, cur, ., getLastChild, (, ), ., getString, (, ), ., equals, (]
[{, if, (, cur, ., getLastChild, (, ), ., getString, (, ), ., equals, (, "prototype", ), ), {, return]
[{, if, (, cur, ., getLastChild, (, ), ., getString, (, ), ., equals, (, "prototype", ), ), {, return]
[getString, (, ), ., equals, (, "prototype", ), ), {, return, cur, ., getFirstChild, (, ), ;, }, else, {]
[), ., equals, (, "prototype", ), ), {, return, cur, ., getFirstChild, (, ), ;, }, else, {, cur, =]
[), ., equals, (, "prototype", ), ), {, return, cur, ., getFirstChild, (, ), ;, }, else, {, cur, =]
[cur, ., getFirstChild, (, ), ;, }, else, {, cur, =, cur, ., getFirstChild, (, ), ;, }, }, return]
[(, ), ;, }, }, return, null, ;, }, static, String, getPrototypePropertyName, (, Node, qName, ), {, String, qNameStr, =]
[(, ), ;, }, }, return, null, ;, }, static, String, getPrototypePropertyName, (, Node, qName, ), {, String, qNameStr, =]
[static, String, getPrototypePropertyName, (, Node, qName, ), {, String, qNameStr, =, qName, ., getQualifiedName, (, ), ;, int, prototypeIdx, =]
[static, String, getPrototypePropertyName, (, Node, qName, ), {, String, qNameStr, =, qName, ., getQualifiedName, (, ), ;, int, prototypeIdx, =]
[Node, qName, ), {, String, qNameStr, =, qName, ., getQualifiedName, (, ), ;, int, prototypeIdx, =, qNameStr, ., lastIndexOf, (]
[=, qName, ., getQualifiedName, (, ), ;, int, prototypeIdx, =, qNameStr, ., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =]
[=, qName, ., getQualifiedName, (, ), ;, int, prototypeIdx, =, qNameStr, ., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =]
[=, qName, ., getQualifiedName, (, ), ;, int, prototypeIdx, =, qNameStr, ., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =]
[., getQualifiedName, (, ), ;, int, prototypeIdx, =, qNameStr, ., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =, prototypeIdx, +]
[., getQualifiedName, (, ), ;, int, prototypeIdx, =, qNameStr, ., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =, prototypeIdx, +]
[prototypeIdx, =, qNameStr, ., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =, prototypeIdx, +, ".prototype", ., length, (, ), +]
[., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =, prototypeIdx, +, ".prototype", ., length, (, ), +, 1, ;, return]
[., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =, prototypeIdx, +, ".prototype", ., length, (, ), +, 1, ;, return]
[), ;, int, memberIndex, =, prototypeIdx, +, ".prototype", ., length, (, ), +, 1, ;, return, qNameStr, ., substring, (]
[return, qNameStr, ., substring, (, memberIndex, ), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node, =]
[return, qNameStr, ., substring, (, memberIndex, ), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node, =]
[(, memberIndex, ), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node, =, IR, ., voidNode, (]
[(, memberIndex, ), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node, =, IR, ., voidNode, (]
[}, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node, =, IR, ., voidNode, (, IR, ., number, (]
[srcReferenceNode, ), {, Node, node, =, IR, ., voidNode, (, IR, ., number, (, 0, ), ), ;, if, (]
[srcReferenceNode, ), {, Node, node, =, IR, ., voidNode, (, IR, ., number, (, 0, ), ), ;, if, (]
[{, Node, node, =, IR, ., voidNode, (, IR, ., number, (, 0, ), ), ;, if, (, srcReferenceNode, !=]
[=, IR, ., voidNode, (, IR, ., number, (, 0, ), ), ;, if, (, srcReferenceNode, !=, null, ), {]
[=, IR, ., voidNode, (, IR, ., number, (, 0, ), ), ;, if, (, srcReferenceNode, !=, null, ), {]
[(, IR, ., number, (, 0, ), ), ;, if, (, srcReferenceNode, !=, null, ), {, node, ., copyInformationFromForTree, (]
[0, ), ), ;, if, (, srcReferenceNode, !=, null, ), {, node, ., copyInformationFromForTree, (, srcReferenceNode, ), ;, }, return]
[;, }, return, node, ;, }, static, Node, newVarNode, (, String, name, ,, Node, value, ), {, Node, nodeName, =]
[;, }, return, node, ;, }, static, Node, newVarNode, (, String, name, ,, Node, value, ), {, Node, nodeName, =]
[;, }, static, Node, newVarNode, (, String, name, ,, Node, value, ), {, Node, nodeName, =, IR, ., name, (]
[(, String, name, ,, Node, value, ), {, Node, nodeName, =, IR, ., name, (, name, ), ;, if, (]
[(, String, name, ,, Node, value, ), {, Node, nodeName, =, IR, ., name, (, name, ), ;, if, (]
[name, ,, Node, value, ), {, Node, nodeName, =, IR, ., name, (, name, ), ;, if, (, value, !=]
[value, ), {, Node, nodeName, =, IR, ., name, (, name, ), ;, if, (, value, !=, null, ), {]
[value, ), {, Node, nodeName, =, IR, ., name, (, name, ), ;, if, (, value, !=, null, ), {]
[nodeName, =, IR, ., name, (, name, ), ;, if, (, value, !=, null, ), {, Preconditions, ., checkState, (]
[nodeName, =, IR, ., name, (, name, ), ;, if, (, value, !=, null, ), {, Preconditions, ., checkState, (]
[nodeName, =, IR, ., name, (, name, ), ;, if, (, value, !=, null, ), {, Preconditions, ., checkState, (]
[name, ), ;, if, (, value, !=, null, ), {, Preconditions, ., checkState, (, value, ., getNext, (, ), ==]
[if, (, value, !=, null, ), {, Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null, ), ;]
[if, (, value, !=, null, ), {, Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null, ), ;]
[null, ), {, Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null, ), ;, nodeName, ., addChildToBack, (]
[Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null, ), ;, nodeName, ., addChildToBack, (, value, ), ;]
[Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null, ), ;, nodeName, ., addChildToBack, (, value, ), ;]
[value, ., getNext, (, ), ==, null, ), ;, nodeName, ., addChildToBack, (, value, ), ;, nodeName, ., srcref, (]
[), ;, nodeName, ., addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =]
[), ;, nodeName, ., addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =]
[), ;, nodeName, ., addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =]
[addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =, IR, ., var, (]
[nodeName, ., srcref, (, value, ), ;, }, Node, var, =, IR, ., var, (, nodeName, ), ., srcref, (]
[value, ), ;, }, Node, var, =, IR, ., var, (, nodeName, ), ., srcref, (, nodeName, ), ;, return]
[private, static, class, MatchNameNode, implements, Predicate, <, Node, >, {, final, String, name, ;, MatchNameNode, (, String, name, ), {]
[private, static, class, MatchNameNode, implements, Predicate, <, Node, >, {, final, String, name, ;, MatchNameNode, (, String, name, ), {]
[implements, Predicate, <, Node, >, {, final, String, name, ;, MatchNameNode, (, String, name, ), {, this, ., name, =]
[), {, this, ., name, =, name, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[), {, this, ., name, =, name, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[), {, this, ., name, =, name, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[name, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., isName, (, ), &&]
[name, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., isName, (, ), &&]
[name, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., isName, (, ), &&]
[(, Node, n, ), {, return, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (]
[}, static, class, MatchNodeType, implements, Predicate, <, Node, >, {, final, int, type, ;, MatchNodeType, (, int, type, ), {]
[}, static, class, MatchNodeType, implements, Predicate, <, Node, >, {, final, int, type, ;, MatchNodeType, (, int, type, ), {]
[implements, Predicate, <, Node, >, {, final, int, type, ;, MatchNodeType, (, int, type, ), {, this, ., type, =]
[), {, this, ., type, =, type, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[), {, this, ., type, =, type, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[), {, this, ., type, =, type, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[type, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., getType, (, ), ==]
[static, class, MatchDeclaration, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[static, class, MatchDeclaration, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[MatchDeclaration, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return, isFunctionDeclaration, (]
[<, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), ||]
[<, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), ||]
[static, class, MatchNotFunction, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[class, MatchNotFunction, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return, !]
[class, MatchNotFunction, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, return, !]
[), {, return, !, n, ., isFunction, (, ), ;, }, }, static, final, Predicate, <, Node, >, MATCH_NOT_FUNCTION, =]
[MatchShallowStatement, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, Node, parent, =]
[MatchShallowStatement, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {, Node, parent, =]
[@, Override, public, boolean, apply, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return]
[@, Override, public, boolean, apply, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return]
[@, Override, public, boolean, apply, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return]
[Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return, n, ., isBlock, (, ), ||]
[n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (]
[n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (]
[), {, Node, parent, =, n, ., getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (, !]
[), {, Node, parent, =, n, ., getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (, !]
[., getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&]
[getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&, (]
[getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&, (]
[getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&, (]
[getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&, (]
[), ;, return, n, ., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&, (, parent, ==]
[return, n, ., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&, (, parent, ==, null, ||]
[., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&, (, parent, ==, null, ||, isControlStructure, (]
[), ||, (, !, n, ., isFunction, (, ), &&, (, parent, ==, null, ||, isControlStructure, (, parent, ), ||]
[(, !, n, ., isFunction, (, ), &&, (, parent, ==, null, ||, isControlStructure, (, parent, ), ||, isStatementBlock, (]
[}, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return]
[static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, getCount, (]
[getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, getCount, (, node, ,]
[node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, getCount, (, node, ,, new, MatchNodeType, (]
[type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, getCount, (, node, ,, new, MatchNodeType, (, type, ), ,]
[;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return]
[static, boolean, isNameReferenced, (, Node, node, ,, String, name, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, has, (]
[isNameReferenced, (, Node, node, ,, String, name, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, has, (, node, ,]
[node, ,, String, name, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, has, (, node, ,, new, MatchNameNode, (]
[name, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return, has, (, node, ,, new, MatchNameNode, (, name, ), ,]
[(, name, ), ,, traverseChildrenPred, ), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ), {, return]
[), ,, traverseChildrenPred, ), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ), {, return, isNameReferenced, (]
[traverseChildrenPred, ), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ), {, return, isNameReferenced, (, node, ,]
[;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ), {, return, isNameReferenced, (, node, ,, name, ,]
[;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ), {, return, isNameReferenced, (, node, ,, name, ,]
[Node, >, alwaysTrue, (, ), ), ;, }, static, int, getNameReferenceCount, (, Node, node, ,, String, name, ), {, return]
[alwaysTrue, (, ), ), ;, }, static, int, getNameReferenceCount, (, Node, node, ,, String, name, ), {, return, getCount, (]
[), ), ;, }, static, int, getNameReferenceCount, (, Node, node, ,, String, name, ), {, return, getCount, (, node, ,]
[}, static, int, getNameReferenceCount, (, Node, node, ,, String, name, ), {, return, getCount, (, node, ,, new, MatchNameNode, (]
[getNameReferenceCount, (, Node, node, ,, String, name, ), {, return, getCount, (, node, ,, new, MatchNameNode, (, name, ), ,]
[getNameReferenceCount, (, Node, node, ,, String, name, ), {, return, getCount, (, node, ,, new, MatchNameNode, (, name, ), ,]
[has, (, Node, node, ,, Predicate, <, Node, >, pred, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, if, (]
[has, (, Node, node, ,, Predicate, <, Node, >, pred, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, if, (]
[,, Predicate, <, Node, >, pred, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, if, (, pred, ., apply, (]
[pred, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, if, (, pred, ., apply, (, node, ), ), {, return]
[>, traverseChildrenPred, ), {, if, (, pred, ., apply, (, node, ), ), {, return, true, ;, }, if, (]
[traverseChildrenPred, ), {, if, (, pred, ., apply, (, node, ), ), {, return, true, ;, }, if, (, !]
[traverseChildrenPred, ), {, if, (, pred, ., apply, (, node, ), ), {, return, true, ;, }, if, (, !]
[(, pred, ., apply, (, node, ), ), {, return, true, ;, }, if, (, !, traverseChildrenPred, ., apply, (]
[node, ), ), {, return, true, ;, }, if, (, !, traverseChildrenPred, ., apply, (, node, ), ), {, return]
[if, (, !, traverseChildrenPred, ., apply, (, node, ), ), {, return, false, ;, }, for, (, Node, c, =]
[if, (, !, traverseChildrenPred, ., apply, (, node, ), ), {, return, false, ;, }, for, (, Node, c, =]
[(, node, ), ), {, return, false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;]
[(, node, ), ), {, return, false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;]
[), ), {, return, false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=]
[{, return, false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;]
[false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[(, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, has, (]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, has, (, c, ,]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, has, (, c, ,, pred, ,]
[c, ., getNext, (, ), ), {, if, (, has, (, c, ,, pred, ,, traverseChildrenPred, ), ), {, return]
[), {, if, (, has, (, c, ,, pred, ,, traverseChildrenPred, ), ), {, return, true, ;, }, }, return]
[(, Node, n, ,, Predicate, <, Node, >, pred, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, int, total, =]
[Predicate, <, Node, >, pred, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, int, total, =, 0, ;, if, (]
[Predicate, <, Node, >, pred, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, int, total, =, 0, ;, if, (]
[pred, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, int, total, =, 0, ;, if, (, pred, ., apply, (]
[Node, >, traverseChildrenPred, ), {, int, total, =, 0, ;, if, (, pred, ., apply, (, n, ), ), {]
[Node, >, traverseChildrenPred, ), {, int, total, =, 0, ;, if, (, pred, ., apply, (, n, ), ), {]
[total, =, 0, ;, if, (, pred, ., apply, (, n, ), ), {, total, ++, ;, }, if, (]
[total, =, 0, ;, if, (, pred, ., apply, (, n, ), ), {, total, ++, ;, }, if, (]
[if, (, pred, ., apply, (, n, ), ), {, total, ++, ;, }, if, (, traverseChildrenPred, ., apply, (]
[{, total, ++, ;, }, if, (, traverseChildrenPred, ., apply, (, n, ), ), {, for, (, Node, c, =]
[{, total, ++, ;, }, if, (, traverseChildrenPred, ., apply, (, n, ), ), {, for, (, Node, c, =]
[(, traverseChildrenPred, ., apply, (, n, ), ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[(, traverseChildrenPred, ., apply, (, n, ), ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[., apply, (, n, ), ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[(, n, ), ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;]
[), ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[), ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[=, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, total, +=]
[(, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, total, +=, getCount, (]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, total, +=, getCount, (, c, ,]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, total, +=, getCount, (, c, ,, pred, ,]
[., getNext, (, ), ), {, total, +=, getCount, (, c, ,, pred, ,, traverseChildrenPred, ), ;, }, }, return]
[), ;, }, static, void, visitPreOrder, (, Node, node, ,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred, ), {]
[), ;, }, static, void, visitPreOrder, (, Node, node, ,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred, ), {]
[void, visitPreOrder, (, Node, node, ,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, visitor, ., visit, (]
[,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, visitor, ., visit, (, node, ), ;, if, (]
[,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, visitor, ., visit, (, node, ), ;, if, (]
[Predicate, <, Node, >, traverseChildrenPred, ), {, visitor, ., visit, (, node, ), ;, if, (, traverseChildrenPred, ., apply, (]
[visit, (, node, ), ;, if, (, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =]
[visit, (, node, ), ;, if, (, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =]
[(, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;]
[(, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;]
[., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=]
[(, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;]
[), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[=, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPreOrder, (]
[(, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPreOrder, (, c, ,]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPreOrder, (, c, ,, visitor, ,]
[}, static, void, visitPostOrder, (, Node, node, ,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, if, (]
[}, static, void, visitPostOrder, (, Node, node, ,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, if, (]
[(, Node, node, ,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, if, (, traverseChildrenPred, ., apply, (]
[Node, >, traverseChildrenPred, ), {, if, (, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =]
[Node, >, traverseChildrenPred, ), {, if, (, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =]
[(, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;]
[(, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;]
[., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=]
[(, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;]
[), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[=, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPostOrder, (]
[(, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPostOrder, (, c, ,]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,]
[c, =, c, ., getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }, }]
[c, =, c, ., getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }, }]
[getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }, }, visitor, ., visit, (]
[), ;, }, }, visitor, ., visit, (, node, ), ;, }, static, boolean, hasFinally, (, Node, n, ), {]
[), ;, }, }, visitor, ., visit, (, node, ), ;, }, static, boolean, hasFinally, (, Node, n, ), {]
[visitor, ., visit, (, node, ), ;, }, static, boolean, hasFinally, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[visitor, ., visit, (, node, ), ;, }, static, boolean, hasFinally, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[static, boolean, hasFinally, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), ), ;, return]
[static, boolean, hasFinally, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), ), ;, return]
[static, boolean, hasFinally, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), ), ;, return]
[), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), ), ;, return, n, ., getChildCount, (, ), ==]
[), ;, return, n, ., getChildCount, (, ), ==, 3, ;, }, static, Node, getCatchBlock, (, Node, n, ), {]
[), ;, return, n, ., getChildCount, (, ), ==, 3, ;, }, static, Node, getCatchBlock, (, Node, n, ), {]
[., getChildCount, (, ), ==, 3, ;, }, static, Node, getCatchBlock, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[., getChildCount, (, ), ==, 3, ;, }, static, Node, getCatchBlock, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[static, Node, getCatchBlock, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), ), ;, return]
[static, Node, getCatchBlock, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), ), ;, return]
[static, Node, getCatchBlock, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), ), ;, return]
[return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, hasCatchHandler, (, Node, n, ), {]
[return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, hasCatchHandler, (, Node, n, ), {]
[(, ), ., getNext, (, ), ;, }, static, boolean, hasCatchHandler, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[(, ), ., getNext, (, ), ;, }, static, boolean, hasCatchHandler, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[static, boolean, hasCatchHandler, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isBlock, (, ), ), ;, return]
[static, boolean, hasCatchHandler, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isBlock, (, ), ), ;, return]
[static, boolean, hasCatchHandler, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isBlock, (, ), ), ;, return]
[), {, Preconditions, ., checkArgument, (, n, ., isBlock, (, ), ), ;, return, n, ., hasChildren, (, ), &&]
[), {, Preconditions, ., checkArgument, (, n, ., isBlock, (, ), ), ;, return, n, ., hasChildren, (, ), &&]
[), {, Preconditions, ., checkArgument, (, n, ., isBlock, (, ), ), ;, return, n, ., hasChildren, (, ), &&]
[n, ., getFirstChild, (, ), ., isCatch, (, ), ;, }, public, static, Node, getFunctionParameters, (, Node, fnNode, ), {]
[n, ., getFirstChild, (, ), ., isCatch, (, ), ;, }, public, static, Node, getFunctionParameters, (, Node, fnNode, ), {]
[), ., isCatch, (, ), ;, }, public, static, Node, getFunctionParameters, (, Node, fnNode, ), {, Preconditions, ., checkArgument, (]
[), ., isCatch, (, ), ;, }, public, static, Node, getFunctionParameters, (, Node, fnNode, ), {, Preconditions, ., checkArgument, (]
[static, Node, getFunctionParameters, (, Node, fnNode, ), {, Preconditions, ., checkArgument, (, fnNode, ., isFunction, (, ), ), ;, return]
[static, Node, getFunctionParameters, (, Node, fnNode, ), {, Preconditions, ., checkArgument, (, fnNode, ., isFunction, (, ), ), ;, return]
[static, Node, getFunctionParameters, (, Node, fnNode, ), {, Preconditions, ., checkArgument, (, fnNode, ., isFunction, (, ), ), ;, return]
[fnNode, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, isConstantName, (, Node, node, ), {, return]
[fnNode, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, isConstantName, (, Node, node, ), {, return]
[), ., getNext, (, ), ;, }, static, boolean, isConstantName, (, Node, node, ), {, return, node, ., getBooleanProp, (]
[), ., getNext, (, ), ;, }, static, boolean, isConstantName, (, Node, node, ), {, return, node, ., getBooleanProp, (]
[), ;, }, static, boolean, isConstantByConvention, (, CodingConvention, convention, ,, Node, node, ,, Node, parent, ), {, String, name, =]
[), ;, }, static, boolean, isConstantByConvention, (, CodingConvention, convention, ,, Node, node, ,, Node, parent, ), {, String, name, =]
[convention, ,, Node, node, ,, Node, parent, ), {, String, name, =, node, ., getString, (, ), ;, if, (]
[convention, ,, Node, node, ,, Node, parent, ), {, String, name, =, node, ., getString, (, ), ;, if, (]
[convention, ,, Node, node, ,, Node, parent, ), {, String, name, =, node, ., getString, (, ), ;, if, (]
[parent, ), {, String, name, =, node, ., getString, (, ), ;, if, (, parent, ., isGetProp, (, ), &&]
[parent, ), {, String, name, =, node, ., getString, (, ), ;, if, (, parent, ., isGetProp, (, ), &&]
[{, String, name, =, node, ., getString, (, ), ;, if, (, parent, ., isGetProp, (, ), &&, node, ==]
[{, String, name, =, node, ., getString, (, ), ;, if, (, parent, ., isGetProp, (, ), &&, node, ==]
[), ;, if, (, parent, ., isGetProp, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {, return]
[), ;, if, (, parent, ., isGetProp, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {, return]
[parent, ., isGetProp, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {, return, convention, ., isConstantKey, (]
[==, parent, ., getLastChild, (, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, if, (]
[., getLastChild, (, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, if, (, isObjectLitKey, (]
[(, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, if, (, isObjectLitKey, (, node, ,]
[convention, ., isConstantKey, (, name, ), ;, }, else, if, (, isObjectLitKey, (, node, ,, parent, ), ), {, return]
[convention, ., isConstantKey, (, name, ), ;, }, else, if, (, isObjectLitKey, (, node, ,, parent, ), ), {, return]
[name, ), ;, }, else, if, (, isObjectLitKey, (, node, ,, parent, ), ), {, return, convention, ., isConstantKey, (]
[isObjectLitKey, (, node, ,, parent, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, {, return]
[isObjectLitKey, (, node, ,, parent, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, {, return]
[parent, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, {, return, convention, ., isConstant, (]
[{, return, convention, ., isConstant, (, name, ), ;, }, }, public, static, JSDocInfo, getFunctionJSDocInfo, (, Node, n, ), {]
[{, return, convention, ., isConstant, (, name, ), ;, }, }, public, static, JSDocInfo, getFunctionJSDocInfo, (, Node, n, ), {]
[isConstant, (, name, ), ;, }, }, public, static, JSDocInfo, getFunctionJSDocInfo, (, Node, n, ), {, Preconditions, ., checkState, (]
[isConstant, (, name, ), ;, }, }, public, static, JSDocInfo, getFunctionJSDocInfo, (, Node, n, ), {, Preconditions, ., checkState, (]
[getFunctionJSDocInfo, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isFunction, (, ), ), ;, JSDocInfo, fnInfo, =]
[getFunctionJSDocInfo, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isFunction, (, ), ), ;, JSDocInfo, fnInfo, =]
[checkState, (, n, ., isFunction, (, ), ), ;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (]
[checkState, (, n, ., isFunction, (, ), ), ;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (]
[checkState, (, n, ., isFunction, (, ), ), ;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (]
[n, ., isFunction, (, ), ), ;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (, fnInfo, ==]
[isFunction, (, ), ), ;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (, fnInfo, ==, null, &&]
[isFunction, (, ), ), ;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (, fnInfo, ==, null, &&]
[;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (, fnInfo, ==, null, &&, NodeUtil, ., isFunctionExpression, (]
[(, ), ;, if, (, fnInfo, ==, null, &&, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Node, parent, =]
[(, ), ;, if, (, fnInfo, ==, null, &&, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Node, parent, =]
[&&, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[&&, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isAssign, (, ), ), {]
[Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isAssign, (, ), ), {, fnInfo, =]
[Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isAssign, (, ), ), {, fnInfo, =]
[(, parent, ., isAssign, (, ), ), {, fnInfo, =, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[(, parent, ., isAssign, (, ), ), {, fnInfo, =, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[{, fnInfo, =, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isName, (, ), ), {]
[=, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isName, (, ), ), {, fnInfo, =]
[=, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isName, (, ), ), {, fnInfo, =]
[=, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isName, (, ), ), {, fnInfo, =]
[isName, (, ), ), {, fnInfo, =, parent, ., getParent, (, ), ., getJSDocInfo, (, ), ;, }, }, return]
[), ;, }, }, return, fnInfo, ;, }, public, static, String, getSourceName, (, Node, n, ), {, String, sourceName, =]
[return, fnInfo, ;, }, public, static, String, getSourceName, (, Node, n, ), {, String, sourceName, =, null, ;, while, (]
[return, fnInfo, ;, }, public, static, String, getSourceName, (, Node, n, ), {, String, sourceName, =, null, ;, while, (]
[return, fnInfo, ;, }, public, static, String, getSourceName, (, Node, n, ), {, String, sourceName, =, null, ;, while, (]
[;, }, public, static, String, getSourceName, (, Node, n, ), {, String, sourceName, =, null, ;, while, (, sourceName, ==]
[public, static, String, getSourceName, (, Node, n, ), {, String, sourceName, =, null, ;, while, (, sourceName, ==, null, &&]
[public, static, String, getSourceName, (, Node, n, ), {, String, sourceName, =, null, ;, while, (, sourceName, ==, null, &&]
[String, getSourceName, (, Node, n, ), {, String, sourceName, =, null, ;, while, (, sourceName, ==, null, &&, n, !=]
[Node, n, ), {, String, sourceName, =, null, ;, while, (, sourceName, ==, null, &&, n, !=, null, ), {]
[), {, String, sourceName, =, null, ;, while, (, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =]
[), {, String, sourceName, =, null, ;, while, (, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =]
[;, while, (, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getSourceFileName, (, ), ;]
[(, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =]
[(, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =]
[), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return]
[(, ), ;, }, return, sourceName, ;, }, public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =]
[return, sourceName, ;, }, public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =, null, ;, while, (]
[return, sourceName, ;, }, public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =, null, ;, while, (]
[return, sourceName, ;, }, public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =, null, ;, while, (]
[;, }, public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =, null, ;, while, (, sourceName, ==]
[public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =, null, ;, while, (, sourceName, ==, null, &&]
[public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =, null, ;, while, (, sourceName, ==, null, &&]
[StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =, null, ;, while, (, sourceName, ==, null, &&, n, !=]
[Node, n, ), {, StaticSourceFile, sourceName, =, null, ;, while, (, sourceName, ==, null, &&, n, !=, null, ), {]
[), {, StaticSourceFile, sourceName, =, null, ;, while, (, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =]
[), {, StaticSourceFile, sourceName, =, null, ;, while, (, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =]
[;, while, (, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;]
[(, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =]
[(, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =]
[), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return]
[getParent, (, ), ;, }, return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, ), {, while, (]
[getParent, (, ), ;, }, return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, ), {, while, (]
[getParent, (, ), ;, }, return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, ), {, while, (]
[), ;, }, return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, ), {, while, (, n, !=]
[}, return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, ), {, while, (, n, !=, null, &&]
[return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, ), {, while, (, n, !=, null, &&, !]
[return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, ), {, while, (, n, !=, null, &&, !]
[getInputId, (, Node, n, ), {, while, (, n, !=, null, &&, !, n, ., isScript, (, ), ), {]
[Node, n, ), {, while, (, n, !=, null, &&, !, n, ., isScript, (, ), ), {, n, =]
[Node, n, ), {, while, (, n, !=, null, &&, !, n, ., isScript, (, ), ), {, n, =]
[null, &&, !, n, ., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return]
[null, &&, !, n, ., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return]
[&&, !, n, ., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return, (]
[&&, !, n, ., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return, (]
[&&, !, n, ., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return, (]
[n, ., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return, (, n, !=]
[isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return, (, n, !=, null, &&]
[isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return, (, n, !=, null, &&]
[n, ., getParent, (, ), ;, }, return, (, n, !=, null, &&, n, ., isScript, (, ), ), ?]
[n, ., getParent, (, ), ;, }, return, (, n, !=, null, &&, n, ., isScript, (, ), ), ?]
[}, return, (, n, !=, null, &&, n, ., isScript, (, ), ), ?, n, ., getInputId, (, ), :]
[), :, null, ;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ..., parameters, ), {, boolean, isFreeCall, =]
[:, null, ;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ..., parameters, ), {, boolean, isFreeCall, =, !]
[;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ..., parameters, ), {, boolean, isFreeCall, =, !, isGet, (]
[Node, callTarget, ,, Node, ..., parameters, ), {, boolean, isFreeCall, =, !, isGet, (, callTarget, ), ;, Node, call, =]
[Node, callTarget, ,, Node, ..., parameters, ), {, boolean, isFreeCall, =, !, isGet, (, callTarget, ), ;, Node, call, =]
[..., parameters, ), {, boolean, isFreeCall, =, !, isGet, (, callTarget, ), ;, Node, call, =, IR, ., call, (]
[{, boolean, isFreeCall, =, !, isGet, (, callTarget, ), ;, Node, call, =, IR, ., call, (, callTarget, ), ;]
[{, boolean, isFreeCall, =, !, isGet, (, callTarget, ), ;, Node, call, =, IR, ., call, (, callTarget, ), ;]
[!, isGet, (, callTarget, ), ;, Node, call, =, IR, ., call, (, callTarget, ), ;, call, ., putBooleanProp, (]
[!, isGet, (, callTarget, ), ;, Node, call, =, IR, ., call, (, callTarget, ), ;, call, ., putBooleanProp, (]
[), ;, Node, call, =, IR, ., call, (, callTarget, ), ;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,]
[(, callTarget, ), ;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,, isFreeCall, ), ;, for, (, Node, parameter, :]
[;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,, isFreeCall, ), ;, for, (, Node, parameter, :, parameters, ), {]
[;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,, isFreeCall, ), ;, for, (, Node, parameter, :, parameters, ), {]
[(, Node, ., FREE_CALL, ,, isFreeCall, ), ;, for, (, Node, parameter, :, parameters, ), {, call, ., addChildToBack, (]
[isFreeCall, ), ;, for, (, Node, parameter, :, parameters, ), {, call, ., addChildToBack, (, parameter, ), ;, }, return]
[., addChildToBack, (, parameter, ), ;, }, return, call, ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ), {, return]
[(, parameter, ), ;, }, return, call, ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ), {, return, evaluatesToLocalValue, (]
[), ;, }, return, call, ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ), {, return, evaluatesToLocalValue, (, value, ,]
[), ;, }, return, call, ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ), {, return, evaluatesToLocalValue, (, value, ,]
[), ), ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ,, Predicate, <, Node, >, locals, ), {, switch, (]
[), ), ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ,, Predicate, <, Node, >, locals, ), {, switch, (]
[Node, value, ,, Predicate, <, Node, >, locals, ), {, switch, (, value, ., getType, (, ), ), {, case]
[Node, value, ,, Predicate, <, Node, >, locals, ), {, switch, (, value, ., getType, (, ), ), {, case]
[Node, >, locals, ), {, switch, (, value, ., getType, (, ), ), {, case, Token, ., CAST, :, return]
[locals, ), {, switch, (, value, ., getType, (, ), ), {, case, Token, ., CAST, :, return, evaluatesToLocalValue, (]
[locals, ), {, switch, (, value, ., getType, (, ), ), {, case, Token, ., CAST, :, return, evaluatesToLocalValue, (]
[., getType, (, ), ), {, case, Token, ., CAST, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,]
[), {, case, Token, ., CAST, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, case]
[), {, case, Token, ., CAST, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, case]
[CAST, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, case, Token, ., ASSIGN, :, return]
[CAST, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, case, Token, ., ASSIGN, :, return]
[CAST, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, case, Token, ., ASSIGN, :, return]
[(, value, ., getFirstChild, (, ), ,, locals, ), ;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (]
[(, value, ., getFirstChild, (, ), ,, locals, ), ;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (]
[locals, ), ;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||]
[), ;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (]
[), ;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (]
[), ;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (]
[., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (, locals, ., apply, (]
[return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (, locals, ., apply, (, value, ), &&]
[., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (, locals, ., apply, (, value, ), &&, evaluatesToLocalValue, (]
[., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (, locals, ., apply, (, value, ), &&, evaluatesToLocalValue, (]
[(, ), ), ||, (, locals, ., apply, (, value, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,]
[locals, ., apply, (, value, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ), ;, case]
[locals, ., apply, (, value, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ), ;, case]
[), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ), ;, case, Token, ., COMMA, :, return]
[evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (]
[evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (]
[), ,, locals, ), ), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,]
[), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., AND, :, case]
[COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., AND, :, case]
[value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return]
[value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return]
[getLastChild, (, ), ,, locals, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, evaluatesToLocalValue, (]
[getLastChild, (, ), ,, locals, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, evaluatesToLocalValue, (]
[;, case, Token, ., AND, :, case, Token, ., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,]
[., AND, :, case, Token, ., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), &&]
[:, case, Token, ., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), &&, evaluatesToLocalValue, (]
[:, case, Token, ., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), &&, evaluatesToLocalValue, (]
[return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,]
[., getFirstChild, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[., getFirstChild, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., HOOK, :, return]
[locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., HOOK, :, return]
[&&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (]
[&&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (]
[&&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (]
[), ;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (, ), ,]
[Token, ., HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (, ), ,, locals, ), &&]
[HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (, ), ,, locals, ), &&, evaluatesToLocalValue, (]
[HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (, ), ,, locals, ), &&, evaluatesToLocalValue, (]
[., getFirstChild, (, ), ., getNext, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,]
[., getNext, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[., getNext, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., INC, :, case]
[locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., INC, :, case]
[., getLastChild, (, ), ,, locals, ), ;, case, Token, ., INC, :, case, Token, ., DEC, :, if, (]
[., getLastChild, (, ), ,, locals, ), ;, case, Token, ., INC, :, case, Token, ., DEC, :, if, (]
[,, locals, ), ;, case, Token, ., INC, :, case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (]
[,, locals, ), ;, case, Token, ., INC, :, case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (]
[INC, :, case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP, ), ), {, return]
[case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP, ), ), {, return, evaluatesToLocalValue, (]
[case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP, ), ), {, return, evaluatesToLocalValue, (]
[(, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP, ), ), {, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,]
[INCRDECR_PROP, ), ), {, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, }, else, {, return]
[return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, }, else, {, return, true, ;, }, case]
[return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, }, else, {, return, true, ;, }, case]
[getFirstChild, (, ), ,, locals, ), ;, }, else, {, return, true, ;, }, case, Token, ., THIS, :, return]
[getFirstChild, (, ), ,, locals, ), ;, }, else, {, return, true, ;, }, case, Token, ., THIS, :, return]
[locals, ), ;, }, else, {, return, true, ;, }, case, Token, ., THIS, :, return, locals, ., apply, (]
[else, {, return, true, ;, }, case, Token, ., THIS, :, return, locals, ., apply, (, value, ), ;, case]
[else, {, return, true, ;, }, case, Token, ., THIS, :, return, locals, ., apply, (, value, ), ;, case]
[}, case, Token, ., THIS, :, return, locals, ., apply, (, value, ), ;, case, Token, ., NAME, :, return]
[}, case, Token, ., THIS, :, return, locals, ., apply, (, value, ), ;, case, Token, ., NAME, :, return]
[Token, ., THIS, :, return, locals, ., apply, (, value, ), ;, case, Token, ., NAME, :, return, isImmutableValue, (]
[:, return, locals, ., apply, (, value, ), ;, case, Token, ., NAME, :, return, isImmutableValue, (, value, ), ||]
[:, return, locals, ., apply, (, value, ), ;, case, Token, ., NAME, :, return, isImmutableValue, (, value, ), ||]
[apply, (, value, ), ;, case, Token, ., NAME, :, return, isImmutableValue, (, value, ), ||, locals, ., apply, (]
[;, case, Token, ., NAME, :, return, isImmutableValue, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[;, case, Token, ., NAME, :, return, isImmutableValue, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[:, return, isImmutableValue, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., GETELEM, :, case]
[:, return, isImmutableValue, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., GETELEM, :, case]
[), ||, locals, ., apply, (, value, ), ;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return]
[), ||, locals, ., apply, (, value, ), ;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return]
[apply, (, value, ), ;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return, locals, ., apply, (]
[;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case]
[;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case]
[:, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case, Token, ., CALL, :, return]
[:, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case, Token, ., CALL, :, return]
[:, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case, Token, ., CALL, :, return]
[Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case, Token, ., CALL, :, return, callHasLocalResult, (]
[:, return, locals, ., apply, (, value, ), ;, case, Token, ., CALL, :, return, callHasLocalResult, (, value, ), ||]
[locals, ., apply, (, value, ), ;, case, Token, ., CALL, :, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (]
[(, value, ), ;, case, Token, ., CALL, :, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value, ), ||]
[(, value, ), ;, case, Token, ., CALL, :, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value, ), ||]
[case, Token, ., CALL, :, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value, ), ||, locals, ., apply, (]
[:, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[:, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[), ||, isToStringMethodCall, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return]
[), ||, isToStringMethodCall, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return]
[isToStringMethodCall, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return, newHasLocalResult, (]
[), ||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||]
[), ||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||]
[apply, (, value, ), ;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (]
[;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[:, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., FUNCTION, :, case]
[:, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., FUNCTION, :, case]
[), ||, locals, ., apply, (, value, ), ;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case]
[), ||, locals, ., apply, (, value, ), ;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case]
[(, value, ), ;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case]
[(, value, ), ;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case]
[Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return]
[:, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, true, ;, case]
[:, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, true, ;, case]
[:, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, true, ;, case, Token, ., DELPROP, :, case]
[:, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, true, ;, case, Token, ., DELPROP, :, case]
[:, case, Token, ., OBJECTLIT, :, return, true, ;, case, Token, ., DELPROP, :, case, Token, ., IN, :, return]
[return, true, ;, case, Token, ., DELPROP, :, case, Token, ., IN, :, return, true, ;, default, :, if, (]
[return, true, ;, case, Token, ., DELPROP, :, case, Token, ., IN, :, return, true, ;, default, :, if, (]
[return, true, ;, case, Token, ., DELPROP, :, case, Token, ., IN, :, return, true, ;, default, :, if, (]
[;, case, Token, ., DELPROP, :, case, Token, ., IN, :, return, true, ;, default, :, if, (, isAssignmentOp, (]
[., DELPROP, :, case, Token, ., IN, :, return, true, ;, default, :, if, (, isAssignmentOp, (, value, ), ||]
[:, case, Token, ., IN, :, return, true, ;, default, :, if, (, isAssignmentOp, (, value, ), ||, isSimpleOperator, (]
[., IN, :, return, true, ;, default, :, if, (, isAssignmentOp, (, value, ), ||, isSimpleOperator, (, value, ), ||]
[:, return, true, ;, default, :, if, (, isAssignmentOp, (, value, ), ||, isSimpleOperator, (, value, ), ||, isImmutableValue, (]
[:, if, (, isAssignmentOp, (, value, ), ||, isSimpleOperator, (, value, ), ||, isImmutableValue, (, value, ), ), {, return]
[(, value, ), ||, isSimpleOperator, (, value, ), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw]
[||, isSimpleOperator, (, value, ), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (]
[||, isSimpleOperator, (, value, ), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (]
[||, isSimpleOperator, (, value, ), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (]
[||, isSimpleOperator, (, value, ), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (]
[(, value, ), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +]
[), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +]
[isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +, "\n parent:", +]
[isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +, "\n parent:", +]
[), ), ;, }, }, private, static, Node, getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =]
[}, private, static, Node, getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =, first, ;, while, (]
[}, private, static, Node, getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =, first, ;, while, (]
[}, private, static, Node, getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =, first, ;, while, (]
[static, Node, getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =, first, ;, while, (, index, !=]
[getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =, first, ;, while, (, index, !=, 0, &&]
[getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =, first, ;, while, (, index, !=, 0, &&]
[Node, first, ,, int, index, ), {, Node, sibling, =, first, ;, while, (, index, !=, 0, &&, sibling, !=]
[int, index, ), {, Node, sibling, =, first, ;, while, (, index, !=, 0, &&, sibling, !=, null, ), {]
[), {, Node, sibling, =, first, ;, while, (, index, !=, 0, &&, sibling, !=, null, ), {, sibling, =]
[), {, Node, sibling, =, first, ;, while, (, index, !=, 0, &&, sibling, !=, null, ), {, sibling, =]
[;, while, (, index, !=, 0, &&, sibling, !=, null, ), {, sibling, =, sibling, ., getNext, (, ), ;]
[;, while, (, index, !=, 0, &&, sibling, !=, null, ), {, sibling, =, sibling, ., getNext, (, ), ;]
[0, &&, sibling, !=, null, ), {, sibling, =, sibling, ., getNext, (, ), ;, index, --, ;, }, return]
[;, index, --, ;, }, return, sibling, ;, }, static, Node, getArgumentForFunction, (, Node, function, ,, int, index, ), {]
[;, index, --, ;, }, return, sibling, ;, }, static, Node, getArgumentForFunction, (, Node, function, ,, int, index, ), {]
[}, return, sibling, ;, }, static, Node, getArgumentForFunction, (, Node, function, ,, int, index, ), {, Preconditions, ., checkState, (]
[}, return, sibling, ;, }, static, Node, getArgumentForFunction, (, Node, function, ,, int, index, ), {, Preconditions, ., checkState, (]
[(, Node, function, ,, int, index, ), {, Preconditions, ., checkState, (, function, ., isFunction, (, ), ), ;, return]
[function, ,, int, index, ), {, Preconditions, ., checkState, (, function, ., isFunction, (, ), ), ;, return, getNthSibling, (]
[function, ,, int, index, ), {, Preconditions, ., checkState, (, function, ., isFunction, (, ), ), ;, return, getNthSibling, (]
[function, ,, int, index, ), {, Preconditions, ., checkState, (, function, ., isFunction, (, ), ), ;, return, getNthSibling, (]
[function, ,, int, index, ), {, Preconditions, ., checkState, (, function, ., isFunction, (, ), ), ;, return, getNthSibling, (]
[), ), ;, return, getNthSibling, (, function, ., getFirstChild, (, ), ., getNext, (, ), ., getFirstChild, (, ), ,]
[., getFirstChild, (, ), ,, index, ), ;, }, static, Node, getArgumentForCallOrNew, (, Node, call, ,, int, index, ), {]
[., getFirstChild, (, ), ,, index, ), ;, }, static, Node, getArgumentForCallOrNew, (, Node, call, ,, int, index, ), {]
[,, index, ), ;, }, static, Node, getArgumentForCallOrNew, (, Node, call, ,, int, index, ), {, Preconditions, ., checkState, (]
[), ;, }, static, Node, getArgumentForCallOrNew, (, Node, call, ,, int, index, ), {, Preconditions, ., checkState, (, isCallOrNew, (]
[getArgumentForCallOrNew, (, Node, call, ,, int, index, ), {, Preconditions, ., checkState, (, isCallOrNew, (, call, ), ), ;, return]
[Node, call, ,, int, index, ), {, Preconditions, ., checkState, (, isCallOrNew, (, call, ), ), ;, return, getNthSibling, (]
[Node, call, ,, int, index, ), {, Preconditions, ., checkState, (, isCallOrNew, (, call, ), ), ;, return, getNthSibling, (]
[Node, call, ,, int, index, ), {, Preconditions, ., checkState, (, isCallOrNew, (, call, ), ), ;, return, getNthSibling, (]
[(, isCallOrNew, (, call, ), ), ;, return, getNthSibling, (, call, ., getFirstChild, (, ), ., getNext, (, ), ,]
[., getNext, (, ), ,, index, ), ;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =]
[., getNext, (, ), ,, index, ), ;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =]
[;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (, ), ;, return]
[;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (, ), ;, return]
[;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (, ), ;, return]
[;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (, ), ;, return]
[static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (, ), ;, return, parent, !=]
[isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (, ), ;, return, parent, !=, null, &&]
[isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (, ), ;, return, parent, !=, null, &&]
[), {, Node, parent, =, target, ., getParent, (, ), ;, return, parent, !=, null, &&, NodeUtil, ., isCallOrNew, (]
[parent, =, target, ., getParent, (, ), ;, return, parent, !=, null, &&, NodeUtil, ., isCallOrNew, (, parent, ), &&]
[parent, =, target, ., getParent, (, ), ;, return, parent, !=, null, &&, NodeUtil, ., isCallOrNew, (, parent, ), &&]
[parent, =, target, ., getParent, (, ), ;, return, parent, !=, null, &&, NodeUtil, ., isCallOrNew, (, parent, ), &&]
[), ;, return, parent, !=, null, &&, NodeUtil, ., isCallOrNew, (, parent, ), &&, parent, ., getFirstChild, (, ), ==]
[., getFirstChild, (, ), ==, target, ;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node, getNode, =]
[., getFirstChild, (, ), ==, target, ;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node, getNode, =]
[private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node, getNode, =, call, ., getFirstChild, (, ), ;, if, (]
[boolean, isToStringMethodCall, (, Node, call, ), {, Node, getNode, =, call, ., getFirstChild, (, ), ;, if, (, isGet, (]
[Node, getNode, =, call, ., getFirstChild, (, ), ;, if, (, isGet, (, getNode, ), ), {, Node, propNode, =]
[Node, getNode, =, call, ., getFirstChild, (, ), ;, if, (, isGet, (, getNode, ), ), {, Node, propNode, =]
[), ;, if, (, isGet, (, getNode, ), ), {, Node, propNode, =, getNode, ., getLastChild, (, ), ;, return]
[), ;, if, (, isGet, (, getNode, ), ), {, Node, propNode, =, getNode, ., getLastChild, (, ), ;, return]
[), ;, if, (, isGet, (, getNode, ), ), {, Node, propNode, =, getNode, ., getLastChild, (, ), ;, return]
[getNode, ), ), {, Node, propNode, =, getNode, ., getLastChild, (, ), ;, return, propNode, ., isString, (, ), &&]
[getNode, ), ), {, Node, propNode, =, getNode, ., getLastChild, (, ), ;, return, propNode, ., isString, (, ), &&]
[Node, propNode, =, getNode, ., getLastChild, (, ), ;, return, propNode, ., isString, (, ), &&, "toString", ., equals, (]
[Node, propNode, =, getNode, ., getLastChild, (, ), ;, return, propNode, ., isString, (, ), &&, "toString", ., equals, (]
[return, propNode, ., isString, (, ), &&, "toString", ., equals, (, propNode, ., getString, (, ), ), ;, }, return]
[(, ), ), ;, }, return, false, ;, }, static, JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo, info, =]
[(, ), ), ;, }, return, false, ;, }, static, JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo, info, =]
[}, static, JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo, info, =, n, ., getJSDocInfo, (, ), ;, if, (]
[}, static, JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo, info, =, n, ., getJSDocInfo, (, ), ;, if, (]
[JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo, info, =, n, ., getJSDocInfo, (, ), ;, if, (, info, ==]
[{, JSDocInfo, info, =, n, ., getJSDocInfo, (, ), ;, if, (, info, ==, null, ), {, Node, parent, =]
[{, JSDocInfo, info, =, n, ., getJSDocInfo, (, ), ;, if, (, info, ==, null, ), {, Node, parent, =]
[), ;, if, (, info, ==, null, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[), ;, if, (, info, ==, null, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[if, (, info, ==, null, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==]
[null, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return]
[=, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, null, ;, }, if, (]
[=, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, null, ;, }, if, (]
[(, parent, ==, null, ), {, return, null, ;, }, if, (, parent, ., isName, (, ), ), {, return]
[==, null, ), {, return, null, ;, }, if, (, parent, ., isName, (, ), ), {, return, getBestJSDocInfo, (]
[}, if, (, parent, ., isName, (, ), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (]
[}, if, (, parent, ., isName, (, ), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (]
[), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isAssign, (, ), ), {, return]
[), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isAssign, (, ), ), {, return]
[if, (, parent, ., isAssign, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[parent, ., isAssign, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, isObjectLitKey, (]
[isAssign, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,]
[isAssign, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,]
[(, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return]
[(, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return]
[,, parent, ., getParent, (, ), ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[,, parent, ., getParent, (, ), ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[{, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isFunction, (, ), ), {, return]
[{, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isFunction, (, ), ), {, return]
[if, (, parent, ., isFunction, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[if, (, parent, ., isFunction, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[if, (, parent, ., isFunction, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isVar, (, ), &&]
[), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isVar, (, ), &&]
[), ;, }, else, if, (, parent, ., isVar, (, ), &&, parent, ., hasOneChild, (, ), ), {, return]
[), ;, }, else, if, (, parent, ., isVar, (, ), &&, parent, ., hasOneChild, (, ), ), {, return]
[), &&, parent, ., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[), &&, parent, ., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[), &&, parent, ., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[), &&, parent, ., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[&&, parent, ., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (]
[&&, parent, ., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (]
[&&, parent, ., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (]
[), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (, parent, ., isHook, (, ), &&]
[), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (, parent, ., isHook, (, ), &&]
[), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (, parent, ., isHook, (, ), &&]
[(, ), ;, }, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=]
[}, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||]
[}, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||]
[., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||]
[., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||]
[., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||]
[getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (]
[getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (]
[getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (]
[||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&]
[||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&]
[||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&]
[||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=]
[), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return]
[(, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestJSDocInfo, (]
[parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (]
[parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (]
[), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return]
[), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return]
[else, if, (, parent, ., isCast, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, }, return]
[(, ), ;, }, }, return, info, ;, }, static, Node, getBestLValue, (, Node, n, ), {, Node, parent, =]
[(, ), ;, }, }, return, info, ;, }, static, Node, getBestLValue, (, Node, n, ), {, Node, parent, =]
[static, Node, getBestLValue, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, boolean, isFunctionDeclaration, =]
[getBestLValue, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, boolean, isFunctionDeclaration, =, isFunctionDeclaration, (]
[{, Node, parent, =, n, ., getParent, (, ), ;, boolean, isFunctionDeclaration, =, isFunctionDeclaration, (, n, ), ;, if, (]
[n, ., getParent, (, ), ;, boolean, isFunctionDeclaration, =, isFunctionDeclaration, (, n, ), ;, if, (, isFunctionDeclaration, ), {, return]
[n, ., getParent, (, ), ;, boolean, isFunctionDeclaration, =, isFunctionDeclaration, (, n, ), ;, if, (, isFunctionDeclaration, ), {, return]
[(, n, ), ;, if, (, isFunctionDeclaration, ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (]
[(, n, ), ;, if, (, isFunctionDeclaration, ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (]
[{, return, n, ., getFirstChild, (, ), ;, }, else, if, (, parent, ., isName, (, ), ), {, return]
[), ;, }, else, if, (, parent, ., isName, (, ), ), {, return, parent, ;, }, else, if, (]
[), ;, }, else, if, (, parent, ., isName, (, ), ), {, return, parent, ;, }, else, if, (]
[isName, (, ), ), {, return, parent, ;, }, else, if, (, parent, ., isAssign, (, ), ), {, return]
[isName, (, ), ), {, return, parent, ;, }, else, if, (, parent, ., isAssign, (, ), ), {, return]
[if, (, parent, ., isAssign, (, ), ), {, return, parent, ., getFirstChild, (, ), ;, }, else, if, (]
[parent, ., isAssign, (, ), ), {, return, parent, ., getFirstChild, (, ), ;, }, else, if, (, isObjectLitKey, (]
[isAssign, (, ), ), {, return, parent, ., getFirstChild, (, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,]
[isAssign, (, ), ), {, return, parent, ., getFirstChild, (, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,]
[(, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return]
[(, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return, parent, ;, }, else, if, (]
[(, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return, parent, ;, }, else, if, (]
[(, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return, parent, ;, }, else, if, (]
[(, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return, parent, ;, }, else, if, (]
[isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return, parent, ;, }, else, if, (, (]
[isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return, parent, ;, }, else, if, (, (]
[isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return, parent, ;, }, else, if, (, (]
[getParent, (, ), ), ), {, return, parent, ;, }, else, if, (, (, parent, ., isHook, (, ), &&]
[getParent, (, ), ), ), {, return, parent, ;, }, else, if, (, (, parent, ., isHook, (, ), &&]
[getParent, (, ), ), ), {, return, parent, ;, }, else, if, (, (, parent, ., isHook, (, ), &&]
[return, parent, ;, }, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=]
[}, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||]
[}, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||]
[., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||]
[., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||]
[., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||]
[getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (]
[getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (]
[getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (]
[||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&]
[||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&]
[||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&]
[||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=]
[), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return]
[(, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestLValue, (]
[parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestLValue, (, parent, ), ;, }, else, if, (]
[parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestLValue, (, parent, ), ;, }, else, if, (]
[), {, return, getBestLValue, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return]
[return, getBestLValue, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return, getBestLValue, (]
[;, }, else, if, (, parent, ., isCast, (, ), ), {, return, getBestLValue, (, parent, ), ;, }, return]
[(, parent, ), ;, }, return, null, ;, }, static, Node, getRValueOfLValue, (, Node, n, ), {, Node, parent, =]
[(, parent, ), ;, }, return, null, ;, }, static, Node, getRValueOfLValue, (, Node, n, ), {, Node, parent, =]
[}, static, Node, getRValueOfLValue, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[}, static, Node, getRValueOfLValue, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[{, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[{, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return]
[parent, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return, n, ., getNext, (, ), ;, case]
[parent, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return, n, ., getNext, (, ), ;, case]
[), {, case, Token, ., ASSIGN, :, return, n, ., getNext, (, ), ;, case, Token, ., VAR, :, return]
[), {, case, Token, ., ASSIGN, :, return, n, ., getNext, (, ), ;, case, Token, ., VAR, :, return]
[return, n, ., getNext, (, ), ;, case, Token, ., VAR, :, return, n, ., getFirstChild, (, ), ;, case]
[return, n, ., getNext, (, ), ;, case, Token, ., VAR, :, return, n, ., getFirstChild, (, ), ;, case]
[), ;, case, Token, ., VAR, :, return, n, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return]
[., VAR, :, return, n, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, parent, ;, }, return]
[return, parent, ;, }, return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (]
[return, parent, ;, }, return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (]
[return, parent, ;, }, return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (]
[;, }, return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==]
[return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||]
[return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||]
[return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||]
[getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||, lValue, ., getParent, (, ), ==]
[Node, lValue, ), {, if, (, lValue, ==, null, ||, lValue, ., getParent, (, ), ==, null, ), {, return]
[(, lValue, ==, null, ||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (]
[==, null, ||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (]
[||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,]
[||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,]
[{, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {, return]
[null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {, return, getBestLValue, (]
[null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {, return, getBestLValue, (]
[getParent, (, ), ), ), {, return, getBestLValue, (, lValue, ., getParent, (, ), ), ;, }, else, if, (]
[), ), ), {, return, getBestLValue, (, lValue, ., getParent, (, ), ), ;, }, else, if, (, isGet, (]
[getBestLValue, (, lValue, ., getParent, (, ), ), ;, }, else, if, (, isGet, (, lValue, ), ), {, return]
[getBestLValue, (, lValue, ., getParent, (, ), ), ;, }, else, if, (, isGet, (, lValue, ), ), {, return]
[;, }, else, if, (, isGet, (, lValue, ), ), {, return, lValue, ., getFirstChild, (, ), ;, }, return]
[(, ), ;, }, return, null, ;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (]
[(, ), ;, }, return, null, ;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (]
[(, ), ;, }, return, null, ;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (]
[;, }, return, null, ;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==]
[return, null, ;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||]
[return, null, ;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||]
[return, null, ;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||]
[getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||, lValue, ., getParent, (, ), ==]
[Node, lValue, ), {, if, (, lValue, ==, null, ||, lValue, ., getParent, (, ), ==, null, ), {, return]
[(, lValue, ==, null, ||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (]
[==, null, ||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (]
[||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,]
[||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,]
[null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {, Node, owner, =]
[}, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {, Node, owner, =, getBestLValue, (]
[}, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {, Node, owner, =, getBestLValue, (]
[getParent, (, ), ), ), {, Node, owner, =, getBestLValue, (, lValue, ., getParent, (, ), ), ;, if, (]
[getParent, (, ), ), ), {, Node, owner, =, getBestLValue, (, lValue, ., getParent, (, ), ), ;, if, (]
[), ), ), {, Node, owner, =, getBestLValue, (, lValue, ., getParent, (, ), ), ;, if, (, owner, !=]
[=, getBestLValue, (, lValue, ., getParent, (, ), ), ;, if, (, owner, !=, null, ), {, String, ownerName, =]
[(, lValue, ., getParent, (, ), ), ;, if, (, owner, !=, null, ), {, String, ownerName, =, getBestLValueName, (]
[), ), ;, if, (, owner, !=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (]
[), ), ;, if, (, owner, !=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (]
[;, if, (, owner, !=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=]
[!=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=, null, ), {, return]
[!=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=, null, ), {, return]
[!=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=, null, ), {, return]
[), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=, null, ), {, return, ownerName, +]
[String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=, null, ), {, return, ownerName, +, ".", +]
[=, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=, null, ), {, return, ownerName, +, ".", +, getObjectLitKeyName, (]
[if, (, ownerName, !=, null, ), {, return, ownerName, +, ".", +, getObjectLitKeyName, (, lValue, ), ;, }, }, return]
[null, ), {, return, ownerName, +, ".", +, getObjectLitKeyName, (, lValue, ), ;, }, }, return, null, ;, }, return]
[null, ), {, return, ownerName, +, ".", +, getObjectLitKeyName, (, lValue, ), ;, }, }, return, null, ;, }, return]
[}, return, lValue, ., getQualifiedName, (, ), ;, }, static, boolean, isExpressionResultUsed, (, Node, expr, ), {, Node, parent, =]
[}, return, lValue, ., getQualifiedName, (, ), ;, }, static, boolean, isExpressionResultUsed, (, Node, expr, ), {, Node, parent, =]
[}, static, boolean, isExpressionResultUsed, (, Node, expr, ), {, Node, parent, =, expr, ., getParent, (, ), ;, switch, (]
[}, static, boolean, isExpressionResultUsed, (, Node, expr, ), {, Node, parent, =, expr, ., getParent, (, ), ;, switch, (]
[{, Node, parent, =, expr, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[{, Node, parent, =, expr, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., BLOCK, :, case]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., BLOCK, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, return]
[., getType, (, ), ), {, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, return, false, ;, case]
[., getType, (, ), ), {, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, return, false, ;, case]
[{, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, return, false, ;, case, Token, ., CAST, :, return]
[Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, return, false, ;, case, Token, ., CAST, :, return, isExpressionResultUsed, (]
[case, Token, ., EXPR_RESULT, :, return, false, ;, case, Token, ., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case]
[case, Token, ., EXPR_RESULT, :, return, false, ;, case, Token, ., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case]
[return, false, ;, case, Token, ., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case, Token, ., HOOK, :, case]
[return, false, ;, case, Token, ., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case, Token, ., HOOK, :, case]
[., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case, Token, ., HOOK, :, case, Token, ., AND, :, case]
[., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case, Token, ., HOOK, :, case, Token, ., AND, :, case]
[(, parent, ), ;, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return]
[(, parent, ), ;, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return]
[parent, ), ;, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, (]
[parent, ), ;, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, (]
[;, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, (, expr, ==]
[;, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, (, expr, ==]
[Token, ., AND, :, case, Token, ., OR, :, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?]
[AND, :, case, Token, ., OR, :, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, true, :]
[case, Token, ., OR, :, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed, (]
[:, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed, (, parent, ), ;, case]
[:, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed, (, parent, ), ;, case]
[getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., COMMA, :, Node, gramps, =]
[getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., COMMA, :, Node, gramps, =]
[(, parent, ), ;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;, if, (]
[(, parent, ), ;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;, if, (]
[(, parent, ), ;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;, if, (]
[., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;, if, (, gramps, ., isCall, (, ), &&]
[., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;, if, (, gramps, ., isCall, (, ), &&]
[:, Node, gramps, =, parent, ., getParent, (, ), ;, if, (, gramps, ., isCall, (, ), &&, parent, ==]
[:, Node, gramps, =, parent, ., getParent, (, ), ;, if, (, gramps, ., isCall, (, ), &&, parent, ==]
[;, if, (, gramps, ., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (]
[;, if, (, gramps, ., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (]
[;, if, (, gramps, ., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (]
[;, if, (, gramps, ., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (]
[;, if, (, gramps, ., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (]
[(, gramps, ., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (, expr, ==]
[(, gramps, ., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (, expr, ==]
[&&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&]
[&&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&]
[&&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&]
[(, ), ), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&, parent, ., getChildCount, (, ), ==]
[), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&, parent, ., getChildCount, (, ), ==, 2, &&]
[), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&, parent, ., getChildCount, (, ), ==, 2, &&]
[), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&, parent, ., getChildCount, (, ), ==, 2, &&]
[), &&, parent, ., getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, ), ., isName, (, ), &&]
[), &&, parent, ., getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, ), ., isName, (, ), &&]
[getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval", ., equals, (]
[getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval", ., equals, (]
[getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval", ., equals, (]
[(, ), &&, "eval", ., equals, (, expr, ., getNext, (, ), ., getString, (, ), ), ), {, return]
[equals, (, expr, ., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;, }, }, return]
[equals, (, expr, ., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;, }, }, return]
[(, expr, ., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;, }, }, return, (]
[(, expr, ., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;, }, }, return, (]
[., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;, }, }, return, (, expr, ==]
[., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;, }, }, return, (, expr, ==]
[), ), ), {, return, true, ;, }, }, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?]
[), {, return, true, ;, }, }, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, false, :]
[return, true, ;, }, }, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, false, :, isExpressionResultUsed, (]
[}, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, false, :, isExpressionResultUsed, (, parent, ), ;, case]
[}, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, false, :, isExpressionResultUsed, (, parent, ), ;, case]
[., getFirstChild, (, ), ), ?, false, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :, if, (]
[getFirstChild, (, ), ), ?, false, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :, if, (, !]
[getFirstChild, (, ), ), ?, false, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :, if, (, !]
[?, false, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (]
[parent, ), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return]
[), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (]
[), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (]
[), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (]
[., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (, parent, ., getChildAtIndex, (]
[if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (, parent, ., getChildAtIndex, (, 1, ), ==]
[), ), {, return, (, parent, ., getChildAtIndex, (, 1, ), ==, expr, ), ;, }, break, ;, }, return]
[}, return, true, ;, }, static, boolean, isExecutedExactlyOnce, (, Node, n, ), {, inspect, :, do, {, Node, parent, =]
[}, return, true, ;, }, static, boolean, isExecutedExactlyOnce, (, Node, n, ), {, inspect, :, do, {, Node, parent, =]
[(, Node, n, ), {, inspect, :, do, {, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[(, Node, n, ), {, inspect, :, do, {, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[{, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[{, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., HOOK, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., HOOK, :, case]
[(, ), ), {, case, Token, ., IF, :, case, Token, ., HOOK, :, case, Token, ., AND, :, case]
[(, ), ), {, case, Token, ., IF, :, case, Token, ., HOOK, :, case, Token, ., AND, :, case]
[., IF, :, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, if, (]
[., IF, :, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, if, (]
[., IF, :, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, if, (]
[HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, if, (, parent, ., getFirstChild, (, ), !=]
[., AND, :, case, Token, ., OR, :, if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return]
[:, if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case]
[:, if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case]
[(, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, ., FOR, :, if, (]
[(, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, ., FOR, :, if, (]
[), {, return, false, ;, }, continue, inspect, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (]
[continue, inspect, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, if, (]
[continue, inspect, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, if, (]
[continue, inspect, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, if, (]
[Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, if, (, parent, ., getChildAtIndex, (]
[:, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, if, (, parent, ., getChildAtIndex, (, 1, ), !=]
[., isForIn, (, parent, ), ), {, if, (, parent, ., getChildAtIndex, (, 1, ), !=, n, ), {, return]
[(, parent, ., getChildAtIndex, (, 1, ), !=, n, ), {, return, false, ;, }, }, else, {, if, (]
[(, parent, ., getChildAtIndex, (, 1, ), !=, n, ), {, return, false, ;, }, }, else, {, if, (]
[(, parent, ., getChildAtIndex, (, 1, ), !=, n, ), {, return, false, ;, }, }, else, {, if, (]
[), !=, n, ), {, return, false, ;, }, }, else, {, if, (, parent, ., getFirstChild, (, ), !=]
[{, return, false, ;, }, }, else, {, if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return]
[if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return, false, ;, }, }, continue, inspect, ;, case]
[if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return, false, ;, }, }, continue, inspect, ;, case]
[(, ), !=, n, ), {, return, false, ;, }, }, continue, inspect, ;, case, Token, ., WHILE, :, case]
[(, ), !=, n, ), {, return, false, ;, }, }, continue, inspect, ;, case, Token, ., WHILE, :, case]
[{, return, false, ;, }, }, continue, inspect, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, return]
[;, }, }, continue, inspect, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, return, false, ;, case]
[;, }, }, continue, inspect, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, return, false, ;, case]
[case, Token, ., WHILE, :, case, Token, ., DO, :, return, false, ;, case, Token, ., TRY, :, if, (]
[case, Token, ., WHILE, :, case, Token, ., DO, :, return, false, ;, case, Token, ., TRY, :, if, (]
[Token, ., WHILE, :, case, Token, ., DO, :, return, false, ;, case, Token, ., TRY, :, if, (, !]
[WHILE, :, case, Token, ., DO, :, return, false, ;, case, Token, ., TRY, :, if, (, !, hasFinally, (]
[Token, ., DO, :, return, false, ;, case, Token, ., TRY, :, if, (, !, hasFinally, (, parent, ), ||]
[Token, ., DO, :, return, false, ;, case, Token, ., TRY, :, if, (, !, hasFinally, (, parent, ), ||]
[Token, ., DO, :, return, false, ;, case, Token, ., TRY, :, if, (, !, hasFinally, (, parent, ), ||]
[;, case, Token, ., TRY, :, if, (, !, hasFinally, (, parent, ), ||, parent, ., getLastChild, (, ), !=]
[TRY, :, if, (, !, hasFinally, (, parent, ), ||, parent, ., getLastChild, (, ), !=, n, ), {, return]
[parent, ), ||, parent, ., getLastChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case]
[parent, ), ||, parent, ., getLastChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case]
[getLastChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, ., CASE, :, case]
[getLastChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, ., CASE, :, case]
[), {, return, false, ;, }, continue, inspect, ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return]
[false, ;, }, continue, inspect, ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, false, ;, case]
[false, ;, }, continue, inspect, ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, false, ;, case]
[;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, false, ;, case, Token, ., SCRIPT, :, case]
[;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, false, ;, case, Token, ., SCRIPT, :, case]
[return, false, ;, case, Token, ., SCRIPT, :, case, Token, ., FUNCTION, :, break, inspect, ;, }, }, while, (]
[return, false, ;, case, Token, ., SCRIPT, :, case, Token, ., FUNCTION, :, break, inspect, ;, }, }, while, (]
[false, ;, case, Token, ., SCRIPT, :, case, Token, ., FUNCTION, :, break, inspect, ;, }, }, while, (, (]
[case, Token, ., SCRIPT, :, case, Token, ., FUNCTION, :, break, inspect, ;, }, }, while, (, (, n, =]
[case, Token, ., SCRIPT, :, case, Token, ., FUNCTION, :, break, inspect, ;, }, }, while, (, (, n, =]
[., FUNCTION, :, break, inspect, ;, }, }, while, (, (, n, =, n, ., getParent, (, ), ), !=]
[inspect, ;, }, }, while, (, (, n, =, n, ., getParent, (, ), ), !=, null, ), ;, return]
[(, ), ), !=, null, ), ;, return, true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return]
[(, ), ), !=, null, ), ;, return, true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return]
[), !=, null, ), ;, return, true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return, value, ?]
[), !=, null, ), ;, return, true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return, value, ?]
[true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return, value, ?, IR, ., trueNode, (, ), :]
[true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return, value, ?, IR, ., trueNode, (, ), :]
[(, ), ;, }, static, Node, numberNode, (, double, value, ,, Node, srcref, ), {, Node, result, ;, if, (]
[(, ), ;, }, static, Node, numberNode, (, double, value, ,, Node, srcref, ), {, Node, result, ;, if, (]
[static, Node, numberNode, (, double, value, ,, Node, srcref, ), {, Node, result, ;, if, (, Double, ., isNaN, (]
[double, value, ,, Node, srcref, ), {, Node, result, ;, if, (, Double, ., isNaN, (, value, ), ), {]
[,, Node, srcref, ), {, Node, result, ;, if, (, Double, ., isNaN, (, value, ), ), {, result, =]
[,, Node, srcref, ), {, Node, result, ;, if, (, Double, ., isNaN, (, value, ), ), {, result, =]
[{, Node, result, ;, if, (, Double, ., isNaN, (, value, ), ), {, result, =, IR, ., name, (]
[., isNaN, (, value, ), ), {, result, =, IR, ., name, (, "NaN", ), ;, }, else, if, (]
[., isNaN, (, value, ), ), {, result, =, IR, ., name, (, "NaN", ), ;, }, else, if, (]
[(, value, ), ), {, result, =, IR, ., name, (, "NaN", ), ;, }, else, if, (, value, ==]
[(, value, ), ), {, result, =, IR, ., name, (, "NaN", ), ;, }, else, if, (, value, ==]
[result, =, IR, ., name, (, "NaN", ), ;, }, else, if, (, value, ==, Double, ., POSITIVE_INFINITY, ), {]
[IR, ., name, (, "NaN", ), ;, }, else, if, (, value, ==, Double, ., POSITIVE_INFINITY, ), {, result, =]
[IR, ., name, (, "NaN", ), ;, }, else, if, (, value, ==, Double, ., POSITIVE_INFINITY, ), {, result, =]
["NaN", ), ;, }, else, if, (, value, ==, Double, ., POSITIVE_INFINITY, ), {, result, =, IR, ., name, (]
[value, ==, Double, ., POSITIVE_INFINITY, ), {, result, =, IR, ., name, (, "Infinity", ), ;, }, else, if, (]
[value, ==, Double, ., POSITIVE_INFINITY, ), {, result, =, IR, ., name, (, "Infinity", ), ;, }, else, if, (]
[Double, ., POSITIVE_INFINITY, ), {, result, =, IR, ., name, (, "Infinity", ), ;, }, else, if, (, value, ==]
[Double, ., POSITIVE_INFINITY, ), {, result, =, IR, ., name, (, "Infinity", ), ;, }, else, if, (, value, ==]
[result, =, IR, ., name, (, "Infinity", ), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {]
[IR, ., name, (, "Infinity", ), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {, result, =]
[IR, ., name, (, "Infinity", ), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {, result, =]
["Infinity", ), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {, result, =, IR, ., neg, (]
["Infinity", ), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {, result, =, IR, ., neg, (]
[else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {, result, =, IR, ., neg, (, IR, ., name, (]
[NEGATIVE_INFINITY, ), {, result, =, IR, ., neg, (, IR, ., name, (, "Infinity", ), ), ;, }, else, {]
[{, result, =, IR, ., neg, (, IR, ., name, (, "Infinity", ), ), ;, }, else, {, result, =]
[{, result, =, IR, ., neg, (, IR, ., name, (, "Infinity", ), ), ;, }, else, {, result, =]
[., neg, (, IR, ., name, (, "Infinity", ), ), ;, }, else, {, result, =, IR, ., number, (]
[(, "Infinity", ), ), ;, }, else, {, result, =, IR, ., number, (, value, ), ;, }, if, (]
[(, "Infinity", ), ), ;, }, else, {, result, =, IR, ., number, (, value, ), ;, }, if, (]
[), ), ;, }, else, {, result, =, IR, ., number, (, value, ), ;, }, if, (, srcref, !=]
[}, else, {, result, =, IR, ., number, (, value, ), ;, }, if, (, srcref, !=, null, ), {]
[}, else, {, result, =, IR, ., number, (, value, ), ;, }, if, (, srcref, !=, null, ), {]
[=, IR, ., number, (, value, ), ;, }, if, (, srcref, !=, null, ), {, result, ., srcrefTree, (]
[value, ), ;, }, if, (, srcref, !=, null, ), {, result, ., srcrefTree, (, srcref, ), ;, }, return]
[srcrefTree, (, srcref, ), ;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (]
[srcrefTree, (, srcref, ), ;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (]
[(, srcref, ), ;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (, (]
[(, srcref, ), ;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (, (]
[(, srcref, ), ;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (, (]
[result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (, (, n, ., isName, (, ), &&]
[result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (, (, n, ., isName, (, ), &&]
[result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (, (, n, ., isName, (, ), &&]
[n, ), {, if, (, (, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (]
[(, (, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||]
[(, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (]
[(, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (]
[(, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (]
[(, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (]
[(, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (]
[(, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (]
[(, n, ., isName, (, ), &&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (]
[&&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (, n, ., getType, (, ), ==]
[&&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (, n, ., getType, (, ), ==]
[(, ), ., equals, (, "NaN", ), ), ||, (, n, ., getType, (, ), ==, Token, ., DIV, &&]
[(, ), ., equals, (, "NaN", ), ), ||, (, n, ., getType, (, ), ==, Token, ., DIV, &&]
[(, ), ., equals, (, "NaN", ), ), ||, (, n, ., getType, (, ), ==, Token, ., DIV, &&]
[n, ., getType, (, ), ==, Token, ., DIV, &&, n, ., getFirstChild, (, ), ., isNumber, (, ), &&]
[n, ., getType, (, ), ==, Token, ., DIV, &&, n, ., getFirstChild, (, ), ., isNumber, (, ), &&]
[n, ., getType, (, ), ==, Token, ., DIV, &&, n, ., getFirstChild, (, ), ., isNumber, (, ), &&]
[n, ., getType, (, ), ==, Token, ., DIV, &&, n, ., getFirstChild, (, ), ., isNumber, (, ), &&]
[n, ., getFirstChild, (, ), ., isNumber, (, ), &&, n, ., getFirstChild, (, ), ., getDouble, (, ), ==]
[getFirstChild, (, ), ., isNumber, (, ), &&, n, ., getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&]
[getFirstChild, (, ), ., isNumber, (, ), &&, n, ., getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&]
[getFirstChild, (, ), ., isNumber, (, ), &&, n, ., getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&]
[getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&, n, ., getLastChild, (, ), ., isNumber, (, ), &&]
[getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&, n, ., getLastChild, (, ), ., isNumber, (, ), &&]
[getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&, n, ., getLastChild, (, ), ., isNumber, (, ), &&]
[getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&, n, ., getLastChild, (, ), ., isNumber, (, ), &&]
[n, ., getLastChild, (, ), ., isNumber, (, ), &&, n, ., getLastChild, (, ), ., getDouble, (, ), ==]
[., isNumber, (, ), &&, n, ., getLastChild, (, ), ., getDouble, (, ), ==, 0, ), ), {, return]
[&&, n, ., getLastChild, (, ), ., getDouble, (, ), ==, 0, ), ), {, return, true, ;, }, return]
