[public, class, GaussNewtonOptimizer, extends, AbstractLeastSquaresOptimizer, {, private, final, boolean, useLU, ;, @, Deprecated, public, GaussNewtonOptimizer, (, ), {, this, (]
[), {, this, (, true, ), ;, }, public, GaussNewtonOptimizer, (, ConvergenceChecker, <, PointVectorValuePair, >, checker, ), {, this, (]
[this, (, true, ), ;, }, public, GaussNewtonOptimizer, (, ConvergenceChecker, <, PointVectorValuePair, >, checker, ), {, this, (, true, ,]
[this, (, true, ,, checker, ), ;, }, @, Deprecated, public, GaussNewtonOptimizer, (, final, boolean, useLU, ), {, this, (]
[true, ,, checker, ), ;, }, @, Deprecated, public, GaussNewtonOptimizer, (, final, boolean, useLU, ), {, this, (, useLU, ,]
[), ), ;, }, public, GaussNewtonOptimizer, (, final, boolean, useLU, ,, ConvergenceChecker, <, PointVectorValuePair, >, checker, ), {, super, (]
[}, public, GaussNewtonOptimizer, (, final, boolean, useLU, ,, ConvergenceChecker, <, PointVectorValuePair, >, checker, ), {, super, (, checker, ), ;]
[}, public, GaussNewtonOptimizer, (, final, boolean, useLU, ,, ConvergenceChecker, <, PointVectorValuePair, >, checker, ), {, super, (, checker, ), ;]
[final, boolean, useLU, ,, ConvergenceChecker, <, PointVectorValuePair, >, checker, ), {, super, (, checker, ), ;, this, ., useLU, =]
[useLU, =, useLU, ;, }, @, Override, public, PointVectorValuePair, doOptimize, (, ), {, final, ConvergenceChecker, <, PointVectorValuePair, >, checker, =]
[Override, public, PointVectorValuePair, doOptimize, (, ), {, final, ConvergenceChecker, <, PointVectorValuePair, >, checker, =, getConvergenceChecker, (, ), ;, if, (]
[Override, public, PointVectorValuePair, doOptimize, (, ), {, final, ConvergenceChecker, <, PointVectorValuePair, >, checker, =, getConvergenceChecker, (, ), ;, if, (]
[PointVectorValuePair, doOptimize, (, ), {, final, ConvergenceChecker, <, PointVectorValuePair, >, checker, =, getConvergenceChecker, (, ), ;, if, (, checker, ==]
[{, final, ConvergenceChecker, <, PointVectorValuePair, >, checker, =, getConvergenceChecker, (, ), ;, if, (, checker, ==, null, ), {, throw]
[if, (, checker, ==, null, ), {, throw, new, NullArgumentException, (, ), ;, }, final, double, [, ], targetValues, =]
[new, NullArgumentException, (, ), ;, }, final, double, [, ], targetValues, =, getTarget, (, ), ;, final, int, nR, =]
[new, NullArgumentException, (, ), ;, }, final, double, [, ], targetValues, =, getTarget, (, ), ;, final, int, nR, =]
[[, ], targetValues, =, getTarget, (, ), ;, final, int, nR, =, targetValues, ., length, ;, final, RealMatrix, weightMatrix, =]
[nR, =, targetValues, ., length, ;, final, RealMatrix, weightMatrix, =, getWeight, (, ), ;, final, double, [, ], residualsWeights, =]
[., length, ;, final, RealMatrix, weightMatrix, =, getWeight, (, ), ;, final, double, [, ], residualsWeights, =, new, double, []
[(, ), ;, final, double, [, ], residualsWeights, =, new, double, [, nR, ], ;, for, (, int, i, =]
[;, final, double, [, ], residualsWeights, =, new, double, [, nR, ], ;, for, (, int, i, =, 0, ;]
[;, final, double, [, ], residualsWeights, =, new, double, [, nR, ], ;, for, (, int, i, =, 0, ;]
[double, [, ], residualsWeights, =, new, double, [, nR, ], ;, for, (, int, i, =, 0, ;, i, <]
[], residualsWeights, =, new, double, [, nR, ], ;, for, (, int, i, =, 0, ;, i, <, nR, ;]
[], residualsWeights, =, new, double, [, nR, ], ;, for, (, int, i, =, 0, ;, i, <, nR, ;]
[double, [, nR, ], ;, for, (, int, i, =, 0, ;, i, <, nR, ;, i, ++, ), {]
[double, [, nR, ], ;, for, (, int, i, =, 0, ;, i, <, nR, ;, i, ++, ), {]
[nR, ], ;, for, (, int, i, =, 0, ;, i, <, nR, ;, i, ++, ), {, residualsWeights, []
[for, (, int, i, =, 0, ;, i, <, nR, ;, i, ++, ), {, residualsWeights, [, i, ], =]
[for, (, int, i, =, 0, ;, i, <, nR, ;, i, ++, ), {, residualsWeights, [, i, ], =]
[=, 0, ;, i, <, nR, ;, i, ++, ), {, residualsWeights, [, i, ], =, weightMatrix, ., getEntry, (]
[;, i, <, nR, ;, i, ++, ), {, residualsWeights, [, i, ], =, weightMatrix, ., getEntry, (, i, ,]
[[, i, ], =, weightMatrix, ., getEntry, (, i, ,, i, ), ;, }, final, double, [, ], currentPoint, =]
[i, ,, i, ), ;, }, final, double, [, ], currentPoint, =, getStartPoint, (, ), ;, final, int, nC, =]
[i, ,, i, ), ;, }, final, double, [, ], currentPoint, =, getStartPoint, (, ), ;, final, int, nC, =]
[double, [, ], currentPoint, =, getStartPoint, (, ), ;, final, int, nC, =, currentPoint, ., length, ;, PointVectorValuePair, current, =]
[getStartPoint, (, ), ;, final, int, nC, =, currentPoint, ., length, ;, PointVectorValuePair, current, =, null, ;, int, iter, =]
[=, currentPoint, ., length, ;, PointVectorValuePair, current, =, null, ;, int, iter, =, 0, ;, for, (, boolean, converged, =]
[., length, ;, PointVectorValuePair, current, =, null, ;, int, iter, =, 0, ;, for, (, boolean, converged, =, false, ;]
[length, ;, PointVectorValuePair, current, =, null, ;, int, iter, =, 0, ;, for, (, boolean, converged, =, false, ;, !]
[=, null, ;, int, iter, =, 0, ;, for, (, boolean, converged, =, false, ;, !, converged, ;, ), {]
[null, ;, int, iter, =, 0, ;, for, (, boolean, converged, =, false, ;, !, converged, ;, ), {, ++]
[0, ;, for, (, boolean, converged, =, false, ;, !, converged, ;, ), {, ++, iter, ;, PointVectorValuePair, previous, =]
[;, !, converged, ;, ), {, ++, iter, ;, PointVectorValuePair, previous, =, current, ;, final, double, [, ], currentObjective, =]
[converged, ;, ), {, ++, iter, ;, PointVectorValuePair, previous, =, current, ;, final, double, [, ], currentObjective, =, computeObjectiveValue, (]
[=, current, ;, final, double, [, ], currentObjective, =, computeObjectiveValue, (, currentPoint, ), ;, final, double, [, ], currentResiduals, =]
[;, final, double, [, ], currentObjective, =, computeObjectiveValue, (, currentPoint, ), ;, final, double, [, ], currentResiduals, =, computeResiduals, (]
[computeObjectiveValue, (, currentPoint, ), ;, final, double, [, ], currentResiduals, =, computeResiduals, (, currentObjective, ), ;, final, RealMatrix, weightedJacobian, =]
[currentPoint, ), ;, final, double, [, ], currentResiduals, =, computeResiduals, (, currentObjective, ), ;, final, RealMatrix, weightedJacobian, =, computeWeightedJacobian, (]
[final, double, [, ], currentResiduals, =, computeResiduals, (, currentObjective, ), ;, final, RealMatrix, weightedJacobian, =, computeWeightedJacobian, (, currentPoint, ), ;]
[[, ], currentResiduals, =, computeResiduals, (, currentObjective, ), ;, final, RealMatrix, weightedJacobian, =, computeWeightedJacobian, (, currentPoint, ), ;, current, =]
[=, computeResiduals, (, currentObjective, ), ;, final, RealMatrix, weightedJacobian, =, computeWeightedJacobian, (, currentPoint, ), ;, current, =, new, PointVectorValuePair, (]
[(, currentObjective, ), ;, final, RealMatrix, weightedJacobian, =, computeWeightedJacobian, (, currentPoint, ), ;, current, =, new, PointVectorValuePair, (, currentPoint, ,]
[(, currentPoint, ), ;, current, =, new, PointVectorValuePair, (, currentPoint, ,, currentObjective, ), ;, final, double, [, ], b, =]
[;, current, =, new, PointVectorValuePair, (, currentPoint, ,, currentObjective, ), ;, final, double, [, ], b, =, new, double, []
[final, double, [, ], b, =, new, double, [, nC, ], ;, final, double, [, ], [, ], a, =]
[], b, =, new, double, [, nC, ], ;, final, double, [, ], [, ], a, =, new, double, []
[new, double, [, nC, ], ;, final, double, [, ], [, ], a, =, new, double, [, nC, ], []
[[, ], [, ], a, =, new, double, [, nC, ], [, nC, ], ;, for, (, int, i, =]
[[, ], a, =, new, double, [, nC, ], [, nC, ], ;, for, (, int, i, =, 0, ;]
[[, ], a, =, new, double, [, nC, ], [, nC, ], ;, for, (, int, i, =, 0, ;]
[a, =, new, double, [, nC, ], [, nC, ], ;, for, (, int, i, =, 0, ;, i, <]
[new, double, [, nC, ], [, nC, ], ;, for, (, int, i, =, 0, ;, i, <, nR, ;]
[double, [, nC, ], [, nC, ], ;, for, (, int, i, =, 0, ;, i, <, nR, ;, ++]
[(, int, i, =, 0, ;, i, <, nR, ;, ++, i, ), {, final, double, [, ], grad, =]
[(, int, i, =, 0, ;, i, <, nR, ;, ++, i, ), {, final, double, [, ], grad, =]
[0, ;, i, <, nR, ;, ++, i, ), {, final, double, [, ], grad, =, weightedJacobian, ., getRow, (]
[i, ), {, final, double, [, ], grad, =, weightedJacobian, ., getRow, (, i, ), ;, final, double, weight, =]
[i, ), {, final, double, [, ], grad, =, weightedJacobian, ., getRow, (, i, ), ;, final, double, weight, =]
[{, final, double, [, ], grad, =, weightedJacobian, ., getRow, (, i, ), ;, final, double, weight, =, residualsWeights, []
[weightedJacobian, ., getRow, (, i, ), ;, final, double, weight, =, residualsWeights, [, i, ], ;, final, double, residual, =]
[weightedJacobian, ., getRow, (, i, ), ;, final, double, weight, =, residualsWeights, [, i, ], ;, final, double, residual, =]
[getRow, (, i, ), ;, final, double, weight, =, residualsWeights, [, i, ], ;, final, double, residual, =, currentResiduals, []
[weight, =, residualsWeights, [, i, ], ;, final, double, residual, =, currentResiduals, [, i, ], ;, final, double, wr, =]
[weight, =, residualsWeights, [, i, ], ;, final, double, residual, =, currentResiduals, [, i, ], ;, final, double, wr, =]
[residualsWeights, [, i, ], ;, final, double, residual, =, currentResiduals, [, i, ], ;, final, double, wr, =, weight, *]
[residual, =, currentResiduals, [, i, ], ;, final, double, wr, =, weight, *, residual, ;, for, (, int, j, =]
[currentResiduals, [, i, ], ;, final, double, wr, =, weight, *, residual, ;, for, (, int, j, =, 0, ;]
[currentResiduals, [, i, ], ;, final, double, wr, =, weight, *, residual, ;, for, (, int, j, =, 0, ;]
[i, ], ;, final, double, wr, =, weight, *, residual, ;, for, (, int, j, =, 0, ;, j, <]
[;, final, double, wr, =, weight, *, residual, ;, for, (, int, j, =, 0, ;, j, <, nC, ;]
[final, double, wr, =, weight, *, residual, ;, for, (, int, j, =, 0, ;, j, <, nC, ;, ++]
[=, weight, *, residual, ;, for, (, int, j, =, 0, ;, j, <, nC, ;, ++, j, ), {]
[=, weight, *, residual, ;, for, (, int, j, =, 0, ;, j, <, nC, ;, ++, j, ), {]
[*, residual, ;, for, (, int, j, =, 0, ;, j, <, nC, ;, ++, j, ), {, b, []
[for, (, int, j, =, 0, ;, j, <, nC, ;, ++, j, ), {, b, [, j, ], +=]
[for, (, int, j, =, 0, ;, j, <, nC, ;, ++, j, ), {, b, [, j, ], +=]
[int, j, =, 0, ;, j, <, nC, ;, ++, j, ), {, b, [, j, ], +=, wr, *]
[int, j, =, 0, ;, j, <, nC, ;, ++, j, ), {, b, [, j, ], +=, wr, *]
[=, 0, ;, j, <, nC, ;, ++, j, ), {, b, [, j, ], +=, wr, *, grad, []
[), {, b, [, j, ], +=, wr, *, grad, [, j, ], ;, }, for, (, int, k, =]
[b, [, j, ], +=, wr, *, grad, [, j, ], ;, }, for, (, int, k, =, 0, ;]
[b, [, j, ], +=, wr, *, grad, [, j, ], ;, }, for, (, int, k, =, 0, ;]
[j, ], +=, wr, *, grad, [, j, ], ;, }, for, (, int, k, =, 0, ;, k, <]
[+=, wr, *, grad, [, j, ], ;, }, for, (, int, k, =, 0, ;, k, <, nC, ;]
[wr, *, grad, [, j, ], ;, }, for, (, int, k, =, 0, ;, k, <, nC, ;, ++]
[for, (, int, k, =, 0, ;, k, <, nC, ;, ++, k, ), {, double, [, ], ak, =]
[for, (, int, k, =, 0, ;, k, <, nC, ;, ++, k, ), {, double, [, ], ak, =]
[int, k, =, 0, ;, k, <, nC, ;, ++, k, ), {, double, [, ], ak, =, a, []
[<, nC, ;, ++, k, ), {, double, [, ], ak, =, a, [, k, ], ;, double, wgk, =]
[<, nC, ;, ++, k, ), {, double, [, ], ak, =, a, [, k, ], ;, double, wgk, =]
[;, ++, k, ), {, double, [, ], ak, =, a, [, k, ], ;, double, wgk, =, weight, *]
[;, ++, k, ), {, double, [, ], ak, =, a, [, k, ], ;, double, wgk, =, weight, *]
[k, ), {, double, [, ], ak, =, a, [, k, ], ;, double, wgk, =, weight, *, grad, []
[a, [, k, ], ;, double, wgk, =, weight, *, grad, [, k, ], ;, for, (, int, l, =]
[k, ], ;, double, wgk, =, weight, *, grad, [, k, ], ;, for, (, int, l, =, 0, ;]
[k, ], ;, double, wgk, =, weight, *, grad, [, k, ], ;, for, (, int, l, =, 0, ;]
[;, double, wgk, =, weight, *, grad, [, k, ], ;, for, (, int, l, =, 0, ;, l, <]
[wgk, =, weight, *, grad, [, k, ], ;, for, (, int, l, =, 0, ;, l, <, nC, ;]
[=, weight, *, grad, [, k, ], ;, for, (, int, l, =, 0, ;, l, <, nC, ;, ++]
[grad, [, k, ], ;, for, (, int, l, =, 0, ;, l, <, nC, ;, ++, l, ), {]
[grad, [, k, ], ;, for, (, int, l, =, 0, ;, l, <, nC, ;, ++, l, ), {]
[k, ], ;, for, (, int, l, =, 0, ;, l, <, nC, ;, ++, l, ), {, ak, []
[for, (, int, l, =, 0, ;, l, <, nC, ;, ++, l, ), {, ak, [, l, ], +=]
[for, (, int, l, =, 0, ;, l, <, nC, ;, ++, l, ), {, ak, [, l, ], +=]
[int, l, =, 0, ;, l, <, nC, ;, ++, l, ), {, ak, [, l, ], +=, wgk, *]
[int, l, =, 0, ;, l, <, nC, ;, ++, l, ), {, ak, [, l, ], +=, wgk, *]
[=, 0, ;, l, <, nC, ;, ++, l, ), {, ak, [, l, ], +=, wgk, *, grad, []
[ak, [, l, ], +=, wgk, *, grad, [, l, ], ;, }, }, }, try, {, RealMatrix, mA, =]
[], +=, wgk, *, grad, [, l, ], ;, }, }, }, try, {, RealMatrix, mA, =, new, BlockRealMatrix, (]
[l, ], ;, }, }, }, try, {, RealMatrix, mA, =, new, BlockRealMatrix, (, a, ), ;, DecompositionSolver, solver, =]
[l, ], ;, }, }, }, try, {, RealMatrix, mA, =, new, BlockRealMatrix, (, a, ), ;, DecompositionSolver, solver, =]
[;, }, }, }, try, {, RealMatrix, mA, =, new, BlockRealMatrix, (, a, ), ;, DecompositionSolver, solver, =, useLU, ?]
[;, }, }, }, try, {, RealMatrix, mA, =, new, BlockRealMatrix, (, a, ), ;, DecompositionSolver, solver, =, useLU, ?]
[}, try, {, RealMatrix, mA, =, new, BlockRealMatrix, (, a, ), ;, DecompositionSolver, solver, =, useLU, ?, new, LUDecomposition, (]
[BlockRealMatrix, (, a, ), ;, DecompositionSolver, solver, =, useLU, ?, new, LUDecomposition, (, mA, ), ., getSolver, (, ), :]
[BlockRealMatrix, (, a, ), ;, DecompositionSolver, solver, =, useLU, ?, new, LUDecomposition, (, mA, ), ., getSolver, (, ), :]
[), ;, DecompositionSolver, solver, =, useLU, ?, new, LUDecomposition, (, mA, ), ., getSolver, (, ), :, new, QRDecomposition, (]
[getSolver, (, ), :, new, QRDecomposition, (, mA, ), ., getSolver, (, ), ;, final, double, [, ], dX, =]
[getSolver, (, ), :, new, QRDecomposition, (, mA, ), ., getSolver, (, ), ;, final, double, [, ], dX, =]
[getSolver, (, ), :, new, QRDecomposition, (, mA, ), ., getSolver, (, ), ;, final, double, [, ], dX, =]
[new, QRDecomposition, (, mA, ), ., getSolver, (, ), ;, final, double, [, ], dX, =, solver, ., solve, (]
[mA, ), ., getSolver, (, ), ;, final, double, [, ], dX, =, solver, ., solve, (, new, ArrayRealVector, (]
[., getSolver, (, ), ;, final, double, [, ], dX, =, solver, ., solve, (, new, ArrayRealVector, (, b, ,]
[solve, (, new, ArrayRealVector, (, b, ,, false, ), ), ., toArray, (, ), ;, for, (, int, i, =]
[new, ArrayRealVector, (, b, ,, false, ), ), ., toArray, (, ), ;, for, (, int, i, =, 0, ;]
[new, ArrayRealVector, (, b, ,, false, ), ), ., toArray, (, ), ;, for, (, int, i, =, 0, ;]
[(, b, ,, false, ), ), ., toArray, (, ), ;, for, (, int, i, =, 0, ;, i, <]
[,, false, ), ), ., toArray, (, ), ;, for, (, int, i, =, 0, ;, i, <, nC, ;]
[false, ), ), ., toArray, (, ), ;, for, (, int, i, =, 0, ;, i, <, nC, ;, ++]
[., toArray, (, ), ;, for, (, int, i, =, 0, ;, i, <, nC, ;, ++, i, ), {]
[., toArray, (, ), ;, for, (, int, i, =, 0, ;, i, <, nC, ;, ++, i, ), {]
[(, ), ;, for, (, int, i, =, 0, ;, i, <, nC, ;, ++, i, ), {, currentPoint, []
[for, (, int, i, =, 0, ;, i, <, nC, ;, ++, i, ), {, currentPoint, [, i, ], +=]
[for, (, int, i, =, 0, ;, i, <, nC, ;, ++, i, ), {, currentPoint, [, i, ], +=]
[int, i, =, 0, ;, i, <, nC, ;, ++, i, ), {, currentPoint, [, i, ], +=, dX, []
[{, currentPoint, [, i, ], +=, dX, [, i, ], ;, }, }, catch, (, SingularMatrixException, e, ), {, throw]
[i, ], +=, dX, [, i, ], ;, }, }, catch, (, SingularMatrixException, e, ), {, throw, new, ConvergenceException, (]
[i, ], +=, dX, [, i, ], ;, }, }, catch, (, SingularMatrixException, e, ), {, throw, new, ConvergenceException, (]
[}, }, catch, (, SingularMatrixException, e, ), {, throw, new, ConvergenceException, (, LocalizedFormats, ., UNABLE_TO_SOLVE_SINGULAR_PROBLEM, ), ;, }, if, (]
[}, }, catch, (, SingularMatrixException, e, ), {, throw, new, ConvergenceException, (, LocalizedFormats, ., UNABLE_TO_SOLVE_SINGULAR_PROBLEM, ), ;, }, if, (]
[catch, (, SingularMatrixException, e, ), {, throw, new, ConvergenceException, (, LocalizedFormats, ., UNABLE_TO_SOLVE_SINGULAR_PROBLEM, ), ;, }, if, (, previous, !=]
[e, ), {, throw, new, ConvergenceException, (, LocalizedFormats, ., UNABLE_TO_SOLVE_SINGULAR_PROBLEM, ), ;, }, if, (, previous, !=, null, ), {]
[{, throw, new, ConvergenceException, (, LocalizedFormats, ., UNABLE_TO_SOLVE_SINGULAR_PROBLEM, ), ;, }, if, (, previous, !=, null, ), {, converged, =]
[{, throw, new, ConvergenceException, (, LocalizedFormats, ., UNABLE_TO_SOLVE_SINGULAR_PROBLEM, ), ;, }, if, (, previous, !=, null, ), {, converged, =]
[(, LocalizedFormats, ., UNABLE_TO_SOLVE_SINGULAR_PROBLEM, ), ;, }, if, (, previous, !=, null, ), {, converged, =, checker, ., converged, (]
[., UNABLE_TO_SOLVE_SINGULAR_PROBLEM, ), ;, }, if, (, previous, !=, null, ), {, converged, =, checker, ., converged, (, iter, ,]
[), ;, }, if, (, previous, !=, null, ), {, converged, =, checker, ., converged, (, iter, ,, previous, ,]
[previous, !=, null, ), {, converged, =, checker, ., converged, (, iter, ,, previous, ,, current, ), ;, if, (]
[), {, converged, =, checker, ., converged, (, iter, ,, previous, ,, current, ), ;, if, (, converged, ), {]
[converged, =, checker, ., converged, (, iter, ,, previous, ,, current, ), ;, if, (, converged, ), {, cost, =]
[checker, ., converged, (, iter, ,, previous, ,, current, ), ;, if, (, converged, ), {, cost, =, computeCost, (]
[(, iter, ,, previous, ,, current, ), ;, if, (, converged, ), {, cost, =, computeCost, (, currentResiduals, ), ;]
[,, previous, ,, current, ), ;, if, (, converged, ), {, cost, =, computeCost, (, currentResiduals, ), ;, point, =]
[,, previous, ,, current, ), ;, if, (, converged, ), {, cost, =, computeCost, (, currentResiduals, ), ;, point, =]
[(, converged, ), {, cost, =, computeCost, (, currentResiduals, ), ;, point, =, current, ., getPoint, (, ), ;, return]
[computeCost, (, currentResiduals, ), ;, point, =, current, ., getPoint, (, ), ;, return, current, ;, }, }, }, throw]
