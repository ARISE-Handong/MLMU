[;, private, final, AbstractCompiler, compiler, ;, private, final, JSModuleGraph, graph, ;, private, final, Map, <, JSModule, ,, Node, >, moduleVarParentMap]
[., getLogger, (, CrossModuleCodeMotion, ., class, ., getName, (, ), ), ;, private, final, AbstractCompiler, compiler, ;, private, final, JSModuleGraph]
[), ;, private, final, AbstractCompiler, compiler, ;, private, final, JSModuleGraph, graph, ;, private, final, Map, <, JSModule, ,, Node, >]
[., getName, (, ), ), ;, private, final, AbstractCompiler, compiler, ;, private, final, JSModuleGraph, graph, ;, private, final, Map, <]
[;, private, final, Map, <, Scope, ., Var, ,, NamedInfo, >, namedInfo, =, new, LinkedHashMap, <, Var, ,, NamedInfo, >]
[;, CrossModuleCodeMotion, (, AbstractCompiler, compiler, ,, JSModuleGraph, graph, ), {, this, ., compiler, =, compiler, ;, this, ., graph, =]
[=, compiler, ;, this, ., graph, =, graph, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node]
[., compiler, =, compiler, ;, this, ., graph, =, graph, ;, }, @, Override, public, void, process, (, Node, externs]
[;, this, ., graph, =, graph, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, )]
[=, graph, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, logger, ., fine]
[., graph, =, graph, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, logger]
[;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, logger, ., fine, (, "Moving functions + variable into deeper modules"]
[;, if, (, graph, !=, null, &&, graph, ., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse, (]
[., fine, (, "Moving functions + variable into deeper modules", ), ;, if, (, graph, !=, null, &&, graph, ., getModuleCount, (, ), >, 1, )]
[), ;, if, (, graph, !=, null, &&, graph, ., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse]
[), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, moveCode, (, ), ;, }, }, private]
[&&, graph, ., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, )]
[!=, null, &&, graph, ., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[&&, graph, ., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, )]
[), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, moveCode, (, ), ;, }, }, private]
[>, 1, ), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, moveCode, (, ), ;, }]
[., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, moveCode]
[), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, moveCode, (, ), ;, }, }, private]
[;, moveCode, (, ), ;, }, }, private, void, moveCode, (, ), {, for, (, NamedInfo, info, :, namedInfo, .]
[., traverse, (, compiler, ,, root, ,, this, ), ;, moveCode, (, ), ;, }, }, private, void, moveCode, (]
[,, root, ,, this, ), ;, moveCode, (, ), ;, }, }, private, void, moveCode, (, ), {, for, (]
[,, this, ), ;, moveCode, (, ), ;, }, }, private, void, moveCode, (, ), {, for, (, NamedInfo, info]
[), ;, moveCode, (, ), ;, }, }, private, void, moveCode, (, ), {, for, (, NamedInfo, info, :, namedInfo]
[;, }, }, private, void, moveCode, (, ), {, for, (, NamedInfo, info, :, namedInfo, ., values, (, ), )]
[), {, JSModule, deepestDependency, =, info, ., deepestModule, ;, if, (, info, ., allowMove, &&, deepestDependency, !=, null, ), {]
[., values, (, ), ), {, JSModule, deepestDependency, =, info, ., deepestModule, ;, if, (, info, ., allowMove, &&, deepestDependency]
[;, if, (, info, ., allowMove, &&, deepestDependency, !=, null, ), {, Iterator, <, Declaration, >, it, =, info, .]
[., deepestModule, ;, if, (, info, ., allowMove, &&, deepestDependency, !=, null, ), {, Iterator, <, Declaration, >, it, =]
[), {, Iterator, <, Declaration, >, it, =, info, ., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph, =, compiler, ., getModuleGraph]
[&&, deepestDependency, !=, null, ), {, Iterator, <, Declaration, >, it, =, info, ., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph]
[., allowMove, &&, deepestDependency, !=, null, ), {, Iterator, <, Declaration, >, it, =, info, ., declarationIterator, (, ), ;]
[), {, Iterator, <, Declaration, >, it, =, info, ., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph, =, compiler, ., getModuleGraph]
[!=, null, ), {, Iterator, <, Declaration, >, it, =, info, ., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph, =, compiler]
[), {, Iterator, <, Declaration, >, it, =, info, ., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph, =, compiler, ., getModuleGraph]
[;, JSModuleGraph, moduleGraph, =, compiler, ., getModuleGraph, (, ), ;, while, (, it, ., hasNext, (, ), ), {, Declaration]
[., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph, =, compiler, ., getModuleGraph, (, ), ;, while, (, it, ., hasNext, (]
[;, while, (, it, ., hasNext, (, ), ), {, Declaration, decl, =, it, ., next, (, ), ;, if]
[., getModuleGraph, (, ), ;, while, (, it, ., hasNext, (, ), ), {, Declaration, decl, =, it, ., next]
[), {, Declaration, decl, =, it, ., next, (, ), ;, if, (, decl, ., module, !=, null, &&, moduleGraph]
[., hasNext, (, ), ), {, Declaration, decl, =, it, ., next, (, ), ;, if, (, decl, ., module]
[;, if, (, decl, ., module, !=, null, &&, moduleGraph, ., dependsOn, (, deepestDependency, ,, decl, ., module, ), )]
[., next, (, ), ;, if, (, decl, ., module, !=, null, &&, moduleGraph, ., dependsOn, (, deepestDependency, ,, decl]
[), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent, ==, null, ), {, destParent]
[&&, moduleGraph, ., dependsOn, (, deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =, moduleVarParentMap, ., get, (]
[!=, null, &&, moduleGraph, ., dependsOn, (, deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =, moduleVarParentMap, .]
[., module, !=, null, &&, moduleGraph, ., dependsOn, (, deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =]
[&&, moduleGraph, ., dependsOn, (, deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =, moduleVarParentMap, ., get, (]
[), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent, ==, null, ), {, destParent]
[., dependsOn, (, deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, )]
[,, decl, ., module, ), ), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent]
[), ), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent, ==, null, ), {]
[., module, ), ), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent, ==, null]
[;, if, (, destParent, ==, null, ), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put]
[., get, (, deepestDependency, ), ;, if, (, destParent, ==, null, ), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency]
[), ;, if, (, destParent, ==, null, ), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, .]
[), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent, ), ;]
[==, null, ), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent]
[), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent, ), ;]
[=, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent]
[;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent, (]
[., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent, =, decl]
[), ;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent]
[;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;, Preconditions, ., checkState, (, !, declParent, .]
[., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;]
[,, destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;, Preconditions, ., checkState, (]
[), ;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;, Preconditions, ., checkState, (, !, declParent]
[;, Preconditions, ., checkState, (, !, declParent, ., isVar, (, ), ||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", )]
[., getParent, (, ), ;, Preconditions, ., checkState, (, !, declParent, ., isVar, (, ), ||, declParent, ., hasOneChild, (]
[., node, ., getParent, (, ), ;, Preconditions, ., checkState, (, !, declParent, ., isVar, (, ), ||, declParent, .]
[;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (, declParent, ), ;, compiler, ., reportCodeChange, (, ), ;]
[., checkState, (, !, declParent, ., isVar, (, ), ||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent]
[,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (, declParent, ), ;, compiler, ., reportCodeChange]
[||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (]
[||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (]
[., isVar, (, ), ||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;]
[,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (, declParent, ), ;, compiler, ., reportCodeChange]
[., hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (, declParent, )]
[), ;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (, declParent, ), ;, compiler, ., reportCodeChange, (, )]
[;, destParent, ., addChildToFront, (, declParent, ), ;, compiler, ., reportCodeChange, (, ), ;, }, }, }, }, }, private]
[., detachFromParent, (, ), ;, destParent, ., addChildToFront, (, declParent, ), ;, compiler, ., reportCodeChange, (, ), ;, }, }]
[;, compiler, ., reportCodeChange, (, ), ;, }, }, }, }, }, private, class, NamedInfo, {, boolean, allowMove, =, true]
[., addChildToFront, (, declParent, ), ;, compiler, ., reportCodeChange, (, ), ;, }, }, }, }, }, private, class, NamedInfo]
[), ;, compiler, ., reportCodeChange, (, ), ;, }, }, }, }, }, private, class, NamedInfo, {, boolean, allowMove, =]
[;, }, }, }, }, }, private, class, NamedInfo, {, boolean, allowMove, =, true, ;, private, JSModule, deepestModule, =, null]
[., reportCodeChange, (, ), ;, }, }, }, }, }, private, class, NamedInfo, {, boolean, allowMove, =, true, ;, private]
[;, private, JSModule, deepestModule, =, null, ;, private, JSModule, declModule, =, null, ;, private, final, Deque, <, Declaration, >, declarations]
[;, private, JSModule, declModule, =, null, ;, private, final, Deque, <, Declaration, >, declarations, =, new, ArrayDeque, <, Declaration, >]
[;, private, final, Deque, <, Declaration, >, declarations, =, new, ArrayDeque, <, Declaration, >, (, ), ;, void, addUsedModule, (]
[;, void, addUsedModule, (, JSModule, m, ), {, if, (, !, allowMove, ), {, return, ;, }, if, (, deepestModule]
[), {, return, ;, }, if, (, deepestModule, ==, null, ), {, deepestModule, =, m, ;, }, else, {, deepestModule]
[), {, return, ;, }, if, (, deepestModule, ==, null, ), {, deepestModule, =, m, ;, }, else, {, deepestModule]
[), {, deepestModule, =, m, ;, }, else, {, deepestModule, =, graph, ., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;]
[==, null, ), {, deepestModule, =, m, ;, }, else, {, deepestModule, =, graph, ., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule]
[), {, deepestModule, =, m, ;, }, else, {, deepestModule, =, graph, ., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;]
[=, m, ;, }, else, {, deepestModule, =, graph, ., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;, }, }, boolean]
[;, }, else, {, deepestModule, =, graph, ., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (]
[=, graph, ., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if]
[;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (, declModule, !=, null, &&, d, ., module, !=]
[., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (, declModule]
[,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (, declModule, !=, null, &&, d]
[), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (, declModule, !=, null, &&, d, ., module]
[), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule, =, d, ., module, ;, return]
[&&, d, ., module, !=, declModule, ), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule]
[!=, null, &&, d, ., module, !=, declModule, ), {, return, false, ;, }, declarations, ., push, (, d, )]
[&&, d, ., module, !=, declModule, ), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule]
[), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule, =, d, ., module, ;, return]
[!=, declModule, ), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule, =, d, ., module]
[., module, !=, declModule, ), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule, =, d]
[), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule, =, d, ., module, ;, return]
[;, }, declarations, ., push, (, d, ), ;, declModule, =, d, ., module, ;, return, true, ;, }, Iterator]
[;, declModule, =, d, ., module, ;, return, true, ;, }, Iterator, <, Declaration, >, declarationIterator, (, ), {, return]
[., push, (, d, ), ;, declModule, =, d, ., module, ;, return, true, ;, }, Iterator, <, Declaration, >]
[), ;, declModule, =, d, ., module, ;, return, true, ;, }, Iterator, <, Declaration, >, declarationIterator, (, ), {]
[=, d, ., module, ;, return, true, ;, }, Iterator, <, Declaration, >, declarationIterator, (, ), {, return, declarations, .]
[;, return, true, ;, }, Iterator, <, Declaration, >, declarationIterator, (, ), {, return, declarations, ., iterator, (, ), ;]
[., module, ;, return, true, ;, }, Iterator, <, Declaration, >, declarationIterator, (, ), {, return, declarations, ., iterator, (]
[;, }, Iterator, <, Declaration, >, declarationIterator, (, ), {, return, declarations, ., iterator, (, ), ;, }, }, private]
[;, }, }, private, class, Declaration, {, final, JSModule, module, ;, final, Node, node, ;, Declaration, (, JSModule, module, ,]
[., iterator, (, ), ;, }, }, private, class, Declaration, {, final, JSModule, module, ;, final, Node, node, ;, Declaration]
[=, module, ;, this, ., node, =, node, ;, }, }, private, boolean, hasConditionalAncestor, (, Node, n, ), {, for]
[., module, =, module, ;, this, ., node, =, node, ;, }, }, private, boolean, hasConditionalAncestor, (, Node, n, )]
[;, this, ., node, =, node, ;, }, }, private, boolean, hasConditionalAncestor, (, Node, n, ), {, for, (, Node]
[=, node, ;, }, }, private, boolean, hasConditionalAncestor, (, Node, n, ), {, for, (, Node, ancestor, :, n, .]
[., node, =, node, ;, }, }, private, boolean, hasConditionalAncestor, (, Node, n, ), {, for, (, Node, ancestor, :]
[;, }, }, private, boolean, hasConditionalAncestor, (, Node, n, ), {, for, (, Node, ancestor, :, n, ., getAncestors, (]
[), {, switch, (, ancestor, ., getType, (, ), ), {, case, Token, ., DO, :, case, Token, ., FOR]
[., getAncestors, (, ), ), {, switch, (, ancestor, ., getType, (, ), ), {, case, Token, ., DO, :]
[), {, case, Token, ., DO, :, case, Token, ., FOR, :, case, Token, ., HOOK, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., DO, :, case, Token, ., FOR, :, case, Token, ., HOOK]
[:, case, Token, ., FOR, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., SWITCH]
[., DO, :, case, Token, ., FOR, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token]
[:, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., WHILE]
[., FOR, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token]
[:, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., WHILE, :, case, Token, ., FUNCTION]
[., HOOK, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., WHILE, :, case, Token]
[:, case, Token, ., SWITCH, :, case, Token, ., WHILE, :, case, Token, ., FUNCTION, :, return, true, ;, }]
[., IF, :, case, Token, ., SWITCH, :, case, Token, ., WHILE, :, case, Token, ., FUNCTION, :, return, true]
[:, case, Token, ., WHILE, :, case, Token, ., FUNCTION, :, return, true, ;, }, }, return, false, ;, }]
[., SWITCH, :, case, Token, ., WHILE, :, case, Token, ., FUNCTION, :, return, true, ;, }, }, return, false]
[:, case, Token, ., FUNCTION, :, return, true, ;, }, }, return, false, ;, }, private, NamedInfo, getNamedInfo, (, Var]
[., WHILE, :, case, Token, ., FUNCTION, :, return, true, ;, }, }, return, false, ;, }, private, NamedInfo, getNamedInfo]
[:, return, true, ;, }, }, return, false, ;, }, private, NamedInfo, getNamedInfo, (, Var, v, ), {, NamedInfo, info]
[., FUNCTION, :, return, true, ;, }, }, return, false, ;, }, private, NamedInfo, getNamedInfo, (, Var, v, ), {]
[;, }, }, return, false, ;, }, private, NamedInfo, getNamedInfo, (, Var, v, ), {, NamedInfo, info, =, namedInfo, .]
[;, }, private, NamedInfo, getNamedInfo, (, Var, v, ), {, NamedInfo, info, =, namedInfo, ., get, (, v, ), ;]
[;, if, (, info, ==, null, ), {, info, =, new, NamedInfo, (, ), ;, namedInfo, ., put, (, v]
[., get, (, v, ), ;, if, (, info, ==, null, ), {, info, =, new, NamedInfo, (, ), ;]
[), ;, if, (, info, ==, null, ), {, info, =, new, NamedInfo, (, ), ;, namedInfo, ., put, (]
[), {, info, =, new, NamedInfo, (, ), ;, namedInfo, ., put, (, v, ,, info, ), ;, }, return]
[==, null, ), {, info, =, new, NamedInfo, (, ), ;, namedInfo, ., put, (, v, ,, info, ), ;]
[), {, info, =, new, NamedInfo, (, ), ;, namedInfo, ., put, (, v, ,, info, ), ;, }, return]
[=, new, NamedInfo, (, ), ;, namedInfo, ., put, (, v, ,, info, ), ;, }, return, info, ;, }]
[;, namedInfo, ., put, (, v, ,, info, ), ;, }, return, info, ;, }, private, void, processReference, (, NodeTraversal]
[;, }, return, info, ;, }, private, void, processReference, (, NodeTraversal, t, ,, NamedInfo, info, ,, String, name, ), {]
[., put, (, v, ,, info, ), ;, }, return, info, ;, }, private, void, processReference, (, NodeTraversal, t, ,]
[,, info, ), ;, }, return, info, ;, }, private, void, processReference, (, NodeTraversal, t, ,, NamedInfo, info, ,, String]
[), ;, }, return, info, ;, }, private, void, processReference, (, NodeTraversal, t, ,, NamedInfo, info, ,, String, name, )]
[;, }, private, void, processReference, (, NodeTraversal, t, ,, NamedInfo, info, ,, String, name, ), {, boolean, recursive, =, false]
[;, Node, rootNode, =, t, ., getScope, (, ), ., getRootNode, (, ), ;, if, (, rootNode, ., isFunction, (]
[;, if, (, rootNode, ., isFunction, (, ), ), {, String, scopeFuncName, =, rootNode, ., getFirstChild, (, ), ., getString]
[., getRootNode, (, ), ;, if, (, rootNode, ., isFunction, (, ), ), {, String, scopeFuncName, =, rootNode, ., getFirstChild]
[., getScope, (, ), ., getRootNode, (, ), ;, if, (, rootNode, ., isFunction, (, ), ), {, String, scopeFuncName]
[), {, String, scopeFuncName, =, rootNode, ., getFirstChild, (, ), ., getString, (, ), ;, Node, scopeFuncParent, =, rootNode, .]
[., isFunction, (, ), ), {, String, scopeFuncName, =, rootNode, ., getFirstChild, (, ), ., getString, (, ), ;, Node]
[;, Node, scopeFuncParent, =, rootNode, ., getParent, (, ), ;, if, (, scopeFuncName, ., equals, (, name, ), ), {]
[., getString, (, ), ;, Node, scopeFuncParent, =, rootNode, ., getParent, (, ), ;, if, (, scopeFuncName, ., equals, (]
[., getFirstChild, (, ), ., getString, (, ), ;, Node, scopeFuncParent, =, rootNode, ., getParent, (, ), ;, if, (]
[;, if, (, scopeFuncName, ., equals, (, name, ), ), {, recursive, =, true, ;, }, else, if, (, scopeFuncParent]
[., getParent, (, ), ;, if, (, scopeFuncName, ., equals, (, name, ), ), {, recursive, =, true, ;, }]
[), {, recursive, =, true, ;, }, else, if, (, scopeFuncParent, ., isName, (, ), &&, scopeFuncParent, ., getString, (]
[., equals, (, name, ), ), {, recursive, =, true, ;, }, else, if, (, scopeFuncParent, ., isName, (, )]
[), ), {, recursive, =, true, ;, }, else, if, (, scopeFuncParent, ., isName, (, ), &&, scopeFuncParent, ., getString]
[=, true, ;, }, else, if, (, scopeFuncParent, ., isName, (, ), &&, scopeFuncParent, ., getString, (, ), ., equals]
[;, }, else, if, (, scopeFuncParent, ., isName, (, ), &&, scopeFuncParent, ., getString, (, ), ., equals, (, name]
[), {, recursive, =, true, ;, }, else, {, for, (, Scope, s, =, t, ., getScope, (, ), ;]
[&&, scopeFuncParent, ., getString, (, ), ., equals, (, name, ), ), {, recursive, =, true, ;, }, else, {]
[., isName, (, ), &&, scopeFuncParent, ., getString, (, ), ., equals, (, name, ), ), {, recursive, =, true]
[), {, recursive, =, true, ;, }, else, {, for, (, Scope, s, =, t, ., getScope, (, ), ;]
[., equals, (, name, ), ), {, recursive, =, true, ;, }, else, {, for, (, Scope, s, =, t]
[., getString, (, ), ., equals, (, name, ), ), {, recursive, =, true, ;, }, else, {, for, (]
[), ), {, recursive, =, true, ;, }, else, {, for, (, Scope, s, =, t, ., getScope, (, )]
[=, true, ;, }, else, {, for, (, Scope, s, =, t, ., getScope, (, ), ;, s, ., getParent]
[;, }, else, {, for, (, Scope, s, =, t, ., getScope, (, ), ;, s, ., getParent, (, )]
[;, s, ., getParent, (, ), !=, null, ;, s, =, s, ., getParent, (, ), ), {, Node, curRoot]
[., getScope, (, ), ;, s, ., getParent, (, ), !=, null, ;, s, =, s, ., getParent, (, )]
[;, s, =, s, ., getParent, (, ), ), {, Node, curRoot, =, s, ., getRootNode, (, ), ;, if]
[!=, null, ;, s, =, s, ., getParent, (, ), ), {, Node, curRoot, =, s, ., getRootNode, (, )]
[., getParent, (, ), !=, null, ;, s, =, s, ., getParent, (, ), ), {, Node, curRoot, =, s]
[;, s, =, s, ., getParent, (, ), ), {, Node, curRoot, =, s, ., getRootNode, (, ), ;, if]
[=, s, ., getParent, (, ), ), {, Node, curRoot, =, s, ., getRootNode, (, ), ;, if, (, curRoot]
[), {, Node, curRoot, =, s, ., getRootNode, (, ), ;, if, (, curRoot, ., getParent, (, ), ., isAssign]
[., getParent, (, ), ), {, Node, curRoot, =, s, ., getRootNode, (, ), ;, if, (, curRoot, ., getParent]
[;, if, (, curRoot, ., getParent, (, ), ., isAssign, (, ), ), {, Node, owner, =, curRoot, ., getParent]
[., getRootNode, (, ), ;, if, (, curRoot, ., getParent, (, ), ., isAssign, (, ), ), {, Node, owner]
[), {, Node, owner, =, curRoot, ., getParent, (, ), ., getFirstChild, (, ), ;, while, (, owner, ., isGetProp]
[., isAssign, (, ), ), {, Node, owner, =, curRoot, ., getParent, (, ), ., getFirstChild, (, ), ;, while]
[., getParent, (, ), ., isAssign, (, ), ), {, Node, owner, =, curRoot, ., getParent, (, ), ., getFirstChild]
[;, while, (, owner, ., isGetProp, (, ), ), {, owner, =, owner, ., getFirstChild, (, ), ;, }, if]
[., getFirstChild, (, ), ;, while, (, owner, ., isGetProp, (, ), ), {, owner, =, owner, ., getFirstChild, (]
[., getParent, (, ), ., getFirstChild, (, ), ;, while, (, owner, ., isGetProp, (, ), ), {, owner, =]
[), {, owner, =, owner, ., getFirstChild, (, ), ;, }, if, (, owner, ., isName, (, ), &&, owner]
[., isGetProp, (, ), ), {, owner, =, owner, ., getFirstChild, (, ), ;, }, if, (, owner, ., isName]
[=, owner, ., getFirstChild, (, ), ;, }, if, (, owner, ., isName, (, ), &&, owner, ., getString, (]
[;, }, if, (, owner, ., isName, (, ), &&, owner, ., getString, (, ), ., equals, (, name, )]
[., getFirstChild, (, ), ;, }, if, (, owner, ., isName, (, ), &&, owner, ., getString, (, ), .]
[), {, recursive, =, true, ;, break, ;, }, }, }, }, }, if, (, !, recursive, ), {, info]
[&&, owner, ., getString, (, ), ., equals, (, name, ), ), {, recursive, =, true, ;, break, ;, }]
[., isName, (, ), &&, owner, ., getString, (, ), ., equals, (, name, ), ), {, recursive, =, true]
[), {, recursive, =, true, ;, break, ;, }, }, }, }, }, if, (, !, recursive, ), {, info]
[., equals, (, name, ), ), {, recursive, =, true, ;, break, ;, }, }, }, }, }, if, (]
[., getString, (, ), ., equals, (, name, ), ), {, recursive, =, true, ;, break, ;, }, }, }]
[), ), {, recursive, =, true, ;, break, ;, }, }, }, }, }, if, (, !, recursive, ), {]
[=, true, ;, break, ;, }, }, }, }, }, if, (, !, recursive, ), {, info, ., addUsedModule, (]
[;, break, ;, }, }, }, }, }, if, (, !, recursive, ), {, info, ., addUsedModule, (, t, .]
[), {, info, ., addUsedModule, (, t, ., getModule, (, ), ), ;, }, }, @, Override, public, void, visit]
[), {, info, ., addUsedModule, (, t, ., getModule, (, ), ), ;, }, }, @, Override, public, void, visit]
[;, }, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if]
[., addUsedModule, (, t, ., getModule, (, ), ), ;, }, }, @, Override, public, void, visit, (, NodeTraversal, t]
[), ;, }, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {]
[., getModule, (, ), ), ;, }, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,]
[), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, if, (, name, ., isEmpty, (]
[), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, if, (, name, ., isEmpty, (]
[., isName, (, ), ), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, if, (]
[;, if, (, name, ., isEmpty, (, ), ||, compiler, ., getCodingConvention, (, ), ., isExported, (, name, ), )]
[., getString, (, ), ;, if, (, name, ., isEmpty, (, ), ||, compiler, ., getCodingConvention, (, ), ., isExported]
[), {, return, ;, }, Var, v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if]
[||, compiler, ., getCodingConvention, (, ), ., isExported, (, name, ), ), {, return, ;, }, Var, v, =, t]
[., isEmpty, (, ), ||, compiler, ., getCodingConvention, (, ), ., isExported, (, name, ), ), {, return, ;, }]
[), {, return, ;, }, Var, v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if]
[., isExported, (, name, ), ), {, return, ;, }, Var, v, =, t, ., getScope, (, ), ., getVar]
[., getCodingConvention, (, ), ., isExported, (, name, ), ), {, return, ;, }, Var, v, =, t, ., getScope]
[), ), {, return, ;, }, Var, v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;]
[;, if, (, v, ==, null, ||, !, v, ., isGlobal, (, ), ), {, return, ;, }, NamedInfo, info]
[., getVar, (, name, ), ;, if, (, v, ==, null, ||, !, v, ., isGlobal, (, ), ), {]
[., getScope, (, ), ., getVar, (, name, ), ;, if, (, v, ==, null, ||, !, v, ., isGlobal]
[), ;, if, (, v, ==, null, ||, !, v, ., isGlobal, (, ), ), {, return, ;, }, NamedInfo]
[), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (, v, ), ;, if, (, info, ., allowMove, ), {]
[||, !, v, ., isGlobal, (, ), ), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (, v, ), ;]
[==, null, ||, !, v, ., isGlobal, (, ), ), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (, v]
[||, !, v, ., isGlobal, (, ), ), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (, v, ), ;]
[), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (, v, ), ;, if, (, info, ., allowMove, ), {]
[), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (, v, ), ;, if, (, info, ., allowMove, ), {]
[., isGlobal, (, ), ), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (, v, ), ;, if, (, info]
[;, if, (, info, ., allowMove, ), {, if, (, maybeProcessDeclaration, (, t, ,, n, ,, parent, ,, info, )]
[), ;, if, (, info, ., allowMove, ), {, if, (, maybeProcessDeclaration, (, t, ,, n, ,, parent, ,, info]
[), {, if, (, maybeProcessDeclaration, (, t, ,, n, ,, parent, ,, info, ), ), {, if, (, hasConditionalAncestor, (]
[., allowMove, ), {, if, (, maybeProcessDeclaration, (, t, ,, n, ,, parent, ,, info, ), ), {, if, (]
[), {, if, (, hasConditionalAncestor, (, parent, ., getParent, (, ), ), ), {, info, ., allowMove, =, false, ;]
[,, n, ,, parent, ,, info, ), ), {, if, (, hasConditionalAncestor, (, parent, ., getParent, (, ), ), )]
[,, parent, ,, info, ), ), {, if, (, hasConditionalAncestor, (, parent, ., getParent, (, ), ), ), {, info]
[,, info, ), ), {, if, (, hasConditionalAncestor, (, parent, ., getParent, (, ), ), ), {, info, ., allowMove]
[), ), {, if, (, hasConditionalAncestor, (, parent, ., getParent, (, ), ), ), {, info, ., allowMove, =, false]
[), {, info, ., allowMove, =, false, ;, }, }, else, {, processReference, (, t, ,, info, ,, name, )]
[), ), {, info, ., allowMove, =, false, ;, }, }, else, {, processReference, (, t, ,, info, ,, name]
[., getParent, (, ), ), ), {, info, ., allowMove, =, false, ;, }, }, else, {, processReference, (, t]
[=, false, ;, }, }, else, {, processReference, (, t, ,, info, ,, name, ), ;, }, }, }, private]
[., allowMove, =, false, ;, }, }, else, {, processReference, (, t, ,, info, ,, name, ), ;, }, }]
[;, }, }, else, {, processReference, (, t, ,, info, ,, name, ), ;, }, }, }, private, boolean, maybeProcessDeclaration]
[;, }, }, }, private, boolean, maybeProcessDeclaration, (, NodeTraversal, t, ,, Node, name, ,, Node, parent, ,, NamedInfo, info, )]
[,, info, ,, name, ), ;, }, }, }, private, boolean, maybeProcessDeclaration, (, NodeTraversal, t, ,, Node, name, ,, Node]
[,, name, ), ;, }, }, }, private, boolean, maybeProcessDeclaration, (, NodeTraversal, t, ,, Node, name, ,, Node, parent, ,]
[), ;, }, }, }, private, boolean, maybeProcessDeclaration, (, NodeTraversal, t, ,, Node, name, ,, Node, parent, ,, NamedInfo, info]
[;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., VAR, :, if, (, canMoveValue, (, name]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., VAR, :, if]
[), {, case, Token, ., VAR, :, if, (, canMoveValue, (, name, ., getFirstChild, (, ), ), ), {, return]
[., getType, (, ), ), {, case, Token, ., VAR, :, if, (, canMoveValue, (, name, ., getFirstChild, (, )]
[:, if, (, canMoveValue, (, name, ., getFirstChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration]
[., VAR, :, if, (, canMoveValue, (, name, ., getFirstChild, (, ), ), ), {, return, info, ., addDeclaration, (]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent, ,]
[), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent]
[., getFirstChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, )]
[;, }, return, false, ;, case, Token, ., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), ), {]
[., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;]
[), ;, }, return, false, ;, case, Token, ., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), )]
[,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, ., FUNCTION, :, if, (]
[., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, .]
[,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, ., FUNCTION, :, if, (, NodeUtil, .]
[,, gramps, ), ), ;, }, return, false, ;, case, Token, ., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (]
[), ), ;, }, return, false, ;, case, Token, ., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, )]
[;, case, Token, ., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), ), {, return, info, ., addDeclaration]
[:, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t]
[., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), ), {, return, info, ., addDeclaration, (, new, Declaration]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent, ,]
[., isFunctionDeclaration, (, parent, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, )]
[), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent]
[;, }, return, false, ;, case, Token, ., ASSIGN, :, case, Token, ., GETPROP, :, Node, child, =, name, ;]
[., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;]
[), ;, }, return, false, ;, case, Token, ., ASSIGN, :, case, Token, ., GETPROP, :, Node, child, =, name]
[,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, ., ASSIGN, :, case, Token]
[., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, .]
[,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, ., ASSIGN, :, case, Token, ., GETPROP]
[,, gramps, ), ), ;, }, return, false, ;, case, Token, ., ASSIGN, :, case, Token, ., GETPROP, :, Node]
[), ), ;, }, return, false, ;, case, Token, ., ASSIGN, :, case, Token, ., GETPROP, :, Node, child, =]
[;, case, Token, ., ASSIGN, :, case, Token, ., GETPROP, :, Node, child, =, name, ;, for, (, Node, current]
[:, case, Token, ., GETPROP, :, Node, child, =, name, ;, for, (, Node, current, :, name, ., getAncestors, (]
[., ASSIGN, :, case, Token, ., GETPROP, :, Node, child, =, name, ;, for, (, Node, current, :, name, .]
[:, Node, child, =, name, ;, for, (, Node, current, :, name, ., getAncestors, (, ), ), {, if, (]
[., GETPROP, :, Node, child, =, name, ;, for, (, Node, current, :, name, ., getAncestors, (, ), ), {]
[;, for, (, Node, current, :, name, ., getAncestors, (, ), ), {, if, (, current, ., isGetProp, (, )]
[), {, if, (, current, ., isGetProp, (, ), ), {, }, else, if, (, current, ., isAssign, (, )]
[., getAncestors, (, ), ), {, if, (, current, ., isGetProp, (, ), ), {, }, else, if, (, current]
[), {, }, else, if, (, current, ., isAssign, (, ), &&, current, ., getFirstChild, (, ), ==, child, )]
[., isGetProp, (, ), ), {, }, else, if, (, current, ., isAssign, (, ), &&, current, ., getFirstChild, (]
[), {, Node, currentParent, =, current, ., getParent, (, ), ;, if, (, currentParent, ., isExprResult, (, ), &&, canMoveValue]
[&&, current, ., getFirstChild, (, ), ==, child, ), {, Node, currentParent, =, current, ., getParent, (, ), ;, if]
[., isAssign, (, ), &&, current, ., getFirstChild, (, ), ==, child, ), {, Node, currentParent, =, current, ., getParent]
[), {, Node, currentParent, =, current, ., getParent, (, ), ;, if, (, currentParent, ., isExprResult, (, ), &&, canMoveValue]
[==, child, ), {, Node, currentParent, =, current, ., getParent, (, ), ;, if, (, currentParent, ., isExprResult, (, )]
[., getFirstChild, (, ), ==, child, ), {, Node, currentParent, =, current, ., getParent, (, ), ;, if, (, currentParent]
[), {, Node, currentParent, =, current, ., getParent, (, ), ;, if, (, currentParent, ., isExprResult, (, ), &&, canMoveValue]
[;, if, (, currentParent, ., isExprResult, (, ), &&, canMoveValue, (, current, ., getLastChild, (, ), ), ), {, return]
[., getParent, (, ), ;, if, (, currentParent, ., isExprResult, (, ), &&, canMoveValue, (, current, ., getLastChild, (, )]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, current, ,, currentParent, ,]
[&&, canMoveValue, (, current, ., getLastChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t]
[., isExprResult, (, ), &&, canMoveValue, (, current, ., getLastChild, (, ), ), ), {, return, info, ., addDeclaration, (]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, current, ,, currentParent, ,]
[), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, current, ,, currentParent]
[., getLastChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, )]
[;, }, }, else, {, return, false, ;, }, child, =, current, ;, }, return, false, ;, case, Token, .]
[., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, current, ,, currentParent, ,, currentParent, ., getParent, (]
[), ;, }, }, else, {, return, false, ;, }, child, =, current, ;, }, return, false, ;, case, Token]
[,, current, ,, currentParent, ,, currentParent, ., getParent, (, ), ), ), ;, }, }, else, {, return, false, ;]
[., getModule, (, ), ,, current, ,, currentParent, ,, currentParent, ., getParent, (, ), ), ), ;, }, }, else]
[,, currentParent, ,, currentParent, ., getParent, (, ), ), ), ;, }, }, else, {, return, false, ;, }, child]
[,, currentParent, ., getParent, (, ), ), ), ;, }, }, else, {, return, false, ;, }, child, =, current]
[), ), ;, }, }, else, {, return, false, ;, }, child, =, current, ;, }, return, false, ;, case]
[., getParent, (, ), ), ), ;, }, }, else, {, return, false, ;, }, child, =, current, ;, }]
[;, }, child, =, current, ;, }, return, false, ;, case, Token, ., CALL, :, if, (, NodeUtil, ., isExprCall]
[=, current, ;, }, return, false, ;, case, Token, ., CALL, :, if, (, NodeUtil, ., isExprCall, (, gramps, )]
[;, }, return, false, ;, case, Token, ., CALL, :, if, (, NodeUtil, ., isExprCall, (, gramps, ), ), {]
[;, case, Token, ., CALL, :, if, (, NodeUtil, ., isExprCall, (, gramps, ), ), {, SubclassRelationship, relationship, =, compiler]
[:, if, (, NodeUtil, ., isExprCall, (, gramps, ), ), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), .]
[., CALL, :, if, (, NodeUtil, ., isExprCall, (, gramps, ), ), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (]
[), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship, !=]
[., isExprCall, (, gramps, ), ), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, )]
[), ), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship]
[;, if, (, relationship, !=, null, &&, name, ., getString, (, ), ., equals, (, relationship, ., subclassName, ), )]
[., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship, !=, null, &&, name, ., getString, (, ), ., equals, (]
[., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship, !=, null, &&, name, ., getString, (]
[), ;, if, (, relationship, !=, null, &&, name, ., getString, (, ), ., equals, (, relationship, ., subclassName, )]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, parent, ,, gramps, ,]
[&&, name, ., getString, (, ), ., equals, (, relationship, ., subclassName, ), ), {, return, info, ., addDeclaration, (]
[!=, null, &&, name, ., getString, (, ), ., equals, (, relationship, ., subclassName, ), ), {, return, info, .]
[&&, name, ., getString, (, ), ., equals, (, relationship, ., subclassName, ), ), {, return, info, ., addDeclaration, (]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, parent, ,, gramps, ,]
[., equals, (, relationship, ., subclassName, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule]
[., getString, (, ), ., equals, (, relationship, ., subclassName, ), ), {, return, info, ., addDeclaration, (, new, Declaration]
[), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, parent, ,, gramps]
[., subclassName, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, parent]
[;, }, }, return, false, ;, default, :, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n, )]
[., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, parent, ,, gramps, ,, gramps, ., getParent, (]
[), ;, }, }, return, false, ;, default, :, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n]
[,, parent, ,, gramps, ,, gramps, ., getParent, (, ), ), ), ;, }, }, return, false, ;, default, :]
[., getModule, (, ), ,, parent, ,, gramps, ,, gramps, ., getParent, (, ), ), ), ;, }, }, return]
[,, gramps, ,, gramps, ., getParent, (, ), ), ), ;, }, }, return, false, ;, default, :, return, false]
[,, gramps, ., getParent, (, ), ), ), ;, }, }, return, false, ;, default, :, return, false, ;, }]
[), ), ;, }, }, return, false, ;, default, :, return, false, ;, }, }, private, boolean, canMoveValue, (, Node]
[., getParent, (, ), ), ), ;, }, }, return, false, ;, default, :, return, false, ;, }, }, private]
[;, default, :, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (, n, ==]
[;, }, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (, n, ==, null, ||, NodeUtil, ., isLiteralValue]
[), {, return, true, ;, }, else, if, (, n, ., isCall, (, ), ), {, Node, functionName, =, n]
[||, n, ., isFunction, (, ), ), {, return, true, ;, }, else, if, (, n, ., isCall, (, )]
[||, NodeUtil, ., isLiteralValue, (, n, ,, true, ), ||, n, ., isFunction, (, ), ), {, return, true, ;]
[==, null, ||, NodeUtil, ., isLiteralValue, (, n, ,, true, ), ||, n, ., isFunction, (, ), ), {, return]
[||, NodeUtil, ., isLiteralValue, (, n, ,, true, ), ||, n, ., isFunction, (, ), ), {, return, true, ;]
[||, n, ., isFunction, (, ), ), {, return, true, ;, }, else, if, (, n, ., isCall, (, )]
[., isLiteralValue, (, n, ,, true, ), ||, n, ., isFunction, (, ), ), {, return, true, ;, }, else]
[,, true, ), ||, n, ., isFunction, (, ), ), {, return, true, ;, }, else, if, (, n, .]
[), ||, n, ., isFunction, (, ), ), {, return, true, ;, }, else, if, (, n, ., isCall, (]
[), {, return, true, ;, }, else, if, (, n, ., isCall, (, ), ), {, Node, functionName, =, n]
[., isFunction, (, ), ), {, return, true, ;, }, else, if, (, n, ., isCall, (, ), ), {]
[;, }, else, if, (, n, ., isCall, (, ), ), {, Node, functionName, =, n, ., getFirstChild, (, )]
[), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return, functionName, ., isName, (, ), &&, (, functionName]
[., isCall, (, ), ), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return, functionName, ., isName, (]
[;, return, functionName, ., isName, (, ), &&, (, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME]
[., getFirstChild, (, ), ;, return, functionName, ., isName, (, ), &&, (, functionName, ., getString, (, ), ., equals]
[;, }, else, if, (, n, ., isArrayLit, (, ), ||, n, ., isObjectLit, (, ), ), {, boolean, isObjectLit]
[&&, (, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME, ), ||, functionName, ., getString, (, )]
[., isName, (, ), &&, (, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME, ), ||, functionName]
[;, }, else, if, (, n, ., isArrayLit, (, ), ||, n, ., isObjectLit, (, ), ), {, boolean, isObjectLit]
[), ;, }, else, if, (, n, ., isArrayLit, (, ), ||, n, ., isObjectLit, (, ), ), {, boolean]
[||, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (, n]
[., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME, ), ||, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, )]
[., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME, ), ||, functionName, ., getString, (, ), ., equals, (]
[), ||, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (]
[., STUB_METHOD_NAME, ), ||, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else]
[), ;, }, else, if, (, n, ., isArrayLit, (, ), ||, n, ., isObjectLit, (, ), ), {, boolean]
[., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (, n, ., isArrayLit, (, ), ||, n]
[., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (, n, ., isArrayLit]
[), ), ;, }, else, if, (, n, ., isArrayLit, (, ), ||, n, ., isObjectLit, (, ), ), {]
[., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (, n, ., isArrayLit, (, ), ||, n, ., isObjectLit, (, )]
[), {, boolean, isObjectLit, =, n, ., isObjectLit, (, ), ;, for, (, Node, child, =, n, ., getFirstChild, (]
[||, n, ., isObjectLit, (, ), ), {, boolean, isObjectLit, =, n, ., isObjectLit, (, ), ;, for, (, Node]
[., isArrayLit, (, ), ||, n, ., isObjectLit, (, ), ), {, boolean, isObjectLit, =, n, ., isObjectLit, (, )]
[), {, boolean, isObjectLit, =, n, ., isObjectLit, (, ), ;, for, (, Node, child, =, n, ., getFirstChild, (]
[., isObjectLit, (, ), ), {, boolean, isObjectLit, =, n, ., isObjectLit, (, ), ;, for, (, Node, child, =]
[;, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, .]
[., isObjectLit, (, ), ;, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;]
[;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (, isObjectLit]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[;, child, =, child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (, isObjectLit, ?, child, ., getFirstChild]
[!=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (, isObjectLit, ?, child]
[;, child, =, child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (, isObjectLit, ?, child, ., getFirstChild]
[=, child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (, isObjectLit, ?, child, ., getFirstChild, (, )]
[), {, if, (, !, canMoveValue, (, isObjectLit, ?, child, ., getFirstChild, (, ), :, child, ), ), {, return]
[., getNext, (, ), ), {, if, (, !, canMoveValue, (, isObjectLit, ?, child, ., getFirstChild, (, ), :, child]
[), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }, }]
[), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }, }]
[), ), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }, }]
[?, child, ., getFirstChild, (, ), :, child, ), ), {, return, false, ;, }, }, return, true, ;, }]
[:, child, ), ), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }, }]
[., getFirstChild, (, ), :, child, ), ), {, return, false, ;, }, }, return, true, ;, }, return, false]
[), ), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }, }]
[;, }, }, return, true, ;, }, return, false, ;, }, }]
[;, }, return, false, ;, }, }]
[;, }, }]
