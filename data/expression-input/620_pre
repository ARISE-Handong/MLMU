[., logging, ., Logger, ;, class, UnreachableCodeElimination, extends, AbstractPostOrderCallback, implements, CompilerPass, ,, ScopedCallback, {, private, static, final, Logger, logger, =]
[., logging, ., Logger, ;, class, UnreachableCodeElimination, extends, AbstractPostOrderCallback, implements, CompilerPass, ,, ScopedCallback, {, private, static, final, Logger, logger, =]
[;, class, UnreachableCodeElimination, extends, AbstractPostOrderCallback, implements, CompilerPass, ,, ScopedCallback, {, private, static, final, Logger, logger, =, Logger, ., getLogger, (]
[;, class, UnreachableCodeElimination, extends, AbstractPostOrderCallback, implements, CompilerPass, ,, ScopedCallback, {, private, static, final, Logger, logger, =, Logger, ., getLogger, (]
[;, private, final, AbstractCompiler, compiler, ;, private, final, boolean, removeNoOpStatements, ;, UnreachableCodeElimination, (, AbstractCompiler, compiler, ,, boolean, removeNoOpStatements, ), {]
[;, private, final, AbstractCompiler, compiler, ;, private, final, boolean, removeNoOpStatements, ;, UnreachableCodeElimination, (, AbstractCompiler, compiler, ,, boolean, removeNoOpStatements, ), {]
[compiler, ;, private, final, boolean, removeNoOpStatements, ;, UnreachableCodeElimination, (, AbstractCompiler, compiler, ,, boolean, removeNoOpStatements, ), {, this, ., compiler, =]
[private, final, boolean, removeNoOpStatements, ;, UnreachableCodeElimination, (, AbstractCompiler, compiler, ,, boolean, removeNoOpStatements, ), {, this, ., compiler, =, compiler, ;]
[private, final, boolean, removeNoOpStatements, ;, UnreachableCodeElimination, (, AbstractCompiler, compiler, ,, boolean, removeNoOpStatements, ), {, this, ., compiler, =, compiler, ;]
[;, UnreachableCodeElimination, (, AbstractCompiler, compiler, ,, boolean, removeNoOpStatements, ), {, this, ., compiler, =, compiler, ;, this, ., removeNoOpStatements, =]
[this, ., removeNoOpStatements, =, removeNoOpStatements, ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, Scope, scope, =]
[this, ., removeNoOpStatements, =, removeNoOpStatements, ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, Scope, scope, =]
[public, void, exitScope, (, NodeTraversal, t, ), {, Scope, scope, =, t, ., getScope, (, ), ;, ControlFlowAnalysis, cfa, =]
[(, NodeTraversal, t, ), {, Scope, scope, =, t, ., getScope, (, ), ;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (]
[t, ), {, Scope, scope, =, t, ., getScope, (, ), ;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (, compiler, ,]
[{, Scope, scope, =, t, ., getScope, (, ), ;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (, compiler, ,, false, ,]
[=, t, ., getScope, (, ), ;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (, compiler, ,, false, ,, false, ), ;]
[=, t, ., getScope, (, ), ;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (, compiler, ,, false, ,, false, ), ;]
[(, ), ;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (, compiler, ,, false, ,, false, ), ;, cfa, ., process, (]
[;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (, compiler, ,, false, ,, false, ), ;, cfa, ., process, (, null, ,]
[;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (, compiler, ,, false, ,, false, ), ;, cfa, ., process, (, null, ,]
[;, cfa, ., process, (, null, ,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node, >, cfg, =]
[;, cfa, ., process, (, null, ,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node, >, cfg, =]
[,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node, >, cfg, =, cfa, ., getCfg, (, ), ;]
[,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node, >, cfg, =, cfa, ., getCfg, (, ), ;]
[Node, >, cfg, =, cfa, ., getCfg, (, ), ;, new, GraphReachability, <, Node, ,, ControlFlowGraph, ., Branch, >, (]
[., getCfg, (, ), ;, new, GraphReachability, <, Node, ,, ControlFlowGraph, ., Branch, >, (, cfg, ), ., compute, (]
[., getCfg, (, ), ;, new, GraphReachability, <, Node, ,, ControlFlowGraph, ., Branch, >, (, cfg, ), ., compute, (]
[., getCfg, (, ), ;, new, GraphReachability, <, Node, ,, ControlFlowGraph, ., Branch, >, (, cfg, ), ., compute, (]
[(, cfg, ), ., compute, (, cfg, ., getEntry, (, ), ., getValue, (, ), ), ;, Node, root, =]
[(, cfg, ), ., compute, (, cfg, ., getEntry, (, ), ., getValue, (, ), ), ;, Node, root, =]
[getEntry, (, ), ., getValue, (, ), ), ;, Node, root, =, scope, ., getRootNode, (, ), ;, if, (]
[getEntry, (, ), ., getValue, (, ), ), ;, Node, root, =, scope, ., getRootNode, (, ), ;, if, (]
[), ;, Node, root, =, scope, ., getRootNode, (, ), ;, if, (, scope, ., isLocal, (, ), ), {]
[Node, root, =, scope, ., getRootNode, (, ), ;, if, (, scope, ., isLocal, (, ), ), {, root, =]
[Node, root, =, scope, ., getRootNode, (, ), ;, if, (, scope, ., isLocal, (, ), ), {, root, =]
[), ;, if, (, scope, ., isLocal, (, ), ), {, root, =, root, ., getLastChild, (, ), ;, }]
[), ;, if, (, scope, ., isLocal, (, ), ), {, root, =, root, ., getLastChild, (, ), ;, }]
[scope, ., isLocal, (, ), ), {, root, =, root, ., getLastChild, (, ), ;, }, NodeTraversal, ., traverse, (]
[isLocal, (, ), ), {, root, =, root, ., getLastChild, (, ), ;, }, NodeTraversal, ., traverse, (, compiler, ,]
[), ), {, root, =, root, ., getLastChild, (, ), ;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[root, =, root, ., getLastChild, (, ), ;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, EliminationPass, (]
[EliminationPass, (, cfg, ), ), ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[EliminationPass, (, cfg, ), ), ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[), ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, NodeTraversal, ., traverse, (]
[}, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, NodeTraversal, ., traverse, (, compiler, ,]
[Override, public, void, process, (, Node, externs, ,, Node, root, ), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[AbstractShallowCallback, {, private, final, ControlFlowGraph, <, Node, >, cfg, ;, private, EliminationPass, (, ControlFlowGraph, <, Node, >, cfg, ), {]
[AbstractShallowCallback, {, private, final, ControlFlowGraph, <, Node, >, cfg, ;, private, EliminationPass, (, ControlFlowGraph, <, Node, >, cfg, ), {]
[ControlFlowGraph, <, Node, >, cfg, ;, private, EliminationPass, (, ControlFlowGraph, <, Node, >, cfg, ), {, this, ., cfg, =]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[@, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, parent, ==]
[,, Node, n, ,, Node, parent, ), {, if, (, parent, ==, null, ), {, return, ;, }, if, (]
[,, Node, n, ,, Node, parent, ), {, if, (, parent, ==, null, ), {, return, ;, }, if, (]
[,, Node, n, ,, Node, parent, ), {, if, (, parent, ==, null, ), {, return, ;, }, if, (]
[), {, if, (, parent, ==, null, ), {, return, ;, }, if, (, n, ., isFunction, (, ), ||]
[), {, if, (, parent, ==, null, ), {, return, ;, }, if, (, n, ., isFunction, (, ), ||]
[), ||, n, ., isScript, (, ), ), {, return, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =]
[), ||, n, ., isScript, (, ), ), {, return, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =]
[isScript, (, ), ), {, return, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (]
[return, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (]
[return, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (]
[}, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==]
[=, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==, null, ), {, return, ;, }, if, (]
[=, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==, null, ), {, return, ;, }, if, (]
[=, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==, null, ), {, return, ;, }, if, (]
[=, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==, null, ), {, return, ;, }, if, (]
[), ;, if, (, gNode, ==, null, ), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=]
[), ;, if, (, gNode, ==, null, ), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=]
[gNode, ==, null, ), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||]
[==, null, ), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (]
[==, null, ), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (]
[), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&]
[{, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&, !]
[{, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&, !]
[if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&, !, NodeUtil, ., mayHaveSideEffects, (]
[gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&, !, NodeUtil, ., mayHaveSideEffects, (, n, ,]
[!=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&, !, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {]
[., REACHABLE, ||, (, removeNoOpStatements, &&, !, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {, removeDeadExprStatementSafely, (]
[!, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }]
[., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (]
[,, compiler, ), ), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }]
[), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }, @, SuppressWarnings, (]
[(, n, ), ;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryRemoveUnconditionalBranching, (, Node, n, ), {, if, (]
[(, n, ), ;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryRemoveUnconditionalBranching, (, Node, n, ), {, if, (]
[), ;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryRemoveUnconditionalBranching, (, Node, n, ), {, if, (, n, ==]
[SuppressWarnings, (, "fallthrough", ), private, Node, tryRemoveUnconditionalBranching, (, Node, n, ), {, if, (, n, ==, null, ), {, return]
[{, if, (, n, ==, null, ), {, return, n, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =]
[{, if, (, n, ==, null, ), {, return, n, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =]
[==, null, ), {, return, n, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (]
[n, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (]
[n, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (]
[}, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==]
[,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==, null, ), {, return]
[cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==, null, ), {, return, n, ;, }, switch, (]
[cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==, null, ), {, return, n, ;, }, switch, (]
[(, gNode, ==, null, ), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[(, gNode, ==, null, ), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., RETURN, :, if, (]
[return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., RETURN, :, if, (]
[), {, case, Token, ., RETURN, :, if, (, n, ., hasChildren, (, ), ), {, break, ;, }, case]
[), {, case, Token, ., RETURN, :, if, (, n, ., hasChildren, (, ), ), {, break, ;, }, case]
[RETURN, :, if, (, n, ., hasChildren, (, ), ), {, break, ;, }, case, Token, ., BREAK, :, case]
[RETURN, :, if, (, n, ., hasChildren, (, ), ), {, break, ;, }, case, Token, ., BREAK, :, case]
[Token, ., BREAK, :, case, Token, ., CONTINUE, :, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =]
[Token, ., BREAK, :, case, Token, ., CONTINUE, :, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =]
[:, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (]
[:, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (]
[:, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (]
[:, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (]
[,, Branch, >, >, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (, outEdges, ., size, (, ), ==]
[>, >, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (, outEdges, ., size, (, ), ==, 1, &&]
[>, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (, outEdges, ., size, (, ), ==, 1, &&, (]
[>, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (, outEdges, ., size, (, ), ==, 1, &&, (]
[>, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (, outEdges, ., size, (, ), ==, 1, &&, (]
[>, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (, outEdges, ., size, (, ), ==, 1, &&, (]
[(, ), ;, if, (, outEdges, ., size, (, ), ==, 1, &&, (, n, ., getNext, (, ), ==]
[;, if, (, outEdges, ., size, (, ), ==, 1, &&, (, n, ., getNext, (, ), ==, null, ||]
[;, if, (, outEdges, ., size, (, ), ==, 1, &&, (, n, ., getNext, (, ), ==, null, ||]
[;, if, (, outEdges, ., size, (, ), ==, 1, &&, (, n, ., getNext, (, ), ==, null, ||]
[n, ., getNext, (, ), ==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {]
[n, ., getNext, (, ), ==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {]
[), ==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions, ., checkState, (]
[), ==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions, ., checkState, (]
[), ==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions, ., checkState, (]
[), ==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions, ., checkState, (]
[n, ., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions, ., checkState, (, outEdges, ., get, (]
[(, ), ), ), {, Preconditions, ., checkState, (, outEdges, ., get, (, 0, ), ., getValue, (, ), ==]
[(, ), ), ), {, Preconditions, ., checkState, (, outEdges, ., get, (, 0, ), ., getValue, (, ), ==]
[(, outEdges, ., get, (, 0, ), ., getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node, fallThrough, =]
[., get, (, 0, ), ., getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (]
[getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =]
[getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =]
[getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =]
[getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =]
[Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =, outEdges, ., get, (]
[Node, nextCfgNode, =, outEdges, ., get, (, 0, ), ., getDestination, (, ), ., getValue, (, ), ;, if, (]
[Node, nextCfgNode, =, outEdges, ., get, (, 0, ), ., getDestination, (, ), ., getValue, (, ), ;, if, (]
[=, outEdges, ., get, (, 0, ), ., getDestination, (, ), ., getValue, (, ), ;, if, (, nextCfgNode, ==]
[get, (, 0, ), ., getDestination, (, ), ., getValue, (, ), ;, if, (, nextCfgNode, ==, fallThrough, ), {]
[0, ), ., getDestination, (, ), ., getValue, (, ), ;, if, (, nextCfgNode, ==, fallThrough, ), {, removeDeadExprStatementSafely, (]
[(, ), ., getValue, (, ), ;, if, (, nextCfgNode, ==, fallThrough, ), {, removeDeadExprStatementSafely, (, n, ), ;, return]
[;, if, (, nextCfgNode, ==, fallThrough, ), {, removeDeadExprStatementSafely, (, n, ), ;, return, fallThrough, ;, }, }, }, return]
[fallThrough, ;, }, }, }, return, n, ;, }, private, Node, computeFollowing, (, Node, n, ), {, Node, next, =]
[fallThrough, ;, }, }, }, return, n, ;, }, private, Node, computeFollowing, (, Node, n, ), {, Node, next, =]
[}, return, n, ;, }, private, Node, computeFollowing, (, Node, n, ), {, Node, next, =, ControlFlowAnalysis, ., computeFollowNode, (]
[private, Node, computeFollowing, (, Node, n, ), {, Node, next, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, while, (]
[private, Node, computeFollowing, (, Node, n, ), {, Node, next, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, while, (]
[private, Node, computeFollowing, (, Node, n, ), {, Node, next, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, while, (]
[computeFollowing, (, Node, n, ), {, Node, next, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, while, (, next, !=]
[Node, n, ), {, Node, next, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, while, (, next, !=, null, &&]
[Node, n, ), {, Node, next, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, while, (, next, !=, null, &&]
[computeFollowNode, (, n, ), ;, while, (, next, !=, null, &&, next, ., isBlock, (, ), ), {, if, (]
[computeFollowNode, (, n, ), ;, while, (, next, !=, null, &&, next, ., isBlock, (, ), ), {, if, (]
[next, !=, null, &&, next, ., isBlock, (, ), ), {, if, (, next, ., hasChildren, (, ), ), {]
[null, &&, next, ., isBlock, (, ), ), {, if, (, next, ., hasChildren, (, ), ), {, next, =]
[null, &&, next, ., isBlock, (, ), ), {, if, (, next, ., hasChildren, (, ), ), {, next, =]
[if, (, next, ., hasChildren, (, ), ), {, next, =, next, ., getFirstChild, (, ), ;, }, else, {]
[next, ., hasChildren, (, ), ), {, next, =, next, ., getFirstChild, (, ), ;, }, else, {, next, =]
[hasChildren, (, ), ), {, next, =, next, ., getFirstChild, (, ), ;, }, else, {, next, =, computeFollowing, (]
[=, next, ., getFirstChild, (, ), ;, }, else, {, next, =, computeFollowing, (, next, ), ;, }, }, return]
[next, ), ;, }, }, return, next, ;, }, private, void, removeDeadExprStatementSafely, (, Node, n, ), {, Node, parent, =]
[next, ), ;, }, }, return, next, ;, }, private, void, removeDeadExprStatementSafely, (, Node, n, ), {, Node, parent, =]
[}, private, void, removeDeadExprStatementSafely, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[}, private, void, removeDeadExprStatementSafely, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[}, private, void, removeDeadExprStatementSafely, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, n, ., isEmpty, (, ), ||]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, n, ., isEmpty, (, ), ||, (]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, n, ., isEmpty, (, ), ||, (]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, n, ., isEmpty, (, ), ||, (]
[., getParent, (, ), ;, if, (, n, ., isEmpty, (, ), ||, (, n, ., isBlock, (, ), &&]
[getParent, (, ), ;, if, (, n, ., isEmpty, (, ), ||, (, n, ., isBlock, (, ), &&, !]
[getParent, (, ), ;, if, (, n, ., isEmpty, (, ), ||, (, n, ., isBlock, (, ), &&, !]
[n, ., isBlock, (, ), &&, !, n, ., hasChildren, (, ), ), ), {, return, ;, }, if, (]
[n, ., isBlock, (, ), &&, !, n, ., hasChildren, (, ), ), ), {, return, ;, }, if, (]
[), &&, !, n, ., hasChildren, (, ), ), ), {, return, ;, }, if, (, NodeUtil, ., isForIn, (]
[), {, return, ;, }, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, ;, }, switch, (]
[), {, return, ;, }, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, ;, }, switch, (]
[., isForIn, (, parent, ), ), {, return, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[., isForIn, (, parent, ), ), {, return, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[return, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., DO, :, return, ;, case]
[return, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., DO, :, return, ;, case]
[., getType, (, ), ), {, case, Token, ., DO, :, return, ;, case, Token, ., BLOCK, :, if, (]
[., getType, (, ), ), {, case, Token, ., DO, :, return, ;, case, Token, ., BLOCK, :, if, (]
[DO, :, return, ;, case, Token, ., BLOCK, :, if, (, parent, ., isTry, (, ), ), {, if, (]
[DO, :, return, ;, case, Token, ., BLOCK, :, if, (, parent, ., isTry, (, ), ), {, if, (]
[case, Token, ., BLOCK, :, if, (, parent, ., isTry, (, ), ), {, if, (, NodeUtil, ., isTryCatchNodeContainer, (]
[), ), {, if, (, NodeUtil, ., isTryCatchNodeContainer, (, n, ), ), {, return, ;, }, }, break, ;, case]
[), ), {, if, (, NodeUtil, ., isTryCatchNodeContainer, (, n, ), ), {, return, ;, }, }, break, ;, case]
[isTryCatchNodeContainer, (, n, ), ), {, return, ;, }, }, break, ;, case, Token, ., CATCH, :, Node, tryNode, =]
[isTryCatchNodeContainer, (, n, ), ), {, return, ;, }, }, break, ;, case, Token, ., CATCH, :, Node, tryNode, =]
[return, ;, }, }, break, ;, case, Token, ., CATCH, :, Node, tryNode, =, parent, ., getParent, (, ), ;]
[return, ;, }, }, break, ;, case, Token, ., CATCH, :, Node, tryNode, =, parent, ., getParent, (, ), ;]
[break, ;, case, Token, ., CATCH, :, Node, tryNode, =, parent, ., getParent, (, ), ;, NodeUtil, ., maybeAddFinally, (]
[tryNode, =, parent, ., getParent, (, ), ;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (]
[tryNode, =, parent, ., getParent, (, ), ;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (]
[tryNode, =, parent, ., getParent, (, ), ;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (]
[), ;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (, n, ., isVar, (, ), &&]
[;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (, n, ., isVar, (, ), &&, !]
[;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (, n, ., isVar, (, ), &&, !]
[;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (, n, ., isVar, (, ), &&, !]
[., isVar, (, ), &&, !, n, ., getFirstChild, (, ), ., hasChildren, (, ), ), {, return, ;, }]
[., isVar, (, ), &&, !, n, ., getFirstChild, (, ), ., hasChildren, (, ), ), {, return, ;, }]
[&&, !, n, ., getFirstChild, (, ), ., hasChildren, (, ), ), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (]
[., getFirstChild, (, ), ., hasChildren, (, ), ), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;]
[., getFirstChild, (, ), ., hasChildren, (, ), ), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;]
[), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (]
[), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (]
[}, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (]
[}, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (]
[), ;, compiler, ., reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {]
[), ;, compiler, ., reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {]
[reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {, logger, ., fine, (]
[reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {, logger, ., fine, (]
[), ;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {, logger, ., fine, (, "Removing ", +]
[), ;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {, logger, ., fine, (, "Removing ", +]
[Level, ., FINE, ), ), {, logger, ., fine, (, "Removing ", +, n, ., toString, (, ), ), ;, }]
[Level, ., FINE, ), ), {, logger, ., fine, (, "Removing ", +, n, ., toString, (, ), ), ;, }]
[), {, logger, ., fine, (, "Removing ", +, n, ., toString, (, ), ), ;, }, NodeUtil, ., removeChild, (]
[), {, logger, ., fine, (, "Removing ", +, n, ., toString, (, ), ), ;, }, NodeUtil, ., removeChild, (]
["Removing ", +, n, ., toString, (, ), ), ;, }, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,]
