[AdjacencyGraph, <, N, ,, E, >, graph, ;, public, GraphColoring, (, AdjacencyGraph, <, N, ,, E, >, graph, ), {]
[AdjacencyGraph, <, N, ,, E, >, graph, ;, public, GraphColoring, (, AdjacencyGraph, <, N, ,, E, >, graph, ), {]
[E, >, graph, ;, public, GraphColoring, (, AdjacencyGraph, <, N, ,, E, >, graph, ), {, this, ., graph, =]
[graph, =, graph, ;, }, public, abstract, int, color, (, ), ;, public, N, getPartitionSuperNode, (, N, node, ), {]
[graph, =, graph, ;, }, public, abstract, int, color, (, ), ;, public, N, getPartitionSuperNode, (, N, node, ), {]
[}, public, abstract, int, color, (, ), ;, public, N, getPartitionSuperNode, (, N, node, ), {, Preconditions, ., checkNotNull, (]
[abstract, int, color, (, ), ;, public, N, getPartitionSuperNode, (, N, node, ), {, Preconditions, ., checkNotNull, (, colorToNodeMap, ,]
[public, N, getPartitionSuperNode, (, N, node, ), {, Preconditions, ., checkNotNull, (, colorToNodeMap, ,, "No coloring founded. color() should be called first.", ), ;, Color, color, =]
[public, N, getPartitionSuperNode, (, N, node, ), {, Preconditions, ., checkNotNull, (, colorToNodeMap, ,, "No coloring founded. color() should be called first.", ), ;, Color, color, =]
[public, N, getPartitionSuperNode, (, N, node, ), {, Preconditions, ., checkNotNull, (, colorToNodeMap, ,, "No coloring founded. color() should be called first.", ), ;, Color, color, =]
[N, node, ), {, Preconditions, ., checkNotNull, (, colorToNodeMap, ,, "No coloring founded. color() should be called first.", ), ;, Color, color, =, graph, ., getNode, (]
["No coloring founded. color() should be called first.", ), ;, Color, color, =, graph, ., getNode, (, node, ), ., getAnnotation, (, ), ;, N, headNode, =]
["No coloring founded. color() should be called first.", ), ;, Color, color, =, graph, ., getNode, (, node, ), ., getAnnotation, (, ), ;, N, headNode, =]
[;, Color, color, =, graph, ., getNode, (, node, ), ., getAnnotation, (, ), ;, N, headNode, =, colorToNodeMap, []
[;, Color, color, =, graph, ., getNode, (, node, ), ., getAnnotation, (, ), ;, N, headNode, =, colorToNodeMap, []
[(, node, ), ., getAnnotation, (, ), ;, N, headNode, =, colorToNodeMap, [, color, ., value, ], ;, if, (]
[(, node, ), ., getAnnotation, (, ), ;, N, headNode, =, colorToNodeMap, [, color, ., value, ], ;, if, (]
[), ., getAnnotation, (, ), ;, N, headNode, =, colorToNodeMap, [, color, ., value, ], ;, if, (, headNode, ==]
[(, ), ;, N, headNode, =, colorToNodeMap, [, color, ., value, ], ;, if, (, headNode, ==, null, ), {]
[(, ), ;, N, headNode, =, colorToNodeMap, [, color, ., value, ], ;, if, (, headNode, ==, null, ), {]
[;, N, headNode, =, colorToNodeMap, [, color, ., value, ], ;, if, (, headNode, ==, null, ), {, colorToNodeMap, []
[;, N, headNode, =, colorToNodeMap, [, color, ., value, ], ;, if, (, headNode, ==, null, ), {, colorToNodeMap, []
[[, color, ., value, ], ;, if, (, headNode, ==, null, ), {, colorToNodeMap, [, color, ., value, ], =]
[value, ], ;, if, (, headNode, ==, null, ), {, colorToNodeMap, [, color, ., value, ], =, node, ;, return]
[==, null, ), {, colorToNodeMap, [, color, ., value, ], =, node, ;, return, node, ;, }, else, {, return]
[}, else, {, return, headNode, ;, }, }, public, AdjacencyGraph, <, N, ,, E, >, getGraph, (, ), {, return]
[E, >, getGraph, (, ), {, return, graph, ;, }, public, static, class, Color, implements, Annotation, {, int, value, =]
[;, }, public, static, class, Color, implements, Annotation, {, int, value, =, 0, ;, Color, (, int, value, ), {]
[;, }, public, static, class, Color, implements, Annotation, {, int, value, =, 0, ;, Color, (, int, value, ), {]
[class, Color, implements, Annotation, {, int, value, =, 0, ;, Color, (, int, value, ), {, this, ., value, =]
[{, this, ., value, =, value, ;, }, @, Override, public, boolean, equals, (, Object, other, ), {, if, (]
[this, ., value, =, value, ;, }, @, Override, public, boolean, equals, (, Object, other, ), {, if, (, !]
[., value, =, value, ;, }, @, Override, public, boolean, equals, (, Object, other, ), {, if, (, !, (]
[., value, =, value, ;, }, @, Override, public, boolean, equals, (, Object, other, ), {, if, (, !, (]
[Override, public, boolean, equals, (, Object, other, ), {, if, (, !, (, other, instanceof, Color, ), ), {, return]
[other, ), {, if, (, !, (, other, instanceof, Color, ), ), {, return, false, ;, }, else, {, return]
[other, ), {, if, (, !, (, other, instanceof, Color, ), ), {, return, false, ;, }, else, {, return]
[{, if, (, !, (, other, instanceof, Color, ), ), {, return, false, ;, }, else, {, return, value, ==]
[{, if, (, !, (, other, instanceof, Color, ), ), {, return, false, ;, }, else, {, return, value, ==]
[if, (, !, (, other, instanceof, Color, ), ), {, return, false, ;, }, else, {, return, value, ==, (]
[(, other, instanceof, Color, ), ), {, return, false, ;, }, else, {, return, value, ==, (, (, Color, )]
[(, (, Color, ), other, ), ., value, ;, }, }, @, Override, public, int, hashCode, (, ), {, return]
[Comparator, <, N, >, tieBreaker, ;, public, GreedyGraphColoring, (, AdjacencyGraph, <, N, ,, E, >, graph, ), {, this, (]
[N, >, tieBreaker, ;, public, GreedyGraphColoring, (, AdjacencyGraph, <, N, ,, E, >, graph, ), {, this, (, graph, ,]
[public, GreedyGraphColoring, (, AdjacencyGraph, <, N, ,, E, >, graph, ,, Comparator, <, N, >, tieBreaker, ), {, super, (]
[AdjacencyGraph, <, N, ,, E, >, graph, ,, Comparator, <, N, >, tieBreaker, ), {, super, (, graph, ), ;]
[AdjacencyGraph, <, N, ,, E, >, graph, ,, Comparator, <, N, >, tieBreaker, ), {, super, (, graph, ), ;]
[E, >, graph, ,, Comparator, <, N, >, tieBreaker, ), {, super, (, graph, ), ;, this, ., tieBreaker, =]
[super, (, graph, ), ;, this, ., tieBreaker, =, tieBreaker, ;, }, @, Override, public, int, color, (, ), {]
[super, (, graph, ), ;, this, ., tieBreaker, =, tieBreaker, ;, }, @, Override, public, int, color, (, ), {]
[(, ), {, graph, ., clearNodeAnnotations, (, ), ;, List, <, GraphNode, <, N, ,, E, >, >, worklist, =]
[(, ), {, graph, ., clearNodeAnnotations, (, ), ;, List, <, GraphNode, <, N, ,, E, >, >, worklist, =]
[., clearNodeAnnotations, (, ), ;, List, <, GraphNode, <, N, ,, E, >, >, worklist, =, Lists, ., newArrayList, (]
[., clearNodeAnnotations, (, ), ;, List, <, GraphNode, <, N, ,, E, >, >, worklist, =, Lists, ., newArrayList, (]
[GraphNode, <, N, ,, E, >, >, worklist, =, Lists, ., newArrayList, (, graph, ., getNodes, (, ), ), ;]
[GraphNode, <, N, ,, E, >, >, worklist, =, Lists, ., newArrayList, (, graph, ., getNodes, (, ), ), ;]
[E, >, >, worklist, =, Lists, ., newArrayList, (, graph, ., getNodes, (, ), ), ;, Collections, ., sort, (]
[>, worklist, =, Lists, ., newArrayList, (, graph, ., getNodes, (, ), ), ;, Collections, ., sort, (, worklist, ,]
[GraphNode, <, N, ,, E, >, o1, ,, GraphNode, <, N, ,, E, >, o2, ), {, int, result, =]
[GraphNode, <, N, ,, E, >, o1, ,, GraphNode, <, N, ,, E, >, o2, ), {, int, result, =]
[GraphNode, <, N, ,, E, >, o1, ,, GraphNode, <, N, ,, E, >, o2, ), {, int, result, =]
[E, >, o1, ,, GraphNode, <, N, ,, E, >, o2, ), {, int, result, =, graph, ., getWeight, (]
[E, >, o1, ,, GraphNode, <, N, ,, E, >, o2, ), {, int, result, =, graph, ., getWeight, (]
[,, E, >, o2, ), {, int, result, =, graph, ., getWeight, (, o2, ., getValue, (, ), ), -]
[,, E, >, o2, ), {, int, result, =, graph, ., getWeight, (, o2, ., getValue, (, ), ), -]
[), {, int, result, =, graph, ., getWeight, (, o2, ., getValue, (, ), ), -, graph, ., getWeight, (]
[), {, int, result, =, graph, ., getWeight, (, o2, ., getValue, (, ), ), -, graph, ., getWeight, (]
[(, o2, ., getValue, (, ), ), -, graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return]
[(, o2, ., getValue, (, ), ), -, graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return]
[(, o2, ., getValue, (, ), ), -, graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return]
[(, o2, ., getValue, (, ), ), -, graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return]
[., getValue, (, ), ), -, graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return, result, ==]
[(, ), ), -, graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return, result, ==, 0, &&]
[(, ), ), -, graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return, result, ==, 0, &&]
[), -, graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return, result, ==, 0, &&, tieBreaker, !=]
[graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return, result, ==, 0, &&, tieBreaker, !=, null, ?]
[graph, ., getWeight, (, o1, ., getValue, (, ), ), ;, return, result, ==, 0, &&, tieBreaker, !=, null, ?]
[o1, ., getValue, (, ), ), ;, return, result, ==, 0, &&, tieBreaker, !=, null, ?, tieBreaker, ., compare, (]
[o1, ., getValue, (, ), ), ;, return, result, ==, 0, &&, tieBreaker, !=, null, ?, tieBreaker, ., compare, (]
[;, return, result, ==, 0, &&, tieBreaker, !=, null, ?, tieBreaker, ., compare, (, o1, ., getValue, (, ), ,]
[;, return, result, ==, 0, &&, tieBreaker, !=, null, ?, tieBreaker, ., compare, (, o1, ., getValue, (, ), ,]
[!=, null, ?, tieBreaker, ., compare, (, o1, ., getValue, (, ), ,, o2, ., getValue, (, ), ), :]
[getValue, (, ), ,, o2, ., getValue, (, ), ), :, result, ;, }, }, ), ;, int, count, =]
[(, ), ), :, result, ;, }, }, ), ;, int, count, =, 0, ;, do, {, Color, color, =]
[:, result, ;, }, }, ), ;, int, count, =, 0, ;, do, {, Color, color, =, new, Color, (]
[;, do, {, Color, color, =, new, Color, (, count, ), ;, SubGraph, <, N, ,, E, >, subgraph, =]
[;, do, {, Color, color, =, new, Color, (, count, ), ;, SubGraph, <, N, ,, E, >, subgraph, =]
[=, graph, ., newSubGraph, (, ), ;, for, (, Iterator, <, GraphNode, <, N, ,, E, >, >, i, =]
[=, graph, ., newSubGraph, (, ), ;, for, (, Iterator, <, GraphNode, <, N, ,, E, >, >, i, =]
[;, for, (, Iterator, <, GraphNode, <, N, ,, E, >, >, i, =, worklist, ., iterator, (, ), ;]
[;, for, (, Iterator, <, GraphNode, <, N, ,, E, >, >, i, =, worklist, ., iterator, (, ), ;]
[iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, GraphNode, <, N, ,, E, >, node, =]
[iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, GraphNode, <, N, ,, E, >, node, =]
[), ;, ), {, GraphNode, <, N, ,, E, >, node, =, i, ., next, (, ), ;, if, (]
[), ;, ), {, GraphNode, <, N, ,, E, >, node, =, i, ., next, (, ), ;, if, (]
[GraphNode, <, N, ,, E, >, node, =, i, ., next, (, ), ;, if, (, subgraph, ., isIndependentOf, (]
[GraphNode, <, N, ,, E, >, node, =, i, ., next, (, ), ;, if, (, subgraph, ., isIndependentOf, (]
[i, ., next, (, ), ;, if, (, subgraph, ., isIndependentOf, (, node, ., getValue, (, ), ), ), {]
[i, ., next, (, ), ;, if, (, subgraph, ., isIndependentOf, (, node, ., getValue, (, ), ), ), {]
[), ;, if, (, subgraph, ., isIndependentOf, (, node, ., getValue, (, ), ), ), {, subgraph, ., addNode, (]
[), ;, if, (, subgraph, ., isIndependentOf, (, node, ., getValue, (, ), ), ), {, subgraph, ., addNode, (]
[(, node, ., getValue, (, ), ), ), {, subgraph, ., addNode, (, node, ., getValue, (, ), ), ;]
[(, node, ., getValue, (, ), ), ), {, subgraph, ., addNode, (, node, ., getValue, (, ), ), ;]
[(, ), ), ), {, subgraph, ., addNode, (, node, ., getValue, (, ), ), ;, node, ., setAnnotation, (]
[), {, subgraph, ., addNode, (, node, ., getValue, (, ), ), ;, node, ., setAnnotation, (, color, ), ;]
[), {, subgraph, ., addNode, (, node, ., getValue, (, ), ), ;, node, ., setAnnotation, (, color, ), ;]
[getValue, (, ), ), ;, node, ., setAnnotation, (, color, ), ;, i, ., remove, (, ), ;, }, }]
[getValue, (, ), ), ;, node, ., setAnnotation, (, color, ), ;, i, ., remove, (, ), ;, }, }]
[., setAnnotation, (, color, ), ;, i, ., remove, (, ), ;, }, }, count, ++, ;, }, while, (]
[setAnnotation, (, color, ), ;, i, ., remove, (, ), ;, }, }, count, ++, ;, }, while, (, !]
[setAnnotation, (, color, ), ;, i, ., remove, (, ), ;, }, }, count, ++, ;, }, while, (, !]
[remove, (, ), ;, }, }, count, ++, ;, }, while, (, !, worklist, ., isEmpty, (, ), ), ;]
[;, }, }, count, ++, ;, }, while, (, !, worklist, ., isEmpty, (, ), ), ;, @, SuppressWarnings, (]
[while, (, !, worklist, ., isEmpty, (, ), ), ;, @, SuppressWarnings, (, "unchecked", ), N, [, ], map, =]
[isEmpty, (, ), ), ;, @, SuppressWarnings, (, "unchecked", ), N, [, ], map, =, (, N, [, ], )]
[), ;, @, SuppressWarnings, (, "unchecked", ), N, [, ], map, =, (, N, [, ], ), new, Object, []
[SuppressWarnings, (, "unchecked", ), N, [, ], map, =, (, N, [, ], ), new, Object, [, count, ], ;]
["unchecked", ), N, [, ], map, =, (, N, [, ], ), new, Object, [, count, ], ;, colorToNodeMap, =]
[[, ], map, =, (, N, [, ], ), new, Object, [, count, ], ;, colorToNodeMap, =, map, ;, return]
