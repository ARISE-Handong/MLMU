[ScopedCallback, {, private, final, AbstractCompiler, compiler, ;, private, LiveVariablesAnalysis, liveness, ;, private, static, final, Predicate, <, Node, >, matchRemovableAssigns, =]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return, (]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return, (]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return, (]
[>, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return, (, NodeUtil, ., isAssignmentOp, (]
[{, @, Override, public, boolean, apply, (, Node, n, ), {, return, (, NodeUtil, ., isAssignmentOp, (, n, ), &&]
[{, @, Override, public, boolean, apply, (, Node, n, ), {, return, (, NodeUtil, ., isAssignmentOp, (, n, ), &&]
[{, @, Override, public, boolean, apply, (, Node, n, ), {, return, (, NodeUtil, ., isAssignmentOp, (, n, ), &&]
[return, (, NodeUtil, ., isAssignmentOp, (, n, ), &&, n, ., getFirstChild, (, ), ., isName, (, ), ), ||]
[return, (, NodeUtil, ., isAssignmentOp, (, n, ), &&, n, ., getFirstChild, (, ), ., isName, (, ), ), ||]
[n, ), &&, n, ., getFirstChild, (, ), ., isName, (, ), ), ||, n, ., isInc, (, ), ||]
[n, ), &&, n, ., getFirstChild, (, ), ., isName, (, ), ), ||, n, ., isInc, (, ), ||]
[isInc, (, ), ||, n, ., isDec, (, ), ;, }, }, ;, public, DeadAssignmentsElimination, (, AbstractCompiler, compiler, ), {]
[isInc, (, ), ||, n, ., isDec, (, ), ;, }, }, ;, public, DeadAssignmentsElimination, (, AbstractCompiler, compiler, ), {]
[n, ., isDec, (, ), ;, }, }, ;, public, DeadAssignmentsElimination, (, AbstractCompiler, compiler, ), {, this, ., compiler, =]
[this, ., compiler, =, compiler, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[this, ., compiler, =, compiler, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[compiler, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, Preconditions, ., checkNotNull, (]
[@, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, Preconditions, ., checkNotNull, (, externs, ), ;]
[@, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, Preconditions, ., checkNotNull, (, externs, ), ;]
[process, (, Node, externs, ,, Node, root, ), {, Preconditions, ., checkNotNull, (, externs, ), ;, Preconditions, ., checkNotNull, (]
[externs, ,, Node, root, ), {, Preconditions, ., checkNotNull, (, externs, ), ;, Preconditions, ., checkNotNull, (, root, ), ;]
[externs, ,, Node, root, ), {, Preconditions, ., checkNotNull, (, externs, ), ;, Preconditions, ., checkNotNull, (, root, ), ;]
[), {, Preconditions, ., checkNotNull, (, externs, ), ;, Preconditions, ., checkNotNull, (, root, ), ;, NodeTraversal, ., traverse, (]
[Preconditions, ., checkNotNull, (, externs, ), ;, Preconditions, ., checkNotNull, (, root, ), ;, NodeTraversal, ., traverse, (, compiler, ,]
[checkNotNull, (, externs, ), ;, Preconditions, ., checkNotNull, (, root, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[,, root, ,, this, ), ;, }, @, Override, public, void, enterScope, (, NodeTraversal, t, ), {, Scope, scope, =]
[,, root, ,, this, ), ;, }, @, Override, public, void, enterScope, (, NodeTraversal, t, ), {, Scope, scope, =]
[Override, public, void, enterScope, (, NodeTraversal, t, ), {, Scope, scope, =, t, ., getScope, (, ), ;, if, (]
[Override, public, void, enterScope, (, NodeTraversal, t, ), {, Scope, scope, =, t, ., getScope, (, ), ;, if, (]
[t, ., getScope, (, ), ;, if, (, scope, ., isGlobal, (, ), ), {, return, ;, }, if, (]
[t, ., getScope, (, ), ;, if, (, scope, ., isGlobal, (, ), ), {, return, ;, }, if, (]
[t, ., getScope, (, ), ;, if, (, scope, ., isGlobal, (, ), ), {, return, ;, }, if, (]
[), ;, if, (, scope, ., isGlobal, (, ), ), {, return, ;, }, if, (, LiveVariablesAnalysis, ., MAX_VARIABLES_TO_ANALYZE, <]
[), ;, if, (, scope, ., isGlobal, (, ), ), {, return, ;, }, if, (, LiveVariablesAnalysis, ., MAX_VARIABLES_TO_ANALYZE, <]
[), ;, if, (, scope, ., isGlobal, (, ), ), {, return, ;, }, if, (, LiveVariablesAnalysis, ., MAX_VARIABLES_TO_ANALYZE, <]
[., MAX_VARIABLES_TO_ANALYZE, <, t, ., getScope, (, ), ., getVarCount, (, ), ), {, return, ;, }, Node, fnBlock, =]
[., MAX_VARIABLES_TO_ANALYZE, <, t, ., getScope, (, ), ., getVarCount, (, ), ), {, return, ;, }, Node, fnBlock, =]
[., MAX_VARIABLES_TO_ANALYZE, <, t, ., getScope, (, ), ., getVarCount, (, ), ), {, return, ;, }, Node, fnBlock, =]
[), {, return, ;, }, Node, fnBlock, =, t, ., getScopeRoot, (, ), ., getLastChild, (, ), ;, if, (]
[), {, return, ;, }, Node, fnBlock, =, t, ., getScopeRoot, (, ), ., getLastChild, (, ), ;, if, (]
[}, Node, fnBlock, =, t, ., getScopeRoot, (, ), ., getLastChild, (, ), ;, if, (, NodeUtil, ., containsFunction, (]
[., getLastChild, (, ), ;, if, (, NodeUtil, ., containsFunction, (, fnBlock, ), ), {, return, ;, }, if, (]
[getLastChild, (, ), ;, if, (, NodeUtil, ., containsFunction, (, fnBlock, ), ), {, return, ;, }, if, (, !]
[getLastChild, (, ), ;, if, (, NodeUtil, ., containsFunction, (, fnBlock, ), ), {, return, ;, }, if, (, !]
[if, (, NodeUtil, ., containsFunction, (, fnBlock, ), ), {, return, ;, }, if, (, !, NodeUtil, ., has, (]
[NodeUtil, ., containsFunction, (, fnBlock, ), ), {, return, ;, }, if, (, !, NodeUtil, ., has, (, fnBlock, ,]
[containsFunction, (, fnBlock, ), ), {, return, ;, }, if, (, !, NodeUtil, ., has, (, fnBlock, ,, matchRemovableAssigns, ,]
[containsFunction, (, fnBlock, ), ), {, return, ;, }, if, (, !, NodeUtil, ., has, (, fnBlock, ,, matchRemovableAssigns, ,]
[Predicates, ., <, Node, >, alwaysTrue, (, ), ), ), {, return, ;, }, ControlFlowGraph, <, Node, >, cfg, =]
[Predicates, ., <, Node, >, alwaysTrue, (, ), ), ), {, return, ;, }, ControlFlowGraph, <, Node, >, cfg, =]
[(, ), ), ), {, return, ;, }, ControlFlowGraph, <, Node, >, cfg, =, t, ., getControlFlowGraph, (, ), ;]
[), ), {, return, ;, }, ControlFlowGraph, <, Node, >, cfg, =, t, ., getControlFlowGraph, (, ), ;, liveness, =]
[return, ;, }, ControlFlowGraph, <, Node, >, cfg, =, t, ., getControlFlowGraph, (, ), ;, liveness, =, new, LiveVariablesAnalysis, (]
[}, ControlFlowGraph, <, Node, >, cfg, =, t, ., getControlFlowGraph, (, ), ;, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,]
[<, Node, >, cfg, =, t, ., getControlFlowGraph, (, ), ;, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,]
[cfg, =, t, ., getControlFlowGraph, (, ), ;, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;]
[cfg, =, t, ., getControlFlowGraph, (, ), ;, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;]
[), ;, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;, liveness, ., analyze, (, ), ;]
[liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;, liveness, ., analyze, (, ), ;, tryRemoveDeadAssignments, (]
[new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;, liveness, ., analyze, (, ), ;, tryRemoveDeadAssignments, (, t, ,]
[t, ,, ControlFlowGraph, <, Node, >, cfg, ), {, Iterable, <, DiGraphNode, <, Node, ,, Branch, >, >, nodes, =]
[t, ,, ControlFlowGraph, <, Node, >, cfg, ), {, Iterable, <, DiGraphNode, <, Node, ,, Branch, >, >, nodes, =]
[>, >, nodes, =, cfg, ., getDirectedGraphNodes, (, ), ;, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :]
[;, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :, nodes, ), {, FlowState, <, LiveVariableLattice, >, state, =]
[;, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :, nodes, ), {, FlowState, <, LiveVariableLattice, >, state, =]
[cfgNode, :, nodes, ), {, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, Node, n, =]
[cfgNode, :, nodes, ), {, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, Node, n, =]
[>, state, =, cfgNode, ., getAnnotation, (, ), ;, Node, n, =, cfgNode, ., getValue, (, ), ;, if, (]
[>, state, =, cfgNode, ., getAnnotation, (, ), ;, Node, n, =, cfgNode, ., getValue, (, ), ;, if, (]
[=, cfgNode, ., getAnnotation, (, ), ;, Node, n, =, cfgNode, ., getValue, (, ), ;, if, (, n, ==]
[n, =, cfgNode, ., getValue, (, ), ;, if, (, n, ==, null, ), {, continue, ;, }, switch, (]
[n, =, cfgNode, ., getValue, (, ), ;, if, (, n, ==, null, ), {, continue, ;, }, switch, (]
[if, (, n, ==, null, ), {, continue, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[if, (, n, ==, null, ), {, continue, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[), {, continue, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[), {, continue, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., WHILE, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., WHILE, :, case]
[getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., DO, :]
[), ), {, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., DO, :, tryRemoveAssignment, (]
[{, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., DO, :, tryRemoveAssignment, (, t, ,]
[{, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., DO, :, tryRemoveAssignment, (, t, ,]
[IF, :, case, Token, ., WHILE, :, case, Token, ., DO, :, tryRemoveAssignment, (, t, ,, NodeUtil, ., getConditionExpression, (]
[Token, ., WHILE, :, case, Token, ., DO, :, tryRemoveAssignment, (, t, ,, NodeUtil, ., getConditionExpression, (, n, ), ,]
[., DO, :, tryRemoveAssignment, (, t, ,, NodeUtil, ., getConditionExpression, (, n, ), ,, state, ), ;, continue, ;, case]
[., DO, :, tryRemoveAssignment, (, t, ,, NodeUtil, ., getConditionExpression, (, n, ), ,, state, ), ;, continue, ;, case]
[,, NodeUtil, ., getConditionExpression, (, n, ), ,, state, ), ;, continue, ;, case, Token, ., FOR, :, if, (]
[NodeUtil, ., getConditionExpression, (, n, ), ,, state, ), ;, continue, ;, case, Token, ., FOR, :, if, (, !]
[NodeUtil, ., getConditionExpression, (, n, ), ,, state, ), ;, continue, ;, case, Token, ., FOR, :, if, (, !]
[n, ), ,, state, ), ;, continue, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (]
[), ;, continue, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, n, ), ), {]
[continue, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, n, ), ), {, tryRemoveAssignment, (]
[case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, n, ), ), {, tryRemoveAssignment, (, t, ,]
[case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, n, ), ), {, tryRemoveAssignment, (, t, ,]
[:, if, (, !, NodeUtil, ., isForIn, (, n, ), ), {, tryRemoveAssignment, (, t, ,, NodeUtil, ., getConditionExpression, (]
[!, NodeUtil, ., isForIn, (, n, ), ), {, tryRemoveAssignment, (, t, ,, NodeUtil, ., getConditionExpression, (, n, ), ,]
[), {, tryRemoveAssignment, (, t, ,, NodeUtil, ., getConditionExpression, (, n, ), ,, state, ), ;, }, continue, ;, case]
[), {, tryRemoveAssignment, (, t, ,, NodeUtil, ., getConditionExpression, (, n, ), ,, state, ), ;, }, continue, ;, case]
[,, NodeUtil, ., getConditionExpression, (, n, ), ,, state, ), ;, }, continue, ;, case, Token, ., SWITCH, :, case]
[,, NodeUtil, ., getConditionExpression, (, n, ), ,, state, ), ;, }, continue, ;, case, Token, ., SWITCH, :, case]
[n, ), ,, state, ), ;, }, continue, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case]
[n, ), ,, state, ), ;, }, continue, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case]
[}, continue, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., RETURN, :, if, (]
[}, continue, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., RETURN, :, if, (]
[:, case, Token, ., CASE, :, case, Token, ., RETURN, :, if, (, n, ., hasChildren, (, ), ), {]
[Token, ., CASE, :, case, Token, ., RETURN, :, if, (, n, ., hasChildren, (, ), ), {, tryRemoveAssignment, (]
[CASE, :, case, Token, ., RETURN, :, if, (, n, ., hasChildren, (, ), ), {, tryRemoveAssignment, (, t, ,]
[CASE, :, case, Token, ., RETURN, :, if, (, n, ., hasChildren, (, ), ), {, tryRemoveAssignment, (, t, ,]
[:, if, (, n, ., hasChildren, (, ), ), {, tryRemoveAssignment, (, t, ,, n, ., getFirstChild, (, ), ,]
[), ), {, tryRemoveAssignment, (, t, ,, n, ., getFirstChild, (, ), ,, state, ), ;, }, continue, ;, }]
[{, tryRemoveAssignment, (, t, ,, n, ., getFirstChild, (, ), ,, state, ), ;, }, continue, ;, }, tryRemoveAssignment, (]
[(, t, ,, n, ., getFirstChild, (, ), ,, state, ), ;, }, continue, ;, }, tryRemoveAssignment, (, t, ,]
[,, n, ., getFirstChild, (, ), ,, state, ), ;, }, continue, ;, }, tryRemoveAssignment, (, t, ,, n, ,]
[;, }, }, private, void, tryRemoveAssignment, (, NodeTraversal, t, ,, Node, n, ,, FlowState, <, LiveVariableLattice, >, state, ), {]
[}, private, void, tryRemoveAssignment, (, NodeTraversal, t, ,, Node, n, ,, FlowState, <, LiveVariableLattice, >, state, ), {, tryRemoveAssignment, (]
[void, tryRemoveAssignment, (, NodeTraversal, t, ,, Node, n, ,, FlowState, <, LiveVariableLattice, >, state, ), {, tryRemoveAssignment, (, t, ,]
[(, NodeTraversal, t, ,, Node, n, ,, FlowState, <, LiveVariableLattice, >, state, ), {, tryRemoveAssignment, (, t, ,, n, ,]
[t, ,, Node, n, ,, FlowState, <, LiveVariableLattice, >, state, ), {, tryRemoveAssignment, (, t, ,, n, ,, n, ,]
[(, NodeTraversal, t, ,, Node, n, ,, Node, exprRoot, ,, FlowState, <, LiveVariableLattice, >, state, ), {, Node, parent, =]
[(, NodeTraversal, t, ,, Node, n, ,, Node, exprRoot, ,, FlowState, <, LiveVariableLattice, >, state, ), {, Node, parent, =]
[exprRoot, ,, FlowState, <, LiveVariableLattice, >, state, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[exprRoot, ,, FlowState, <, LiveVariableLattice, >, state, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[exprRoot, ,, FlowState, <, LiveVariableLattice, >, state, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[exprRoot, ,, FlowState, <, LiveVariableLattice, >, state, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[LiveVariableLattice, >, state, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, NodeUtil, ., isAssignmentOp, (]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, NodeUtil, ., isAssignmentOp, (, n, ), ||]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, NodeUtil, ., isAssignmentOp, (, n, ), ||]
[., getParent, (, ), ;, if, (, NodeUtil, ., isAssignmentOp, (, n, ), ||, n, ., isInc, (, ), ||]
[., getParent, (, ), ;, if, (, NodeUtil, ., isAssignmentOp, (, n, ), ||, n, ., isInc, (, ), ||]
[(, n, ), ||, n, ., isInc, (, ), ||, n, ., isDec, (, ), ), {, Node, lhs, =]
[(, n, ), ||, n, ., isInc, (, ), ||, n, ., isDec, (, ), ), {, Node, lhs, =]
[||, n, ., isDec, (, ), ), {, Node, lhs, =, n, ., getFirstChild, (, ), ;, Node, rhs, =]
[||, n, ., isDec, (, ), ), {, Node, lhs, =, n, ., getFirstChild, (, ), ;, Node, rhs, =]
[Node, lhs, =, n, ., getFirstChild, (, ), ;, Node, rhs, =, lhs, ., getNext, (, ), ;, if, (]
[Node, lhs, =, n, ., getFirstChild, (, ), ;, Node, rhs, =, lhs, ., getNext, (, ), ;, if, (]
[=, n, ., getFirstChild, (, ), ;, Node, rhs, =, lhs, ., getNext, (, ), ;, if, (, rhs, !=]
[getFirstChild, (, ), ;, Node, rhs, =, lhs, ., getNext, (, ), ;, if, (, rhs, !=, null, ), {]
[), ;, Node, rhs, =, lhs, ., getNext, (, ), ;, if, (, rhs, !=, null, ), {, tryRemoveAssignment, (]
[Node, rhs, =, lhs, ., getNext, (, ), ;, if, (, rhs, !=, null, ), {, tryRemoveAssignment, (, t, ,]
[=, lhs, ., getNext, (, ), ;, if, (, rhs, !=, null, ), {, tryRemoveAssignment, (, t, ,, rhs, ,]
[., getNext, (, ), ;, if, (, rhs, !=, null, ), {, tryRemoveAssignment, (, t, ,, rhs, ,, exprRoot, ,]
[), ;, if, (, rhs, !=, null, ), {, tryRemoveAssignment, (, t, ,, rhs, ,, exprRoot, ,, state, ), ;]
[if, (, rhs, !=, null, ), {, tryRemoveAssignment, (, t, ,, rhs, ,, exprRoot, ,, state, ), ;, rhs, =]
[if, (, rhs, !=, null, ), {, tryRemoveAssignment, (, t, ,, rhs, ,, exprRoot, ,, state, ), ;, rhs, =]
[,, rhs, ,, exprRoot, ,, state, ), ;, rhs, =, lhs, ., getNext, (, ), ;, }, Scope, scope, =]
[,, rhs, ,, exprRoot, ,, state, ), ;, rhs, =, lhs, ., getNext, (, ), ;, }, Scope, scope, =]
[rhs, =, lhs, ., getNext, (, ), ;, }, Scope, scope, =, t, ., getScope, (, ), ;, if, (]
[=, lhs, ., getNext, (, ), ;, }, Scope, scope, =, t, ., getScope, (, ), ;, if, (, !]
[=, lhs, ., getNext, (, ), ;, }, Scope, scope, =, t, ., getScope, (, ), ;, if, (, !]
[getScope, (, ), ;, if, (, !, lhs, ., isName, (, ), ), {, return, ;, }, String, name, =]
[getScope, (, ), ;, if, (, !, lhs, ., isName, (, ), ), {, return, ;, }, String, name, =]
[., isName, (, ), ), {, return, ;, }, String, name, =, lhs, ., getString, (, ), ;, if, (]
[isName, (, ), ), {, return, ;, }, String, name, =, lhs, ., getString, (, ), ;, if, (, !]
[isName, (, ), ), {, return, ;, }, String, name, =, lhs, ., getString, (, ), ;, if, (, !]
[{, return, ;, }, String, name, =, lhs, ., getString, (, ), ;, if, (, !, scope, ., isDeclared, (]
[;, }, String, name, =, lhs, ., getString, (, ), ;, if, (, !, scope, ., isDeclared, (, name, ,]
[;, if, (, !, scope, ., isDeclared, (, name, ,, false, ), ), {, return, ;, }, Var, var, =]
[;, if, (, !, scope, ., isDeclared, (, name, ,, false, ), ), {, return, ;, }, Var, var, =]
[scope, ., isDeclared, (, name, ,, false, ), ), {, return, ;, }, Var, var, =, scope, ., getVar, (]
[,, false, ), ), {, return, ;, }, Var, var, =, scope, ., getVar, (, name, ), ;, if, (]
[,, false, ), ), {, return, ;, }, Var, var, =, scope, ., getVar, (, name, ), ;, if, (]
[,, false, ), ), {, return, ;, }, Var, var, =, scope, ., getVar, (, name, ), ;, if, (]
[Var, var, =, scope, ., getVar, (, name, ), ;, if, (, liveness, ., getEscapedLocals, (, ), ., contains, (]
[;, if, (, liveness, ., getEscapedLocals, (, ), ., contains, (, var, ), ), {, return, ;, }, if, (]
[;, if, (, liveness, ., getEscapedLocals, (, ), ., contains, (, var, ), ), {, return, ;, }, if, (]
[;, if, (, liveness, ., getEscapedLocals, (, ), ., contains, (, var, ), ), {, return, ;, }, if, (]
[;, if, (, liveness, ., getEscapedLocals, (, ), ., contains, (, var, ), ), {, return, ;, }, if, (]
[;, if, (, liveness, ., getEscapedLocals, (, ), ., contains, (, var, ), ), {, return, ;, }, if, (]
[(, liveness, ., getEscapedLocals, (, ), ., contains, (, var, ), ), {, return, ;, }, if, (, rhs, !=]
[., getEscapedLocals, (, ), ., contains, (, var, ), ), {, return, ;, }, if, (, rhs, !=, null, &&]
[., getEscapedLocals, (, ), ., contains, (, var, ), ), {, return, ;, }, if, (, rhs, !=, null, &&]
[(, var, ), ), {, return, ;, }, if, (, rhs, !=, null, &&, rhs, ., isName, (, ), &&]
[(, var, ), ), {, return, ;, }, if, (, rhs, !=, null, &&, rhs, ., isName, (, ), &&]
[(, var, ), ), {, return, ;, }, if, (, rhs, !=, null, &&, rhs, ., isName, (, ), &&]
[if, (, rhs, !=, null, &&, rhs, ., isName, (, ), &&, rhs, ., getString, (, ), ., equals, (]
[if, (, rhs, !=, null, &&, rhs, ., isName, (, ), &&, rhs, ., getString, (, ), ., equals, (]
[&&, rhs, ., isName, (, ), &&, rhs, ., getString, (, ), ., equals, (, var, ., name, ), &&]
[&&, rhs, ., isName, (, ), &&, rhs, ., getString, (, ), ., equals, (, var, ., name, ), &&]
[rhs, ., getString, (, ), ., equals, (, var, ., name, ), &&, n, ., isAssign, (, ), ), {]
[rhs, ., getString, (, ), ., equals, (, var, ., name, ), &&, n, ., isAssign, (, ), ), {]
[), ., equals, (, var, ., name, ), &&, n, ., isAssign, (, ), ), {, n, ., removeChild, (]
[(, var, ., name, ), &&, n, ., isAssign, (, ), ), {, n, ., removeChild, (, rhs, ), ;]
[(, var, ., name, ), &&, n, ., isAssign, (, ), ), {, n, ., removeChild, (, rhs, ), ;]
[(, var, ., name, ), &&, n, ., isAssign, (, ), ), {, n, ., removeChild, (, rhs, ), ;]
[isAssign, (, ), ), {, n, ., removeChild, (, rhs, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ), {, n, ., removeChild, (, rhs, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[n, ., removeChild, (, rhs, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, rhs, ), ;]
[n, ., removeChild, (, rhs, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, rhs, ), ;]
[), ., replaceChild, (, n, ,, rhs, ), ;, compiler, ., reportCodeChange, (, ), ;, return, ;, }, if, (]
[), ., replaceChild, (, n, ,, rhs, ), ;, compiler, ., reportCodeChange, (, ), ;, return, ;, }, if, (]
[), ., replaceChild, (, n, ,, rhs, ), ;, compiler, ., reportCodeChange, (, ), ;, return, ;, }, if, (]
[;, compiler, ., reportCodeChange, (, ), ;, return, ;, }, if, (, state, ., getOut, (, ), ., isLive, (]
[}, if, (, state, ., getOut, (, ), ., isLive, (, var, ), ), {, return, ;, }, if, (]
[}, if, (, state, ., getOut, (, ), ., isLive, (, var, ), ), {, return, ;, }, if, (]
[}, if, (, state, ., getOut, (, ), ., isLive, (, var, ), ), {, return, ;, }, if, (]
[}, if, (, state, ., getOut, (, ), ., isLive, (, var, ), ), {, return, ;, }, if, (]
[., isLive, (, var, ), ), {, return, ;, }, if, (, state, ., getIn, (, ), ., isLive, (]
[var, ), ), {, return, ;, }, if, (, state, ., getIn, (, ), ., isLive, (, var, ), &&]
[), {, return, ;, }, if, (, state, ., getIn, (, ), ., isLive, (, var, ), &&, isVariableStillLiveWithinExpression, (]
[return, ;, }, if, (, state, ., getIn, (, ), ., isLive, (, var, ), &&, isVariableStillLiveWithinExpression, (, n, ,]
[}, if, (, state, ., getIn, (, ), ., isLive, (, var, ), &&, isVariableStillLiveWithinExpression, (, n, ,, exprRoot, ,]
[}, if, (, state, ., getIn, (, ), ., isLive, (, var, ), &&, isVariableStillLiveWithinExpression, (, n, ,, exprRoot, ,]
[var, ), &&, isVariableStillLiveWithinExpression, (, n, ,, exprRoot, ,, var, ., name, ), ), {, return, ;, }, if, (]
[var, ), &&, isVariableStillLiveWithinExpression, (, n, ,, exprRoot, ,, var, ., name, ), ), {, return, ;, }, if, (]
[exprRoot, ,, var, ., name, ), ), {, return, ;, }, if, (, n, ., isAssign, (, ), ), {]
[exprRoot, ,, var, ., name, ), ), {, return, ;, }, if, (, n, ., isAssign, (, ), ), {]
[name, ), ), {, return, ;, }, if, (, n, ., isAssign, (, ), ), {, n, ., removeChild, (]
[{, return, ;, }, if, (, n, ., isAssign, (, ), ), {, n, ., removeChild, (, rhs, ), ;]
[{, return, ;, }, if, (, n, ., isAssign, (, ), ), {, n, ., removeChild, (, rhs, ), ;]
[{, return, ;, }, if, (, n, ., isAssign, (, ), ), {, n, ., removeChild, (, rhs, ), ;]
[isAssign, (, ), ), {, n, ., removeChild, (, rhs, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ), {, n, ., removeChild, (, rhs, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[rhs, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, rhs, ), ;, }, else, if, (]
[rhs, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, rhs, ), ;, }, else, if, (]
[., getParent, (, ), ., replaceChild, (, n, ,, rhs, ), ;, }, else, if, (, NodeUtil, ., isAssignmentOp, (]
[., replaceChild, (, n, ,, rhs, ), ;, }, else, if, (, NodeUtil, ., isAssignmentOp, (, n, ), ), {]
[., replaceChild, (, n, ,, rhs, ), ;, }, else, if, (, NodeUtil, ., isAssignmentOp, (, n, ), ), {]
[,, rhs, ), ;, }, else, if, (, NodeUtil, ., isAssignmentOp, (, n, ), ), {, n, ., removeChild, (]
[;, }, else, if, (, NodeUtil, ., isAssignmentOp, (, n, ), ), {, n, ., removeChild, (, rhs, ), ;]
[;, }, else, if, (, NodeUtil, ., isAssignmentOp, (, n, ), ), {, n, ., removeChild, (, rhs, ), ;]
[(, NodeUtil, ., isAssignmentOp, (, n, ), ), {, n, ., removeChild, (, rhs, ), ;, n, ., removeChild, (]
[), ), {, n, ., removeChild, (, rhs, ), ;, n, ., removeChild, (, lhs, ), ;, Node, op, =]
[n, ., removeChild, (, rhs, ), ;, n, ., removeChild, (, lhs, ), ;, Node, op, =, new, Node, (]
[n, ., removeChild, (, rhs, ), ;, n, ., removeChild, (, lhs, ), ;, Node, op, =, new, Node, (]
[rhs, ), ;, n, ., removeChild, (, lhs, ), ;, Node, op, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (]
[n, ., removeChild, (, lhs, ), ;, Node, op, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ,]
[removeChild, (, lhs, ), ;, Node, op, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ,, lhs, ,]
[), ;, Node, op, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ,, lhs, ,, rhs, ), ;]
[), ;, Node, op, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ,, lhs, ,, rhs, ), ;]
[=, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ,, lhs, ,, rhs, ), ;, parent, ., replaceChild, (]
[Node, (, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ,, lhs, ,, rhs, ), ;, parent, ., replaceChild, (, n, ,]
[), ,, lhs, ,, rhs, ), ;, parent, ., replaceChild, (, n, ,, op, ), ;, }, else, if, (]
[), ,, lhs, ,, rhs, ), ;, parent, ., replaceChild, (, n, ,, op, ), ;, }, else, if, (]
[), ,, lhs, ,, rhs, ), ;, parent, ., replaceChild, (, n, ,, op, ), ;, }, else, if, (]
[;, parent, ., replaceChild, (, n, ,, op, ), ;, }, else, if, (, n, ., isInc, (, ), ||]
[;, parent, ., replaceChild, (, n, ,, op, ), ;, }, else, if, (, n, ., isInc, (, ), ||]
[;, }, else, if, (, n, ., isInc, (, ), ||, n, ., isDec, (, ), ), {, if, (]
[;, }, else, if, (, n, ., isInc, (, ), ||, n, ., isDec, (, ), ), {, if, (]
[isInc, (, ), ||, n, ., isDec, (, ), ), {, if, (, parent, ., isExprResult, (, ), ), {]
[isInc, (, ), ||, n, ., isDec, (, ), ), {, if, (, parent, ., isExprResult, (, ), ), {]
[n, ., isDec, (, ), ), {, if, (, parent, ., isExprResult, (, ), ), {, parent, ., replaceChild, (]
[isDec, (, ), ), {, if, (, parent, ., isExprResult, (, ), ), {, parent, ., replaceChild, (, n, ,]
[isDec, (, ), ), {, if, (, parent, ., isExprResult, (, ), ), {, parent, ., replaceChild, (, n, ,]
[{, if, (, parent, ., isExprResult, (, ), ), {, parent, ., replaceChild, (, n, ,, IR, ., voidNode, (]
[{, if, (, parent, ., isExprResult, (, ), ), {, parent, ., replaceChild, (, n, ,, IR, ., voidNode, (]
[{, if, (, parent, ., isExprResult, (, ), ), {, parent, ., replaceChild, (, n, ,, IR, ., voidNode, (]
[., isExprResult, (, ), ), {, parent, ., replaceChild, (, n, ,, IR, ., voidNode, (, IR, ., number, (]
[{, parent, ., replaceChild, (, n, ,, IR, ., voidNode, (, IR, ., number, (, 0, ), ., srcref, (]
[voidNode, (, IR, ., number, (, 0, ), ., srcref, (, n, ), ), ), ;, }, else, if, (]
[voidNode, (, IR, ., number, (, 0, ), ., srcref, (, n, ), ), ), ;, }, else, if, (]
[voidNode, (, IR, ., number, (, 0, ), ., srcref, (, n, ), ), ), ;, }, else, if, (]
[0, ), ., srcref, (, n, ), ), ), ;, }, else, if, (, n, ., isComma, (, ), &&]
[0, ), ., srcref, (, n, ), ), ), ;, }, else, if, (, n, ., isComma, (, ), &&]
[., srcref, (, n, ), ), ), ;, }, else, if, (, n, ., isComma, (, ), &&, n, !=]
[., srcref, (, n, ), ), ), ;, }, else, if, (, n, ., isComma, (, ), &&, n, !=]
[;, }, else, if, (, n, ., isComma, (, ), &&, n, !=, parent, ., getLastChild, (, ), ), {]
[;, }, else, if, (, n, ., isComma, (, ), &&, n, !=, parent, ., getLastChild, (, ), ), {]
[(, n, ., isComma, (, ), &&, n, !=, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (]
[n, !=, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, n, ), ;, }, else, if, (]
[n, !=, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, n, ), ;, }, else, if, (]
[n, !=, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, n, ), ;, }, else, if, (]
[n, !=, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, n, ), ;, }, else, if, (]
[), ), {, parent, ., removeChild, (, n, ), ;, }, else, if, (, parent, ., isFor, (, ), &&]
[), {, parent, ., removeChild, (, n, ), ;, }, else, if, (, parent, ., isFor, (, ), &&, !]
[), {, parent, ., removeChild, (, n, ), ;, }, else, if, (, parent, ., isFor, (, ), &&, !]
[removeChild, (, n, ), ;, }, else, if, (, parent, ., isFor, (, ), &&, !, NodeUtil, ., isForIn, (]
[), ;, }, else, if, (, parent, ., isFor, (, ), &&, !, NodeUtil, ., isForIn, (, parent, ), &&]
[), ;, }, else, if, (, parent, ., isFor, (, ), &&, !, NodeUtil, ., isForIn, (, parent, ), &&]
[), ;, }, else, if, (, parent, ., isFor, (, ), &&, !, NodeUtil, ., isForIn, (, parent, ), &&]
[if, (, parent, ., isFor, (, ), &&, !, NodeUtil, ., isForIn, (, parent, ), &&, NodeUtil, ., getConditionExpression, (]
[., isFor, (, ), &&, !, NodeUtil, ., isForIn, (, parent, ), &&, NodeUtil, ., getConditionExpression, (, parent, ), !=]
[), &&, !, NodeUtil, ., isForIn, (, parent, ), &&, NodeUtil, ., getConditionExpression, (, parent, ), !=, n, ), {]
[), &&, !, NodeUtil, ., isForIn, (, parent, ), &&, NodeUtil, ., getConditionExpression, (, parent, ), !=, n, ), {]
[., isForIn, (, parent, ), &&, NodeUtil, ., getConditionExpression, (, parent, ), !=, n, ), {, parent, ., replaceChild, (]
[(, parent, ), &&, NodeUtil, ., getConditionExpression, (, parent, ), !=, n, ), {, parent, ., replaceChild, (, n, ,]
[(, parent, ), &&, NodeUtil, ., getConditionExpression, (, parent, ), !=, n, ), {, parent, ., replaceChild, (, n, ,]
[replaceChild, (, n, ,, IR, ., empty, (, ), ), ;, }, else, {, return, ;, }, }, else, {]
[replaceChild, (, n, ,, IR, ., empty, (, ), ), ;, }, else, {, return, ;, }, }, else, {]
[IR, ., empty, (, ), ), ;, }, else, {, return, ;, }, }, else, {, Preconditions, ., checkState, (]
[empty, (, ), ), ;, }, else, {, return, ;, }, }, else, {, Preconditions, ., checkState, (, false, ,]
[;, }, else, {, return, ;, }, }, else, {, Preconditions, ., checkState, (, false, ,, "Unknown statement", ), ;, }]
[;, }, else, {, return, ;, }, }, else, {, Preconditions, ., checkState, (, false, ,, "Unknown statement", ), ;, }]
["Unknown statement", ), ;, }, compiler, ., reportCodeChange, (, ), ;, return, ;, }, else, {, for, (, Node, c, =]
["Unknown statement", ), ;, }, compiler, ., reportCodeChange, (, ), ;, return, ;, }, else, {, for, (, Node, c, =]
[reportCodeChange, (, ), ;, return, ;, }, else, {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[reportCodeChange, (, ), ;, return, ;, }, else, {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[), ;, return, ;, }, else, {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, ), {, Node, next, =]
[for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, ), {, Node, next, =]
[(, ), ;, c, !=, null, ;, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (]
[), ;, c, !=, null, ;, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (, !]
[), ;, c, !=, null, ;, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (, !]
[null, ;, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (]
[Node, next, =, c, ., getNext, (, ), ;, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), ), {]
[=, c, ., getNext, (, ), ;, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), ), {, tryRemoveAssignment, (]
[., getNext, (, ), ;, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), ), {, tryRemoveAssignment, (, t, ,]
[(, ), ;, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), ), {, tryRemoveAssignment, (, t, ,, c, ,]
[;, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), ), {, tryRemoveAssignment, (, t, ,, c, ,, exprRoot, ,]
[ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), ), {, tryRemoveAssignment, (, t, ,, c, ,, exprRoot, ,, state, ), ;, }]
[isEnteringNewCfgNode, (, c, ), ), {, tryRemoveAssignment, (, t, ,, c, ,, exprRoot, ,, state, ), ;, }, c, =]
[return, ;, }, }, private, boolean, isVariableStillLiveWithinExpression, (, Node, n, ,, Node, exprRoot, ,, String, variable, ), {, while, (]
[return, ;, }, }, private, boolean, isVariableStillLiveWithinExpression, (, Node, n, ,, Node, exprRoot, ,, String, variable, ), {, while, (]
[}, }, private, boolean, isVariableStillLiveWithinExpression, (, Node, n, ,, Node, exprRoot, ,, String, variable, ), {, while, (, n, !=]
[Node, n, ,, Node, exprRoot, ,, String, variable, ), {, while, (, n, !=, exprRoot, ), {, VariableLiveness, state, =]
[Node, n, ,, Node, exprRoot, ,, String, variable, ), {, while, (, n, !=, exprRoot, ), {, VariableLiveness, state, =]
[String, variable, ), {, while, (, n, !=, exprRoot, ), {, VariableLiveness, state, =, VariableLiveness, ., MAYBE_LIVE, ;, switch, (]
[String, variable, ), {, while, (, n, !=, exprRoot, ), {, VariableLiveness, state, =, VariableLiveness, ., MAYBE_LIVE, ;, switch, (]
[String, variable, ), {, while, (, n, !=, exprRoot, ), {, VariableLiveness, state, =, VariableLiveness, ., MAYBE_LIVE, ;, switch, (]
[state, =, VariableLiveness, ., MAYBE_LIVE, ;, switch, (, n, ., getParent, (, ), ., getType, (, ), ), {, case]
[state, =, VariableLiveness, ., MAYBE_LIVE, ;, switch, (, n, ., getParent, (, ), ., getType, (, ), ), {, case]
[;, switch, (, n, ., getParent, (, ), ., getType, (, ), ), {, case, Token, ., OR, :, case]
[;, switch, (, n, ., getParent, (, ), ., getType, (, ), ), {, case, Token, ., OR, :, case]
[(, ), ., getType, (, ), ), {, case, Token, ., OR, :, case, Token, ., AND, :, if, (]
[(, ), ., getType, (, ), ), {, case, Token, ., OR, :, case, Token, ., AND, :, if, (]
[(, ), ., getType, (, ), ), {, case, Token, ., OR, :, case, Token, ., AND, :, if, (]
[), {, case, Token, ., OR, :, case, Token, ., AND, :, if, (, n, ., getNext, (, ), !=]
[Token, ., OR, :, case, Token, ., AND, :, if, (, n, ., getNext, (, ), !=, null, ), {]
[OR, :, case, Token, ., AND, :, if, (, n, ., getNext, (, ), !=, null, ), {, state, =]
[case, Token, ., AND, :, if, (, n, ., getNext, (, ), !=, null, ), {, state, =, isVariableReadBeforeKill, (]
[case, Token, ., AND, :, if, (, n, ., getNext, (, ), !=, null, ), {, state, =, isVariableReadBeforeKill, (]
[(, n, ., getNext, (, ), !=, null, ), {, state, =, isVariableReadBeforeKill, (, n, ., getNext, (, ), ,]
[), !=, null, ), {, state, =, isVariableReadBeforeKill, (, n, ., getNext, (, ), ,, variable, ), ;, if, (]
[), !=, null, ), {, state, =, isVariableReadBeforeKill, (, n, ., getNext, (, ), ,, variable, ), ;, if, (]
[null, ), {, state, =, isVariableReadBeforeKill, (, n, ., getNext, (, ), ,, variable, ), ;, if, (, state, ==]
[null, ), {, state, =, isVariableReadBeforeKill, (, n, ., getNext, (, ), ,, variable, ), ;, if, (, state, ==]
[isVariableReadBeforeKill, (, n, ., getNext, (, ), ,, variable, ), ;, if, (, state, ==, VariableLiveness, ., KILL, ), {]
[n, ., getNext, (, ), ,, variable, ), ;, if, (, state, ==, VariableLiveness, ., KILL, ), {, state, =]
[n, ., getNext, (, ), ,, variable, ), ;, if, (, state, ==, VariableLiveness, ., KILL, ), {, state, =]
[if, (, state, ==, VariableLiveness, ., KILL, ), {, state, =, VariableLiveness, ., MAYBE_LIVE, ;, }, }, break, ;, case]
[if, (, state, ==, VariableLiveness, ., KILL, ), {, state, =, VariableLiveness, ., MAYBE_LIVE, ;, }, }, break, ;, case]
[KILL, ), {, state, =, VariableLiveness, ., MAYBE_LIVE, ;, }, }, break, ;, case, Token, ., HOOK, :, if, (]
[KILL, ), {, state, =, VariableLiveness, ., MAYBE_LIVE, ;, }, }, break, ;, case, Token, ., HOOK, :, if, (]
[KILL, ), {, state, =, VariableLiveness, ., MAYBE_LIVE, ;, }, }, break, ;, case, Token, ., HOOK, :, if, (]
[KILL, ), {, state, =, VariableLiveness, ., MAYBE_LIVE, ;, }, }, break, ;, case, Token, ., HOOK, :, if, (]
[., MAYBE_LIVE, ;, }, }, break, ;, case, Token, ., HOOK, :, if, (, n, ., getNext, (, ), !=]
[;, }, }, break, ;, case, Token, ., HOOK, :, if, (, n, ., getNext, (, ), !=, null, &&]
[;, }, }, break, ;, case, Token, ., HOOK, :, if, (, n, ., getNext, (, ), !=, null, &&]
[;, }, }, break, ;, case, Token, ., HOOK, :, if, (, n, ., getNext, (, ), !=, null, &&]
[;, }, }, break, ;, case, Token, ., HOOK, :, if, (, n, ., getNext, (, ), !=, null, &&]
[if, (, n, ., getNext, (, ), !=, null, &&, n, ., getNext, (, ), ., getNext, (, ), !=]
[., getNext, (, ), !=, null, &&, n, ., getNext, (, ), ., getNext, (, ), !=, null, ), {]
[(, ), !=, null, &&, n, ., getNext, (, ), ., getNext, (, ), !=, null, ), {, state, =]
[!=, null, &&, n, ., getNext, (, ), ., getNext, (, ), !=, null, ), {, state, =, checkHookBranchReadBeforeKill, (]
[!=, null, &&, n, ., getNext, (, ), ., getNext, (, ), !=, null, ), {, state, =, checkHookBranchReadBeforeKill, (]
[(, ), ., getNext, (, ), !=, null, ), {, state, =, checkHookBranchReadBeforeKill, (, n, ., getNext, (, ), ,]
[(, ), ., getNext, (, ), !=, null, ), {, state, =, checkHookBranchReadBeforeKill, (, n, ., getNext, (, ), ,]
[(, ), ., getNext, (, ), !=, null, ), {, state, =, checkHookBranchReadBeforeKill, (, n, ., getNext, (, ), ,]
[state, =, checkHookBranchReadBeforeKill, (, n, ., getNext, (, ), ,, n, ., getNext, (, ), ., getNext, (, ), ,]
[(, ), ., getNext, (, ), ,, variable, ), ;, }, break, ;, default, :, for, (, Node, sibling, =]
[(, ), ., getNext, (, ), ,, variable, ), ;, }, break, ;, default, :, for, (, Node, sibling, =]
[,, variable, ), ;, }, break, ;, default, :, for, (, Node, sibling, =, n, ., getNext, (, ), ;]
[,, variable, ), ;, }, break, ;, default, :, for, (, Node, sibling, =, n, ., getNext, (, ), ;]
[), ;, }, break, ;, default, :, for, (, Node, sibling, =, n, ., getNext, (, ), ;, sibling, !=]
[}, break, ;, default, :, for, (, Node, sibling, =, n, ., getNext, (, ), ;, sibling, !=, null, ;]
[;, default, :, for, (, Node, sibling, =, n, ., getNext, (, ), ;, sibling, !=, null, ;, sibling, =]
[;, default, :, for, (, Node, sibling, =, n, ., getNext, (, ), ;, sibling, !=, null, ;, sibling, =]
[=, n, ., getNext, (, ), ;, sibling, !=, null, ;, sibling, =, sibling, ., getNext, (, ), ), {]
[., getNext, (, ), ;, sibling, !=, null, ;, sibling, =, sibling, ., getNext, (, ), ), {, state, =]
[(, ), ;, sibling, !=, null, ;, sibling, =, sibling, ., getNext, (, ), ), {, state, =, isVariableReadBeforeKill, (]
[;, sibling, !=, null, ;, sibling, =, sibling, ., getNext, (, ), ), {, state, =, isVariableReadBeforeKill, (, sibling, ,]
[sibling, =, sibling, ., getNext, (, ), ), {, state, =, isVariableReadBeforeKill, (, sibling, ,, variable, ), ;, if, (]
[sibling, =, sibling, ., getNext, (, ), ), {, state, =, isVariableReadBeforeKill, (, sibling, ,, variable, ), ;, if, (]
[sibling, ., getNext, (, ), ), {, state, =, isVariableReadBeforeKill, (, sibling, ,, variable, ), ;, if, (, state, !=]
[sibling, ., getNext, (, ), ), {, state, =, isVariableReadBeforeKill, (, sibling, ,, variable, ), ;, if, (, state, !=]
[,, variable, ), ;, if, (, state, !=, VariableLiveness, ., MAYBE_LIVE, ), {, break, ;, }, }, }, if, (]
[,, variable, ), ;, if, (, state, !=, VariableLiveness, ., MAYBE_LIVE, ), {, break, ;, }, }, }, if, (]
[), ;, if, (, state, !=, VariableLiveness, ., MAYBE_LIVE, ), {, break, ;, }, }, }, if, (, state, ==]
[), ;, if, (, state, !=, VariableLiveness, ., MAYBE_LIVE, ), {, break, ;, }, }, }, if, (, state, ==]
[VariableLiveness, ., MAYBE_LIVE, ), {, break, ;, }, }, }, if, (, state, ==, VariableLiveness, ., READ, ), {, return]
[;, }, }, }, if, (, state, ==, VariableLiveness, ., READ, ), {, return, true, ;, }, else, if, (]
[;, }, }, }, if, (, state, ==, VariableLiveness, ., READ, ), {, return, true, ;, }, else, if, (]
[}, }, if, (, state, ==, VariableLiveness, ., READ, ), {, return, true, ;, }, else, if, (, state, ==]
[}, }, if, (, state, ==, VariableLiveness, ., READ, ), {, return, true, ;, }, else, if, (, state, ==]
[VariableLiveness, ., READ, ), {, return, true, ;, }, else, if, (, state, ==, VariableLiveness, ., KILL, ), {, return]
[), {, return, true, ;, }, else, if, (, state, ==, VariableLiveness, ., KILL, ), {, return, false, ;, }]
[return, true, ;, }, else, if, (, state, ==, VariableLiveness, ., KILL, ), {, return, false, ;, }, n, =]
[return, true, ;, }, else, if, (, state, ==, VariableLiveness, ., KILL, ), {, return, false, ;, }, n, =]
[==, VariableLiveness, ., KILL, ), {, return, false, ;, }, n, =, n, ., getParent, (, ), ;, }, return]
[MAYBE_LIVE, ,, READ, ,, KILL, ,, }, private, VariableLiveness, isVariableReadBeforeKill, (, Node, n, ,, String, variable, ), {, if, (]
[MAYBE_LIVE, ,, READ, ,, KILL, ,, }, private, VariableLiveness, isVariableReadBeforeKill, (, Node, n, ,, String, variable, ), {, if, (]
[KILL, ,, }, private, VariableLiveness, isVariableReadBeforeKill, (, Node, n, ,, String, variable, ), {, if, (, ControlFlowGraph, ., isEnteringNewCfgNode, (]
[isVariableReadBeforeKill, (, Node, n, ,, String, variable, ), {, if, (, ControlFlowGraph, ., isEnteringNewCfgNode, (, n, ), ), {, return]
[isVariableReadBeforeKill, (, Node, n, ,, String, variable, ), {, if, (, ControlFlowGraph, ., isEnteringNewCfgNode, (, n, ), ), {, return]
[), {, if, (, ControlFlowGraph, ., isEnteringNewCfgNode, (, n, ), ), {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, if, (]
[), {, if, (, ControlFlowGraph, ., isEnteringNewCfgNode, (, n, ), ), {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, if, (]
[), {, if, (, ControlFlowGraph, ., isEnteringNewCfgNode, (, n, ), ), {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, if, (]
[isEnteringNewCfgNode, (, n, ), ), {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, if, (, n, ., isName, (, ), &&]
[isEnteringNewCfgNode, (, n, ), ), {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, if, (, n, ., isName, (, ), &&]
[), {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, if, (, n, ., isName, (, ), &&, variable, ., equals, (]
[), {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, if, (, n, ., isName, (, ), &&, variable, ., equals, (]
[n, ., isName, (, ), &&, variable, ., equals, (, n, ., getString, (, ), ), ), {, if, (]
[n, ., isName, (, ), &&, variable, ., equals, (, n, ., getString, (, ), ), ), {, if, (]
[), &&, variable, ., equals, (, n, ., getString, (, ), ), ), {, if, (, NodeUtil, ., isVarOrSimpleAssignLhs, (]
[variable, ., equals, (, n, ., getString, (, ), ), ), {, if, (, NodeUtil, ., isVarOrSimpleAssignLhs, (, n, ,]
[variable, ., equals, (, n, ., getString, (, ), ), ), {, if, (, NodeUtil, ., isVarOrSimpleAssignLhs, (, n, ,]
[), ), ), {, if, (, NodeUtil, ., isVarOrSimpleAssignLhs, (, n, ,, n, ., getParent, (, ), ), ), {]
[), ), ), {, if, (, NodeUtil, ., isVarOrSimpleAssignLhs, (, n, ,, n, ., getParent, (, ), ), ), {]
[if, (, NodeUtil, ., isVarOrSimpleAssignLhs, (, n, ,, n, ., getParent, (, ), ), ), {, Preconditions, ., checkState, (]
[if, (, NodeUtil, ., isVarOrSimpleAssignLhs, (, n, ,, n, ., getParent, (, ), ), ), {, Preconditions, ., checkState, (]
[if, (, NodeUtil, ., isVarOrSimpleAssignLhs, (, n, ,, n, ., getParent, (, ), ), ), {, Preconditions, ., checkState, (]
[), {, Preconditions, ., checkState, (, n, ., getParent, (, ), ., isAssign, (, ), ), ;, Node, rhs, =]
[), {, Preconditions, ., checkState, (, n, ., getParent, (, ), ., isAssign, (, ), ), ;, Node, rhs, =]
[(, ), ., isAssign, (, ), ), ;, Node, rhs, =, n, ., getNext, (, ), ;, VariableLiveness, state, =]
[., isAssign, (, ), ), ;, Node, rhs, =, n, ., getNext, (, ), ;, VariableLiveness, state, =, isVariableReadBeforeKill, (]
[(, ), ), ;, Node, rhs, =, n, ., getNext, (, ), ;, VariableLiveness, state, =, isVariableReadBeforeKill, (, rhs, ,]
[rhs, =, n, ., getNext, (, ), ;, VariableLiveness, state, =, isVariableReadBeforeKill, (, rhs, ,, variable, ), ;, if, (]
[rhs, =, n, ., getNext, (, ), ;, VariableLiveness, state, =, isVariableReadBeforeKill, (, rhs, ,, variable, ), ;, if, (]
[n, ., getNext, (, ), ;, VariableLiveness, state, =, isVariableReadBeforeKill, (, rhs, ,, variable, ), ;, if, (, state, ==]
[n, ., getNext, (, ), ;, VariableLiveness, state, =, isVariableReadBeforeKill, (, rhs, ,, variable, ), ;, if, (, state, ==]
[VariableLiveness, state, =, isVariableReadBeforeKill, (, rhs, ,, variable, ), ;, if, (, state, ==, VariableLiveness, ., READ, ), {, return]
[(, rhs, ,, variable, ), ;, if, (, state, ==, VariableLiveness, ., READ, ), {, return, state, ;, }, return]
[(, rhs, ,, variable, ), ;, if, (, state, ==, VariableLiveness, ., READ, ), {, return, state, ;, }, return]
[state, ==, VariableLiveness, ., READ, ), {, return, state, ;, }, return, VariableLiveness, ., KILL, ;, }, else, {, return]
[state, ==, VariableLiveness, ., READ, ), {, return, state, ;, }, return, VariableLiveness, ., KILL, ;, }, else, {, return]
[state, ;, }, return, VariableLiveness, ., KILL, ;, }, else, {, return, VariableLiveness, ., READ, ;, }, }, switch, (]
[state, ;, }, return, VariableLiveness, ., KILL, ;, }, else, {, return, VariableLiveness, ., READ, ;, }, }, switch, (]
[}, else, {, return, VariableLiveness, ., READ, ;, }, }, switch, (, n, ., getType, (, ), ), {, case]
[}, else, {, return, VariableLiveness, ., READ, ;, }, }, switch, (, n, ., getType, (, ), ), {, case]
[., READ, ;, }, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., OR, :, case]
[., READ, ;, }, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., OR, :, case]
[n, ., getType, (, ), ), {, case, Token, ., OR, :, case, Token, ., AND, :, VariableLiveness, v1, =]
[getType, (, ), ), {, case, Token, ., OR, :, case, Token, ., AND, :, VariableLiveness, v1, =, isVariableReadBeforeKill, (]
[getType, (, ), ), {, case, Token, ., OR, :, case, Token, ., AND, :, VariableLiveness, v1, =, isVariableReadBeforeKill, (]
[Token, ., OR, :, case, Token, ., AND, :, VariableLiveness, v1, =, isVariableReadBeforeKill, (, n, ., getFirstChild, (, ), ,]
[., AND, :, VariableLiveness, v1, =, isVariableReadBeforeKill, (, n, ., getFirstChild, (, ), ,, variable, ), ;, VariableLiveness, v2, =]
[:, VariableLiveness, v1, =, isVariableReadBeforeKill, (, n, ., getFirstChild, (, ), ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (]
[:, VariableLiveness, v1, =, isVariableReadBeforeKill, (, n, ., getFirstChild, (, ), ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (]
[n, ., getFirstChild, (, ), ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, n, ., getLastChild, (, ), ,]
[,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, n, ., getLastChild, (, ), ,, variable, ), ;, if, (]
[,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, n, ., getLastChild, (, ), ,, variable, ), ;, if, (]
[), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, n, ., getLastChild, (, ), ,, variable, ), ;, if, (, v1, !=]
[), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, n, ., getLastChild, (, ), ,, variable, ), ;, if, (, v1, !=]
[(, n, ., getLastChild, (, ), ,, variable, ), ;, if, (, v1, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return]
[,, variable, ), ;, if, (, v1, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, v1, ;, }, else, if, (]
[,, variable, ), ;, if, (, v1, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, v1, ;, }, else, if, (]
[), ;, if, (, v1, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, v1, ;, }, else, if, (, v2, ==]
[), ;, if, (, v1, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, v1, ;, }, else, if, (, v2, ==]
[VariableLiveness, ., MAYBE_LIVE, ), {, return, v1, ;, }, else, if, (, v2, ==, VariableLiveness, ., READ, ), {, return]
[VariableLiveness, ., MAYBE_LIVE, ), {, return, v1, ;, }, else, if, (, v2, ==, VariableLiveness, ., READ, ), {, return]
[}, else, if, (, v2, ==, VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, {, return]
[}, else, if, (, v2, ==, VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, {, return]
[VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, case]
[VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, case]
[., READ, ;, }, else, {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, case, Token, ., HOOK, :, VariableLiveness, first, =]
[;, }, else, {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, case, Token, ., HOOK, :, VariableLiveness, first, =, isVariableReadBeforeKill, (]
[;, }, else, {, return, VariableLiveness, ., MAYBE_LIVE, ;, }, case, Token, ., HOOK, :, VariableLiveness, first, =, isVariableReadBeforeKill, (]
[., MAYBE_LIVE, ;, }, case, Token, ., HOOK, :, VariableLiveness, first, =, isVariableReadBeforeKill, (, n, ., getFirstChild, (, ), ,]
[Token, ., HOOK, :, VariableLiveness, first, =, isVariableReadBeforeKill, (, n, ., getFirstChild, (, ), ,, variable, ), ;, if, (]
[Token, ., HOOK, :, VariableLiveness, first, =, isVariableReadBeforeKill, (, n, ., getFirstChild, (, ), ,, variable, ), ;, if, (]
[HOOK, :, VariableLiveness, first, =, isVariableReadBeforeKill, (, n, ., getFirstChild, (, ), ,, variable, ), ;, if, (, first, !=]
[HOOK, :, VariableLiveness, first, =, isVariableReadBeforeKill, (, n, ., getFirstChild, (, ), ,, variable, ), ;, if, (, first, !=]
[(, n, ., getFirstChild, (, ), ,, variable, ), ;, if, (, first, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return]
[(, ), ,, variable, ), ;, if, (, first, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, first, ;, }, return]
[,, variable, ), ;, if, (, first, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, first, ;, }, return, checkHookBranchReadBeforeKill, (]
[,, variable, ), ;, if, (, first, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, first, ;, }, return, checkHookBranchReadBeforeKill, (]
[,, variable, ), ;, if, (, first, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, first, ;, }, return, checkHookBranchReadBeforeKill, (]
[MAYBE_LIVE, ), {, return, first, ;, }, return, checkHookBranchReadBeforeKill, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,]
[MAYBE_LIVE, ), {, return, first, ;, }, return, checkHookBranchReadBeforeKill, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,]
[}, return, checkHookBranchReadBeforeKill, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, n, ., getLastChild, (, ), ,]
[getNext, (, ), ,, n, ., getLastChild, (, ), ,, variable, ), ;, default, :, for, (, Node, child, =]
[getNext, (, ), ,, n, ., getLastChild, (, ), ,, variable, ), ;, default, :, for, (, Node, child, =]
[getLastChild, (, ), ,, variable, ), ;, default, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[getLastChild, (, ), ,, variable, ), ;, default, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[), ,, variable, ), ;, default, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=]
[variable, ), ;, default, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;]
[;, default, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[;, default, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, VariableLiveness, state, =]
[), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, VariableLiveness, state, =, isVariableReadBeforeKill, (]
[child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, VariableLiveness, state, =, isVariableReadBeforeKill, (, child, ,]
[=, child, ., getNext, (, ), ), {, VariableLiveness, state, =, isVariableReadBeforeKill, (, child, ,, variable, ), ;, if, (]
[=, child, ., getNext, (, ), ), {, VariableLiveness, state, =, isVariableReadBeforeKill, (, child, ,, variable, ), ;, if, (]
[., getNext, (, ), ), {, VariableLiveness, state, =, isVariableReadBeforeKill, (, child, ,, variable, ), ;, if, (, state, !=]
[., getNext, (, ), ), {, VariableLiveness, state, =, isVariableReadBeforeKill, (, child, ,, variable, ), ;, if, (, state, !=]
[VariableLiveness, state, =, isVariableReadBeforeKill, (, child, ,, variable, ), ;, if, (, state, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return]
[,, variable, ), ;, if, (, state, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, state, ;, }, }, }, return]
[,, variable, ), ;, if, (, state, !=, VariableLiveness, ., MAYBE_LIVE, ), {, return, state, ;, }, }, }, return]
[MAYBE_LIVE, ;, }, private, VariableLiveness, checkHookBranchReadBeforeKill, (, Node, trueCase, ,, Node, falseCase, ,, String, variable, ), {, VariableLiveness, v1, =]
[}, private, VariableLiveness, checkHookBranchReadBeforeKill, (, Node, trueCase, ,, Node, falseCase, ,, String, variable, ), {, VariableLiveness, v1, =, isVariableReadBeforeKill, (]
[VariableLiveness, checkHookBranchReadBeforeKill, (, Node, trueCase, ,, Node, falseCase, ,, String, variable, ), {, VariableLiveness, v1, =, isVariableReadBeforeKill, (, trueCase, ,]
[Node, falseCase, ,, String, variable, ), {, VariableLiveness, v1, =, isVariableReadBeforeKill, (, trueCase, ,, variable, ), ;, VariableLiveness, v2, =]
[,, String, variable, ), {, VariableLiveness, v1, =, isVariableReadBeforeKill, (, trueCase, ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (]
[variable, ), {, VariableLiveness, v1, =, isVariableReadBeforeKill, (, trueCase, ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,]
[=, isVariableReadBeforeKill, (, trueCase, ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,, variable, ), ;, if, (]
[=, isVariableReadBeforeKill, (, trueCase, ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,, variable, ), ;, if, (]
[=, isVariableReadBeforeKill, (, trueCase, ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,, variable, ), ;, if, (]
[(, trueCase, ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,, variable, ), ;, if, (, v1, ==]
[(, trueCase, ,, variable, ), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,, variable, ), ;, if, (, v1, ==]
[), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,, variable, ), ;, if, (, v1, ==, VariableLiveness, ., READ, ||]
[), ;, VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,, variable, ), ;, if, (, v1, ==, VariableLiveness, ., READ, ||]
[VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,, variable, ), ;, if, (, v1, ==, VariableLiveness, ., READ, ||, v2, ==]
[VariableLiveness, v2, =, isVariableReadBeforeKill, (, falseCase, ,, variable, ), ;, if, (, v1, ==, VariableLiveness, ., READ, ||, v2, ==]
[,, variable, ), ;, if, (, v1, ==, VariableLiveness, ., READ, ||, v2, ==, VariableLiveness, ., READ, ), {, return]
[,, variable, ), ;, if, (, v1, ==, VariableLiveness, ., READ, ||, v2, ==, VariableLiveness, ., READ, ), {, return]
[VariableLiveness, ., READ, ||, v2, ==, VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, if, (]
[VariableLiveness, ., READ, ||, v2, ==, VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, if, (]
[VariableLiveness, ., READ, ||, v2, ==, VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, if, (]
[READ, ||, v2, ==, VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, if, (, v1, ==]
[READ, ||, v2, ==, VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, if, (, v1, ==]
[VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, if, (, v1, ==, VariableLiveness, ., KILL, &&]
[VariableLiveness, ., READ, ), {, return, VariableLiveness, ., READ, ;, }, else, if, (, v1, ==, VariableLiveness, ., KILL, &&]
[READ, ), {, return, VariableLiveness, ., READ, ;, }, else, if, (, v1, ==, VariableLiveness, ., KILL, &&, v2, ==]
[READ, ), {, return, VariableLiveness, ., READ, ;, }, else, if, (, v1, ==, VariableLiveness, ., KILL, &&, v2, ==]
[READ, ;, }, else, if, (, v1, ==, VariableLiveness, ., KILL, &&, v2, ==, VariableLiveness, ., KILL, ), {, return]
[READ, ;, }, else, if, (, v1, ==, VariableLiveness, ., KILL, &&, v2, ==, VariableLiveness, ., KILL, ), {, return]
[VariableLiveness, ., KILL, &&, v2, ==, VariableLiveness, ., KILL, ), {, return, VariableLiveness, ., KILL, ;, }, else, {, return]
[VariableLiveness, ., KILL, &&, v2, ==, VariableLiveness, ., KILL, ), {, return, VariableLiveness, ., KILL, ;, }, else, {, return]
