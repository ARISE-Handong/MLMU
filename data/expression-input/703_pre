[private, final, Annotatable, first, ;, private, final, Annotation, second, ;, public, AnnotationState, (, Annotatable, annotatable, ,, Annotation, annotation, ), {]
[private, final, Annotatable, first, ;, private, final, Annotation, second, ;, public, AnnotationState, (, Annotatable, annotatable, ,, Annotation, annotation, ), {]
[;, private, final, Annotation, second, ;, public, AnnotationState, (, Annotatable, annotatable, ,, Annotation, annotation, ), {, this, ., first, =]
[final, Annotation, second, ;, public, AnnotationState, (, Annotatable, annotatable, ,, Annotation, annotation, ), {, this, ., first, =, annotatable, ;]
[final, Annotation, second, ;, public, AnnotationState, (, Annotatable, annotatable, ,, Annotation, annotation, ), {, this, ., first, =, annotatable, ;]
[public, AnnotationState, (, Annotatable, annotatable, ,, Annotation, annotation, ), {, this, ., first, =, annotatable, ;, this, ., second, =]
[annotation, ;, }, }, private, static, class, GraphAnnotationState, extends, ArrayList, <, AnnotationState, >, {, private, static, final, long, serialVersionUID, =]
[AnnotationState, >, {, private, static, final, long, serialVersionUID, =, 1L, ;, public, GraphAnnotationState, (, int, size, ), {, super, (]
[n2, ), ;, public, final, void, connectIfNotFound, (, N, n1, ,, E, edge, ,, N, n2, ), {, if, (]
[), ;, public, final, void, connectIfNotFound, (, N, n1, ,, E, edge, ,, N, n2, ), {, if, (, !]
[public, final, void, connectIfNotFound, (, N, n1, ,, E, edge, ,, N, n2, ), {, if, (, !, isConnected, (]
[void, connectIfNotFound, (, N, n1, ,, E, edge, ,, N, n2, ), {, if, (, !, isConnected, (, n1, ,]
[(, N, n1, ,, E, edge, ,, N, n2, ), {, if, (, !, isConnected, (, n1, ,, edge, ,]
[E, edge, ,, N, n2, ), {, if, (, !, isConnected, (, n1, ,, edge, ,, n2, ), ), {]
[,, N, n2, ), {, if, (, !, isConnected, (, n1, ,, edge, ,, n2, ), ), {, connect, (]
[n2, ), {, if, (, !, isConnected, (, n1, ,, edge, ,, n2, ), ), {, connect, (, n1, ,]
[{, if, (, !, isConnected, (, n1, ,, edge, ,, n2, ), ), {, connect, (, n1, ,, edge, ,]
[public, abstract, int, getNodeDegree, (, N, value, ), ;, @, Override, public, int, getWeight, (, N, value, ), {, return]
[int, getNodeDegree, (, N, value, ), ;, @, Override, public, int, getWeight, (, N, value, ), {, return, getNodeDegree, (]
[>, getFirstEdge, (, N, n1, ,, N, n2, ), ;, public, final, boolean, hasNode, (, N, n, ), {, return]
[>, getFirstEdge, (, N, n1, ,, N, n2, ), ;, public, final, boolean, hasNode, (, N, n, ), {, return]
[(, N, n1, ,, N, n2, ), ;, public, final, boolean, hasNode, (, N, n, ), {, return, getNode, (]
[,, N, n2, ), ;, public, final, boolean, hasNode, (, N, n, ), {, return, getNode, (, n, ), !=]
[,, N, n2, ), ;, public, abstract, boolean, isConnected, (, N, n1, ,, E, e, ,, N, n2, ), ;]
[), ;, public, abstract, boolean, isConnected, (, N, n1, ,, E, e, ,, N, n2, ), ;, @, SuppressWarnings, (]
[<, T, extends, GraphNode, <, N, ,, E, >, >, T, getNodeOrFail, (, N, val, ), {, T, node, =]
[GraphNode, <, N, ,, E, >, >, T, getNodeOrFail, (, N, val, ), {, T, node, =, (, T, )]
[N, ,, E, >, >, T, getNodeOrFail, (, N, val, ), {, T, node, =, (, T, ), getNode, (]
[T, getNodeOrFail, (, N, val, ), {, T, node, =, (, T, ), getNode, (, val, ), ;, if, (]
[T, getNodeOrFail, (, N, val, ), {, T, node, =, (, T, ), getNode, (, val, ), ;, if, (]
[(, N, val, ), {, T, node, =, (, T, ), getNode, (, val, ), ;, if, (, node, ==]
[{, T, node, =, (, T, ), getNode, (, val, ), ;, if, (, node, ==, null, ), {, throw]
[=, (, T, ), getNode, (, val, ), ;, if, (, node, ==, null, ), {, throw, new, IllegalArgumentException, (]
[=, (, T, ), getNode, (, val, ), ;, if, (, node, ==, null, ), {, throw, new, IllegalArgumentException, (]
[T, ), getNode, (, val, ), ;, if, (, node, ==, null, ), {, throw, new, IllegalArgumentException, (, val, +]
[), ;, if, (, node, ==, null, ), {, throw, new, IllegalArgumentException, (, val, +, " does not exist in graph", ), ;, }, return]
[}, @, Override, public, final, void, clearNodeAnnotations, (, ), {, for, (, GraphNode, <, N, ,, E, >, n, :]
[void, clearNodeAnnotations, (, ), {, for, (, GraphNode, <, N, ,, E, >, n, :, getNodes, (, ), ), {]
[void, clearNodeAnnotations, (, ), {, for, (, GraphNode, <, N, ,, E, >, n, :, getNodes, (, ), ), {]
[{, for, (, GraphNode, <, N, ,, E, >, n, :, getNodes, (, ), ), {, n, ., setAnnotation, (]
[;, }, }, public, final, void, clearEdgeAnnotations, (, ), {, for, (, GraphEdge, <, N, ,, E, >, e, :]
[void, clearEdgeAnnotations, (, ), {, for, (, GraphEdge, <, N, ,, E, >, e, :, getEdges, (, ), ), {]
[void, clearEdgeAnnotations, (, ), {, for, (, GraphEdge, <, N, ,, E, >, e, :, getEdges, (, ), ), {]
[{, for, (, GraphEdge, <, N, ,, E, >, e, :, getEdges, (, ), ), {, e, ., setAnnotation, (]
[), {, e, ., setAnnotation, (, null, ), ;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (]
[), {, e, ., setAnnotation, (, null, ), ;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (]
[e, ., setAnnotation, (, null, ), ;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (, nodeAnnotationStack, ==]
[(, null, ), ;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (, nodeAnnotationStack, ==, null, ), {]
[), ;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (, nodeAnnotationStack, ==, null, ), {, nodeAnnotationStack, =]
[), ;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (, nodeAnnotationStack, ==, null, ), {, nodeAnnotationStack, =]
[pushNodeAnnotations, (, ), {, if, (, nodeAnnotationStack, ==, null, ), {, nodeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }]
[), {, if, (, nodeAnnotationStack, ==, null, ), {, nodeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (]
[if, (, nodeAnnotationStack, ==, null, ), {, nodeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, nodeAnnotationStack, ,]
[), ;, }, pushAnnotations, (, nodeAnnotationStack, ,, getNodes, (, ), ), ;, }, public, final, void, popNodeAnnotations, (, ), {]
[), ;, }, pushAnnotations, (, nodeAnnotationStack, ,, getNodes, (, ), ), ;, }, public, final, void, popNodeAnnotations, (, ), {]
[(, nodeAnnotationStack, ,, getNodes, (, ), ), ;, }, public, final, void, popNodeAnnotations, (, ), {, Preconditions, ., checkNotNull, (]
[,, getNodes, (, ), ), ;, }, public, final, void, popNodeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, nodeAnnotationStack, ,]
[), ), ;, }, public, final, void, popNodeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, nodeAnnotationStack, ,, "Popping node annotations without pushing.", ), ;]
[;, }, public, final, void, popNodeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, nodeAnnotationStack, ,, "Popping node annotations without pushing.", ), ;, popAnnotations, (]
[nodeAnnotationStack, ,, "Popping node annotations without pushing.", ), ;, popAnnotations, (, nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (]
[nodeAnnotationStack, ,, "Popping node annotations without pushing.", ), ;, popAnnotations, (, nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (]
["Popping node annotations without pushing.", ), ;, popAnnotations, (, nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack, ==]
[popAnnotations, (, nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack, ==, null, ), {]
[nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack, ==, null, ), {, edgeAnnotationStack, =]
[nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack, ==, null, ), {, edgeAnnotationStack, =]
[pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack, ==, null, ), {, edgeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }]
[), {, if, (, edgeAnnotationStack, ==, null, ), {, edgeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (]
[if, (, edgeAnnotationStack, ==, null, ), {, edgeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, edgeAnnotationStack, ,]
[), ;, }, pushAnnotations, (, edgeAnnotationStack, ,, getEdges, (, ), ), ;, }, public, final, void, popEdgeAnnotations, (, ), {]
[), ;, }, pushAnnotations, (, edgeAnnotationStack, ,, getEdges, (, ), ), ;, }, public, final, void, popEdgeAnnotations, (, ), {]
[(, edgeAnnotationStack, ,, getEdges, (, ), ), ;, }, public, final, void, popEdgeAnnotations, (, ), {, Preconditions, ., checkNotNull, (]
[,, getEdges, (, ), ), ;, }, public, final, void, popEdgeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, edgeAnnotationStack, ,]
[), ), ;, }, public, final, void, popEdgeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, edgeAnnotationStack, ,, "Popping edge annotations without pushing.", ), ;]
[;, }, public, final, void, popEdgeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, edgeAnnotationStack, ,, "Popping edge annotations without pushing.", ), ;, popAnnotations, (]
[Graph, <, N, ,, E, >, graph, ;, private, List, <, GraphNode, <, N, ,, E, >, >, nodes, =]
[Graph, <, N, ,, E, >, graph, ;, private, List, <, GraphNode, <, N, ,, E, >, >, nodes, =]
[>, nodes, =, Lists, ., newArrayList, (, ), ;, SimpleSubGraph, (, Graph, <, N, ,, E, >, graph, ), {]
[>, nodes, =, Lists, ., newArrayList, (, ), ;, SimpleSubGraph, (, Graph, <, N, ,, E, >, graph, ), {]
[., newArrayList, (, ), ;, SimpleSubGraph, (, Graph, <, N, ,, E, >, graph, ), {, this, ., graph, =]
[;, }, @, Override, public, boolean, isIndependentOf, (, N, value, ), {, GraphNode, <, N, ,, E, >, node, =]
[;, }, @, Override, public, boolean, isIndependentOf, (, N, value, ), {, GraphNode, <, N, ,, E, >, node, =]
[public, boolean, isIndependentOf, (, N, value, ), {, GraphNode, <, N, ,, E, >, node, =, graph, ., getNode, (]
[>, node, =, graph, ., getNode, (, value, ), ;, for, (, GraphNode, <, N, ,, E, >, n, :]
[getNode, (, value, ), ;, for, (, GraphNode, <, N, ,, E, >, n, :, nodes, ), {, if, (]
[getNode, (, value, ), ;, for, (, GraphNode, <, N, ,, E, >, n, :, nodes, ), {, if, (]
[getNode, (, value, ), ;, for, (, GraphNode, <, N, ,, E, >, n, :, nodes, ), {, if, (]
[;, for, (, GraphNode, <, N, ,, E, >, n, :, nodes, ), {, if, (, graph, ., getNeighborNodes, (]
[;, for, (, GraphNode, <, N, ,, E, >, n, :, nodes, ), {, if, (, graph, ., getNeighborNodes, (]
[n, :, nodes, ), {, if, (, graph, ., getNeighborNodes, (, n, ., getValue, (, ), ), ., contains, (]
[if, (, graph, ., getNeighborNodes, (, n, ., getValue, (, ), ), ., contains, (, node, ), ), {, return]
[(, n, ., getValue, (, ), ), ., contains, (, node, ), ), {, return, false, ;, }, }, return]
[{, return, false, ;, }, }, return, true, ;, }, @, Override, public, void, addNode, (, N, value, ), {]
[{, return, false, ;, }, }, return, true, ;, }, @, Override, public, void, addNode, (, N, value, ), {]
[}, }, return, true, ;, }, @, Override, public, void, addNode, (, N, value, ), {, nodes, ., add, (]
[}, }, return, true, ;, }, @, Override, public, void, addNode, (, N, value, ), {, nodes, ., add, (]
[;, }, @, Override, public, void, addNode, (, N, value, ), {, nodes, ., add, (, graph, ., getNodeOrFail, (]
[private, static, void, pushAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ,, Collection, <, ?, extends, Annotatable, >, haveAnnotations, ), {]
[private, static, void, pushAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ,, Collection, <, ?, extends, Annotatable, >, haveAnnotations, ), {]
[(, Deque, <, GraphAnnotationState, >, stack, ,, Collection, <, ?, extends, Annotatable, >, haveAnnotations, ), {, stack, ., push, (]
[GraphAnnotationState, >, stack, ,, Collection, <, ?, extends, Annotatable, >, haveAnnotations, ), {, stack, ., push, (, new, GraphAnnotationState, (]
[GraphAnnotationState, >, stack, ,, Collection, <, ?, extends, Annotatable, >, haveAnnotations, ), {, stack, ., push, (, new, GraphAnnotationState, (]
[stack, ., push, (, new, GraphAnnotationState, (, haveAnnotations, ., size, (, ), ), ), ;, for, (, Annotatable, h, :]
[(, new, GraphAnnotationState, (, haveAnnotations, ., size, (, ), ), ), ;, for, (, Annotatable, h, :, haveAnnotations, ), {]
[(, new, GraphAnnotationState, (, haveAnnotations, ., size, (, ), ), ), ;, for, (, Annotatable, h, :, haveAnnotations, ), {]
[(, new, GraphAnnotationState, (, haveAnnotations, ., size, (, ), ), ), ;, for, (, Annotatable, h, :, haveAnnotations, ), {]
[), ), ), ;, for, (, Annotatable, h, :, haveAnnotations, ), {, stack, ., peek, (, ), ., add, (]
[;, for, (, Annotatable, h, :, haveAnnotations, ), {, stack, ., peek, (, ), ., add, (, new, AnnotationState, (]
[(, Annotatable, h, :, haveAnnotations, ), {, stack, ., peek, (, ), ., add, (, new, AnnotationState, (, h, ,]
[(, Annotatable, h, :, haveAnnotations, ), {, stack, ., peek, (, ), ., add, (, new, AnnotationState, (, h, ,]
[., peek, (, ), ., add, (, new, AnnotationState, (, h, ,, h, ., getAnnotation, (, ), ), ), ;]
[., peek, (, ), ., add, (, new, AnnotationState, (, h, ,, h, ., getAnnotation, (, ), ), ), ;]
[., add, (, new, AnnotationState, (, h, ,, h, ., getAnnotation, (, ), ), ), ;, h, ., setAnnotation, (]
[;, }, }, private, static, void, popAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ), {, for, (, AnnotationState, as, :]
[;, }, }, private, static, void, popAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ), {, for, (, AnnotationState, as, :]
[(, Deque, <, GraphAnnotationState, >, stack, ), {, for, (, AnnotationState, as, :, stack, ., pop, (, ), ), {]
[(, Deque, <, GraphAnnotationState, >, stack, ), {, for, (, AnnotationState, as, :, stack, ., pop, (, ), ), {]
[(, Deque, <, GraphAnnotationState, >, stack, ), {, for, (, AnnotationState, as, :, stack, ., pop, (, ), ), {]
[), {, for, (, AnnotationState, as, :, stack, ., pop, (, ), ), {, as, ., first, ., setAnnotation, (]
[), {, for, (, AnnotationState, as, :, stack, ., pop, (, ), ), {, as, ., first, ., setAnnotation, (]
