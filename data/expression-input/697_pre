[;, public, ExpressionDecomposer, (, AbstractCompiler, compiler, ,, Supplier, <, String, >, safeNameIdSupplier, ,, Set, <, String, >, constNames, ), {]
[;, public, ExpressionDecomposer, (, AbstractCompiler, compiler, ,, Supplier, <, String, >, safeNameIdSupplier, ,, Set, <, String, >, constNames, ), {]
[AbstractCompiler, compiler, ,, Supplier, <, String, >, safeNameIdSupplier, ,, Set, <, String, >, constNames, ), {, Preconditions, ., checkNotNull, (]
[Supplier, <, String, >, safeNameIdSupplier, ,, Set, <, String, >, constNames, ), {, Preconditions, ., checkNotNull, (, compiler, ), ;]
[Supplier, <, String, >, safeNameIdSupplier, ,, Set, <, String, >, constNames, ), {, Preconditions, ., checkNotNull, (, compiler, ), ;]
[safeNameIdSupplier, ,, Set, <, String, >, constNames, ), {, Preconditions, ., checkNotNull, (, compiler, ), ;, Preconditions, ., checkNotNull, (]
[<, String, >, constNames, ), {, Preconditions, ., checkNotNull, (, compiler, ), ;, Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;]
[<, String, >, constNames, ), {, Preconditions, ., checkNotNull, (, compiler, ), ;, Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;]
[), {, Preconditions, ., checkNotNull, (, compiler, ), ;, Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (]
[., checkNotNull, (, compiler, ), ;, Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;]
[., checkNotNull, (, compiler, ), ;, Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;]
[), ;, Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =]
[Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler, ;]
[Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler, ;]
[safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =]
[;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;]
[;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;]
[(, constNames, ), ;, this, ., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;, this, ., knownConstants, =]
[;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;, this, ., knownConstants, =, constNames, ;, }, private, static, final, int, MAX_INTERATIONS, =]
[;, }, private, static, final, int, MAX_INTERATIONS, =, 100, ;, void, maybeExposeExpression, (, Node, expression, ), {, int, i, =]
[final, int, MAX_INTERATIONS, =, 100, ;, void, maybeExposeExpression, (, Node, expression, ), {, int, i, =, 0, ;, while, (]
[final, int, MAX_INTERATIONS, =, 100, ;, void, maybeExposeExpression, (, Node, expression, ), {, int, i, =, 0, ;, while, (]
[final, int, MAX_INTERATIONS, =, 100, ;, void, maybeExposeExpression, (, Node, expression, ), {, int, i, =, 0, ;, while, (]
[100, ;, void, maybeExposeExpression, (, Node, expression, ), {, int, i, =, 0, ;, while, (, DecompositionType, ., DECOMPOSABLE, ==]
[void, maybeExposeExpression, (, Node, expression, ), {, int, i, =, 0, ;, while, (, DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression, (]
[expression, ), {, int, i, =, 0, ;, while, (, DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression, (, expression, ), ), {]
[{, int, i, =, 0, ;, while, (, DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression, (, expression, ), ), {, exposeExpression, (]
[=, 0, ;, while, (, DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression, (, expression, ), ), {, exposeExpression, (, expression, ), ;]
[=, 0, ;, while, (, DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression, (, expression, ), ), {, exposeExpression, (, expression, ), ;]
[DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression, (, expression, ), ), {, exposeExpression, (, expression, ), ;, i, ++, ;, if, (]
[DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression, (, expression, ), ), {, exposeExpression, (, expression, ), ;, i, ++, ;, if, (]
[DECOMPOSABLE, ==, canExposeExpression, (, expression, ), ), {, exposeExpression, (, expression, ), ;, i, ++, ;, if, (, i, >]
[expression, ), ), {, exposeExpression, (, expression, ), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw]
[{, exposeExpression, (, expression, ), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException, (]
[{, exposeExpression, (, expression, ), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException, (]
[(, expression, ), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +]
[(, expression, ), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +]
[expression, ., toStringTree, (, ), ), ;, }, }, }, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =]
[toStringTree, (, ), ), ;, }, }, }, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot, (]
[), ;, }, }, }, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;]
[), ;, }, }, }, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;]
[}, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;, Preconditions, ., checkState, (]
[}, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;, Preconditions, ., checkState, (]
[exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;, Preconditions, ., checkState, (, expressionRoot, !=]
[expression, ), {, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;, Preconditions, ., checkState, (, expressionRoot, !=, null, ), ;]
[{, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;, Preconditions, ., checkState, (, expressionRoot, !=, null, ), ;, exposeExpression, (]
[expressionRoot, =, findExpressionRoot, (, expression, ), ;, Preconditions, ., checkState, (, expressionRoot, !=, null, ), ;, exposeExpression, (, expressionRoot, ,]
[(, expression, ), ;, Preconditions, ., checkState, (, expressionRoot, !=, null, ), ;, exposeExpression, (, expressionRoot, ,, expression, ), ;]
[(, expression, ), ;, Preconditions, ., checkState, (, expressionRoot, !=, null, ), ;, exposeExpression, (, expressionRoot, ,, expression, ), ;]
[expression, ), ;, compiler, ., reportCodeChange, (, ), ;, }, void, moveExpression, (, Node, expression, ), {, String, resultName, =]
[), ;, }, void, moveExpression, (, Node, expression, ), {, String, resultName, =, getResultValueName, (, ), ;, Node, injectionPoint, =]
[}, void, moveExpression, (, Node, expression, ), {, String, resultName, =, getResultValueName, (, ), ;, Node, injectionPoint, =, findInjectionPoint, (]
[(, Node, expression, ), {, String, resultName, =, getResultValueName, (, ), ;, Node, injectionPoint, =, findInjectionPoint, (, expression, ), ;]
[(, Node, expression, ), {, String, resultName, =, getResultValueName, (, ), ;, Node, injectionPoint, =, findInjectionPoint, (, expression, ), ;]
[{, String, resultName, =, getResultValueName, (, ), ;, Node, injectionPoint, =, findInjectionPoint, (, expression, ), ;, Preconditions, ., checkNotNull, (]
[), ;, Node, injectionPoint, =, findInjectionPoint, (, expression, ), ;, Preconditions, ., checkNotNull, (, injectionPoint, ), ;, Node, injectionPointParent, =]
[), ;, Node, injectionPoint, =, findInjectionPoint, (, expression, ), ;, Preconditions, ., checkNotNull, (, injectionPoint, ), ;, Node, injectionPointParent, =]
[(, expression, ), ;, Preconditions, ., checkNotNull, (, injectionPoint, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;]
[(, expression, ), ;, Preconditions, ., checkNotNull, (, injectionPoint, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;]
[Preconditions, ., checkNotNull, (, injectionPoint, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (]
[(, injectionPoint, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, injectionPointParent, ), ;]
[(, injectionPoint, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, injectionPointParent, ), ;]
[Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, injectionPointParent, ), ;, Preconditions, ., checkState, (]
[Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, injectionPointParent, ), ;, Preconditions, ., checkState, (]
[., getParent, (, ), ;, Preconditions, ., checkNotNull, (, injectionPointParent, ), ;, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (]
[checkNotNull, (, injectionPointParent, ), ;, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent, =]
[checkNotNull, (, injectionPointParent, ), ;, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent, =]
[., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent, =, expression, ., getParent, (, ), ;]
[., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent, =, expression, ., getParent, (, ), ;]
[., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent, =, expression, ., getParent, (, ), ;, expressionParent, ., replaceChild, (]
[(, injectionPointParent, ), ), ;, Node, expressionParent, =, expression, ., getParent, (, ), ;, expressionParent, ., replaceChild, (, expression, ,]
[(, injectionPointParent, ), ), ;, Node, expressionParent, =, expression, ., getParent, (, ), ;, expressionParent, ., replaceChild, (, expression, ,]
[;, Node, expressionParent, =, expression, ., getParent, (, ), ;, expressionParent, ., replaceChild, (, expression, ,, IR, ., name, (]
[(, ), ;, expressionParent, ., replaceChild, (, expression, ,, IR, ., name, (, resultName, ), ), ;, Node, newExpressionRoot, =]
[(, ), ;, expressionParent, ., replaceChild, (, expression, ,, IR, ., name, (, resultName, ), ), ;, Node, newExpressionRoot, =]
[., replaceChild, (, expression, ,, IR, ., name, (, resultName, ), ), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (]
[(, expression, ,, IR, ., name, (, resultName, ), ), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,]
[IR, ., name, (, resultName, ), ), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;]
[IR, ., name, (, resultName, ), ), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;]
[resultName, ), ), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;, injectionPointParent, ., addChildBefore, (]
[), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;, injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,]
[newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;, injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,, injectionPoint, ), ;]
[newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;, injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,, injectionPoint, ), ;]
[., reportCodeChange, (, ), ;, }, private, void, exposeExpression, (, Node, expressionRoot, ,, Node, subExpression, ), {, Node, nonconditionalExpr, =]
[(, ), ;, }, private, void, exposeExpression, (, Node, expressionRoot, ,, Node, subExpression, ), {, Node, nonconditionalExpr, =, findNonconditionalParent, (]
[;, }, private, void, exposeExpression, (, Node, expressionRoot, ,, Node, subExpression, ), {, Node, nonconditionalExpr, =, findNonconditionalParent, (, subExpression, ,]
[Node, expressionRoot, ,, Node, subExpression, ), {, Node, nonconditionalExpr, =, findNonconditionalParent, (, subExpression, ,, expressionRoot, ), ;, boolean, hasFollowingSideEffects, =]
[Node, expressionRoot, ,, Node, subExpression, ), {, Node, nonconditionalExpr, =, findNonconditionalParent, (, subExpression, ,, expressionRoot, ), ;, boolean, hasFollowingSideEffects, =]
[subExpression, ), {, Node, nonconditionalExpr, =, findNonconditionalParent, (, subExpression, ,, expressionRoot, ), ;, boolean, hasFollowingSideEffects, =, NodeUtil, ., mayHaveSideEffects, (]
[{, Node, nonconditionalExpr, =, findNonconditionalParent, (, subExpression, ,, expressionRoot, ), ;, boolean, hasFollowingSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, nonconditionalExpr, ,]
[subExpression, ,, expressionRoot, ), ;, boolean, hasFollowingSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, nonconditionalExpr, ,, compiler, ), ;, Node, exprInjectionPoint, =]
[expressionRoot, ), ;, boolean, hasFollowingSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, nonconditionalExpr, ,, compiler, ), ;, Node, exprInjectionPoint, =, findInjectionPoint, (]
[NodeUtil, ., mayHaveSideEffects, (, nonconditionalExpr, ,, compiler, ), ;, Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =]
[,, compiler, ), ;, Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;]
[,, compiler, ), ;, Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;]
[Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;, state, ., sideEffects, =]
[=, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;, state, ., sideEffects, =, hasFollowingSideEffects, ;]
[=, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;, state, ., sideEffects, =, hasFollowingSideEffects, ;]
[), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;, state, ., sideEffects, =, hasFollowingSideEffects, ;, state, ., extractBeforeStatement, =]
[(, ), ;, state, ., sideEffects, =, hasFollowingSideEffects, ;, state, ., extractBeforeStatement, =, exprInjectionPoint, ;, for, (, Node, grandchild, =]
[., sideEffects, =, hasFollowingSideEffects, ;, state, ., extractBeforeStatement, =, exprInjectionPoint, ;, for, (, Node, grandchild, =, null, ,, child, =]
[;, state, ., extractBeforeStatement, =, exprInjectionPoint, ;, for, (, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =]
[;, state, ., extractBeforeStatement, =, exprInjectionPoint, ;, for, (, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =]
[;, for, (, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =, child, ., getParent, (, ), ;]
[;, for, (, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =, child, ., getParent, (, ), ;]
[(, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =, child, ., getParent, (, ), ;, parent, !=]
[grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;]
[null, ,, child, =, nonconditionalExpr, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, grandchild, =]
[child, =, nonconditionalExpr, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, grandchild, =, child, ,]
[nonconditionalExpr, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, grandchild, =, child, ,, child, =]
[parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, grandchild, =, child, ,, child, =, parent, ,]
[child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, grandchild, =, child, ,, child, =, parent, ,, parent, =]
[child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, grandchild, =, child, ,, child, =, parent, ,, parent, =]
[grandchild, =, child, ,, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, int, parentType, =]
[grandchild, =, child, ,, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, int, parentType, =]
[parent, ,, parent, =, child, ., getParent, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;]
[parent, ,, parent, =, child, ., getParent, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;]
[child, ., getParent, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (]
[child, ., getParent, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (]
[., getParent, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (, !]
[(, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (, !, isConditionalOp, (]
[{, int, parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (, !, isConditionalOp, (, parent, ), ||]
[{, int, parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (, !, isConditionalOp, (, parent, ), ||]
[parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (, !, isConditionalOp, (, parent, ), ||, child, ==]
[parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (, !, isConditionalOp, (, parent, ), ||, child, ==]
[., checkState, (, !, isConditionalOp, (, parent, ), ||, child, ==, parent, ., getFirstChild, (, ), ), ;, if, (]
[., checkState, (, !, isConditionalOp, (, parent, ), ||, child, ==, parent, ., getFirstChild, (, ), ), ;, if, (]
[(, !, isConditionalOp, (, parent, ), ||, child, ==, parent, ., getFirstChild, (, ), ), ;, if, (, parentType, ==]
[(, !, isConditionalOp, (, parent, ), ||, child, ==, parent, ., getFirstChild, (, ), ), ;, if, (, parentType, ==]
[child, ==, parent, ., getFirstChild, (, ), ), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (]
[parent, ., getFirstChild, (, ), ), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (, isSafeAssign, (]
[getFirstChild, (, ), ), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (, isSafeAssign, (, parent, ,]
[getFirstChild, (, ), ), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (, isSafeAssign, (, parent, ,]
[), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects, ), ), {, }, else, {, Node, left, =]
[), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects, ), ), {, }, else, {, Node, left, =]
[., sideEffects, ), ), {, }, else, {, Node, left, =, parent, ., getFirstChild, (, ), ;, int, type, =]
[., sideEffects, ), ), {, }, else, {, Node, left, =, parent, ., getFirstChild, (, ), ;, int, type, =]
[Node, left, =, parent, ., getFirstChild, (, ), ;, int, type, =, left, ., getType, (, ), ;, if, (]
[Node, left, =, parent, ., getFirstChild, (, ), ;, int, type, =, left, ., getType, (, ), ;, if, (]
[=, parent, ., getFirstChild, (, ), ;, int, type, =, left, ., getType, (, ), ;, if, (, left, !=]
[getFirstChild, (, ), ;, int, type, =, left, ., getType, (, ), ;, if, (, left, !=, child, ), {]
[getFirstChild, (, ), ;, int, type, =, left, ., getType, (, ), ;, if, (, left, !=, child, ), {]
[int, type, =, left, ., getType, (, ), ;, if, (, left, !=, child, ), {, Preconditions, ., checkState, (]
[int, type, =, left, ., getType, (, ), ;, if, (, left, !=, child, ), {, Preconditions, ., checkState, (]
[., getType, (, ), ;, if, (, left, !=, child, ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (]
[(, left, !=, child, ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;, if, (]
[(, left, !=, child, ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;, if, (]
[!=, child, ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;, if, (, type, ==]
[!=, child, ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;, if, (, type, ==]
[., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;, if, (, type, ==, Token, ., GETELEM, ), {]
[(, NodeUtil, ., isGet, (, left, ), ), ;, if, (, type, ==, Token, ., GETELEM, ), {, decomposeSubExpressions, (]
[(, NodeUtil, ., isGet, (, left, ), ), ;, if, (, type, ==, Token, ., GETELEM, ), {, decomposeSubExpressions, (]
[), ), ;, if, (, type, ==, Token, ., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,]
[;, if, (, type, ==, Token, ., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,]
[==, Token, ., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,, state, ), ;, }]
[., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,, state, ), ;, }, decomposeSubExpressions, (]
[., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,, state, ), ;, }, decomposeSubExpressions, (]
[left, ., getLastChild, (, ), ,, null, ,, state, ), ;, }, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,]
[getLastChild, (, ), ,, null, ,, state, ), ;, }, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null, ,]
[}, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null, ,, state, ), ;, }, }, }, else, if, (]
[}, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null, ,, state, ), ;, }, }, }, else, if, (]
[}, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null, ,, state, ), ;, }, }, }, else, if, (]
[(, left, ., getFirstChild, (, ), ,, null, ,, state, ), ;, }, }, }, else, if, (, parentType, ==]
[(, left, ., getFirstChild, (, ), ,, null, ,, state, ), ;, }, }, }, else, if, (, parentType, ==]
[(, ), ,, null, ,, state, ), ;, }, }, }, else, if, (, parentType, ==, Token, ., CALL, &&]
[(, ), ,, null, ,, state, ), ;, }, }, }, else, if, (, parentType, ==, Token, ., CALL, &&]
[,, state, ), ;, }, }, }, else, if, (, parentType, ==, Token, ., CALL, &&, NodeUtil, ., isGet, (]
[,, state, ), ;, }, }, }, else, if, (, parentType, ==, Token, ., CALL, &&, NodeUtil, ., isGet, (]
[==, Token, ., CALL, &&, NodeUtil, ., isGet, (, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =]
[==, Token, ., CALL, &&, NodeUtil, ., isGet, (, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =]
[., isGet, (, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;]
[(, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;, decomposeSubExpressions, (]
[(, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;, decomposeSubExpressions, (]
[), ), {, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,]
[{, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child, ,]
[., getFirstChild, (, ), ;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child, ,, state, ), ;, if, (]
[., getFirstChild, (, ), ;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child, ,, state, ), ;, if, (]
[(, ), ;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (]
[;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,]
[;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,]
[getNext, (, ), ,, child, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&]
[getNext, (, ), ,, child, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&]
[getNext, (, ), ,, child, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&]
[state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=]
[if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {]
[if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {]
[functionExpression, ,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {, Preconditions, ., checkState, (]
[sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,]
[functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;]
[functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;]
[), !=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =]
[Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true, ;, Node, replacement, =]
[checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true, ;, Node, replacement, =, rewriteCallExpression, (]
[allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true, ;, Node, replacement, =, rewriteCallExpression, (, parent, ,]
[,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true, ;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;]
[), ;, state, ., sideEffects, =, true, ;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =]
[;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =, replacement, ;, }, }, else, if, (]
[;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =, replacement, ;, }, }, else, if, (]
[replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =, replacement, ;, }, }, else, if, (, parentType, ==]
[replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =, replacement, ;, }, }, else, if, (, parentType, ==]
[,, state, ), ;, parent, =, replacement, ;, }, }, else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {]
[), ;, parent, =, replacement, ;, }, }, else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (]
[), ;, parent, =, replacement, ;, }, }, else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (]
[}, }, else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,]
[else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,, child, ,]
[., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, else, {]
[), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, else, {, decomposeSubExpressions, (]
[), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, else, {, decomposeSubExpressions, (]
[getFirstChild, (, ), ,, child, ,, state, ), ;, }, else, {, decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,]
[), ,, child, ,, state, ), ;, }, else, {, decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,, child, ,]
[}, else, {, decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, }, if, (]
[}, else, {, decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, }, if, (]
[{, decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, }, if, (, nonconditionalExpr, ==]
[child, ,, state, ), ;, }, }, if, (, nonconditionalExpr, ==, subExpression, ), {, }, else, {, Node, parent, =]
[child, ,, state, ), ;, }, }, if, (, nonconditionalExpr, ==, subExpression, ), {, }, else, {, Node, parent, =]
[nonconditionalExpr, ==, subExpression, ), {, }, else, {, Node, parent, =, nonconditionalExpr, ., getParent, (, ), ;, boolean, needResult, =]
[==, subExpression, ), {, }, else, {, Node, parent, =, nonconditionalExpr, ., getParent, (, ), ;, boolean, needResult, =, !]
[==, subExpression, ), {, }, else, {, Node, parent, =, nonconditionalExpr, ., getParent, (, ), ;, boolean, needResult, =, !]
[=, nonconditionalExpr, ., getParent, (, ), ;, boolean, needResult, =, !, parent, ., isExprResult, (, ), ;, Node, extractedConditional, =]
[., getParent, (, ), ;, boolean, needResult, =, !, parent, ., isExprResult, (, ), ;, Node, extractedConditional, =, extractConditional, (]
[(, ), ;, boolean, needResult, =, !, parent, ., isExprResult, (, ), ;, Node, extractedConditional, =, extractConditional, (, nonconditionalExpr, ,]
[;, boolean, needResult, =, !, parent, ., isExprResult, (, ), ;, Node, extractedConditional, =, extractConditional, (, nonconditionalExpr, ,, exprInjectionPoint, ,]
[=, extractConditional, (, nonconditionalExpr, ,, exprInjectionPoint, ,, needResult, ), ;, }, }, private, static, boolean, allowObjectCallDecomposing, (, ), {, return]
[private, static, boolean, allowObjectCallDecomposing, (, ), {, return, false, ;, }, private, boolean, maybeExternMethod, (, Node, node, ), {, return]
[{, return, true, ;, }, private, static, Node, findNonconditionalParent, (, Node, subExpression, ,, Node, expressionRoot, ), {, Node, result, =]
[Node, findNonconditionalParent, (, Node, subExpression, ,, Node, expressionRoot, ), {, Node, result, =, subExpression, ;, for, (, Node, child, =]
[subExpression, ,, Node, expressionRoot, ), {, Node, result, =, subExpression, ;, for, (, Node, child, =, subExpression, ,, parent, =]
[subExpression, ,, Node, expressionRoot, ), {, Node, result, =, subExpression, ;, for, (, Node, child, =, subExpression, ,, parent, =]
[Node, result, =, subExpression, ;, for, (, Node, child, =, subExpression, ,, parent, =, child, ., getParent, (, ), ;]
[Node, result, =, subExpression, ;, for, (, Node, child, =, subExpression, ,, parent, =, child, ., getParent, (, ), ;]
[=, subExpression, ;, for, (, Node, child, =, subExpression, ,, parent, =, child, ., getParent, (, ), ;, parent, !=]
[;, for, (, Node, child, =, subExpression, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;]
[(, Node, child, =, subExpression, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, child, =]
[child, =, subExpression, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, child, =, parent, ,]
[subExpression, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, child, =, parent, ,, parent, =]
[subExpression, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, child, =, parent, ,, parent, =]
[;, parent, !=, expressionRoot, ;, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, if, (]
[!=, expressionRoot, ;, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (]
[,, parent, =, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, ), ), {, if, (]
[,, parent, =, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, ), ), {, if, (]
[=, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=]
[=, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=]
[{, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=, parent, ., getFirstChild, (, ), ), {]
[(, isConditionalOp, (, parent, ), ), {, if, (, child, !=, parent, ., getFirstChild, (, ), ), {, result, =]
[{, if, (, child, !=, parent, ., getFirstChild, (, ), ), {, result, =, parent, ;, }, }, }, return]
[Node, extractBeforeStatement, ;, }, private, void, decomposeObjectLiteralKeys, (, Node, key, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (]
[Node, extractBeforeStatement, ;, }, private, void, decomposeObjectLiteralKeys, (, Node, key, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (]
[Node, extractBeforeStatement, ;, }, private, void, decomposeObjectLiteralKeys, (, Node, key, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (]
[;, }, private, void, decomposeObjectLiteralKeys, (, Node, key, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, key, ==]
[private, void, decomposeObjectLiteralKeys, (, Node, key, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, key, ==, null, ||]
[private, void, decomposeObjectLiteralKeys, (, Node, key, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, key, ==, null, ||]
[decomposeObjectLiteralKeys, (, Node, key, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, key, ==, null, ||, key, ==]
[stopNode, ,, DecompositionState, state, ), {, if, (, key, ==, null, ||, key, ==, stopNode, ), {, return, ;, }]
[DecompositionState, state, ), {, if, (, key, ==, null, ||, key, ==, stopNode, ), {, return, ;, }, decomposeObjectLiteralKeys, (]
[DecompositionState, state, ), {, if, (, key, ==, null, ||, key, ==, stopNode, ), {, return, ;, }, decomposeObjectLiteralKeys, (]
[key, ==, null, ||, key, ==, stopNode, ), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,]
[null, ||, key, ==, stopNode, ), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,]
[==, stopNode, ), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state, ), ;]
[), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state, ), ;, decomposeSubExpressions, (]
[), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state, ), ;, decomposeSubExpressions, (]
[(, key, ., getNext, (, ), ,, stopNode, ,, state, ), ;, decomposeSubExpressions, (, key, ., getFirstChild, (, ), ,]
[., getNext, (, ), ,, stopNode, ,, state, ), ;, decomposeSubExpressions, (, key, ., getFirstChild, (, ), ,, stopNode, ,]
[state, ), ;, }, private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (]
[state, ), ;, }, private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (]
[state, ), ;, }, private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (]
[;, }, private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, n, ==]
[private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, n, ==, null, ||]
[private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, n, ==, null, ||]
[decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, n, ==, null, ||, n, ==]
[stopNode, ,, DecompositionState, state, ), {, if, (, n, ==, null, ||, n, ==, stopNode, ), {, return, ;, }]
[stopNode, ,, DecompositionState, state, ), {, if, (, n, ==, null, ||, n, ==, stopNode, ), {, return, ;, }]
[), {, if, (, n, ==, null, ||, n, ==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (]
[{, if, (, n, ==, null, ||, n, ==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (, !]
[{, if, (, n, ==, null, ||, n, ==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (, !]
[==, null, ||, n, ==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (]
[||, n, ==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,]
[||, n, ==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,]
[}, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (, ), ), ), ;]
[., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (, ), ), ), ;, decomposeSubExpressions, (]
[., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (, ), ), ), ;, decomposeSubExpressions, (]
[isObjectLitKey, (, n, ,, n, ., getParent, (, ), ), ), ;, decomposeSubExpressions, (, n, ., getNext, (, ), ,]
[n, ,, n, ., getParent, (, ), ), ), ;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,]
[(, ), ), ), ;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, ), ;, if, (]
[), ), ;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (]
[;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n, ,]
[;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n, ,]
[(, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {]
[(, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {]
[,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {, state, ., sideEffects, =]
[), ;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {, state, ., sideEffects, =, true, ;]
[), ;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {, state, ., sideEffects, =, true, ;]
[isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {, state, ., sideEffects, =, true, ;, state, ., extractBeforeStatement, =]
[n, ,, state, ., sideEffects, ), ), {, state, ., sideEffects, =, true, ;, state, ., extractBeforeStatement, =, extractExpression, (]
[state, ., sideEffects, ), ), {, state, ., sideEffects, =, true, ;, state, ., extractBeforeStatement, =, extractExpression, (, n, ,]
[state, ., sideEffects, ), ), {, state, ., sideEffects, =, true, ;, state, ., extractBeforeStatement, =, extractExpression, (, n, ,]
[;, }, }, private, Node, extractConditional, (, Node, expr, ,, Node, injectionPoint, ,, boolean, needResult, ), {, Node, parent, =]
[;, }, }, private, Node, extractConditional, (, Node, expr, ,, Node, injectionPoint, ,, boolean, needResult, ), {, Node, parent, =]
[,, Node, injectionPoint, ,, boolean, needResult, ), {, Node, parent, =, expr, ., getParent, (, ), ;, String, tempName, =]
[{, Node, parent, =, expr, ., getParent, (, ), ;, String, tempName, =, getTempValueName, (, ), ;, Node, first, =]
[{, Node, parent, =, expr, ., getParent, (, ), ;, String, tempName, =, getTempValueName, (, ), ;, Node, first, =]
[;, String, tempName, =, getTempValueName, (, ), ;, Node, first, =, expr, ., getFirstChild, (, ), ;, Node, second, =]
[;, String, tempName, =, getTempValueName, (, ), ;, Node, first, =, expr, ., getFirstChild, (, ), ;, Node, second, =]
[first, =, expr, ., getFirstChild, (, ), ;, Node, second, =, first, ., getNext, (, ), ;, Node, last, =]
[first, =, expr, ., getFirstChild, (, ), ;, Node, second, =, first, ., getNext, (, ), ;, Node, last, =]
[), ;, Node, second, =, first, ., getNext, (, ), ;, Node, last, =, expr, ., getLastChild, (, ), ;]
[), ;, Node, second, =, first, ., getNext, (, ), ;, Node, last, =, expr, ., getLastChild, (, ), ;]
[), ;, Node, last, =, expr, ., getLastChild, (, ), ;, expr, ., detachChildren, (, ), ;, Node, cond, =]
[expr, ., getLastChild, (, ), ;, expr, ., detachChildren, (, ), ;, Node, cond, =, null, ;, Node, trueExpr, =]
[expr, ., getLastChild, (, ), ;, expr, ., detachChildren, (, ), ;, Node, cond, =, null, ;, Node, trueExpr, =]
[expr, ., getLastChild, (, ), ;, expr, ., detachChildren, (, ), ;, Node, cond, =, null, ;, Node, trueExpr, =]
[detachChildren, (, ), ;, Node, cond, =, null, ;, Node, trueExpr, =, IR, ., block, (, ), ., srcref, (]
[=, null, ;, Node, trueExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;, Node, falseExpr, =]
[=, null, ;, Node, trueExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;, Node, falseExpr, =]
[=, null, ;, Node, trueExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;, Node, falseExpr, =]
[block, (, ), ., srcref, (, expr, ), ;, Node, falseExpr, =, IR, ., block, (, ), ., srcref, (]
[(, expr, ), ;, Node, falseExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;, switch, (]
[(, expr, ), ;, Node, falseExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;, switch, (]
[., block, (, ), ., srcref, (, expr, ), ;, switch, (, expr, ., getType, (, ), ), {, case]
[., block, (, ), ., srcref, (, expr, ), ;, switch, (, expr, ., getType, (, ), ), {, case]
[., srcref, (, expr, ), ;, switch, (, expr, ., getType, (, ), ), {, case, Token, ., HOOK, :]
[(, expr, ), ;, switch, (, expr, ., getType, (, ), ), {, case, Token, ., HOOK, :, cond, =]
[), ;, switch, (, expr, ., getType, (, ), ), {, case, Token, ., HOOK, :, cond, =, first, ;]
[), ;, switch, (, expr, ., getType, (, ), ), {, case, Token, ., HOOK, :, cond, =, first, ;]
[expr, ., getType, (, ), ), {, case, Token, ., HOOK, :, cond, =, first, ;, trueExpr, ., addChildToFront, (]
[expr, ., getType, (, ), ), {, case, Token, ., HOOK, :, cond, =, first, ;, trueExpr, ., addChildToFront, (]
[), ), {, case, Token, ., HOOK, :, cond, =, first, ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (]
[{, case, Token, ., HOOK, :, cond, =, first, ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (]
[Token, ., HOOK, :, cond, =, first, ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,]
[HOOK, :, cond, =, first, ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,]
[;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), ), ), ;]
[;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), ), ), ;]
[(, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), ), ), ;, falseExpr, ., addChildToFront, (]
[(, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), ), ), ;, falseExpr, ., addChildToFront, (]
[(, buildResultExpression, (, second, ,, needResult, ,, tempName, ), ), ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (]
[(, second, ,, needResult, ,, tempName, ), ), ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (]
[,, needResult, ,, tempName, ), ), ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,]
[,, tempName, ), ), ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,]
[addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case]
[addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case]
[newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., AND, :]
[buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., AND, :, cond, =]
[last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (]
[needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,]
[tempName, ), ), ), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,]
[), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;]
[), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;]
[case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (]
[case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (]
[:, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (]
[=, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (]
[(, first, ,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,]
[,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,]
[addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case]
[addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case]
[newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., OR, :]
[buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., OR, :, cond, =]
[last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (]
[needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,]
[tempName, ), ), ), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,]
[), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;]
[), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;]
[case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (]
[case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (]
[:, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (]
[=, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (]
[(, first, ,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,]
[,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,]
[NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, default, :, throw]
[(, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, default, :, throw, new, IllegalStateException, (]
[), ), ;, break, ;, default, :, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode, ;, if, (]
[), ), ;, break, ;, default, :, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode, ;, if, (]
[throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode, ;, if, (, falseExpr, ., hasChildren, (, ), ), {]
[IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode, ;, if, (, falseExpr, ., hasChildren, (, ), ), {, ifNode, =]
[IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode, ;, if, (, falseExpr, ., hasChildren, (, ), ), {, ifNode, =]
[;, }, Node, ifNode, ;, if, (, falseExpr, ., hasChildren, (, ), ), {, ifNode, =, IR, ., ifNode, (]
[Node, ifNode, ;, if, (, falseExpr, ., hasChildren, (, ), ), {, ifNode, =, IR, ., ifNode, (, cond, ,]
[;, if, (, falseExpr, ., hasChildren, (, ), ), {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ,]
[(, ), ), {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ,, falseExpr, ), ;, }, else, {]
[), {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =]
[), {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =]
[IR, ., ifNode, (, cond, ,, trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =, IR, ., ifNode, (]
[ifNode, (, cond, ,, trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =, IR, ., ifNode, (, cond, ,]
[trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ), ;, }]
[trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ), ;, }]
[;, }, else, {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom, (]
[=, IR, ., ifNode, (, cond, ,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (]
[,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (, needResult, ), {, Node, tempVarNode, =]
[,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (, needResult, ), {, Node, tempVarNode, =]
[,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (, needResult, ), {, Node, tempVarNode, =]
[}, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (, needResult, ), {, Node, tempVarNode, =, NodeUtil, ., newVarNode, (]
[., copyInformationFrom, (, expr, ), ;, if, (, needResult, ), {, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,]
[;, if, (, needResult, ), {, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, null, ), ., copyInformationFromForTree, (]
[Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, null, ), ., copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =]
[Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, null, ), ., copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =]
[(, tempName, ,, null, ), ., copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;]
[(, tempName, ,, null, ), ., copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;]
[), ., copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (]
[copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,]
[), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;]
[), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;]
[=, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, injectionPointParent, ., addChildAfter, (]
[., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, injectionPointParent, ., addChildAfter, (, ifNode, ,]
[., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =]
[., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =]
[,, injectionPoint, ), ;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (]
[;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ;]
[;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ;]
[(, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ;, parent, ., replaceChild, (]
[,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ;, parent, ., replaceChild, (, expr, ,]
[=, IR, ., name, (, tempName, ), ;, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, }, else, {]
[=, IR, ., name, (, tempName, ), ;, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, }, else, {]
[(, tempName, ), ;, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, }, else, {, Preconditions, ., checkArgument, (]
[(, tempName, ), ;, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, }, else, {, Preconditions, ., checkArgument, (]
[replacementValueNode, ), ;, }, else, {, Preconditions, ., checkArgument, (, parent, ., isExprResult, (, ), ), ;, Node, gramps, =]
[replacementValueNode, ), ;, }, else, {, Preconditions, ., checkArgument, (, parent, ., isExprResult, (, ), ), ;, Node, gramps, =]
[Preconditions, ., checkArgument, (, parent, ., isExprResult, (, ), ), ;, Node, gramps, =, parent, ., getParent, (, ), ;]
[Preconditions, ., checkArgument, (, parent, ., isExprResult, (, ), ), ;, Node, gramps, =, parent, ., getParent, (, ), ;]
[parent, ., isExprResult, (, ), ), ;, Node, gramps, =, parent, ., getParent, (, ), ;, gramps, ., replaceChild, (]
[isExprResult, (, ), ), ;, Node, gramps, =, parent, ., getParent, (, ), ;, gramps, ., replaceChild, (, parent, ,]
[Node, gramps, =, parent, ., getParent, (, ), ;, gramps, ., replaceChild, (, parent, ,, ifNode, ), ;, }, return]
[ifNode, ;, }, private, static, Node, buildResultExpression, (, Node, expr, ,, boolean, needResult, ,, String, tempName, ), {, if, (]
[static, Node, buildResultExpression, (, Node, expr, ,, boolean, needResult, ,, String, tempName, ), {, if, (, needResult, ), {, return]
[static, Node, buildResultExpression, (, Node, expr, ,, boolean, needResult, ,, String, tempName, ), {, if, (, needResult, ), {, return]
[static, Node, buildResultExpression, (, Node, expr, ,, boolean, needResult, ,, String, tempName, ), {, if, (, needResult, ), {, return]
[Node, expr, ,, boolean, needResult, ,, String, tempName, ), {, if, (, needResult, ), {, return, IR, ., assign, (]
[Node, expr, ,, boolean, needResult, ,, String, tempName, ), {, if, (, needResult, ), {, return, IR, ., assign, (]
[needResult, ,, String, tempName, ), {, if, (, needResult, ), {, return, IR, ., assign, (, IR, ., name, (]
[tempName, ), {, if, (, needResult, ), {, return, IR, ., assign, (, IR, ., name, (, tempName, ), ,]
[needResult, ), {, return, IR, ., assign, (, IR, ., name, (, tempName, ), ,, expr, ), ., srcrefTree, (]
[(, IR, ., name, (, tempName, ), ,, expr, ), ., srcrefTree, (, expr, ), ;, }, else, {, return]
[return, expr, ;, }, }, private, boolean, isConstantName, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, return]
[return, expr, ;, }, }, private, boolean, isConstantName, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, return]
[return, expr, ;, }, }, private, boolean, isConstantName, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, return]
[boolean, isConstantName, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, return, n, ., isName, (, ), &&]
[isConstantName, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, return, n, ., isName, (, ), &&, (]
[isConstantName, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, return, n, ., isName, (, ), &&, (]
[isConstantName, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, return, n, ., isName, (, ), &&, (]
[,, Set, <, String, >, knownConstants, ), {, return, n, ., isName, (, ), &&, (, NodeUtil, ., isConstantName, (]
[String, >, knownConstants, ), {, return, n, ., isName, (, ), &&, (, NodeUtil, ., isConstantName, (, n, ), ||]
[String, >, knownConstants, ), {, return, n, ., isName, (, ), &&, (, NodeUtil, ., isConstantName, (, n, ), ||]
[{, return, n, ., isName, (, ), &&, (, NodeUtil, ., isConstantName, (, n, ), ||, knownConstants, ., contains, (]
[{, return, n, ., isName, (, ), &&, (, NodeUtil, ., isConstantName, (, n, ), ||, knownConstants, ., contains, (]
[(, ), ), ), ;, }, private, Node, extractExpression, (, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =]
[(, ), ), ), ;, }, private, Node, extractExpression, (, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =]
[(, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =, expr, ., getParent, (, ), ;, boolean, isLhsOfAssignOp, =]
[(, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =, expr, ., getParent, (, ), ;, boolean, isLhsOfAssignOp, =]
[(, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =, expr, ., getParent, (, ), ;, boolean, isLhsOfAssignOp, =]
[(, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =, expr, ., getParent, (, ), ;, boolean, isLhsOfAssignOp, =]
[Node, injectionPoint, ), {, Node, parent, =, expr, ., getParent, (, ), ;, boolean, isLhsOfAssignOp, =, NodeUtil, ., isAssignmentOp, (]
[{, Node, parent, =, expr, ., getParent, (, ), ;, boolean, isLhsOfAssignOp, =, NodeUtil, ., isAssignmentOp, (, parent, ), &&]
[Node, parent, =, expr, ., getParent, (, ), ;, boolean, isLhsOfAssignOp, =, NodeUtil, ., isAssignmentOp, (, parent, ), &&, !]
[Node, parent, =, expr, ., getParent, (, ), ;, boolean, isLhsOfAssignOp, =, NodeUtil, ., isAssignmentOp, (, parent, ), &&, !]
[(, ), ;, boolean, isLhsOfAssignOp, =, NodeUtil, ., isAssignmentOp, (, parent, ), &&, !, parent, ., isAssign, (, ), &&]
[(, ), ;, boolean, isLhsOfAssignOp, =, NodeUtil, ., isAssignmentOp, (, parent, ), &&, !, parent, ., isAssign, (, ), &&]
[(, ), ;, boolean, isLhsOfAssignOp, =, NodeUtil, ., isAssignmentOp, (, parent, ), &&, !, parent, ., isAssign, (, ), &&]
[NodeUtil, ., isAssignmentOp, (, parent, ), &&, !, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==]
[), &&, !, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =]
[., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (]
[., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (]
[(, ), &&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&]
[(, ), &&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&]
[., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, ., isGet, (]
[=, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, ., isGet, (, expr, ), ), {, for, (, Node, n, :]
[=, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, ., isGet, (, expr, ), ), {, for, (, Node, n, :]
[isGet, (, expr, ), ), {, for, (, Node, n, :, expr, ., children, (, ), ), {, if, (]
[isGet, (, expr, ), ), {, for, (, Node, n, :, expr, ., children, (, ), ), {, if, (]
[(, expr, ), ), {, for, (, Node, n, :, expr, ., children, (, ), ), {, if, (, !]
[(, expr, ), ), {, for, (, Node, n, :, expr, ., children, (, ), ), {, if, (, !]
[(, Node, n, :, expr, ., children, (, ), ), {, if, (, !, n, ., isString, (, ), &&]
[Node, n, :, expr, ., children, (, ), ), {, if, (, !, n, ., isString, (, ), &&, !]
[:, expr, ., children, (, ), ), {, if, (, !, n, ., isString, (, ), &&, !, isConstantName, (]
[., children, (, ), ), {, if, (, !, n, ., isString, (, ), &&, !, isConstantName, (, n, ,]
[(, !, n, ., isString, (, ), &&, !, isConstantName, (, n, ,, knownConstants, ), ), {, Node, extractedNode, =]
[n, ., isString, (, ), &&, !, isConstantName, (, n, ,, knownConstants, ), ), {, Node, extractedNode, =, extractExpression, (]
[isString, (, ), &&, !, isConstantName, (, n, ,, knownConstants, ), ), {, Node, extractedNode, =, extractExpression, (, n, ,]
[isConstantName, (, n, ,, knownConstants, ), ), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (]
[isConstantName, (, n, ,, knownConstants, ), ), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (]
[n, ,, knownConstants, ), ), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==]
[), ), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {]
[{, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =]
[), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String, tempName, =]
[), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String, tempName, =, getTempConstantValueName, (, ), ;, Node, replacementValueNode, =]
[), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String, tempName, =, getTempConstantValueName, (, ), ;, Node, replacementValueNode, =]
[), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String, tempName, =, getTempConstantValueName, (, ), ;, Node, replacementValueNode, =]
[extractedNode, ;, }, }, }, }, String, tempName, =, getTempConstantValueName, (, ), ;, Node, replacementValueNode, =, IR, ., name, (]
[}, String, tempName, =, getTempConstantValueName, (, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ., srcref, (]
[Node, replacementValueNode, =, IR, ., name, (, tempName, ), ., srcref, (, expr, ), ;, Node, tempNameValue, ;, if, (]
[IR, ., name, (, tempName, ), ., srcref, (, expr, ), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {]
[IR, ., name, (, tempName, ), ., srcref, (, expr, ), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {]
[tempName, ), ., srcref, (, expr, ), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (]
[tempName, ), ., srcref, (, expr, ), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (]
[tempName, ), ., srcref, (, expr, ), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (]
[), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (, expr, ., isName, (, ), ||]
[), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (, expr, ., isName, (, ), ||]
[;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (, expr, ., isName, (, ), ||, NodeUtil, ., isGet, (]
[., checkState, (, expr, ., isName, (, ), ||, NodeUtil, ., isGet, (, expr, ), ), ;, Node, opNode, =]
[., checkState, (, expr, ., isName, (, ), ||, NodeUtil, ., isGet, (, expr, ), ), ;, Node, opNode, =]
[expr, ., isName, (, ), ||, NodeUtil, ., isGet, (, expr, ), ), ;, Node, opNode, =, new, Node, (]
[expr, ., isName, (, ), ||, NodeUtil, ., isGet, (, expr, ), ), ;, Node, opNode, =, new, Node, (]
[), ||, NodeUtil, ., isGet, (, expr, ), ), ;, Node, opNode, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (]
[expr, ), ), ;, Node, opNode, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (]
[=, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =]
[=, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =]
[getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;]
[getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;]
[), ., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;, parent, ., setType, (]
[), ., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;, parent, ., setType, (]
[), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;, parent, ., setType, (, Token, ., ASSIGN, ), ;]
[), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;, parent, ., setType, (, Token, ., ASSIGN, ), ;]
[=, parent, ., getLastChild, (, ), ;, parent, ., setType, (, Token, ., ASSIGN, ), ;, parent, ., replaceChild, (]
[., getLastChild, (, ), ;, parent, ., setType, (, Token, ., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,]
[), ;, parent, ., setType, (, Token, ., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;]
[), ;, parent, ., setType, (, Token, ., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;]
[setType, (, Token, ., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront, (]
[., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;]
[., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;]
[parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack, (]
[(, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack, (, rightOperand, ), ;]
[,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =]
[,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =]
[), ;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {]
[), ;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {]
[addChildToBack, (, rightOperand, ), ;, tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {, parent, ., replaceChild, (]
[rightOperand, ), ;, tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {, parent, ., replaceChild, (, expr, ,]
[tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;]
[expr, ., cloneTree, (, ), ;, }, else, {, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, tempNameValue, =]
[}, else, {, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, tempNameValue, =, expr, ;, }, Node, tempVarNode, =]
[}, else, {, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, tempNameValue, =, expr, ;, }, Node, tempVarNode, =]
[., replaceChild, (, expr, ,, replacementValueNode, ), ;, tempNameValue, =, expr, ;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (]
[(, expr, ,, replacementValueNode, ), ;, tempNameValue, =, expr, ;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,]
[tempNameValue, =, expr, ;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, ), ;, Node, injectionPointParent, =]
[tempNameValue, =, expr, ;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, ), ;, Node, injectionPointParent, =]
[tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;]
[tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;]
[newVarNode, (, tempName, ,, tempNameValue, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (]
[tempName, ,, tempNameValue, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,]
[Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if, (]
[Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if, (]
[=, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==]
[getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {]
[), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =]
[addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, tempVarNode, ;, }, return]
[firstExtractedNode, =, tempVarNode, ;, }, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression, (, Node, call, ,, DecompositionState, state, ), {]
[firstExtractedNode, =, tempVarNode, ;, }, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression, (, Node, call, ,, DecompositionState, state, ), {]
[}, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression, (, Node, call, ,, DecompositionState, state, ), {, Preconditions, ., checkArgument, (]
[}, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression, (, Node, call, ,, DecompositionState, state, ), {, Preconditions, ., checkArgument, (]
[call, ,, DecompositionState, state, ), {, Preconditions, ., checkArgument, (, call, ., isCall, (, ), ), ;, Node, first, =]
[call, ,, DecompositionState, state, ), {, Preconditions, ., checkArgument, (, call, ., isCall, (, ), ), ;, Node, first, =]
[Preconditions, ., checkArgument, (, call, ., isCall, (, ), ), ;, Node, first, =, call, ., getFirstChild, (, ), ;]
[Preconditions, ., checkArgument, (, call, ., isCall, (, ), ), ;, Node, first, =, call, ., getFirstChild, (, ), ;]
[call, ., isCall, (, ), ), ;, Node, first, =, call, ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (]
[call, ., isCall, (, ), ), ;, Node, first, =, call, ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (]
[), ), ;, Node, first, =, call, ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (]
[., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, first, ), ), ;, Node, getVarNode, =]
[(, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, first, ), ), ;, Node, getVarNode, =, extractExpression, (]
[;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, first, ), ), ;, Node, getVarNode, =, extractExpression, (, first, ,]
[;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, first, ), ), ;, Node, getVarNode, =, extractExpression, (, first, ,]
[NodeUtil, ., isGet, (, first, ), ), ;, Node, getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;]
[NodeUtil, ., isGet, (, first, ), ), ;, Node, getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;]
[first, ), ), ;, Node, getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =]
[getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =]
[getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =]
[getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =]
[;, state, ., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, ), ;]
[;, state, ., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, ), ;]
[=, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (]
[=, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (]
[getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (]
[., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, getExprNode, ), ), ;, Node, thisVarNode, =]
[(, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, getExprNode, ), ), ;, Node, thisVarNode, =, extractExpression, (]
[(, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, getExprNode, ), ), ;, Node, thisVarNode, =, extractExpression, (]
[(, NodeUtil, ., isGet, (, getExprNode, ), ), ;, Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (, ), ,]
[(, NodeUtil, ., isGet, (, getExprNode, ), ), ;, Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (, ), ,]
[getExprNode, ), ), ;, Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (, ), ,, state, ., extractBeforeStatement, ), ;]
[getExprNode, ), ), ;, Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (, ), ,, state, ., extractBeforeStatement, ), ;]
[Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (, ), ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =]
[getExprNode, ., getFirstChild, (, ), ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =]
[getExprNode, ., getFirstChild, (, ), ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =]
[), ;, state, ., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =]
[), ;, state, ., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =]
[thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node, newCall, =]
[thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node, newCall, =]
[thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node, newCall, =]
[getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node, newCall, =, IR, ., call, (]
[getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node, newCall, =, IR, ., call, (]
[Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node, newCall, =, IR, ., call, (, IR, ., getprop, (]
[Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node, newCall, =, IR, ., call, (, IR, ., getprop, (]
[(, ), ;, Node, newCall, =, IR, ., call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,]
[(, ), ;, Node, newCall, =, IR, ., call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,]
[newCall, =, IR, ., call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,, IR, ., string, (]
[call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,, IR, ., string, (, "call", ), ), ,]
[call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,, IR, ., string, (, "call", ), ), ,]
[(, ), ,, IR, ., string, (, "call", ), ), ,, thisNameNode, ., cloneNode, (, ), ), ., srcref, (]
[IR, ., string, (, "call", ), ), ,, thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, ), ;]
[IR, ., string, (, "call", ), ), ,, thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, ), ;]
[thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, ), ;, call, ., removeFirstChild, (, ), ;, if, (]
[thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, ), ;, call, ., removeFirstChild, (, ), ;, if, (]
[srcref, (, call, ), ;, call, ., removeFirstChild, (, ), ;, if, (, call, ., hasChildren, (, ), ), {]
[srcref, (, call, ), ;, call, ., removeFirstChild, (, ), ;, if, (, call, ., hasChildren, (, ), ), {]
[;, call, ., removeFirstChild, (, ), ;, if, (, call, ., hasChildren, (, ), ), {, newCall, ., addChildrenToBack, (]
[;, call, ., removeFirstChild, (, ), ;, if, (, call, ., hasChildren, (, ), ), {, newCall, ., addChildrenToBack, (]
[hasChildren, (, ), ), {, newCall, ., addChildrenToBack, (, call, ., removeChildren, (, ), ), ;, }, Node, callParent, =]
[hasChildren, (, ), ), {, newCall, ., addChildrenToBack, (, call, ., removeChildren, (, ), ), ;, }, Node, callParent, =]
[., addChildrenToBack, (, call, ., removeChildren, (, ), ), ;, }, Node, callParent, =, call, ., getParent, (, ), ;]
[., addChildrenToBack, (, call, ., removeChildren, (, ), ), ;, }, Node, callParent, =, call, ., getParent, (, ), ;]
[., removeChildren, (, ), ), ;, }, Node, callParent, =, call, ., getParent, (, ), ;, callParent, ., replaceChild, (]
[(, ), ), ;, }, Node, callParent, =, call, ., getParent, (, ), ;, callParent, ., replaceChild, (, call, ,]
[}, Node, callParent, =, call, ., getParent, (, ), ;, callParent, ., replaceChild, (, call, ,, newCall, ), ;, return]
[(, ), ;, callParent, ., replaceChild, (, call, ,, newCall, ), ;, return, newCall, ;, }, private, String, tempNamePrefix, =]
[(, call, ,, newCall, ), ;, return, newCall, ;, }, private, String, tempNamePrefix, =, "JSCompiler_temp", ;, private, String, resultNamePrefix, =]
[tempNamePrefix, =, "JSCompiler_temp", ;, private, String, resultNamePrefix, =, "JSCompiler_inline_result", ;, @, VisibleForTesting, public, void, setTempNamePrefix, (, String, prefix, ), {]
[tempNamePrefix, =, "JSCompiler_temp", ;, private, String, resultNamePrefix, =, "JSCompiler_inline_result", ;, @, VisibleForTesting, public, void, setTempNamePrefix, (, String, prefix, ), {]
[private, String, resultNamePrefix, =, "JSCompiler_inline_result", ;, @, VisibleForTesting, public, void, setTempNamePrefix, (, String, prefix, ), {, this, ., tempNamePrefix, =]
[setTempNamePrefix, (, String, prefix, ), {, this, ., tempNamePrefix, =, prefix, ;, }, private, String, getTempValueName, (, ), {, return]
[setTempNamePrefix, (, String, prefix, ), {, this, ., tempNamePrefix, =, prefix, ;, }, private, String, getTempValueName, (, ), {, return]
[setTempNamePrefix, (, String, prefix, ), {, this, ., tempNamePrefix, =, prefix, ;, }, private, String, getTempValueName, (, ), {, return]
[String, prefix, ), {, this, ., tempNamePrefix, =, prefix, ;, }, private, String, getTempValueName, (, ), {, return, tempNamePrefix, +]
[String, prefix, ), {, this, ., tempNamePrefix, =, prefix, ;, }, private, String, getTempValueName, (, ), {, return, tempNamePrefix, +]
[this, ., tempNamePrefix, =, prefix, ;, }, private, String, getTempValueName, (, ), {, return, tempNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +]
[this, ., tempNamePrefix, =, prefix, ;, }, private, String, getTempValueName, (, ), {, return, tempNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +]
[., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix, ), {]
[., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix, ), {]
[., get, (, ), ;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix, ), {, this, ., resultNamePrefix, =]
[setResultNamePrefix, (, String, prefix, ), {, this, ., resultNamePrefix, =, prefix, ;, }, private, String, getResultValueName, (, ), {, return]
[setResultNamePrefix, (, String, prefix, ), {, this, ., resultNamePrefix, =, prefix, ;, }, private, String, getResultValueName, (, ), {, return]
[setResultNamePrefix, (, String, prefix, ), {, this, ., resultNamePrefix, =, prefix, ;, }, private, String, getResultValueName, (, ), {, return]
[String, prefix, ), {, this, ., resultNamePrefix, =, prefix, ;, }, private, String, getResultValueName, (, ), {, return, resultNamePrefix, +]
[String, prefix, ), {, this, ., resultNamePrefix, =, prefix, ;, }, private, String, getResultValueName, (, ), {, return, resultNamePrefix, +]
[this, ., resultNamePrefix, =, prefix, ;, }, private, String, getResultValueName, (, ), {, return, resultNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +]
[this, ., resultNamePrefix, =, prefix, ;, }, private, String, getResultValueName, (, ), {, return, resultNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +]
[ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =]
[ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =]
[ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =]
[ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =]
[UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +]
[safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +, "_const", +]
[safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +, "_const", +]
[), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +]
[), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +]
[(, ), {, String, name, =, tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;]
[(, ), {, String, name, =, tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;]
[(, ), {, String, name, =, tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;]
[tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, this, ., knownConstants, ., add, (]
[ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, this, ., knownConstants, ., add, (, name, ), ;, return]
[add, (, name, ), ;, return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression, ), {, Node, expressionRoot, =]
[name, ), ;, return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (]
[return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;]
[return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;]
[static, Node, findInjectionPoint, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, Preconditions, ., checkNotNull, (]
[), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, Preconditions, ., checkNotNull, (, expressionRoot, ), ;, Node, injectionPoint, =]
[findExpressionRoot, (, subExpression, ), ;, Preconditions, ., checkNotNull, (, expressionRoot, ), ;, Node, injectionPoint, =, expressionRoot, ;, Node, parent, =]
[findExpressionRoot, (, subExpression, ), ;, Preconditions, ., checkNotNull, (, expressionRoot, ), ;, Node, injectionPoint, =, expressionRoot, ;, Node, parent, =]
[(, expressionRoot, ), ;, Node, injectionPoint, =, expressionRoot, ;, Node, parent, =, injectionPoint, ., getParent, (, ), ;, while, (]
[(, expressionRoot, ), ;, Node, injectionPoint, =, expressionRoot, ;, Node, parent, =, injectionPoint, ., getParent, (, ), ;, while, (]
[expressionRoot, ;, Node, parent, =, injectionPoint, ., getParent, (, ), ;, while, (, parent, ., isLabel, (, ), ), {]
[Node, parent, =, injectionPoint, ., getParent, (, ), ;, while, (, parent, ., isLabel, (, ), ), {, injectionPoint, =]
[=, injectionPoint, ., getParent, (, ), ;, while, (, parent, ., isLabel, (, ), ), {, injectionPoint, =, parent, ;]
[., getParent, (, ), ;, while, (, parent, ., isLabel, (, ), ), {, injectionPoint, =, parent, ;, parent, =]
[., getParent, (, ), ;, while, (, parent, ., isLabel, (, ), ), {, injectionPoint, =, parent, ;, parent, =]
[parent, ., isLabel, (, ), ), {, injectionPoint, =, parent, ;, parent, =, injectionPoint, ., getParent, (, ), ;, }]
[parent, ., isLabel, (, ), ), {, injectionPoint, =, parent, ;, parent, =, injectionPoint, ., getParent, (, ), ;, }]
[), ), {, injectionPoint, =, parent, ;, parent, =, injectionPoint, ., getParent, (, ), ;, }, Preconditions, ., checkState, (]
[), ), {, injectionPoint, =, parent, ;, parent, =, injectionPoint, ., getParent, (, ), ;, }, Preconditions, ., checkState, (]
[=, parent, ;, parent, =, injectionPoint, ., getParent, (, ), ;, }, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (]
[=, parent, ;, parent, =, injectionPoint, ., getParent, (, ), ;, }, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (]
[), ;, }, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPoint, ., getParent, (, ), ), ), ;, return]
[(, ), ), ), ;, return, injectionPoint, ;, }, private, static, boolean, isConditionalOp, (, Node, n, ), {, switch, (]
[(, ), ), ), ;, return, injectionPoint, ;, }, private, static, boolean, isConditionalOp, (, Node, n, ), {, switch, (]
[}, private, static, boolean, isConditionalOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, private, static, boolean, isConditionalOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., HOOK, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., HOOK, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., HOOK, :, case, Token, ., AND, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., HOOK, :, case, Token, ., AND, :, case]
[(, ), ), {, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return]
[Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, true, ;, default, :, return]
[true, ;, default, :, return, false, ;, }, }, static, Node, findExpressionRoot, (, Node, subExpression, ), {, Node, child, =]
[}, }, static, Node, findExpressionRoot, (, Node, subExpression, ), {, Node, child, =, subExpression, ;, for, (, Node, parent, :]
[}, }, static, Node, findExpressionRoot, (, Node, subExpression, ), {, Node, child, =, subExpression, ;, for, (, Node, parent, :]
[Node, child, =, subExpression, ;, for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, int, parentType, =]
[Node, child, =, subExpression, ;, for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, int, parentType, =]
[parent, :, child, ., getAncestors, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, switch, (]
[getAncestors, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, switch, (, parentType, ), {, case]
[getAncestors, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, switch, (, parentType, ), {, case]
[int, parentType, =, parent, ., getType, (, ), ;, switch, (, parentType, ), {, case, Token, ., EXPR_RESULT, :, case]
[int, parentType, =, parent, ., getType, (, ), ;, switch, (, parentType, ), {, case, Token, ., EXPR_RESULT, :, case]
[getType, (, ), ;, switch, (, parentType, ), {, case, Token, ., EXPR_RESULT, :, case, Token, ., IF, :, case]
[getType, (, ), ;, switch, (, parentType, ), {, case, Token, ., EXPR_RESULT, :, case, Token, ., IF, :, case]
[(, parentType, ), {, case, Token, ., EXPR_RESULT, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case]
[(, parentType, ), {, case, Token, ., EXPR_RESULT, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case]
[Token, ., EXPR_RESULT, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case]
[Token, ., EXPR_RESULT, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case]
[case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR, :]
[case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR, :]
[:, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR, :, Preconditions, ., checkState, (]
[:, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR, :, Preconditions, ., checkState, (]
[Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR, :, Preconditions, ., checkState, (, child, ==]
[Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR, :, Preconditions, ., checkState, (, child, ==]
[:, case, Token, ., VAR, :, Preconditions, ., checkState, (, child, ==, parent, ., getFirstChild, (, ), ), ;, return]
[., VAR, :, Preconditions, ., checkState, (, child, ==, parent, ., getFirstChild, (, ), ), ;, return, parent, ;, case]
[., VAR, :, Preconditions, ., checkState, (, child, ==, parent, ., getFirstChild, (, ), ), ;, return, parent, ;, case]
[checkState, (, child, ==, parent, ., getFirstChild, (, ), ), ;, return, parent, ;, case, Token, ., SCRIPT, :, case]
[checkState, (, child, ==, parent, ., getFirstChild, (, ), ), ;, return, parent, ;, case, Token, ., SCRIPT, :, case]
[., getFirstChild, (, ), ), ;, return, parent, ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case]
[., getFirstChild, (, ), ), ;, return, parent, ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case]
[;, return, parent, ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, case]
[;, return, parent, ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, case]
[Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, case, Token, ., CASE, :, case]
[Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, case, Token, ., CASE, :, case]
[Token, ., BLOCK, :, case, Token, ., LABEL, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return]
[:, case, Token, ., LABEL, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, null, ;, }]
[Token, ., LABEL, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, null, ;, }, child, =]
[case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, null, ;, }, child, =, parent, ;, }, throw]
[CASE, :, case, Token, ., DEFAULT_CASE, :, return, null, ;, }, child, =, parent, ;, }, throw, new, IllegalStateException, (]
[;, }, throw, new, IllegalStateException, (, "Unexpected AST structure.", ), ;, }, DecompositionType, canExposeExpression, (, Node, subExpression, ), {, Node, expressionRoot, =]
[throw, new, IllegalStateException, (, "Unexpected AST structure.", ), ;, }, DecompositionType, canExposeExpression, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (]
[), ;, }, DecompositionType, canExposeExpression, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, if, (]
[), ;, }, DecompositionType, canExposeExpression, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, if, (]
[}, DecompositionType, canExposeExpression, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, if, (, expressionRoot, !=]
[Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, if, (, expressionRoot, !=, null, ), {, return]
[), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, if, (, expressionRoot, !=, null, ), {, return, isSubexpressionMovable, (]
[Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, if, (, expressionRoot, !=, null, ), {, return, isSubexpressionMovable, (, expressionRoot, ,]
[subExpression, ), ;, if, (, expressionRoot, !=, null, ), {, return, isSubexpressionMovable, (, expressionRoot, ,, subExpression, ), ;, }, return]
[subExpression, ), ;, if, (, expressionRoot, !=, null, ), {, return, isSubexpressionMovable, (, expressionRoot, ,, subExpression, ), ;, }, return]
[return, DecompositionType, ., UNDECOMPOSABLE, ;, }, private, DecompositionType, isSubexpressionMovable, (, Node, expressionRoot, ,, Node, subExpression, ), {, boolean, requiresDecomposition, =]
[}, private, DecompositionType, isSubexpressionMovable, (, Node, expressionRoot, ,, Node, subExpression, ), {, boolean, requiresDecomposition, =, false, ;, boolean, seenSideEffects, =]
[}, private, DecompositionType, isSubexpressionMovable, (, Node, expressionRoot, ,, Node, subExpression, ), {, boolean, requiresDecomposition, =, false, ;, boolean, seenSideEffects, =]
[(, Node, expressionRoot, ,, Node, subExpression, ), {, boolean, requiresDecomposition, =, false, ;, boolean, seenSideEffects, =, NodeUtil, ., mayHaveSideEffects, (]
[expressionRoot, ,, Node, subExpression, ), {, boolean, requiresDecomposition, =, false, ;, boolean, seenSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, subExpression, ,]
[boolean, requiresDecomposition, =, false, ;, boolean, seenSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, subExpression, ,, compiler, ), ;, Node, child, =]
[=, NodeUtil, ., mayHaveSideEffects, (, subExpression, ,, compiler, ), ;, Node, child, =, subExpression, ;, for, (, Node, parent, :]
[=, NodeUtil, ., mayHaveSideEffects, (, subExpression, ,, compiler, ), ;, Node, child, =, subExpression, ;, for, (, Node, parent, :]
[;, Node, child, =, subExpression, ;, for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, if, (]
[;, Node, child, =, subExpression, ;, for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, if, (]
[child, =, subExpression, ;, for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, if, (, parent, ==]
[for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, if, (, parent, ==, expressionRoot, ), {, return]
[for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, if, (, parent, ==, expressionRoot, ), {, return]
[Node, parent, :, child, ., getAncestors, (, ), ), {, if, (, parent, ==, expressionRoot, ), {, return, requiresDecomposition, ?]
[Node, parent, :, child, ., getAncestors, (, ), ), {, if, (, parent, ==, expressionRoot, ), {, return, requiresDecomposition, ?]
[., getAncestors, (, ), ), {, if, (, parent, ==, expressionRoot, ), {, return, requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :]
[., getAncestors, (, ), ), {, if, (, parent, ==, expressionRoot, ), {, return, requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :]
[parent, ==, expressionRoot, ), {, return, requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;, }, int, parentType, =]
[parent, ==, expressionRoot, ), {, return, requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;, }, int, parentType, =]
[DecompositionType, ., DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;, }, int, parentType, =, parent, ., getType, (, ), ;, if, (]
[DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;, }, int, parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp, (]
[}, int, parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp, (, parent, ), ), {, if, (]
[}, int, parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp, (, parent, ), ), {, if, (]
[parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=]
[parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=]
[;, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=, parent, ., getFirstChild, (, ), ), {]
[(, isConditionalOp, (, parent, ), ), {, if, (, child, !=, parent, ., getFirstChild, (, ), ), {, requiresDecomposition, =]
[(, child, !=, parent, ., getFirstChild, (, ), ), {, requiresDecomposition, =, true, ;, }, }, else, {, if, (]
[!=, parent, ., getFirstChild, (, ), ), {, requiresDecomposition, =, true, ;, }, }, else, {, if, (, isSafeAssign, (]
[., getFirstChild, (, ), ), {, requiresDecomposition, =, true, ;, }, }, else, {, if, (, isSafeAssign, (, parent, ,]
[else, {, if, (, isSafeAssign, (, parent, ,, seenSideEffects, ), ), {, }, else, {, for, (, Node, n, :]
[else, {, if, (, isSafeAssign, (, parent, ,, seenSideEffects, ), ), {, }, else, {, for, (, Node, n, :]
[), ), {, }, else, {, for, (, Node, n, :, parent, ., children, (, ), ), {, if, (]
[), ), {, }, else, {, for, (, Node, n, :, parent, ., children, (, ), ), {, if, (]
[{, }, else, {, for, (, Node, n, :, parent, ., children, (, ), ), {, if, (, n, ==]
[:, parent, ., children, (, ), ), {, if, (, n, ==, child, ), {, break, ;, }, if, (]
[., children, (, ), ), {, if, (, n, ==, child, ), {, break, ;, }, if, (, isExpressionTreeUnsafe, (]
[(, ), ), {, if, (, n, ==, child, ), {, break, ;, }, if, (, isExpressionTreeUnsafe, (, n, ,]
[if, (, n, ==, child, ), {, break, ;, }, if, (, isExpressionTreeUnsafe, (, n, ,, seenSideEffects, ), ), {]
[n, ==, child, ), {, break, ;, }, if, (, isExpressionTreeUnsafe, (, n, ,, seenSideEffects, ), ), {, seenSideEffects, =]
[child, ), {, break, ;, }, if, (, isExpressionTreeUnsafe, (, n, ,, seenSideEffects, ), ), {, seenSideEffects, =, true, ;]
[{, break, ;, }, if, (, isExpressionTreeUnsafe, (, n, ,, seenSideEffects, ), ), {, seenSideEffects, =, true, ;, requiresDecomposition, =]
[(, n, ,, seenSideEffects, ), ), {, seenSideEffects, =, true, ;, requiresDecomposition, =, true, ;, }, }, Node, first, =]
[(, n, ,, seenSideEffects, ), ), {, seenSideEffects, =, true, ;, requiresDecomposition, =, true, ;, }, }, Node, first, =]
[=, true, ;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (]
[=, true, ;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (]
[=, true, ;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (]
[;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (, requiresDecomposition, &&]
[;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (, requiresDecomposition, &&]
[}, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (, requiresDecomposition, &&, parent, ., isCall, (, ), &&]
[}, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (, requiresDecomposition, &&, parent, ., isCall, (, ), &&]
[parent, ., getFirstChild, (, ), ;, if, (, requiresDecomposition, &&, parent, ., isCall, (, ), &&, NodeUtil, ., isGet, (]
[if, (, requiresDecomposition, &&, parent, ., isCall, (, ), &&, NodeUtil, ., isGet, (, first, ), ), {, if, (]
[requiresDecomposition, &&, parent, ., isCall, (, ), &&, NodeUtil, ., isGet, (, first, ), ), {, if, (, maybeExternMethod, (]
[(, ), &&, NodeUtil, ., isGet, (, first, ), ), {, if, (, maybeExternMethod, (, first, ), ), {, return]
[(, ), &&, NodeUtil, ., isGet, (, first, ), ), {, if, (, maybeExternMethod, (, first, ), ), {, return]
[), ), {, if, (, maybeExternMethod, (, first, ), ), {, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, else, {, return]
[), ), {, if, (, maybeExternMethod, (, first, ), ), {, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, else, {, return]
[), ), {, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, else, {, return, DecompositionType, ., DECOMPOSABLE, ;, }, }, }, }]
[{, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, else, {, return, DecompositionType, ., DECOMPOSABLE, ;, }, }, }, }, child, =]
[UNDECOMPOSABLE, ;, }, else, {, return, DecompositionType, ., DECOMPOSABLE, ;, }, }, }, }, child, =, parent, ;, }, throw]
[else, {, return, DecompositionType, ., DECOMPOSABLE, ;, }, }, }, }, child, =, parent, ;, }, throw, new, IllegalStateException, (]
[new, IllegalStateException, (, "Unexpected.", ), ;, }, private, boolean, isSafeAssign, (, Node, n, ,, boolean, seenSideEffects, ), {, if, (]
[new, IllegalStateException, (, "Unexpected.", ), ;, }, private, boolean, isSafeAssign, (, Node, n, ,, boolean, seenSideEffects, ), {, if, (]
[(, Node, n, ,, boolean, seenSideEffects, ), {, if, (, n, ., isAssign, (, ), ), {, Node, lhs, =]
[(, Node, n, ,, boolean, seenSideEffects, ), {, if, (, n, ., isAssign, (, ), ), {, Node, lhs, =]
[if, (, n, ., isAssign, (, ), ), {, Node, lhs, =, n, ., getFirstChild, (, ), ;, switch, (]
[if, (, n, ., isAssign, (, ), ), {, Node, lhs, =, n, ., getFirstChild, (, ), ;, switch, (]
[{, Node, lhs, =, n, ., getFirstChild, (, ), ;, switch, (, lhs, ., getType, (, ), ), {, case]
[{, Node, lhs, =, n, ., getFirstChild, (, ), ;, switch, (, lhs, ., getType, (, ), ), {, case]
[., getFirstChild, (, ), ;, switch, (, lhs, ., getType, (, ), ), {, case, Token, ., NAME, :, return]
[), ;, switch, (, lhs, ., getType, (, ), ), {, case, Token, ., NAME, :, return, true, ;, case]
[), ;, switch, (, lhs, ., getType, (, ), ), {, case, Token, ., NAME, :, return, true, ;, case]
[., getType, (, ), ), {, case, Token, ., NAME, :, return, true, ;, case, Token, ., GETPROP, :, return]
[getType, (, ), ), {, case, Token, ., NAME, :, return, true, ;, case, Token, ., GETPROP, :, return, !]
[), ), {, case, Token, ., NAME, :, return, true, ;, case, Token, ., GETPROP, :, return, !, isExpressionTreeUnsafe, (]
[), ), {, case, Token, ., NAME, :, return, true, ;, case, Token, ., GETPROP, :, return, !, isExpressionTreeUnsafe, (]
[NAME, :, return, true, ;, case, Token, ., GETPROP, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,]
[;, case, Token, ., GETPROP, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case]
[;, case, Token, ., GETPROP, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case]
[:, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case, Token, ., GETELEM, :, return]
[:, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case, Token, ., GETELEM, :, return]
[return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case, Token, ., GETELEM, :, return, !]
[isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (]
[isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (]
[), ,, seenSideEffects, ), ;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,]
[), ;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&]
[;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&, !]
[Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&, !, isExpressionTreeUnsafe, (]
[Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&, !, isExpressionTreeUnsafe, (]
[isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&, !, isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,]
[), ,, seenSideEffects, ), &&, !, isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,, seenSideEffects, ), ;, }, }, return]
[;, }, }, return, false, ;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (]
[false, ;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (, followingSideEffectsExist, ), {, return]
[false, ;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (, followingSideEffectsExist, ), {, return]
[boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (, followingSideEffectsExist, ), {, return, NodeUtil, ., canBeSideEffected, (]
[(, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (, followingSideEffectsExist, ), {, return, NodeUtil, ., canBeSideEffected, (, n, ,]
[(, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (, followingSideEffectsExist, ), {, return, NodeUtil, ., canBeSideEffected, (, n, ,]
[(, followingSideEffectsExist, ), {, return, NodeUtil, ., canBeSideEffected, (, n, ,, this, ., knownConstants, ), ;, }, else, {, return]
[(, followingSideEffectsExist, ), {, return, NodeUtil, ., canBeSideEffected, (, n, ,, this, ., knownConstants, ), ;, }, else, {, return]
[return, NodeUtil, ., canBeSideEffected, (, n, ,, this, ., knownConstants, ), ;, }, else, {, return, NodeUtil, ., mayHaveSideEffects, (]
[., canBeSideEffected, (, n, ,, this, ., knownConstants, ), ;, }, else, {, return, NodeUtil, ., mayHaveSideEffects, (, n, ,]
