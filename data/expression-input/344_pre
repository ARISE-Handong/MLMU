[google, ., javascript, ., rhino, ., jstype, ., TernaryValue, ;, class, PeepholeFoldConstants, extends, AbstractPeepholeOptimization, {, static, final, DiagnosticType, INVALID_GETELEM_INDEX_ERROR, =]
[google, ., javascript, ., rhino, ., jstype, ., TernaryValue, ;, class, PeepholeFoldConstants, extends, AbstractPeepholeOptimization, {, static, final, DiagnosticType, INVALID_GETELEM_INDEX_ERROR, =]
[rhino, ., jstype, ., TernaryValue, ;, class, PeepholeFoldConstants, extends, AbstractPeepholeOptimization, {, static, final, DiagnosticType, INVALID_GETELEM_INDEX_ERROR, =, DiagnosticType, ., warning, (]
[jstype, ., TernaryValue, ;, class, PeepholeFoldConstants, extends, AbstractPeepholeOptimization, {, static, final, DiagnosticType, INVALID_GETELEM_INDEX_ERROR, =, DiagnosticType, ., warning, (, "JSC_INVALID_GETELEM_INDEX_ERROR", ,]
[{, static, final, DiagnosticType, INVALID_GETELEM_INDEX_ERROR, =, DiagnosticType, ., warning, (, "JSC_INVALID_GETELEM_INDEX_ERROR", ,, "Array index not integer: {0}", ), ;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =]
[{, static, final, DiagnosticType, INVALID_GETELEM_INDEX_ERROR, =, DiagnosticType, ., warning, (, "JSC_INVALID_GETELEM_INDEX_ERROR", ,, "Array index not integer: {0}", ), ;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =]
[INVALID_GETELEM_INDEX_ERROR, =, DiagnosticType, ., warning, (, "JSC_INVALID_GETELEM_INDEX_ERROR", ,, "Array index not integer: {0}", ), ;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =, DiagnosticType, ., warning, (]
[DiagnosticType, ., warning, (, "JSC_INVALID_GETELEM_INDEX_ERROR", ,, "Array index not integer: {0}", ), ;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =, DiagnosticType, ., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,]
[;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =, DiagnosticType, ., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,, "Array index out of bounds: {0}", ), ;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =]
[;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =, DiagnosticType, ., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,, "Array index out of bounds: {0}", ), ;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =]
[INDEX_OUT_OF_BOUNDS_ERROR, =, DiagnosticType, ., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,, "Array index out of bounds: {0}", ), ;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =, DiagnosticType, ., warning, (]
[DiagnosticType, ., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,, "Array index out of bounds: {0}", ), ;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =, DiagnosticType, ., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,]
[;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =, DiagnosticType, ., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,, "Can't negate non-numeric value: {0}", ), ;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =]
[;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =, DiagnosticType, ., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,, "Can't negate non-numeric value: {0}", ), ;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =]
[NEGATING_A_NON_NUMBER_ERROR, =, DiagnosticType, ., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,, "Can't negate non-numeric value: {0}", ), ;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =, DiagnosticType, ., warning, (]
[DiagnosticType, ., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,, "Can't negate non-numeric value: {0}", ), ;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =, DiagnosticType, ., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,]
[;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =, DiagnosticType, ., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,, "Operand out of range, bitwise operation will lose information: {0}", ), ;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =]
[;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =, DiagnosticType, ., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,, "Operand out of range, bitwise operation will lose information: {0}", ), ;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =]
[BITWISE_OPERAND_OUT_OF_RANGE, =, DiagnosticType, ., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,, "Operand out of range, bitwise operation will lose information: {0}", ), ;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =, DiagnosticType, ., warning, (]
[DiagnosticType, ., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,, "Operand out of range, bitwise operation will lose information: {0}", ), ;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =, DiagnosticType, ., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,]
[;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =, DiagnosticType, ., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,, "Shift amount out of bounds: {0}", ), ;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =]
[;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =, DiagnosticType, ., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,, "Shift amount out of bounds: {0}", ), ;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =]
[SHIFT_AMOUNT_OUT_OF_BOUNDS, =, DiagnosticType, ., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,, "Shift amount out of bounds: {0}", ), ;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =, DiagnosticType, ., warning, (]
[DiagnosticType, ., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,, "Shift amount out of bounds: {0}", ), ;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =, DiagnosticType, ., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,]
[static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =, DiagnosticType, ., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,, "Fractional bitwise operand: {0}", ), ;, private, static, final, double, MAX_FOLD_NUMBER, =]
[static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =, DiagnosticType, ., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,, "Fractional bitwise operand: {0}", ), ;, private, static, final, double, MAX_FOLD_NUMBER, =]
[=, DiagnosticType, ., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,, "Fractional bitwise operand: {0}", ), ;, private, static, final, double, MAX_FOLD_NUMBER, =, Math, ., pow, (]
[., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,, "Fractional bitwise operand: {0}", ), ;, private, static, final, double, MAX_FOLD_NUMBER, =, Math, ., pow, (, 2, ,]
[Math, ., pow, (, 2, ,, 53, ), ;, private, final, boolean, late, ;, PeepholeFoldConstants, (, boolean, late, ), {]
[Math, ., pow, (, 2, ,, 53, ), ;, private, final, boolean, late, ;, PeepholeFoldConstants, (, boolean, late, ), {]
[2, ,, 53, ), ;, private, final, boolean, late, ;, PeepholeFoldConstants, (, boolean, late, ), {, this, ., late, =]
[), {, this, ., late, =, late, ;, }, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (]
[), {, this, ., late, =, late, ;, }, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (]
[}, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (, subtree, ., getType, (, ), ), {, case]
[}, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (, subtree, ., getType, (, ), ), {, case]
[(, Node, subtree, ), {, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., NEW, :, return]
[subtree, ), {, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., NEW, :, return, tryFoldCtorCall, (]
[(, subtree, ., getType, (, ), ), {, case, Token, ., NEW, :, return, tryFoldCtorCall, (, subtree, ), ;, case]
[(, subtree, ., getType, (, ), ), {, case, Token, ., NEW, :, return, tryFoldCtorCall, (, subtree, ), ;, case]
[), ), {, case, Token, ., NEW, :, return, tryFoldCtorCall, (, subtree, ), ;, case, Token, ., TYPEOF, :, return]
[{, case, Token, ., NEW, :, return, tryFoldCtorCall, (, subtree, ), ;, case, Token, ., TYPEOF, :, return, tryFoldTypeof, (]
[NEW, :, return, tryFoldCtorCall, (, subtree, ), ;, case, Token, ., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case]
[NEW, :, return, tryFoldCtorCall, (, subtree, ), ;, case, Token, ., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case]
[subtree, ), ;, case, Token, ., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case, Token, ., NOT, :, case]
[subtree, ), ;, case, Token, ., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case, Token, ., NOT, :, case]
[., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case, Token, ., NOT, :, case, Token, ., POS, :, case]
[., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case, Token, ., NOT, :, case, Token, ., POS, :, case]
[(, subtree, ), ;, case, Token, ., NOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, case]
[(, subtree, ), ;, case, Token, ., NOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, case]
[case, Token, ., NOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., BITNOT, :]
[., NOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (]
[Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return]
[POS, :, case, Token, ., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (]
[., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (, subtree, ), ;, case]
[., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (, subtree, ), ;, case]
[., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (, subtree, ), ;, case, Token, ., VOID, :, return]
[:, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (, subtree, ), ;, case, Token, ., VOID, :, return, tryReduceVoid, (]
[;, return, tryFoldUnaryOperator, (, subtree, ), ;, case, Token, ., VOID, :, return, tryReduceVoid, (, subtree, ), ;, default, :]
[tryFoldUnaryOperator, (, subtree, ), ;, case, Token, ., VOID, :, return, tryReduceVoid, (, subtree, ), ;, default, :, tryReduceOperandsForOp, (]
[;, case, Token, ., VOID, :, return, tryReduceVoid, (, subtree, ), ;, default, :, tryReduceOperandsForOp, (, subtree, ), ;, return]
[Token, ., VOID, :, return, tryReduceVoid, (, subtree, ), ;, default, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldBinaryOperator, (]
[;, return, tryFoldBinaryOperator, (, subtree, ), ;, }, }, private, Node, tryFoldBinaryOperator, (, Node, subtree, ), {, Node, left, =]
[;, return, tryFoldBinaryOperator, (, subtree, ), ;, }, }, private, Node, tryFoldBinaryOperator, (, Node, subtree, ), {, Node, left, =]
[}, private, Node, tryFoldBinaryOperator, (, Node, subtree, ), {, Node, left, =, subtree, ., getFirstChild, (, ), ;, if, (]
[}, private, Node, tryFoldBinaryOperator, (, Node, subtree, ), {, Node, left, =, subtree, ., getFirstChild, (, ), ;, if, (]
[Node, tryFoldBinaryOperator, (, Node, subtree, ), {, Node, left, =, subtree, ., getFirstChild, (, ), ;, if, (, left, ==]
[subtree, ), {, Node, left, =, subtree, ., getFirstChild, (, ), ;, if, (, left, ==, null, ), {, return]
[subtree, ., getFirstChild, (, ), ;, if, (, left, ==, null, ), {, return, subtree, ;, }, Node, right, =]
[subtree, ., getFirstChild, (, ), ;, if, (, left, ==, null, ), {, return, subtree, ;, }, Node, right, =]
[left, ==, null, ), {, return, subtree, ;, }, Node, right, =, left, ., getNext, (, ), ;, if, (]
[left, ==, null, ), {, return, subtree, ;, }, Node, right, =, left, ., getNext, (, ), ;, if, (]
[null, ), {, return, subtree, ;, }, Node, right, =, left, ., getNext, (, ), ;, if, (, right, ==]
[subtree, ;, }, Node, right, =, left, ., getNext, (, ), ;, if, (, right, ==, null, ), {, return]
[=, left, ., getNext, (, ), ;, if, (, right, ==, null, ), {, return, subtree, ;, }, switch, (]
[=, left, ., getNext, (, ), ;, if, (, right, ==, null, ), {, return, subtree, ;, }, switch, (]
[(, right, ==, null, ), {, return, subtree, ;, }, switch, (, subtree, ., getType, (, ), ), {, case]
[(, right, ==, null, ), {, return, subtree, ;, }, switch, (, subtree, ., getType, (, ), ), {, case]
[{, return, subtree, ;, }, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., GETPROP, :, return]
[subtree, ;, }, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., GETPROP, :, return, tryFoldGetProp, (]
[}, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., GETPROP, :, return, tryFoldGetProp, (, subtree, ,]
[(, subtree, ., getType, (, ), ), {, case, Token, ., GETPROP, :, return, tryFoldGetProp, (, subtree, ,, left, ,]
[(, ), ), {, case, Token, ., GETPROP, :, return, tryFoldGetProp, (, subtree, ,, left, ,, right, ), ;, case]
[(, ), ), {, case, Token, ., GETPROP, :, return, tryFoldGetProp, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., GETPROP, :, return, tryFoldGetProp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., GETELEM, :, return]
[GETPROP, :, return, tryFoldGetProp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (]
[return, tryFoldGetProp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree, ,]
[(, subtree, ,, left, ,, right, ), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,]
[,, right, ), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case]
[,, right, ), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case, Token, ., INSTANCEOF, :, return]
[GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (]
[return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,]
[(, subtree, ,, left, ,, right, ), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,]
[,, right, ), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case]
[,, right, ), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case, Token, ., AND, :, case]
[Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case, Token, ., AND, :, case]
[tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return]
[subtree, ,, left, ,, right, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (]
[left, ,, right, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,]
[right, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,]
[Token, ., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LSH, :, case]
[Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LSH, :, case]
[tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case]
[tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case]
[,, right, ), ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return]
[), ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (]
[case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (, subtree, ,]
[., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (, subtree, ,, left, ,]
[Token, ., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., URSH, :, return, tryFoldShift, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN, :, return]
[URSH, :, return, tryFoldShift, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (]
[return, tryFoldShift, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,]
[(, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,]
[,, right, ), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case]
[,, right, ), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case]
[Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case]
[tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case]
[tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case]
[,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case]
[Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case]
[Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case]
[Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case]
[Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case]
[Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case]
[Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case]
[Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case]
[Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case]
[Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case]
[Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case]
[Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case]
[Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case]
[Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case]
[Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return]
[ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (]
[case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,]
[., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,]
[Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ADD, :, return]
[ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ADD, :, return, tryFoldAdd, (]
[return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,]
[(, subtree, ,, left, ,, right, ), ;, case, Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,]
[,, right, ), ;, case, Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case]
[,, right, ), ;, case, Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case, Token, ., SUB, :, case]
[Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case, Token, ., SUB, :, case]
[tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case, Token, ., SUB, :, case, Token, ., DIV, :, case]
[tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case, Token, ., SUB, :, case, Token, ., DIV, :, case]
[,, right, ), ;, case, Token, ., SUB, :, case, Token, ., DIV, :, case, Token, ., MOD, :, return]
[), ;, case, Token, ., SUB, :, case, Token, ., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (]
[case, Token, ., SUB, :, case, Token, ., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,]
[., SUB, :, case, Token, ., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,]
[Token, ., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case]
[Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., MUL, :, case]
[Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., MUL, :, case]
[tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., MUL, :, case, Token, ., BITAND, :, case]
[tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., MUL, :, case, Token, ., BITAND, :, case]
[,, right, ), ;, case, Token, ., MUL, :, case, Token, ., BITAND, :, case, Token, ., BITOR, :, case]
[,, right, ), ;, case, Token, ., MUL, :, case, Token, ., BITAND, :, case, Token, ., BITOR, :, case]
[MUL, :, case, Token, ., BITAND, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, Node, result, =]
[case, Token, ., BITAND, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (]
[., BITAND, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,]
[:, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,]
[:, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, if, (]
[:, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, if, (]
[Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, if, (, result, !=]
[Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, if, (, result, !=, subtree, ), {, return]
[(, subtree, ,, left, ,, right, ), ;, if, (, result, !=, subtree, ), {, return, result, ;, }, return]
[,, left, ,, right, ), ;, if, (, result, !=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (]
[,, right, ), ;, if, (, result, !=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,]
[), ;, if, (, result, !=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,]
[result, !=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case]
[result, !=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case]
[return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LT, :, case]
[return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LT, :, case]
[tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LT, :, case, Token, ., GT, :, case]
[tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LT, :, case, Token, ., GT, :, case]
[,, right, ), ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[,, right, ), ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case]
[Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., EQ, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., EQ, :, case]
[Token, ., LE, :, case, Token, ., GE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[Token, ., LE, :, case, Token, ., GE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[Token, ., GE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[Token, ., GE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return]
[EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, tryFoldComparison, (]
[case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, tryFoldComparison, (, subtree, ,]
[., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, tryFoldComparison, (, subtree, ,, left, ,]
[SHEQ, :, case, Token, ., SHNE, :, return, tryFoldComparison, (, subtree, ,, left, ,, right, ), ;, default, :, return]
[), ;, default, :, return, subtree, ;, }, }, private, Node, tryReduceVoid, (, Node, n, ), {, Node, child, =]
[), ;, default, :, return, subtree, ;, }, }, private, Node, tryReduceVoid, (, Node, n, ), {, Node, child, =]
[}, private, Node, tryReduceVoid, (, Node, n, ), {, Node, child, =, n, ., getFirstChild, (, ), ;, if, (]
[}, private, Node, tryReduceVoid, (, Node, n, ), {, Node, child, =, n, ., getFirstChild, (, ), ;, if, (]
[private, Node, tryReduceVoid, (, Node, n, ), {, Node, child, =, n, ., getFirstChild, (, ), ;, if, (, !]
[private, Node, tryReduceVoid, (, Node, n, ), {, Node, child, =, n, ., getFirstChild, (, ), ;, if, (, !]
[), {, Node, child, =, n, ., getFirstChild, (, ), ;, if, (, !, child, ., isNumber, (, ), ||]
[), {, Node, child, =, n, ., getFirstChild, (, ), ;, if, (, !, child, ., isNumber, (, ), ||]
[), {, Node, child, =, n, ., getFirstChild, (, ), ;, if, (, !, child, ., isNumber, (, ), ||]
[., getFirstChild, (, ), ;, if, (, !, child, ., isNumber, (, ), ||, child, ., getDouble, (, ), !=]
[if, (, !, child, ., isNumber, (, ), ||, child, ., getDouble, (, ), !=, 0.0, ), {, if, (]
[(, !, child, ., isNumber, (, ), ||, child, ., getDouble, (, ), !=, 0.0, ), {, if, (, !]
[child, ., isNumber, (, ), ||, child, ., getDouble, (, ), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (]
[), ||, child, ., getDouble, (, ), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n, ), ), {]
[), ||, child, ., getDouble, (, ), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n, ), ), {]
[getDouble, (, ), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild, (]
[), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild, (, child, ,]
[), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild, (, child, ,]
[{, if, (, !, mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild, (, child, ,, IR, ., number, (]
[mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild, (, child, ,, IR, ., number, (, 0, ), ), ;]
[., replaceChild, (, child, ,, IR, ., number, (, 0, ), ), ;, reportCodeChange, (, ), ;, }, }, return]
[reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, void, tryReduceOperandsForOp, (, Node, n, ), {, switch, (]
[reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, void, tryReduceOperandsForOp, (, Node, n, ), {, switch, (]
[;, }, private, void, tryReduceOperandsForOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, private, void, tryReduceOperandsForOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ADD, :, Node, left, =]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., ADD, :, Node, left, =]
[), ), {, case, Token, ., ADD, :, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =]
[), ), {, case, Token, ., ADD, :, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =]
[Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (]
[Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (]
[left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, !]
[left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, !]
[getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, !, NodeUtil, ., mayBeString, (]
[;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, !, NodeUtil, ., mayBeString, (, left, ), &&]
[Node, right, =, n, ., getLastChild, (, ), ;, if, (, !, NodeUtil, ., mayBeString, (, left, ), &&, !]
[Node, right, =, n, ., getLastChild, (, ), ;, if, (, !, NodeUtil, ., mayBeString, (, left, ), &&, !]
[., getLastChild, (, ), ;, if, (, !, NodeUtil, ., mayBeString, (, left, ), &&, !, NodeUtil, ., mayBeString, (]
[;, if, (, !, NodeUtil, ., mayBeString, (, left, ), &&, !, NodeUtil, ., mayBeString, (, right, ), ), {]
[(, !, NodeUtil, ., mayBeString, (, left, ), &&, !, NodeUtil, ., mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (]
[), &&, !, NodeUtil, ., mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case]
[), &&, !, NodeUtil, ., mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case]
[mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case]
[mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case]
[{, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case]
[{, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case]
[;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case]
[Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case]
[Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case]
[Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case]
[Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case]
[Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case]
[Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case]
[Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case]
[Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case]
[Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case]
[Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case]
[Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case]
[case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :]
[., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (]
[., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (]
[., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, break, ;, case]
[., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, break, ;, case]
[., ASSIGN_DIV, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, break, ;, case, Token, ., BITNOT, :, case]
[., ASSIGN_DIV, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, break, ;, case, Token, ., BITNOT, :, case]
[n, ., getLastChild, (, ), ), ;, break, ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case]
[n, ., getLastChild, (, ), ), ;, break, ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case]
[), ;, break, ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[), ;, break, ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case]
[Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case]
[Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case]
[Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case]
[Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case]
[Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case]
[Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case]
[Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case]
[Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case]
[Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case]
[Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case]
[Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case]
[Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case]
[Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case]
[Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case]
[Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., POS, :, case]
[Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., POS, :, case]
[case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., POS, :, case, Token, ., NEG, :]
[., MOD, :, case, Token, ., DIV, :, case, Token, ., POS, :, case, Token, ., NEG, :, tryConvertOperandsToNumber, (]
[break, ;, }, }, private, void, tryConvertOperandsToNumber, (, Node, n, ), {, Node, next, ;, for, (, Node, c, =]
[break, ;, }, }, private, void, tryConvertOperandsToNumber, (, Node, n, ), {, Node, next, ;, for, (, Node, c, =]
[tryConvertOperandsToNumber, (, Node, n, ), {, Node, next, ;, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[tryConvertOperandsToNumber, (, Node, n, ), {, Node, next, ;, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[Node, n, ), {, Node, next, ;, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[), {, Node, next, ;, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;]
[Node, next, ;, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, next, ), {]
[Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, next, ), {, next, =]
[Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, next, ), {, next, =]
[(, ), ;, c, !=, null, ;, c, =, next, ), {, next, =, c, ., getNext, (, ), ;]
[;, c, !=, null, ;, c, =, next, ), {, next, =, c, ., getNext, (, ), ;, tryConvertToNumber, (]
[(, ), ;, tryConvertToNumber, (, c, ), ;, }, }, private, void, tryConvertToNumber, (, Node, n, ), {, switch, (]
[(, ), ;, tryConvertToNumber, (, c, ), ;, }, }, private, void, tryConvertToNumber, (, Node, n, ), {, switch, (]
[}, }, private, void, tryConvertToNumber, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, }, private, void, tryConvertToNumber, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., NUMBER, :, return, ;, case]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., NUMBER, :, return, ;, case]
[n, ., getType, (, ), ), {, case, Token, ., NUMBER, :, return, ;, case, Token, ., AND, :, case]
[n, ., getType, (, ), ), {, case, Token, ., NUMBER, :, return, ;, case, Token, ., AND, :, case]
[), {, case, Token, ., NUMBER, :, return, ;, case, Token, ., AND, :, case, Token, ., OR, :, case]
[), {, case, Token, ., NUMBER, :, return, ;, case, Token, ., AND, :, case, Token, ., OR, :, case]
[., NUMBER, :, return, ;, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, ., COMMA, :]
[:, return, ;, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, ., COMMA, :, tryConvertToNumber, (]
[:, return, ;, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, ., COMMA, :, tryConvertToNumber, (]
[., OR, :, case, Token, ., COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case]
[., OR, :, case, Token, ., COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case]
[Token, ., COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., HOOK, :]
[COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (]
[COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (]
[n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (, n, ., getChildAtIndex, (]
[), ), ;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (, n, ., getChildAtIndex, (, 1, ), ), ;]
[;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (, n, ., getChildAtIndex, (, 1, ), ), ;, tryConvertToNumber, (]
[;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (, n, ., getChildAtIndex, (, 1, ), ), ;, tryConvertToNumber, (]
[n, ., getChildAtIndex, (, 1, ), ), ;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case]
[n, ., getChildAtIndex, (, 1, ), ), ;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case]
[), ;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., NAME, :, if, (]
[;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., NAME, :, if, (, !]
[;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., NAME, :, if, (, !]
[., getLastChild, (, ), ), ;, return, ;, case, Token, ., NAME, :, if, (, !, NodeUtil, ., isUndefined, (]
[if, (, !, NodeUtil, ., isUndefined, (, n, ), ), {, return, ;, }, break, ;, }, Double, result, =]
[if, (, !, NodeUtil, ., isUndefined, (, n, ), ), {, return, ;, }, break, ;, }, Double, result, =]
[., isUndefined, (, n, ), ), {, return, ;, }, break, ;, }, Double, result, =, NodeUtil, ., getNumberValue, (]
[), {, return, ;, }, break, ;, }, Double, result, =, NodeUtil, ., getNumberValue, (, n, ), ;, if, (]
[), {, return, ;, }, break, ;, }, Double, result, =, NodeUtil, ., getNumberValue, (, n, ), ;, if, (]
[return, ;, }, break, ;, }, Double, result, =, NodeUtil, ., getNumberValue, (, n, ), ;, if, (, result, ==]
[NodeUtil, ., getNumberValue, (, n, ), ;, if, (, result, ==, null, ), {, return, ;, }, double, value, =]
[), ;, if, (, result, ==, null, ), {, return, ;, }, double, value, =, result, ;, Node, replacement, =]
[), ;, if, (, result, ==, null, ), {, return, ;, }, double, value, =, result, ;, Node, replacement, =]
[result, ==, null, ), {, return, ;, }, double, value, =, result, ;, Node, replacement, =, NodeUtil, ., numberNode, (]
[null, ), {, return, ;, }, double, value, =, result, ;, Node, replacement, =, NodeUtil, ., numberNode, (, value, ,]
[}, double, value, =, result, ;, Node, replacement, =, NodeUtil, ., numberNode, (, value, ,, n, ), ;, if, (]
[}, double, value, =, result, ;, Node, replacement, =, NodeUtil, ., numberNode, (, value, ,, n, ), ;, if, (]
[result, ;, Node, replacement, =, NodeUtil, ., numberNode, (, value, ,, n, ), ;, if, (, replacement, ., isEquivalentTo, (]
[numberNode, (, value, ,, n, ), ;, if, (, replacement, ., isEquivalentTo, (, n, ), ), {, return, ;, }]
[numberNode, (, value, ,, n, ), ;, if, (, replacement, ., isEquivalentTo, (, n, ), ), {, return, ;, }]
[numberNode, (, value, ,, n, ), ;, if, (, replacement, ., isEquivalentTo, (, n, ), ), {, return, ;, }]
[(, replacement, ., isEquivalentTo, (, n, ), ), {, return, ;, }, n, ., getParent, (, ), ., replaceChild, (]
[., isEquivalentTo, (, n, ), ), {, return, ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[n, ), ), {, return, ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;]
[replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, }, private, Node, tryFoldTypeof, (, Node, originalTypeofNode, ), {]
[replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, }, private, Node, tryFoldTypeof, (, Node, originalTypeofNode, ), {]
[replacement, ), ;, reportCodeChange, (, ), ;, }, private, Node, tryFoldTypeof, (, Node, originalTypeofNode, ), {, Preconditions, ., checkArgument, (]
[replacement, ), ;, reportCodeChange, (, ), ;, }, private, Node, tryFoldTypeof, (, Node, originalTypeofNode, ), {, Preconditions, ., checkArgument, (]
[tryFoldTypeof, (, Node, originalTypeofNode, ), {, Preconditions, ., checkArgument, (, originalTypeofNode, ., isTypeOf, (, ), ), ;, Node, argumentNode, =]
[tryFoldTypeof, (, Node, originalTypeofNode, ), {, Preconditions, ., checkArgument, (, originalTypeofNode, ., isTypeOf, (, ), ), ;, Node, argumentNode, =]
[checkArgument, (, originalTypeofNode, ., isTypeOf, (, ), ), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (]
[checkArgument, (, originalTypeofNode, ., isTypeOf, (, ), ), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (]
[checkArgument, (, originalTypeofNode, ., isTypeOf, (, ), ), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (]
[originalTypeofNode, ., isTypeOf, (, ), ), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (, argumentNode, ==]
[isTypeOf, (, ), ), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (, argumentNode, ==, null, ||]
[(, ), ), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (, argumentNode, ==, null, ||, !]
[(, ), ), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (, argumentNode, ==, null, ||, !]
[Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (, argumentNode, ==, null, ||, !, NodeUtil, ., isLiteralValue, (]
[=, originalTypeofNode, ., getFirstChild, (, ), ;, if, (, argumentNode, ==, null, ||, !, NodeUtil, ., isLiteralValue, (, argumentNode, ,]
[), ;, if, (, argumentNode, ==, null, ||, !, NodeUtil, ., isLiteralValue, (, argumentNode, ,, true, ), ), {, return]
[null, ||, !, NodeUtil, ., isLiteralValue, (, argumentNode, ,, true, ), ), {, return, originalTypeofNode, ;, }, String, typeNameString, =]
[., isLiteralValue, (, argumentNode, ,, true, ), ), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (]
[., isLiteralValue, (, argumentNode, ,, true, ), ), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (]
[{, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (, ), ), {, case]
[{, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (, ), ), {, case]
[}, String, typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (, ), ), {, case, Token, ., FUNCTION, :]
[typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, typeNameString, =]
[(, argumentNode, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, typeNameString, =, "function", ;, break, ;, case]
[(, argumentNode, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, typeNameString, =, "function", ;, break, ;, case]
[(, ), ), {, case, Token, ., FUNCTION, :, typeNameString, =, "function", ;, break, ;, case, Token, ., STRING, :]
[), {, case, Token, ., FUNCTION, :, typeNameString, =, "function", ;, break, ;, case, Token, ., STRING, :, typeNameString, =]
[FUNCTION, :, typeNameString, =, "function", ;, break, ;, case, Token, ., STRING, :, typeNameString, =, "string", ;, break, ;, case]
[FUNCTION, :, typeNameString, =, "function", ;, break, ;, case, Token, ., STRING, :, typeNameString, =, "string", ;, break, ;, case]
["function", ;, break, ;, case, Token, ., STRING, :, typeNameString, =, "string", ;, break, ;, case, Token, ., NUMBER, :]
[break, ;, case, Token, ., STRING, :, typeNameString, =, "string", ;, break, ;, case, Token, ., NUMBER, :, typeNameString, =]
[STRING, :, typeNameString, =, "string", ;, break, ;, case, Token, ., NUMBER, :, typeNameString, =, "number", ;, break, ;, case]
[STRING, :, typeNameString, =, "string", ;, break, ;, case, Token, ., NUMBER, :, typeNameString, =, "number", ;, break, ;, case]
[;, break, ;, case, Token, ., NUMBER, :, typeNameString, =, "number", ;, break, ;, case, Token, ., TRUE, :, case]
[;, break, ;, case, Token, ., NUMBER, :, typeNameString, =, "number", ;, break, ;, case, Token, ., TRUE, :, case]
[Token, ., NUMBER, :, typeNameString, =, "number", ;, break, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :]
[NUMBER, :, typeNameString, =, "number", ;, break, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, typeNameString, =]
[;, break, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case]
[;, break, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case]
[., TRUE, :, case, Token, ., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case, Token, ., NULL, :, case]
[., TRUE, :, case, Token, ., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case, Token, ., NULL, :, case]
[., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case, Token, ., NULL, :, case, Token, ., OBJECTLIT, :, case]
[., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case, Token, ., NULL, :, case, Token, ., OBJECTLIT, :, case]
[=, "boolean", ;, break, ;, case, Token, ., NULL, :, case, Token, ., OBJECTLIT, :, case, Token, ., ARRAYLIT, :]
[;, break, ;, case, Token, ., NULL, :, case, Token, ., OBJECTLIT, :, case, Token, ., ARRAYLIT, :, typeNameString, =]
[., NULL, :, case, Token, ., OBJECTLIT, :, case, Token, ., ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case]
[., NULL, :, case, Token, ., OBJECTLIT, :, case, Token, ., ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case]
[Token, ., OBJECTLIT, :, case, Token, ., ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case, Token, ., VOID, :]
[OBJECTLIT, :, case, Token, ., ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case, Token, ., VOID, :, typeNameString, =]
[ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case, Token, ., VOID, :, typeNameString, =, "undefined", ;, break, ;, case]
[ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case, Token, ., VOID, :, typeNameString, =, "undefined", ;, break, ;, case]
[break, ;, case, Token, ., VOID, :, typeNameString, =, "undefined", ;, break, ;, case, Token, ., NAME, :, if, (]
[break, ;, case, Token, ., VOID, :, typeNameString, =, "undefined", ;, break, ;, case, Token, ., NAME, :, if, (]
[., VOID, :, typeNameString, =, "undefined", ;, break, ;, case, Token, ., NAME, :, if, (, "undefined", ., equals, (]
[., VOID, :, typeNameString, =, "undefined", ;, break, ;, case, Token, ., NAME, :, if, (, "undefined", ., equals, (]
[;, case, Token, ., NAME, :, if, (, "undefined", ., equals, (, argumentNode, ., getString, (, ), ), ), {]
[Token, ., NAME, :, if, (, "undefined", ., equals, (, argumentNode, ., getString, (, ), ), ), {, typeNameString, =]
[equals, (, argumentNode, ., getString, (, ), ), ), {, typeNameString, =, "undefined", ;, }, break, ;, }, if, (]
[equals, (, argumentNode, ., getString, (, ), ), ), {, typeNameString, =, "undefined", ;, }, break, ;, }, if, (]
[argumentNode, ., getString, (, ), ), ), {, typeNameString, =, "undefined", ;, }, break, ;, }, if, (, typeNameString, !=]
[), {, typeNameString, =, "undefined", ;, }, break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode, =]
[), {, typeNameString, =, "undefined", ;, }, break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode, =]
["undefined", ;, }, break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode, =, IR, ., string, (]
[break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode, =, IR, ., string, (, typeNameString, ), ;]
[break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode, =, IR, ., string, (, typeNameString, ), ;]
[break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode, =, IR, ., string, (, typeNameString, ), ;]
[), {, Node, newNode, =, IR, ., string, (, typeNameString, ), ;, originalTypeofNode, ., getParent, (, ), ., replaceChild, (]
[Node, newNode, =, IR, ., string, (, typeNameString, ), ;, originalTypeofNode, ., getParent, (, ), ., replaceChild, (, originalTypeofNode, ,]
[IR, ., string, (, typeNameString, ), ;, originalTypeofNode, ., getParent, (, ), ., replaceChild, (, originalTypeofNode, ,, newNode, ), ;]
[), ;, originalTypeofNode, ., getParent, (, ), ., replaceChild, (, originalTypeofNode, ,, newNode, ), ;, reportCodeChange, (, ), ;, return]
[getParent, (, ), ., replaceChild, (, originalTypeofNode, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return]
[reportCodeChange, (, ), ;, return, newNode, ;, }, return, originalTypeofNode, ;, }, private, Node, tryFoldUnaryOperator, (, Node, n, ), {]
[reportCodeChange, (, ), ;, return, newNode, ;, }, return, originalTypeofNode, ;, }, private, Node, tryFoldUnaryOperator, (, Node, n, ), {]
[return, newNode, ;, }, return, originalTypeofNode, ;, }, private, Node, tryFoldUnaryOperator, (, Node, n, ), {, Preconditions, ., checkState, (]
[return, newNode, ;, }, return, originalTypeofNode, ;, }, private, Node, tryFoldUnaryOperator, (, Node, n, ), {, Preconditions, ., checkState, (]
[tryFoldUnaryOperator, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., hasOneChild, (, ), ), ;, Node, left, =]
[tryFoldUnaryOperator, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., hasOneChild, (, ), ), ;, Node, left, =]
[(, n, ., hasOneChild, (, ), ), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, parent, =]
[(, n, ., hasOneChild, (, ), ), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, parent, =]
[Node, left, =, n, ., getFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[Node, left, =, n, ., getFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[=, n, ., getFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, left, ==]
[(, ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, left, ==, null, ), {, return]
[n, ., getParent, (, ), ;, if, (, left, ==, null, ), {, return, n, ;, }, TernaryValue, leftVal, =]
[n, ., getParent, (, ), ;, if, (, left, ==, null, ), {, return, n, ;, }, TernaryValue, leftVal, =]
[), ;, if, (, left, ==, null, ), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (]
[==, null, ), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left, ), ;, if, (]
[==, null, ), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left, ), ;, if, (]
[), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left, ), ;, if, (, leftVal, ==]
[), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left, ), ;, if, (, leftVal, ==]
[TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left, ), ;, if, (, leftVal, ==, TernaryValue, ., UNKNOWN, ), {, return]
[getPureBooleanValue, (, left, ), ;, if, (, leftVal, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, switch, (]
[getPureBooleanValue, (, left, ), ;, if, (, leftVal, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, switch, (]
[==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :, if, (]
[return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :, if, (]
[;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :, if, (, late, &&]
[;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :, if, (, late, &&]
[{, case, Token, ., NOT, :, if, (, late, &&, left, ., isNumber, (, ), ), {, double, numValue, =]
[{, case, Token, ., NOT, :, if, (, late, &&, left, ., isNumber, (, ), ), {, double, numValue, =]
[late, &&, left, ., isNumber, (, ), ), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (]
[late, &&, left, ., isNumber, (, ), ), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (]
[late, &&, left, ., isNumber, (, ), ), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (]
[left, ., isNumber, (, ), ), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (, numValue, ==]
[isNumber, (, ), ), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (, numValue, ==, 0, ||]
[isNumber, (, ), ), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (, numValue, ==, 0, ||]
[), ), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (, numValue, ==, 0, ||, numValue, ==]
[numValue, =, left, ., getDouble, (, ), ;, if, (, numValue, ==, 0, ||, numValue, ==, 1, ), {, return]
[;, if, (, numValue, ==, 0, ||, numValue, ==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =]
[;, if, (, numValue, ==, 0, ||, numValue, ==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =]
[==, 0, ||, numValue, ==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (]
[0, ||, numValue, ==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !]
[0, ||, numValue, ==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !]
[1, ), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean, (]
[n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean, (, true, ), ), ;]
[n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean, (, true, ), ), ;]
[Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean, (, true, ), ), ;, parent, ., replaceChild, (]
[=, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean, (, true, ), ), ;, parent, ., replaceChild, (, n, ,]
[booleanNode, (, !, leftVal, ., toBoolean, (, true, ), ), ;, parent, ., replaceChild, (, n, ,, replacementNode, ), ;]
[toBoolean, (, true, ), ), ;, parent, ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return]
[), ), ;, parent, ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case]
[), ), ;, parent, ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case]
[(, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token, ., POS, :, if, (]
[(, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token, ., POS, :, if, (]
[), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (]
[), ;, return, replacementNode, ;, case, Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (, left, ), ), {]
[), ;, return, replacementNode, ;, case, Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (, left, ), ), {]
[;, case, Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (, left, ), ), {, parent, ., replaceChild, (]
[Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (, left, ), ), {, parent, ., replaceChild, (, n, ,]
[Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (, left, ), ), {, parent, ., replaceChild, (, n, ,]
[., isNumericResult, (, left, ), ), {, parent, ., replaceChild, (, n, ,, left, ., detachFromParent, (, ), ), ;]
[), {, parent, ., replaceChild, (, n, ,, left, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return]
[replaceChild, (, n, ,, left, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, left, ;, }, return]
[,, left, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, left, ;, }, return, n, ;, case]
[,, left, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, left, ;, }, return, n, ;, case]
[), ;, reportCodeChange, (, ), ;, return, left, ;, }, return, n, ;, case, Token, ., NEG, :, if, (]
[), ;, reportCodeChange, (, ), ;, return, left, ;, }, return, n, ;, case, Token, ., NEG, :, if, (]
[}, return, n, ;, case, Token, ., NEG, :, if, (, left, ., isName, (, ), ), {, if, (]
[}, return, n, ;, case, Token, ., NEG, :, if, (, left, ., isName, (, ), ), {, if, (]
[}, return, n, ;, case, Token, ., NEG, :, if, (, left, ., isName, (, ), ), {, if, (]
[:, if, (, left, ., isName, (, ), ), {, if, (, left, ., getString, (, ), ., equals, (]
[isName, (, ), ), {, if, (, left, ., getString, (, ), ., equals, (, "Infinity", ), ), {, return]
[(, left, ., getString, (, ), ., equals, (, "Infinity", ), ), {, return, n, ;, }, else, if, (]
[(, left, ., getString, (, ), ., equals, (, "Infinity", ), ), {, return, n, ;, }, else, if, (]
[(, left, ., getString, (, ), ., equals, (, "Infinity", ), ), {, return, n, ;, }, else, if, (]
[(, "Infinity", ), ), {, return, n, ;, }, else, if, (, left, ., getString, (, ), ., equals, (]
[{, return, n, ;, }, else, if, (, left, ., getString, (, ), ., equals, (, "NaN", ), ), {]
[{, return, n, ;, }, else, if, (, left, ., getString, (, ), ., equals, (, "NaN", ), ), {]
[}, else, if, (, left, ., getString, (, ), ., equals, (, "NaN", ), ), {, n, ., removeChild, (]
[(, left, ., getString, (, ), ., equals, (, "NaN", ), ), {, n, ., removeChild, (, left, ), ;]
[(, left, ., getString, (, ), ., equals, (, "NaN", ), ), {, n, ., removeChild, (, left, ), ;]
[(, ), ., equals, (, "NaN", ), ), {, n, ., removeChild, (, left, ), ;, parent, ., replaceChild, (]
[., equals, (, "NaN", ), ), {, n, ., removeChild, (, left, ), ;, parent, ., replaceChild, (, n, ,]
["NaN", ), ), {, n, ., removeChild, (, left, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;]
[., removeChild, (, left, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, reportCodeChange, (, ), ;, return]
[parent, ., replaceChild, (, n, ,, left, ), ;, reportCodeChange, (, ), ;, return, left, ;, }, }, if, (]
[parent, ., replaceChild, (, n, ,, left, ), ;, reportCodeChange, (, ), ;, return, left, ;, }, }, if, (]
[(, ), ;, return, left, ;, }, }, if, (, left, ., isNumber, (, ), ), {, double, negNum, =]
[), ;, return, left, ;, }, }, if, (, left, ., isNumber, (, ), ), {, double, negNum, =, -]
[), ;, return, left, ;, }, }, if, (, left, ., isNumber, (, ), ), {, double, negNum, =, -]
[left, ., isNumber, (, ), ), {, double, negNum, =, -, left, ., getDouble, (, ), ;, Node, negNumNode, =]
[left, ., isNumber, (, ), ), {, double, negNum, =, -, left, ., getDouble, (, ), ;, Node, negNumNode, =]
[), ), {, double, negNum, =, -, left, ., getDouble, (, ), ;, Node, negNumNode, =, IR, ., number, (]
[double, negNum, =, -, left, ., getDouble, (, ), ;, Node, negNumNode, =, IR, ., number, (, negNum, ), ;]
[double, negNum, =, -, left, ., getDouble, (, ), ;, Node, negNumNode, =, IR, ., number, (, negNum, ), ;]
[left, ., getDouble, (, ), ;, Node, negNumNode, =, IR, ., number, (, negNum, ), ;, parent, ., replaceChild, (]
[getDouble, (, ), ;, Node, negNumNode, =, IR, ., number, (, negNum, ), ;, parent, ., replaceChild, (, n, ,]
[;, Node, negNumNode, =, IR, ., number, (, negNum, ), ;, parent, ., replaceChild, (, n, ,, negNumNode, ), ;]
[., number, (, negNum, ), ;, parent, ., replaceChild, (, n, ,, negNumNode, ), ;, reportCodeChange, (, ), ;, return]
[;, parent, ., replaceChild, (, n, ,, negNumNode, ), ;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else, {]
[., replaceChild, (, n, ,, negNumNode, ), ;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else, {, report, (]
[(, n, ,, negNumNode, ), ;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else, {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,]
[), ;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else, {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return]
[), ;, return, negNumNode, ;, }, else, {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return, n, ;, }, case]
[), ;, return, negNumNode, ;, }, else, {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return, n, ;, }, case]
[(, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return, n, ;, }, case, Token, ., BITNOT, :, try, {, double, val, =]
[(, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return, n, ;, }, case, Token, ., BITNOT, :, try, {, double, val, =]
[;, }, case, Token, ., BITNOT, :, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (]
[;, }, case, Token, ., BITNOT, :, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (]
[;, }, case, Token, ., BITNOT, :, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (]
[case, Token, ., BITNOT, :, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (, val, >=]
[case, Token, ., BITNOT, :, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (, val, >=]
[:, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (, val, >=, Integer, ., MIN_VALUE, &&]
[:, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (, val, >=, Integer, ., MIN_VALUE, &&]
[{, double, val, =, left, ., getDouble, (, ), ;, if, (, val, >=, Integer, ., MIN_VALUE, &&, val, <=]
[{, double, val, =, left, ., getDouble, (, ), ;, if, (, val, >=, Integer, ., MIN_VALUE, &&, val, <=]
[), ;, if, (, val, >=, Integer, ., MIN_VALUE, &&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =]
[(, val, >=, Integer, ., MIN_VALUE, &&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (, int, )]
[., MIN_VALUE, &&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (, int, ), val, ;, if, (]
[., MIN_VALUE, &&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (, int, ), val, ;, if, (]
[&&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==]
[), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =]
[), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =]
[=, (, int, ), val, ;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =, IR, ., number, (]
[(, int, ), val, ;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =, IR, ., number, (, ~]
[val, ;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;]
[val, ;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;]
[intVal, ==, val, ), {, Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;, parent, ., replaceChild, (]
[val, ), {, Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;, parent, ., replaceChild, (, n, ,]
[Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;, parent, ., replaceChild, (, n, ,, notIntValNode, ), ;]
[number, (, ~, intVal, ), ;, parent, ., replaceChild, (, n, ,, notIntValNode, ), ;, reportCodeChange, (, ), ;, return]
[;, parent, ., replaceChild, (, n, ,, notIntValNode, ), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else, {]
[., replaceChild, (, n, ,, notIntValNode, ), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else, {, report, (]
[(, n, ,, notIntValNode, ), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,]
[), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return]
[return, notIntValNode, ;, }, else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, }, else, {]
[;, }, else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, }, else, {, report, (]
[else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, }, else, {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,]
[FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, }, else, {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return]
[else, {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, }, catch, (, UnsupportedOperationException, ex, ), {]
[report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, }, catch, (, UnsupportedOperationException, ex, ), {, report, (]
[BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, }, catch, (, UnsupportedOperationException, ex, ), {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,]
[;, return, n, ;, }, }, catch, (, UnsupportedOperationException, ex, ), {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return]
[catch, (, UnsupportedOperationException, ex, ), {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return, n, ;, }, default, :, return]
[:, return, n, ;, }, }, private, Node, tryFoldInstanceof, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[:, return, n, ;, }, }, private, Node, tryFoldInstanceof, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[}, }, private, Node, tryFoldInstanceof, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[}, }, private, Node, tryFoldInstanceof, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, n, ., isInstanceOf, (, ), ), ;, if, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, n, ., isInstanceOf, (, ), ), ;, if, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, n, ., isInstanceOf, (, ), ), ;, if, (]
[right, ), {, Preconditions, ., checkArgument, (, n, ., isInstanceOf, (, ), ), ;, if, (, NodeUtil, ., isLiteralValue, (]
[{, Preconditions, ., checkArgument, (, n, ., isInstanceOf, (, ), ), ;, if, (, NodeUtil, ., isLiteralValue, (, left, ,]
[checkArgument, (, n, ., isInstanceOf, (, ), ), ;, if, (, NodeUtil, ., isLiteralValue, (, left, ,, true, ), &&]
[(, n, ., isInstanceOf, (, ), ), ;, if, (, NodeUtil, ., isLiteralValue, (, left, ,, true, ), &&, !]
[., isInstanceOf, (, ), ), ;, if, (, NodeUtil, ., isLiteralValue, (, left, ,, true, ), &&, !, mayHaveSideEffects, (]
[(, NodeUtil, ., isLiteralValue, (, left, ,, true, ), &&, !, mayHaveSideEffects, (, right, ), ), {, Node, replacementNode, =]
[(, left, ,, true, ), &&, !, mayHaveSideEffects, (, right, ), ), {, Node, replacementNode, =, null, ;, if, (]
[(, left, ,, true, ), &&, !, mayHaveSideEffects, (, right, ), ), {, Node, replacementNode, =, null, ;, if, (]
[), &&, !, mayHaveSideEffects, (, right, ), ), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (]
[(, right, ), ), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (, left, ), ), {]
[), ), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =]
[), ), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =]
[NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =, IR, ., falseNode, (, ), ;, }, else, if, (]
[NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =, IR, ., falseNode, (, ), ;, }, else, if, (]
[NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =, IR, ., falseNode, (, ), ;, }, else, if, (]
[), {, replacementNode, =, IR, ., falseNode, (, ), ;, }, else, if, (, right, ., isName, (, ), &&]
[), {, replacementNode, =, IR, ., falseNode, (, ), ;, }, else, if, (, right, ., isName, (, ), &&]
[IR, ., falseNode, (, ), ;, }, else, if, (, right, ., isName, (, ), &&, "Object", ., equals, (]
[IR, ., falseNode, (, ), ;, }, else, if, (, right, ., isName, (, ), &&, "Object", ., equals, (]
[if, (, right, ., isName, (, ), &&, "Object", ., equals, (, right, ., getString, (, ), ), ), {]
[right, ., isName, (, ), &&, "Object", ., equals, (, right, ., getString, (, ), ), ), {, replacementNode, =]
[right, ., isName, (, ), &&, "Object", ., equals, (, right, ., getString, (, ), ), ), {, replacementNode, =]
[(, right, ., getString, (, ), ), ), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (]
[(, right, ., getString, (, ), ), ), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (]
[., getString, (, ), ), ), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (, replacementNode, !=]
[), ), ), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (, replacementNode, !=, null, ), {]
[), ), ), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (, replacementNode, !=, null, ), {]
[), ), ), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (, replacementNode, !=, null, ), {]
[trueNode, (, ), ;, }, if, (, replacementNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild, (]
[), ;, }, if, (, replacementNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[if, (, replacementNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacementNode, ), ;]
[), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return]
[(, ), ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, }, }, return]
[}, }, return, n, ;, }, private, Node, tryFoldAssign, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[}, }, return, n, ;, }, private, Node, tryFoldAssign, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[;, }, private, Node, tryFoldAssign, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, }, private, Node, tryFoldAssign, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, n, ., isAssign, (, ), ), ;, if, (]
[left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, n, ., isAssign, (, ), ), ;, if, (, !]
[), {, Preconditions, ., checkArgument, (, n, ., isAssign, (, ), ), ;, if, (, !, late, ), {, return]
[(, n, ., isAssign, (, ), ), ;, if, (, !, late, ), {, return, n, ;, }, if, (]
[(, n, ., isAssign, (, ), ), ;, if, (, !, late, ), {, return, n, ;, }, if, (]
[n, ., isAssign, (, ), ), ;, if, (, !, late, ), {, return, n, ;, }, if, (, !]
[n, ., isAssign, (, ), ), ;, if, (, !, late, ), {, return, n, ;, }, if, (, !]
[;, if, (, !, late, ), {, return, n, ;, }, if, (, !, right, ., hasChildren, (, ), ||]
[;, if, (, !, late, ), {, return, n, ;, }, if, (, !, right, ., hasChildren, (, ), ||]
[;, if, (, !, late, ), {, return, n, ;, }, if, (, !, right, ., hasChildren, (, ), ||]
[;, if, (, !, late, ), {, return, n, ;, }, if, (, !, right, ., hasChildren, (, ), ||]
[}, if, (, !, right, ., hasChildren, (, ), ||, right, ., getFirstChild, (, ), ., getNext, (, ), !=]
[}, if, (, !, right, ., hasChildren, (, ), ||, right, ., getFirstChild, (, ), ., getNext, (, ), !=]
[), ||, right, ., getFirstChild, (, ), ., getNext, (, ), !=, right, ., getLastChild, (, ), ), {, return]
[(, ), ., getNext, (, ), !=, right, ., getLastChild, (, ), ), {, return, n, ;, }, if, (]
[., getNext, (, ), !=, right, ., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (]
[right, ., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return]
[n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, Node, newRight, ;, if, (]
[}, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, Node, newRight, ;, if, (, areNodesEqualForInlining, (]
[(, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, Node, newRight, ;, if, (, areNodesEqualForInlining, (, left, ,]
[(, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, Node, newRight, ;, if, (, areNodesEqualForInlining, (, left, ,]
[n, ;, }, Node, newRight, ;, if, (, areNodesEqualForInlining, (, left, ,, right, ., getFirstChild, (, ), ), ), {]
[}, Node, newRight, ;, if, (, areNodesEqualForInlining, (, left, ,, right, ., getFirstChild, (, ), ), ), {, newRight, =]
[}, Node, newRight, ;, if, (, areNodesEqualForInlining, (, left, ,, right, ., getFirstChild, (, ), ), ), {, newRight, =]
[right, ., getFirstChild, (, ), ), ), {, newRight, =, right, ., getLastChild, (, ), ;, }, else, if, (]
[right, ., getFirstChild, (, ), ), ), {, newRight, =, right, ., getLastChild, (, ), ;, }, else, if, (]
[right, ., getFirstChild, (, ), ), ), {, newRight, =, right, ., getLastChild, (, ), ;, }, else, if, (]
[), ), ), {, newRight, =, right, ., getLastChild, (, ), ;, }, else, if, (, NodeUtil, ., isCommutative, (]
[), ), ), {, newRight, =, right, ., getLastChild, (, ), ;, }, else, if, (, NodeUtil, ., isCommutative, (]
[., getLastChild, (, ), ;, }, else, if, (, NodeUtil, ., isCommutative, (, right, ., getType, (, ), ), &&]
[(, ), ;, }, else, if, (, NodeUtil, ., isCommutative, (, right, ., getType, (, ), ), &&, areNodesEqualForInlining, (]
[;, }, else, if, (, NodeUtil, ., isCommutative, (, right, ., getType, (, ), ), &&, areNodesEqualForInlining, (, left, ,]
[;, }, else, if, (, NodeUtil, ., isCommutative, (, right, ., getType, (, ), ), &&, areNodesEqualForInlining, (, left, ,]
[(, right, ., getType, (, ), ), &&, areNodesEqualForInlining, (, left, ,, right, ., getLastChild, (, ), ), ), {]
[., getType, (, ), ), &&, areNodesEqualForInlining, (, left, ,, right, ., getLastChild, (, ), ), ), {, newRight, =]
[., getType, (, ), ), &&, areNodesEqualForInlining, (, left, ,, right, ., getLastChild, (, ), ), ), {, newRight, =]
[right, ., getLastChild, (, ), ), ), {, newRight, =, right, ., getFirstChild, (, ), ;, }, else, {, return]
[), {, newRight, =, right, ., getFirstChild, (, ), ;, }, else, {, return, n, ;, }, int, newType, =]
[{, newRight, =, right, ., getFirstChild, (, ), ;, }, else, {, return, n, ;, }, int, newType, =, -]
[., getFirstChild, (, ), ;, }, else, {, return, n, ;, }, int, newType, =, -, 1, ;, switch, (]
[., getFirstChild, (, ), ;, }, else, {, return, n, ;, }, int, newType, =, -, 1, ;, switch, (]
[return, n, ;, }, int, newType, =, -, 1, ;, switch, (, right, ., getType, (, ), ), {, case]
[return, n, ;, }, int, newType, =, -, 1, ;, switch, (, right, ., getType, (, ), ), {, case]
[int, newType, =, -, 1, ;, switch, (, right, ., getType, (, ), ), {, case, Token, ., ADD, :]
[=, -, 1, ;, switch, (, right, ., getType, (, ), ), {, case, Token, ., ADD, :, newType, =]
[=, -, 1, ;, switch, (, right, ., getType, (, ), ), {, case, Token, ., ADD, :, newType, =]
[., getType, (, ), ), {, case, Token, ., ADD, :, newType, =, Token, ., ASSIGN_ADD, ;, break, ;, case]
[., getType, (, ), ), {, case, Token, ., ADD, :, newType, =, Token, ., ASSIGN_ADD, ;, break, ;, case]
[), {, case, Token, ., ADD, :, newType, =, Token, ., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :]
[case, Token, ., ADD, :, newType, =, Token, ., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :, newType, =]
[case, Token, ., ADD, :, newType, =, Token, ., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :, newType, =]
[Token, ., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;, case]
[Token, ., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;, case]
[break, ;, case, Token, ., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR, :]
[case, Token, ., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR, :, newType, =]
[case, Token, ., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR, :, newType, =]
[Token, ., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;, case]
[Token, ., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;, case]
[break, ;, case, Token, ., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR, :]
[case, Token, ., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR, :, newType, =]
[case, Token, ., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR, :, newType, =]
[Token, ., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;, case]
[Token, ., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;, case]
[break, ;, case, Token, ., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV, :]
[case, Token, ., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV, :, newType, =]
[case, Token, ., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV, :, newType, =]
[Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;, break, ;, case]
[Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;, break, ;, case]
[break, ;, case, Token, ., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH, :]
[case, Token, ., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH, :, newType, =]
[case, Token, ., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH, :, newType, =]
[Token, ., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;, break, ;, case]
[Token, ., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;, break, ;, case]
[break, ;, case, Token, ., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD, :]
[case, Token, ., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD, :, newType, =]
[case, Token, ., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD, :, newType, =]
[Token, ., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;, break, ;, case]
[Token, ., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;, break, ;, case]
[break, ;, case, Token, ., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL, :]
[case, Token, ., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL, :, newType, =]
[case, Token, ., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL, :, newType, =]
[Token, ., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;, break, ;, case]
[Token, ., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;, break, ;, case]
[break, ;, case, Token, ., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH, :]
[case, Token, ., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH, :, newType, =]
[case, Token, ., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH, :, newType, =]
[Token, ., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;, break, ;, case]
[Token, ., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;, break, ;, case]
[break, ;, case, Token, ., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB, :]
[case, Token, ., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB, :, newType, =]
[case, Token, ., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB, :, newType, =]
[Token, ., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;, break, ;, case]
[Token, ., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;, break, ;, case]
[break, ;, case, Token, ., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;, break, ;, case, Token, ., URSH, :]
[case, Token, ., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;, break, ;, case, Token, ., URSH, :, newType, =]
[case, Token, ., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;, break, ;, case, Token, ., URSH, :, newType, =]
[ASSIGN_SUB, ;, break, ;, case, Token, ., URSH, :, newType, =, Token, ., ASSIGN_URSH, ;, break, ;, default, :, return]
[., URSH, :, newType, =, Token, ., ASSIGN_URSH, ;, break, ;, default, :, return, n, ;, }, Node, newNode, =]
[newType, =, Token, ., ASSIGN_URSH, ;, break, ;, default, :, return, n, ;, }, Node, newNode, =, new, Node, (]
[Token, ., ASSIGN_URSH, ;, break, ;, default, :, return, n, ;, }, Node, newNode, =, new, Node, (, newType, ,]
[Token, ., ASSIGN_URSH, ;, break, ;, default, :, return, n, ;, }, Node, newNode, =, new, Node, (, newType, ,]
[default, :, return, n, ;, }, Node, newNode, =, new, Node, (, newType, ,, left, ., detachFromParent, (, ), ,]
[default, :, return, n, ;, }, Node, newNode, =, new, Node, (, newType, ,, left, ., detachFromParent, (, ), ,]
[newNode, =, new, Node, (, newType, ,, left, ., detachFromParent, (, ), ,, newRight, ., detachFromParent, (, ), ), ;]
[newNode, =, new, Node, (, newType, ,, left, ., detachFromParent, (, ), ,, newRight, ., detachFromParent, (, ), ), ;]
[newNode, =, new, Node, (, newType, ,, left, ., detachFromParent, (, ), ,, newRight, ., detachFromParent, (, ), ), ;]
[., detachFromParent, (, ), ,, newRight, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (]
[(, ), ,, newRight, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[newRight, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return]
[return, newNode, ;, }, private, Node, tryUnfoldAssignOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[private, Node, tryUnfoldAssignOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, late, ), {, return]
[n, ,, Node, left, ,, Node, right, ), {, if, (, late, ), {, return, n, ;, }, if, (]
[n, ,, Node, left, ,, Node, right, ), {, if, (, late, ), {, return, n, ;, }, if, (]
[,, Node, left, ,, Node, right, ), {, if, (, late, ), {, return, n, ;, }, if, (, !]
[,, Node, left, ,, Node, right, ), {, if, (, late, ), {, return, n, ;, }, if, (, !]
[), {, if, (, late, ), {, return, n, ;, }, if, (, !, n, ., hasChildren, (, ), ||]
[), {, if, (, late, ), {, return, n, ;, }, if, (, !, n, ., hasChildren, (, ), ||]
[), {, if, (, late, ), {, return, n, ;, }, if, (, !, n, ., hasChildren, (, ), ||]
[), {, if, (, late, ), {, return, n, ;, }, if, (, !, n, ., hasChildren, (, ), ||]
[}, if, (, !, n, ., hasChildren, (, ), ||, n, ., getFirstChild, (, ), ., getNext, (, ), !=]
[}, if, (, !, n, ., hasChildren, (, ), ||, n, ., getFirstChild, (, ), ., getNext, (, ), !=]
[), ||, n, ., getFirstChild, (, ), ., getNext, (, ), !=, n, ., getLastChild, (, ), ), {, return]
[(, ), ., getNext, (, ), !=, n, ., getLastChild, (, ), ), {, return, n, ;, }, if, (]
[., getNext, (, ), !=, n, ., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (]
[n, ., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return]
[{, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, int, op, =]
[{, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, int, op, =]
[}, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, int, op, =, NodeUtil, ., getOpFromAssignmentOp, (]
[), ), {, return, n, ;, }, int, op, =, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =]
[), ), {, return, n, ;, }, int, op, =, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =]
[n, ;, }, int, op, =, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =, IR, ., assign, (]
[n, ;, }, int, op, =, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =, IR, ., assign, (]
[NodeUtil, ., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =, IR, ., assign, (, left, ., detachFromParent, (, ), ,]
[NodeUtil, ., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =, IR, ., assign, (, left, ., detachFromParent, (, ), ,]
[(, n, ), ;, Node, replacement, =, IR, ., assign, (, left, ., detachFromParent, (, ), ,, new, Node, (]
[), ;, Node, replacement, =, IR, ., assign, (, left, ., detachFromParent, (, ), ,, new, Node, (, op, ,]
[), ;, Node, replacement, =, IR, ., assign, (, left, ., detachFromParent, (, ), ,, new, Node, (, op, ,]
[., assign, (, left, ., detachFromParent, (, ), ,, new, Node, (, op, ,, left, ., cloneTree, (, ), ,]
[., assign, (, left, ., detachFromParent, (, ), ,, new, Node, (, op, ,, left, ., cloneTree, (, ), ,]
[new, Node, (, op, ,, left, ., cloneTree, (, ), ,, right, ., detachFromParent, (, ), ), ., srcref, (]
[,, left, ., cloneTree, (, ), ,, right, ., detachFromParent, (, ), ), ., srcref, (, n, ), ), ;]
[,, left, ., cloneTree, (, ), ,, right, ., detachFromParent, (, ), ), ., srcref, (, n, ), ), ;]
[,, left, ., cloneTree, (, ), ,, right, ., detachFromParent, (, ), ), ., srcref, (, n, ), ), ;]
[., detachFromParent, (, ), ), ., srcref, (, n, ), ), ;, n, ., getParent, (, ), ., replaceChild, (]
[(, ), ), ., srcref, (, n, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[., srcref, (, n, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
[replacement, ;, }, private, Node, tryFoldAndOr, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, parent, =]
[replacement, ;, }, private, Node, tryFoldAndOr, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, parent, =]
[,, Node, left, ,, Node, right, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, result, =]
[right, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, result, =, null, ;, int, type, =]
[right, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, result, =, null, ;, int, type, =]
[(, ), ;, Node, result, =, null, ;, int, type, =, n, ., getType, (, ), ;, TernaryValue, leftVal, =]
[(, ), ;, Node, result, =, null, ;, int, type, =, n, ., getType, (, ), ;, TernaryValue, leftVal, =]
[result, =, null, ;, int, type, =, n, ., getType, (, ), ;, TernaryValue, leftVal, =, NodeUtil, ., getImpureBooleanValue, (]
[type, =, n, ., getType, (, ), ;, TernaryValue, leftVal, =, NodeUtil, ., getImpureBooleanValue, (, left, ), ;, if, (]
[type, =, n, ., getType, (, ), ;, TernaryValue, leftVal, =, NodeUtil, ., getImpureBooleanValue, (, left, ), ;, if, (]
[n, ., getType, (, ), ;, TernaryValue, leftVal, =, NodeUtil, ., getImpureBooleanValue, (, left, ), ;, if, (, leftVal, !=]
[n, ., getType, (, ), ;, TernaryValue, leftVal, =, NodeUtil, ., getImpureBooleanValue, (, left, ), ;, if, (, leftVal, !=]
[=, NodeUtil, ., getImpureBooleanValue, (, left, ), ;, if, (, leftVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =]
[=, NodeUtil, ., getImpureBooleanValue, (, left, ), ;, if, (, leftVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =]
[(, left, ), ;, if, (, leftVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (]
[(, leftVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (]
[(, leftVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (]
[(, leftVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (]
[!=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&]
[!=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&]
[., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==]
[., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==]
[boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, ., OR, ||]
[boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, ., OR, ||]
[lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, ., OR, ||, !]
[leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, ., OR, ||, !, lval, &&]
[leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, ., OR, ||, !, lval, &&]
[toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, ., OR, ||, !, lval, &&, type, ==]
[toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, ., OR, ||, !, lval, &&, type, ==]
[if, (, lval, &&, type, ==, Token, ., OR, ||, !, lval, &&, type, ==, Token, ., AND, ), {]
[lval, &&, type, ==, Token, ., OR, ||, !, lval, &&, type, ==, Token, ., AND, ), {, result, =]
[OR, ||, !, lval, &&, type, ==, Token, ., AND, ), {, result, =, left, ;, }, else, if, (]
[||, !, lval, &&, type, ==, Token, ., AND, ), {, result, =, left, ;, }, else, if, (, !]
[lval, &&, type, ==, Token, ., AND, ), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (]
[Token, ., AND, ), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {]
[AND, ), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =]
[;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =, right, ;, }, }, if, (]
[;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =, right, ;, }, }, if, (]
[else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =, right, ;, }, }, if, (, result, !=]
[!, mayHaveSideEffects, (, left, ), ), {, result, =, right, ;, }, }, if, (, result, !=, null, ), {]
[!, mayHaveSideEffects, (, left, ), ), {, result, =, right, ;, }, }, if, (, result, !=, null, ), {]
[), ), {, result, =, right, ;, }, }, if, (, result, !=, null, ), {, n, ., removeChild, (]
[result, =, right, ;, }, }, if, (, result, !=, null, ), {, n, ., removeChild, (, result, ), ;]
[result, =, right, ;, }, }, if, (, result, !=, null, ), {, n, ., removeChild, (, result, ), ;]
[}, }, if, (, result, !=, null, ), {, n, ., removeChild, (, result, ), ;, parent, ., replaceChild, (]
[if, (, result, !=, null, ), {, n, ., removeChild, (, result, ), ;, parent, ., replaceChild, (, n, ,]
[!=, null, ), {, n, ., removeChild, (, result, ), ;, parent, ., replaceChild, (, n, ,, result, ), ;]
[., removeChild, (, result, ), ;, parent, ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return]
[parent, ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return, result, ;, }, else, {, return]
[n, ;, }, }, private, Node, tryFoldChildAddString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[n, ;, }, }, private, Node, tryFoldChildAddString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[n, ;, }, }, private, Node, tryFoldChildAddString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[private, Node, tryFoldChildAddString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, NodeUtil, ., isLiteralValue, (]
[tryFoldChildAddString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, NodeUtil, ., isLiteralValue, (, right, ,]
[n, ,, Node, left, ,, Node, right, ), {, if, (, NodeUtil, ., isLiteralValue, (, right, ,, false, ), &&]
[n, ,, Node, left, ,, Node, right, ), {, if, (, NodeUtil, ., isLiteralValue, (, right, ,, false, ), &&]
[(, NodeUtil, ., isLiteralValue, (, right, ,, false, ), &&, left, ., isAdd, (, ), ), {, Node, ll, =]
[(, NodeUtil, ., isLiteralValue, (, right, ,, false, ), &&, left, ., isAdd, (, ), ), {, Node, ll, =]
[&&, left, ., isAdd, (, ), ), {, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =]
[&&, left, ., isAdd, (, ), ), {, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =]
[Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;, if, (]
[Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;, if, (]
[lr, =, ll, ., getNext, (, ), ;, if, (, lr, ., isString, (, ), ), {, String, leftString, =]
[lr, =, ll, ., getNext, (, ), ;, if, (, lr, ., isString, (, ), ), {, String, leftString, =]
[getNext, (, ), ;, if, (, lr, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (]
[lr, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, lr, ), ;, String, rightString, =]
[lr, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, lr, ), ;, String, rightString, =]
[), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, lr, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (]
[=, NodeUtil, ., getStringValue, (, lr, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (]
[=, NodeUtil, ., getStringValue, (, lr, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (]
[=, NodeUtil, ., getStringValue, (, lr, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (]
[., getStringValue, (, lr, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=]
[(, lr, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&]
[(, lr, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&]
[), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=]
[rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {]
[rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {]
[getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, left, ., removeChild, (]
[(, leftString, !=, null, &&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;, String, result, =]
[(, leftString, !=, null, &&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;, String, result, =]
[!=, null, &&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +]
[&&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;]
[&&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;]
[), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (]
[left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, left, ,]
[(, ll, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, left, ,, ll, ), ;]
[(, ll, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, left, ,, ll, ), ;]
[String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, left, ,, ll, ), ;, n, ., replaceChild, (]
[=, leftString, +, rightString, ;, n, ., replaceChild, (, left, ,, ll, ), ;, n, ., replaceChild, (, right, ,]
[=, leftString, +, rightString, ;, n, ., replaceChild, (, left, ,, ll, ), ;, n, ., replaceChild, (, right, ,]
[;, n, ., replaceChild, (, left, ,, ll, ), ;, n, ., replaceChild, (, right, ,, IR, ., string, (]
[(, left, ,, ll, ), ;, n, ., replaceChild, (, right, ,, IR, ., string, (, result, ), ), ;]
[;, n, ., replaceChild, (, right, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return]
[IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if, (]
[IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if, (]
[IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if, (]
[result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if, (, NodeUtil, ., isLiteralValue, (]
[), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if, (, NodeUtil, ., isLiteralValue, (, left, ,]
[(, ), ;, return, n, ;, }, }, }, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&]
[(, ), ;, return, n, ;, }, }, }, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&]
[(, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, right, ., isAdd, (, ), ), {, Node, rl, =]
[(, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, right, ., isAdd, (, ), ), {, Node, rl, =]
[&&, right, ., isAdd, (, ), ), {, Node, rl, =, right, ., getFirstChild, (, ), ;, Node, rr, =]
[&&, right, ., isAdd, (, ), ), {, Node, rl, =, right, ., getFirstChild, (, ), ;, Node, rr, =]
[Node, rl, =, right, ., getFirstChild, (, ), ;, Node, rr, =, right, ., getLastChild, (, ), ;, if, (]
[Node, rl, =, right, ., getFirstChild, (, ), ;, Node, rr, =, right, ., getLastChild, (, ), ;, if, (]
[rr, =, right, ., getLastChild, (, ), ;, if, (, rl, ., isString, (, ), ), {, String, leftString, =]
[rr, =, right, ., getLastChild, (, ), ;, if, (, rl, ., isString, (, ), ), {, String, leftString, =]
[getLastChild, (, ), ;, if, (, rl, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (]
[rl, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =]
[rl, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =]
[), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (]
[=, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (]
[=, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (]
[=, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (]
[., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (, leftString, !=]
[(, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (, leftString, !=, null, &&]
[(, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (, leftString, !=, null, &&]
[), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (, leftString, !=, null, &&, rightString, !=]
[rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {]
[rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {]
[getStringValue, (, rl, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, right, ., removeChild, (]
[(, leftString, !=, null, &&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;, String, result, =]
[(, leftString, !=, null, &&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;, String, result, =]
[!=, null, &&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +]
[&&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;]
[&&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;]
[), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (]
[right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, right, ,]
[(, rr, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, right, ,, rr, ), ;]
[(, rr, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, right, ,, rr, ), ;]
[String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, right, ,, rr, ), ;, n, ., replaceChild, (]
[=, leftString, +, rightString, ;, n, ., replaceChild, (, right, ,, rr, ), ;, n, ., replaceChild, (, left, ,]
[=, leftString, +, rightString, ;, n, ., replaceChild, (, right, ,, rr, ), ;, n, ., replaceChild, (, left, ,]
[;, n, ., replaceChild, (, right, ,, rr, ), ;, n, ., replaceChild, (, left, ,, IR, ., string, (]
[(, right, ,, rr, ), ;, n, ., replaceChild, (, left, ,, IR, ., string, (, result, ), ), ;]
[;, n, ., replaceChild, (, left, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return]
[,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, return]
[return, n, ;, }, private, Node, tryFoldAddConstantString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[return, n, ;, }, private, Node, tryFoldAddConstantString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[return, n, ;, }, private, Node, tryFoldAddConstantString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[tryFoldAddConstantString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, left, ., isString, (, ), ||]
[tryFoldAddConstantString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, left, ., isString, (, ), ||]
[), {, if, (, left, ., isString, (, ), ||, right, ., isString, (, ), ), {, String, leftString, =]
[), {, if, (, left, ., isString, (, ), ||, right, ., isString, (, ), ), {, String, leftString, =]
[left, ., isString, (, ), ||, right, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (]
[right, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =]
[right, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =]
[), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (]
[=, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (]
[=, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (]
[=, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (]
[., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=]
[(, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&]
[(, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&]
[), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=]
[., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =]
[., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =]
[), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (]
[), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (]
[if, (, leftString, !=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (, leftString, +]
[!=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;]
[!=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;]
[!=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;]
[Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[=, IR, ., string, (, leftString, +, rightString, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[string, (, leftString, +, rightString, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newStringNode, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newStringNode, ), ;, reportCodeChange, (, ), ;, return]
[(, ), ., replaceChild, (, n, ,, newStringNode, ), ;, reportCodeChange, (, ), ;, return, newStringNode, ;, }, }, return]
[n, ;, }, private, Node, tryFoldArithmeticOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, result, =]
[}, private, Node, tryFoldArithmeticOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, result, =, performArithmeticOp, (]
[}, private, Node, tryFoldArithmeticOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, result, =, performArithmeticOp, (]
[n, ,, Node, left, ,, Node, right, ), {, Node, result, =, performArithmeticOp, (, n, ., getType, (, ), ,]
[Node, left, ,, Node, right, ), {, Node, result, =, performArithmeticOp, (, n, ., getType, (, ), ,, left, ,]
[), {, Node, result, =, performArithmeticOp, (, n, ., getType, (, ), ,, left, ,, right, ), ;, if, (]
[), {, Node, result, =, performArithmeticOp, (, n, ., getType, (, ), ,, left, ,, right, ), ;, if, (]
[Node, result, =, performArithmeticOp, (, n, ., getType, (, ), ,, left, ,, right, ), ;, if, (, result, !=]
[performArithmeticOp, (, n, ., getType, (, ), ,, left, ,, right, ), ;, if, (, result, !=, null, ), {]
[performArithmeticOp, (, n, ., getType, (, ), ,, left, ,, right, ), ;, if, (, result, !=, null, ), {]
[getType, (, ), ,, left, ,, right, ), ;, if, (, result, !=, null, ), {, result, ., copyInformationFromForTree, (]
[,, left, ,, right, ), ;, if, (, result, !=, null, ), {, result, ., copyInformationFromForTree, (, n, ), ;]
[,, left, ,, right, ), ;, if, (, result, !=, null, ), {, result, ., copyInformationFromForTree, (, n, ), ;]
[,, left, ,, right, ), ;, if, (, result, !=, null, ), {, result, ., copyInformationFromForTree, (, n, ), ;]
[result, !=, null, ), {, result, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[null, ), {, result, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[result, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, result, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return]
[getParent, (, ), ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return, result, ;, }, return]
[return, n, ;, }, private, Node, performArithmeticOp, (, int, opType, ,, Node, left, ,, Node, right, ), {, if, (]
[return, n, ;, }, private, Node, performArithmeticOp, (, int, opType, ,, Node, left, ,, Node, right, ), {, if, (]
[return, n, ;, }, private, Node, performArithmeticOp, (, int, opType, ,, Node, left, ,, Node, right, ), {, if, (]
[;, }, private, Node, performArithmeticOp, (, int, opType, ,, Node, left, ,, Node, right, ), {, if, (, opType, ==]
[;, }, private, Node, performArithmeticOp, (, int, opType, ,, Node, left, ,, Node, right, ), {, if, (, opType, ==]
[performArithmeticOp, (, int, opType, ,, Node, left, ,, Node, right, ), {, if, (, opType, ==, Token, ., ADD, &&]
[(, int, opType, ,, Node, left, ,, Node, right, ), {, if, (, opType, ==, Token, ., ADD, &&, (]
[(, int, opType, ,, Node, left, ,, Node, right, ), {, if, (, opType, ==, Token, ., ADD, &&, (]
[(, int, opType, ,, Node, left, ,, Node, right, ), {, if, (, opType, ==, Token, ., ADD, &&, (]
[Node, left, ,, Node, right, ), {, if, (, opType, ==, Token, ., ADD, &&, (, NodeUtil, ., mayBeString, (]
[,, Node, right, ), {, if, (, opType, ==, Token, ., ADD, &&, (, NodeUtil, ., mayBeString, (, left, ,]
[), {, if, (, opType, ==, Token, ., ADD, &&, (, NodeUtil, ., mayBeString, (, left, ,, false, ), ||]
[), {, if, (, opType, ==, Token, ., ADD, &&, (, NodeUtil, ., mayBeString, (, left, ,, false, ), ||]
[opType, ==, Token, ., ADD, &&, (, NodeUtil, ., mayBeString, (, left, ,, false, ), ||, NodeUtil, ., mayBeString, (]
[Token, ., ADD, &&, (, NodeUtil, ., mayBeString, (, left, ,, false, ), ||, NodeUtil, ., mayBeString, (, right, ,]
[., mayBeString, (, left, ,, false, ), ||, NodeUtil, ., mayBeString, (, right, ,, false, ), ), ), {, return]
[., mayBeString, (, right, ,, false, ), ), ), {, return, null, ;, }, double, result, ;, Double, lValObj, =]
[., mayBeString, (, right, ,, false, ), ), ), {, return, null, ;, }, double, result, ;, Double, lValObj, =]
[,, false, ), ), ), {, return, null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (]
[{, return, null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (]
[{, return, null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (]
[null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (, lValObj, ==]
[result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (, lValObj, ==, null, ), {, return]
[., getNumberValue, (, left, ), ;, if, (, lValObj, ==, null, ), {, return, null, ;, }, Double, rValObj, =]
[., getNumberValue, (, left, ), ;, if, (, lValObj, ==, null, ), {, return, null, ;, }, Double, rValObj, =]
[), ;, if, (, lValObj, ==, null, ), {, return, null, ;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (]
[==, null, ), {, return, null, ;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[==, null, ), {, return, null, ;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[), {, return, null, ;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rValObj, ==]
[;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rValObj, ==, null, ), {, return]
[., getNumberValue, (, right, ), ;, if, (, rValObj, ==, null, ), {, return, null, ;, }, double, lval, =]
[;, if, (, rValObj, ==, null, ), {, return, null, ;, }, double, lval, =, lValObj, ;, double, rval, =]
[==, null, ), {, return, null, ;, }, double, lval, =, lValObj, ;, double, rval, =, rValObj, ;, switch, (]
[return, null, ;, }, double, lval, =, lValObj, ;, double, rval, =, rValObj, ;, switch, (, opType, ), {, case]
[return, null, ;, }, double, lval, =, lValObj, ;, double, rval, =, rValObj, ;, switch, (, opType, ), {, case]
[double, lval, =, lValObj, ;, double, rval, =, rValObj, ;, switch, (, opType, ), {, case, Token, ., BITAND, :]
[=, lValObj, ;, double, rval, =, rValObj, ;, switch, (, opType, ), {, case, Token, ., BITAND, :, result, =]
[=, lValObj, ;, double, rval, =, rValObj, ;, switch, (, opType, ), {, case, Token, ., BITAND, :, result, =]
[=, lValObj, ;, double, rval, =, rValObj, ;, switch, (, opType, ), {, case, Token, ., BITAND, :, result, =]
[rval, =, rValObj, ;, switch, (, opType, ), {, case, Token, ., BITAND, :, result, =, ScriptRuntime, ., toInt32, (]
[;, switch, (, opType, ), {, case, Token, ., BITAND, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), &]
[;, switch, (, opType, ), {, case, Token, ., BITAND, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), &]
[), {, case, Token, ., BITAND, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), &, ScriptRuntime, ., toInt32, (]
[:, result, =, ScriptRuntime, ., toInt32, (, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case]
[:, result, =, ScriptRuntime, ., toInt32, (, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case]
[., toInt32, (, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITOR, :]
[(, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITOR, :, result, =]
[(, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITOR, :, result, =]
[(, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITOR, :, result, =]
[ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, ., toInt32, (]
[(, rval, ), ;, break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), |]
[(, rval, ), ;, break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), |]
[break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32, (]
[:, result, =, ScriptRuntime, ., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case]
[:, result, =, ScriptRuntime, ., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case]
[., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITXOR, :]
[(, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITXOR, :, result, =]
[(, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITXOR, :, result, =]
[(, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITXOR, :, result, =]
[ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, ., toInt32, (]
[(, rval, ), ;, break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^]
[(, rval, ), ;, break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^]
[break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32, (]
[:, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case]
[:, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case]
[., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., ADD, :]
[(, lval, ), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., ADD, :, result, =]
[(, lval, ), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., ADD, :, result, =]
[), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., ADD, :, result, =, lval, +]
[(, rval, ), ;, break, ;, case, Token, ., ADD, :, result, =, lval, +, rval, ;, break, ;, case]
[(, rval, ), ;, break, ;, case, Token, ., ADD, :, result, =, lval, +, rval, ;, break, ;, case]
[break, ;, case, Token, ., ADD, :, result, =, lval, +, rval, ;, break, ;, case, Token, ., SUB, :]
[case, Token, ., ADD, :, result, =, lval, +, rval, ;, break, ;, case, Token, ., SUB, :, result, =]
[case, Token, ., ADD, :, result, =, lval, +, rval, ;, break, ;, case, Token, ., SUB, :, result, =]
[., ADD, :, result, =, lval, +, rval, ;, break, ;, case, Token, ., SUB, :, result, =, lval, -]
[lval, +, rval, ;, break, ;, case, Token, ., SUB, :, result, =, lval, -, rval, ;, break, ;, case]
[lval, +, rval, ;, break, ;, case, Token, ., SUB, :, result, =, lval, -, rval, ;, break, ;, case]
[break, ;, case, Token, ., SUB, :, result, =, lval, -, rval, ;, break, ;, case, Token, ., MUL, :]
[case, Token, ., SUB, :, result, =, lval, -, rval, ;, break, ;, case, Token, ., MUL, :, result, =]
[case, Token, ., SUB, :, result, =, lval, -, rval, ;, break, ;, case, Token, ., MUL, :, result, =]
[., SUB, :, result, =, lval, -, rval, ;, break, ;, case, Token, ., MUL, :, result, =, lval, *]
[lval, -, rval, ;, break, ;, case, Token, ., MUL, :, result, =, lval, *, rval, ;, break, ;, case]
[lval, -, rval, ;, break, ;, case, Token, ., MUL, :, result, =, lval, *, rval, ;, break, ;, case]
[case, Token, ., MUL, :, result, =, lval, *, rval, ;, break, ;, case, Token, ., MOD, :, if, (]
[case, Token, ., MUL, :, result, =, lval, *, rval, ;, break, ;, case, Token, ., MOD, :, if, (]
[., MUL, :, result, =, lval, *, rval, ;, break, ;, case, Token, ., MOD, :, if, (, rval, ==]
[=, lval, *, rval, ;, break, ;, case, Token, ., MOD, :, if, (, rval, ==, 0, ), {, return]
[rval, ;, break, ;, case, Token, ., MOD, :, if, (, rval, ==, 0, ), {, return, null, ;, }]
[break, ;, case, Token, ., MOD, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =]
[break, ;, case, Token, ., MOD, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =]
[case, Token, ., MOD, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =, lval, %]
[if, (, rval, ==, 0, ), {, return, null, ;, }, result, =, lval, %, rval, ;, break, ;, case]
[if, (, rval, ==, 0, ), {, return, null, ;, }, result, =, lval, %, rval, ;, break, ;, case]
[{, return, null, ;, }, result, =, lval, %, rval, ;, break, ;, case, Token, ., DIV, :, if, (]
[{, return, null, ;, }, result, =, lval, %, rval, ;, break, ;, case, Token, ., DIV, :, if, (]
[null, ;, }, result, =, lval, %, rval, ;, break, ;, case, Token, ., DIV, :, if, (, rval, ==]
[=, lval, %, rval, ;, break, ;, case, Token, ., DIV, :, if, (, rval, ==, 0, ), {, return]
[rval, ;, break, ;, case, Token, ., DIV, :, if, (, rval, ==, 0, ), {, return, null, ;, }]
[break, ;, case, Token, ., DIV, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =]
[break, ;, case, Token, ., DIV, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =]
[case, Token, ., DIV, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =, lval, /]
[rval, ==, 0, ), {, return, null, ;, }, result, =, lval, /, rval, ;, break, ;, default, :, throw]
[), {, return, null, ;, }, result, =, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (]
[result, =, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (]
[result, =, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (]
[result, =, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (]
[result, =, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (]
[=, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (]
[=, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (]
[=, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (]
[=, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (]
[=, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (]
[;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (, String, ., valueOf, (]
[Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (, String, ., valueOf, (, result, ), ., length, (, ), <=]
[Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (, String, ., valueOf, (, result, ), ., length, (, ), <=]
[Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (, String, ., valueOf, (, result, ), ., length, (, ), <=]
[Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (, String, ., valueOf, (, result, ), ., length, (, ), <=]
[Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (, String, ., valueOf, (, result, ), ., length, (, ), <=]
[;, }, if, (, (, String, ., valueOf, (, result, ), ., length, (, ), <=, String, ., valueOf, (]
[valueOf, (, result, ), ., length, (, ), <=, String, ., valueOf, (, lval, ), ., length, (, ), +]
[valueOf, (, result, ), ., length, (, ), <=, String, ., valueOf, (, lval, ), ., length, (, ), +]
[valueOf, (, result, ), ., length, (, ), <=, String, ., valueOf, (, lval, ), ., length, (, ), +]
[., length, (, ), <=, String, ., valueOf, (, lval, ), ., length, (, ), +, String, ., valueOf, (]
[valueOf, (, lval, ), ., length, (, ), +, String, ., valueOf, (, rval, ), ., length, (, ), +]
[lval, ), ., length, (, ), +, String, ., valueOf, (, rval, ), ., length, (, ), +, 1, &&]
[lval, ), ., length, (, ), +, String, ., valueOf, (, rval, ), ., length, (, ), +, 1, &&]
[lval, ), ., length, (, ), +, String, ., valueOf, (, rval, ), ., length, (, ), +, 1, &&]
[(, ), +, String, ., valueOf, (, rval, ), ., length, (, ), +, 1, &&, Math, ., abs, (]
[String, ., valueOf, (, rval, ), ., length, (, ), +, 1, &&, Math, ., abs, (, result, ), <=]
[(, rval, ), ., length, (, ), +, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||]
[(, rval, ), ., length, (, ), +, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||]
[length, (, ), +, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (]
[+, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||]
[+, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||]
[&&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==]
[&&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==]
[(, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||]
[(, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||]
[), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==]
[), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==]
[., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return]
[., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return]
[), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (]
[result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result, ,]
[||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;, }, return]
[null, ;, }, private, Node, tryFoldLeftChildOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, int, opType, =]
[null, ;, }, private, Node, tryFoldLeftChildOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, int, opType, =]
[(, Node, n, ,, Node, left, ,, Node, right, ), {, int, opType, =, n, ., getType, (, ), ;]
[(, Node, n, ,, Node, left, ,, Node, right, ), {, int, opType, =, n, ., getType, (, ), ;]
[Node, left, ,, Node, right, ), {, int, opType, =, n, ., getType, (, ), ;, Preconditions, ., checkState, (]
[Node, left, ,, Node, right, ), {, int, opType, =, n, ., getType, (, ), ;, Preconditions, ., checkState, (]
[left, ,, Node, right, ), {, int, opType, =, n, ., getType, (, ), ;, Preconditions, ., checkState, (, (]
[left, ,, Node, right, ), {, int, opType, =, n, ., getType, (, ), ;, Preconditions, ., checkState, (, (]
[left, ,, Node, right, ), {, int, opType, =, n, ., getType, (, ), ;, Preconditions, ., checkState, (, (]
[), {, int, opType, =, n, ., getType, (, ), ;, Preconditions, ., checkState, (, (, NodeUtil, ., isAssociative, (]
[opType, =, n, ., getType, (, ), ;, Preconditions, ., checkState, (, (, NodeUtil, ., isAssociative, (, opType, ), &&]
[opType, =, n, ., getType, (, ), ;, Preconditions, ., checkState, (, (, NodeUtil, ., isAssociative, (, opType, ), &&]
[getType, (, ), ;, Preconditions, ., checkState, (, (, NodeUtil, ., isAssociative, (, opType, ), &&, NodeUtil, ., isCommutative, (]
[Preconditions, ., checkState, (, (, NodeUtil, ., isAssociative, (, opType, ), &&, NodeUtil, ., isCommutative, (, opType, ), ), ||]
[Preconditions, ., checkState, (, (, NodeUtil, ., isAssociative, (, opType, ), &&, NodeUtil, ., isCommutative, (, opType, ), ), ||]
[isAssociative, (, opType, ), &&, NodeUtil, ., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), ), ;]
[isAssociative, (, opType, ), &&, NodeUtil, ., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), ), ;]
[&&, NodeUtil, ., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (]
[&&, NodeUtil, ., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (]
[NodeUtil, ., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !]
[NodeUtil, ., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !]
[), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||]
[||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||, !]
[||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||, !]
[(, ), ), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||, !, NodeUtil, ., mayBeString, (]
[(, !, n, ., isAdd, (, ), ||, !, NodeUtil, ., mayBeString, (, n, ), ), ;, Double, rightValObj, =]
[(, !, n, ., isAdd, (, ), ||, !, NodeUtil, ., mayBeString, (, n, ), ), ;, Double, rightValObj, =]
[isAdd, (, ), ||, !, NodeUtil, ., mayBeString, (, n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (]
[NodeUtil, ., mayBeString, (, n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[NodeUtil, ., mayBeString, (, n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[NodeUtil, ., mayBeString, (, n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[mayBeString, (, n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=]
[n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&]
[n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&]
[n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&]
[=, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&, left, ., getType, (, ), ==]
[getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&, left, ., getType, (, ), ==, opType, ), {]
[getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&, left, ., getType, (, ), ==, opType, ), {]
[;, if, (, rightValObj, !=, null, &&, left, ., getType, (, ), ==, opType, ), {, Preconditions, ., checkState, (]
[;, if, (, rightValObj, !=, null, &&, left, ., getType, (, ), ==, opType, ), {, Preconditions, ., checkState, (]
[;, if, (, rightValObj, !=, null, &&, left, ., getType, (, ), ==, opType, ), {, Preconditions, ., checkState, (]
[&&, left, ., getType, (, ), ==, opType, ), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==]
[==, opType, ), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==, 2, ), ;, Node, ll, =]
[==, opType, ), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==, 2, ), ;, Node, ll, =]
[., getChildCount, (, ), ==, 2, ), ;, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =]
[., getChildCount, (, ), ==, 2, ), ;, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =]
[ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;, Node, valueToCombine, =]
[(, ), ;, Node, lr, =, ll, ., getNext, (, ), ;, Node, valueToCombine, =, ll, ;, Node, replacement, =]
[;, Node, lr, =, ll, ., getNext, (, ), ;, Node, valueToCombine, =, ll, ;, Node, replacement, =, performArithmeticOp, (]
[lr, =, ll, ., getNext, (, ), ;, Node, valueToCombine, =, ll, ;, Node, replacement, =, performArithmeticOp, (, opType, ,]
[ll, ., getNext, (, ), ;, Node, valueToCombine, =, ll, ;, Node, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,]
[;, Node, valueToCombine, =, ll, ;, Node, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, if, (]
[;, Node, valueToCombine, =, ll, ;, Node, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, if, (]
[valueToCombine, =, ll, ;, Node, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, if, (, replacement, ==]
[;, Node, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, if, (, replacement, ==, null, ), {]
[replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, if, (, replacement, ==, null, ), {, valueToCombine, =]
[performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, if, (, replacement, ==, null, ), {, valueToCombine, =, lr, ;]
[opType, ,, valueToCombine, ,, right, ), ;, if, (, replacement, ==, null, ), {, valueToCombine, =, lr, ;, replacement, =]
[valueToCombine, ,, right, ), ;, if, (, replacement, ==, null, ), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (]
[right, ), ;, if, (, replacement, ==, null, ), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,]
[;, if, (, replacement, ==, null, ), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,]
[), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (]
[), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (]
[valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (, replacement, !=]
[;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (, replacement, !=, null, ), {]
[;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (, replacement, !=, null, ), {]
[(, opType, ,, valueToCombine, ,, right, ), ;, }, if, (, replacement, !=, null, ), {, left, ., removeChild, (]
[valueToCombine, ,, right, ), ;, }, if, (, replacement, !=, null, ), {, left, ., removeChild, (, valueToCombine, ), ;]
[valueToCombine, ,, right, ), ;, }, if, (, replacement, !=, null, ), {, left, ., removeChild, (, valueToCombine, ), ;]
[;, }, if, (, replacement, !=, null, ), {, left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (]
[if, (, replacement, !=, null, ), {, left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (, left, ,]
[if, (, replacement, !=, null, ), {, left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (, left, ,]
[left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, ), ), ;]
[left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, ), ), ;]
[valueToCombine, ), ;, n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (]
[n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (, right, ), ;]
[n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (, right, ), ;]
[left, ,, left, ., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (, right, ), ;, n, ., replaceChild, (]
[left, ., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (, right, ), ;, n, ., replaceChild, (, right, ,]
[(, ), ), ;, replacement, ., copyInformationFromForTree, (, right, ), ;, n, ., replaceChild, (, right, ,, replacement, ), ;]
[(, right, ), ;, n, ., replaceChild, (, right, ,, replacement, ), ;, reportCodeChange, (, ), ;, }, }, return]
[}, }, return, n, ;, }, private, Node, tryFoldAdd, (, Node, node, ,, Node, left, ,, Node, right, ), {]
[}, }, return, n, ;, }, private, Node, tryFoldAdd, (, Node, node, ,, Node, left, ,, Node, right, ), {]
[;, }, private, Node, tryFoldAdd, (, Node, node, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, }, private, Node, tryFoldAdd, (, Node, node, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, node, ., isAdd, (, ), ), ;, if, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, node, ., isAdd, (, ), ), ;, if, (]
[right, ), {, Preconditions, ., checkArgument, (, node, ., isAdd, (, ), ), ;, if, (, NodeUtil, ., mayBeString, (]
[{, Preconditions, ., checkArgument, (, node, ., isAdd, (, ), ), ;, if, (, NodeUtil, ., mayBeString, (, node, ,]
[., isAdd, (, ), ), ;, if, (, NodeUtil, ., mayBeString, (, node, ,, true, ), ), {, if, (]
[., isAdd, (, ), ), ;, if, (, NodeUtil, ., mayBeString, (, node, ,, true, ), ), {, if, (]
[., isAdd, (, ), ), ;, if, (, NodeUtil, ., mayBeString, (, node, ,, true, ), ), {, if, (]
[), ;, if, (, NodeUtil, ., mayBeString, (, node, ,, true, ), ), {, if, (, NodeUtil, ., isLiteralValue, (]
[if, (, NodeUtil, ., mayBeString, (, node, ,, true, ), ), {, if, (, NodeUtil, ., isLiteralValue, (, left, ,]
[., mayBeString, (, node, ,, true, ), ), {, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&]
[., mayBeString, (, node, ,, true, ), ), {, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&]
[,, true, ), ), {, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, NodeUtil, ., isLiteralValue, (]
[), ), {, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, NodeUtil, ., isLiteralValue, (, right, ,]
[NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, NodeUtil, ., isLiteralValue, (, right, ,, false, ), ), {, return]
[isLiteralValue, (, left, ,, false, ), &&, NodeUtil, ., isLiteralValue, (, right, ,, false, ), ), {, return, tryFoldAddConstantString, (]
[left, ,, false, ), &&, NodeUtil, ., isLiteralValue, (, right, ,, false, ), ), {, return, tryFoldAddConstantString, (, node, ,]
[false, ), &&, NodeUtil, ., isLiteralValue, (, right, ,, false, ), ), {, return, tryFoldAddConstantString, (, node, ,, left, ,]
[right, ,, false, ), ), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right, ), ;, }, else, {, return]
[false, ), ), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right, ), ;, }, else, {, return, tryFoldChildAddString, (]
[), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right, ), ;, }, else, {, return, tryFoldChildAddString, (, node, ,]
[return, tryFoldAddConstantString, (, node, ,, left, ,, right, ), ;, }, else, {, return, tryFoldChildAddString, (, node, ,, left, ,]
[}, else, {, return, tryFoldChildAddString, (, node, ,, left, ,, right, ), ;, }, }, else, {, Node, result, =]
[{, return, tryFoldChildAddString, (, node, ,, left, ,, right, ), ;, }, }, else, {, Node, result, =, tryFoldArithmeticOp, (]
[tryFoldChildAddString, (, node, ,, left, ,, right, ), ;, }, }, else, {, Node, result, =, tryFoldArithmeticOp, (, node, ,]
[node, ,, left, ,, right, ), ;, }, }, else, {, Node, result, =, tryFoldArithmeticOp, (, node, ,, left, ,]
[), ;, }, }, else, {, Node, result, =, tryFoldArithmeticOp, (, node, ,, left, ,, right, ), ;, if, (]
[), ;, }, }, else, {, Node, result, =, tryFoldArithmeticOp, (, node, ,, left, ,, right, ), ;, if, (]
[}, }, else, {, Node, result, =, tryFoldArithmeticOp, (, node, ,, left, ,, right, ), ;, if, (, result, !=]
[Node, result, =, tryFoldArithmeticOp, (, node, ,, left, ,, right, ), ;, if, (, result, !=, node, ), {, return]
[(, node, ,, left, ,, right, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return]
[,, left, ,, right, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (]
[,, right, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, node, ,]
[), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, node, ,, left, ,]
[), ;, }, }, private, Node, tryFoldShift, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[), ;, }, }, private, Node, tryFoldShift, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[), ;, }, }, private, Node, tryFoldShift, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[tryFoldShift, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, left, ., isNumber, (, ), &&]
[tryFoldShift, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, left, ., isNumber, (, ), &&]
[(, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), {, double, result, ;, double, lval, =]
[(, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), {, double, result, ;, double, lval, =]
[isNumber, (, ), ), {, double, result, ;, double, lval, =, left, ., getDouble, (, ), ;, double, rval, =]
[isNumber, (, ), ), {, double, result, ;, double, lval, =, left, ., getDouble, (, ), ;, double, rval, =]
[double, lval, =, left, ., getDouble, (, ), ;, double, rval, =, right, ., getDouble, (, ), ;, if, (]
[lval, =, left, ., getDouble, (, ), ;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !]
[=, left, ., getDouble, (, ), ;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !, (]
[=, left, ., getDouble, (, ), ;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !, (]
[=, left, ., getDouble, (, ), ;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !, (]
[., getDouble, (, ), ;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !, (, lval, >=]
[., getDouble, (, ), ;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !, (, lval, >=]
[;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !, (, lval, >=, Integer, ., MIN_VALUE, &&]
[;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !, (, lval, >=, Integer, ., MIN_VALUE, &&]
[rval, =, right, ., getDouble, (, ), ;, if, (, !, (, lval, >=, Integer, ., MIN_VALUE, &&, lval, <=]
[rval, =, right, ., getDouble, (, ), ;, if, (, !, (, lval, >=, Integer, ., MIN_VALUE, &&, lval, <=]
[), ;, if, (, !, (, lval, >=, Integer, ., MIN_VALUE, &&, lval, <=, Integer, ., MAX_VALUE, ), ), {]
[if, (, !, (, lval, >=, Integer, ., MIN_VALUE, &&, lval, <=, Integer, ., MAX_VALUE, ), ), {, report, (]
[!, (, lval, >=, Integer, ., MIN_VALUE, &&, lval, <=, Integer, ., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,]
[Integer, ., MIN_VALUE, &&, lval, <=, Integer, ., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return]
[<=, Integer, ., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (]
[Integer, ., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !]
[., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (]
[., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (]
[., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (]
[), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=]
[{, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=, 0, &&]
[{, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=, 0, &&]
[(, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=, 0, &&, rval, <]
[), ;, return, n, ;, }, if, (, !, (, rval, >=, 0, &&, rval, <, 32, ), ), {]
[return, n, ;, }, if, (, !, (, rval, >=, 0, &&, rval, <, 32, ), ), {, report, (]
[;, }, if, (, !, (, rval, >=, 0, &&, rval, <, 32, ), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,]
[!, (, rval, >=, 0, &&, rval, <, 32, ), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return]
[rval, <, 32, ), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =]
[), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, )]
[(, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, ), lval, ;, if, (]
[(, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, ), lval, ;, if, (]
[,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, ), lval, ;, if, (, lvalInt, !=]
[;, return, n, ;, }, int, lvalInt, =, (, int, ), lval, ;, if, (, lvalInt, !=, lval, ), {]
[n, ;, }, int, lvalInt, =, (, int, ), lval, ;, if, (, lvalInt, !=, lval, ), {, report, (]
[}, int, lvalInt, =, (, int, ), lval, ;, if, (, lvalInt, !=, lval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,]
[(, int, ), lval, ;, if, (, lvalInt, !=, lval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return]
[(, lvalInt, !=, lval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, int, rvalInt, =]
[lval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, int, rvalInt, =, (, int, )]
[(, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, int, rvalInt, =, (, int, ), rval, ;, if, (]
[(, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, int, rvalInt, =, (, int, ), rval, ;, if, (]
[,, left, ), ;, return, n, ;, }, int, rvalInt, =, (, int, ), rval, ;, if, (, rvalInt, !=]
[;, return, n, ;, }, int, rvalInt, =, (, int, ), rval, ;, if, (, rvalInt, !=, rval, ), {]
[n, ;, }, int, rvalInt, =, (, int, ), rval, ;, if, (, rvalInt, !=, rval, ), {, report, (]
[}, int, rvalInt, =, (, int, ), rval, ;, if, (, rvalInt, !=, rval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,]
[(, int, ), rval, ;, if, (, rvalInt, !=, rval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return]
[if, (, rvalInt, !=, rval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return, n, ;, }, switch, (]
[if, (, rvalInt, !=, rval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return, n, ;, }, switch, (]
[(, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[(, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[), ;, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., LSH, :]
[return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., LSH, :, result, =]
[return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., LSH, :, result, =]
[;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., LSH, :, result, =, lvalInt, <<]
[., getType, (, ), ), {, case, Token, ., LSH, :, result, =, lvalInt, <<, rvalInt, ;, break, ;, case]
[., getType, (, ), ), {, case, Token, ., LSH, :, result, =, lvalInt, <<, rvalInt, ;, break, ;, case]
[), {, case, Token, ., LSH, :, result, =, lvalInt, <<, rvalInt, ;, break, ;, case, Token, ., RSH, :]
[case, Token, ., LSH, :, result, =, lvalInt, <<, rvalInt, ;, break, ;, case, Token, ., RSH, :, result, =]
[case, Token, ., LSH, :, result, =, lvalInt, <<, rvalInt, ;, break, ;, case, Token, ., RSH, :, result, =]
[LSH, :, result, =, lvalInt, <<, rvalInt, ;, break, ;, case, Token, ., RSH, :, result, =, lvalInt, >, >]
[<<, rvalInt, ;, break, ;, case, Token, ., RSH, :, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case]
[<<, rvalInt, ;, break, ;, case, Token, ., RSH, :, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case]
[., RSH, :, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =]
[., RSH, :, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =]
[:, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &]
[=, lvalInt, >, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;]
[>, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;, result, =]
[>, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;, result, =]
[break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;, result, =, lvalLong, >, >, >]
[long, lvalLong, =, lvalInt, &, 0xffffffffL, ;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw]
[lvalInt, &, 0xffffffffL, ;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (]
[lvalInt, &, 0xffffffffL, ;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (]
[0xffffffffL, ;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +]
[0xffffffffL, ;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +]
[lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +, Token, ., name, (]
[lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +, Token, ., name, (]
[AssertionError, (, "Unknown shift operator: ", +, Token, ., name, (, n, ., getType, (, ), ), ), ;, }, Node, newNumber, =]
[AssertionError, (, "Unknown shift operator: ", +, Token, ., name, (, n, ., getType, (, ), ), ), ;, }, Node, newNumber, =]
[Token, ., name, (, n, ., getType, (, ), ), ), ;, }, Node, newNumber, =, IR, ., number, (]
[(, n, ., getType, (, ), ), ), ;, }, Node, newNumber, =, IR, ., number, (, result, ), ;]
[(, n, ., getType, (, ), ), ), ;, }, Node, newNumber, =, IR, ., number, (, result, ), ;]
[(, n, ., getType, (, ), ), ), ;, }, Node, newNumber, =, IR, ., number, (, result, ), ;]
[;, }, Node, newNumber, =, IR, ., number, (, result, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[Node, newNumber, =, IR, ., number, (, result, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[IR, ., number, (, result, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNumber, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNumber, ), ;, reportCodeChange, (, ), ;, return]
[getParent, (, ), ., replaceChild, (, n, ,, newNumber, ), ;, reportCodeChange, (, ), ;, return, newNumber, ;, }, return]
[., replaceChild, (, n, ,, newNumber, ), ;, reportCodeChange, (, ), ;, return, newNumber, ;, }, return, n, ;, }]
[n, ,, newNumber, ), ;, reportCodeChange, (, ), ;, return, newNumber, ;, }, return, n, ;, }, @, SuppressWarnings, (]
[(, "fallthrough", ), private, Node, tryFoldComparison, (, Node, n, ,, Node, left, ,, Node, right, ), {, TernaryValue, result, =]
[), private, Node, tryFoldComparison, (, Node, n, ,, Node, left, ,, Node, right, ), {, TernaryValue, result, =, evaluateComparison, (]
[), private, Node, tryFoldComparison, (, Node, n, ,, Node, left, ,, Node, right, ), {, TernaryValue, result, =, evaluateComparison, (]
[n, ,, Node, left, ,, Node, right, ), {, TernaryValue, result, =, evaluateComparison, (, n, ., getType, (, ), ,]
[Node, left, ,, Node, right, ), {, TernaryValue, result, =, evaluateComparison, (, n, ., getType, (, ), ,, left, ,]
[), {, TernaryValue, result, =, evaluateComparison, (, n, ., getType, (, ), ,, left, ,, right, ), ;, if, (]
[), {, TernaryValue, result, =, evaluateComparison, (, n, ., getType, (, ), ,, left, ,, right, ), ;, if, (]
[TernaryValue, result, =, evaluateComparison, (, n, ., getType, (, ), ,, left, ,, right, ), ;, if, (, result, ==]
[TernaryValue, result, =, evaluateComparison, (, n, ., getType, (, ), ,, left, ,, right, ), ;, if, (, result, ==]
[., getType, (, ), ,, left, ,, right, ), ;, if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return]
[,, right, ), ;, if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =]
[,, right, ), ;, if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =]
[if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (]
[if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (]
[TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (, result, ., toBoolean, (]
[{, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (, result, ., toBoolean, (, true, ), ), ;]
[{, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (, result, ., toBoolean, (, true, ), ), ;]
[{, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (, result, ., toBoolean, (, true, ), ), ;]
[NodeUtil, ., booleanNode, (, result, ., toBoolean, (, true, ), ), ;, n, ., getParent, (, ), ., replaceChild, (]
[booleanNode, (, result, ., toBoolean, (, true, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[., toBoolean, (, true, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return]
[newNode, ;, }, static, TernaryValue, evaluateComparison, (, int, op, ,, Node, left, ,, Node, right, ), {, boolean, leftLiteral, =]
[newNode, ;, }, static, TernaryValue, evaluateComparison, (, int, op, ,, Node, left, ,, Node, right, ), {, boolean, leftLiteral, =]
[TernaryValue, evaluateComparison, (, int, op, ,, Node, left, ,, Node, right, ), {, boolean, leftLiteral, =, NodeUtil, ., isLiteralValue, (]
[(, int, op, ,, Node, left, ,, Node, right, ), {, boolean, leftLiteral, =, NodeUtil, ., isLiteralValue, (, left, ,]
[,, Node, right, ), {, boolean, leftLiteral, =, NodeUtil, ., isLiteralValue, (, left, ,, true, ), ;, boolean, rightLiteral, =]
[,, Node, right, ), {, boolean, leftLiteral, =, NodeUtil, ., isLiteralValue, (, left, ,, true, ), ;, boolean, rightLiteral, =]
[{, boolean, leftLiteral, =, NodeUtil, ., isLiteralValue, (, left, ,, true, ), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (]
[leftLiteral, =, NodeUtil, ., isLiteralValue, (, left, ,, true, ), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,]
[(, left, ,, true, ), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (]
[(, left, ,, true, ), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (]
[left, ,, true, ), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (, !]
[true, ), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||]
[), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||, !]
[NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (]
[NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (]
[NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (]
[isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op, !=]
[isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op, !=]
[true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&]
[true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&]
[;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&, op, !=]
[;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&, op, !=]
[!, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&, op, !=, Token, ., LT, ), {, return]
[!, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&, op, !=, Token, ., LT, ), {, return]
[., GT, &&, op, !=, Token, ., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =]
[., GT, &&, op, !=, Token, ., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =]
[., GT, &&, op, !=, Token, ., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =]
[!=, Token, ., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (]
[LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (, right, ), &&]
[., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (, right, ), &&, rightLiteral, ;, boolean, nullRight, =]
[., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (, right, ), &&, rightLiteral, ;, boolean, nullRight, =]
[., isUndefined, (, right, ), &&, rightLiteral, ;, boolean, nullRight, =, right, ., isNull, (, ), ;, int, lhType, =]
[(, right, ), &&, rightLiteral, ;, boolean, nullRight, =, right, ., isNull, (, ), ;, int, lhType, =, getNormalizedNodeType, (]
[boolean, nullRight, =, right, ., isNull, (, ), ;, int, lhType, =, getNormalizedNodeType, (, left, ), ;, int, rhType, =]
[=, right, ., isNull, (, ), ;, int, lhType, =, getNormalizedNodeType, (, left, ), ;, int, rhType, =, getNormalizedNodeType, (]
[), ;, int, lhType, =, getNormalizedNodeType, (, left, ), ;, int, rhType, =, getNormalizedNodeType, (, right, ), ;, switch, (]
[=, getNormalizedNodeType, (, left, ), ;, int, rhType, =, getNormalizedNodeType, (, right, ), ;, switch, (, lhType, ), {, case]
[=, getNormalizedNodeType, (, left, ), ;, int, rhType, =, getNormalizedNodeType, (, right, ), ;, switch, (, lhType, ), {, case]
[int, rhType, =, getNormalizedNodeType, (, right, ), ;, switch, (, lhType, ), {, case, Token, ., VOID, :, if, (]
[rhType, =, getNormalizedNodeType, (, right, ), ;, switch, (, lhType, ), {, case, Token, ., VOID, :, if, (, !]
[right, ), ;, switch, (, lhType, ), {, case, Token, ., VOID, :, if, (, !, leftLiteral, ), {, return]
[right, ), ;, switch, (, lhType, ), {, case, Token, ., VOID, :, if, (, !, leftLiteral, ), {, return]
[case, Token, ., VOID, :, if, (, !, leftLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, if, (]
[Token, ., VOID, :, if, (, !, leftLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, if, (, !]
[if, (, !, leftLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, if, (, !, rightLiteral, ), {, return]
[if, (, !, leftLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, if, (, !, rightLiteral, ), {, return]
[., UNKNOWN, ;, }, else, if, (, !, rightLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return]
[., UNKNOWN, ;, }, else, if, (, !, rightLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return]
[else, if, (, !, rightLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, TernaryValue, ., forBoolean, (]
[(, !, rightLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[rightLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,]
[UNKNOWN, ;, }, else, {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, case]
[UNKNOWN, ;, }, else, {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, case]
[TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, case, Token, ., NULL, :, if, (]
[TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, case, Token, ., NULL, :, if, (]
[forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, case, Token, ., NULL, :, if, (, rightLiteral, &&]
[compareToUndefined, (, right, ,, op, ), ), ;, }, case, Token, ., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (]
[), ), ;, }, case, Token, ., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return]
[), ), ;, }, case, Token, ., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return]
[case, Token, ., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (]
[., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[:, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,]
[(, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,, op, ), ), ;, }, case]
[(, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,, op, ), ), ;, }, case]
[return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,, op, ), ), ;, }, case, Token, ., TRUE, :, case]
[return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,, op, ), ), ;, }, case, Token, ., TRUE, :, case]
[(, right, ,, op, ), ), ;, }, case, Token, ., TRUE, :, case, Token, ., FALSE, :, if, (]
[), ), ;, }, case, Token, ., TRUE, :, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return]
[), ), ;, }, case, Token, ., TRUE, :, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return]
[case, Token, ., TRUE, :, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (]
[., TRUE, :, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[:, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rhType, !=]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rhType, !=]
[., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&]
[., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&]
[(, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=]
[(, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=]
[,, op, ), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&]
[,, op, ), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&]
[), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&, rhType, !=]
[), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&, rhType, !=]
[rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&, rhType, !=, Token, ., NULL, ), {, return]
[rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&, rhType, !=, Token, ., NULL, ), {, return]
[!=, Token, ., FALSE, &&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (]
[&&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[&&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case]
[NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return]
[switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., forBoolean, (]
[switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., forBoolean, (]
[op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., forBoolean, (, lhType, ==]
[Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case]
[Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case]
[Token, ., EQ, :, return, TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case, Token, ., SHNE, :, case]
[Token, ., EQ, :, return, TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case, Token, ., SHNE, :, case]
[TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return]
[TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return]
[lhType, ==, rhType, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (]
[lhType, ==, rhType, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (]
[rhType, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=]
[Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case]
[Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case]
[Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case, Token, ., GE, :, case]
[Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case, Token, ., GE, :, case]
[TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case, Token, ., GE, :, case, Token, ., LE, :, case]
[TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case, Token, ., GE, :, case, Token, ., LE, :, case]
[!=, rhType, ), ;, case, Token, ., GE, :, case, Token, ., LE, :, case, Token, ., GT, :, case]
[!=, rhType, ), ;, case, Token, ., GE, :, case, Token, ., LE, :, case, Token, ., GT, :, case]
[Token, ., GE, :, case, Token, ., LE, :, case, Token, ., GT, :, case, Token, ., LT, :, return]
[GE, :, case, Token, ., LE, :, case, Token, ., GT, :, case, Token, ., LT, :, return, compareAsNumbers, (]
[case, Token, ., LE, :, case, Token, ., GT, :, case, Token, ., LT, :, return, compareAsNumbers, (, op, ,]
[., LE, :, case, Token, ., GT, :, case, Token, ., LT, :, return, compareAsNumbers, (, op, ,, left, ,]
[., GT, :, case, Token, ., LT, :, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, }, return]
[., GT, :, case, Token, ., LT, :, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, }, return]
[., LT, :, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[., LT, :, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[op, ,, left, ,, right, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., THIS, :, if, (]
[,, left, ,, right, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., THIS, :, if, (, !]
[,, left, ,, right, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., THIS, :, if, (, !]
[TernaryValue, ., UNKNOWN, ;, case, Token, ., THIS, :, if, (, !, right, ., isThis, (, ), ), {, return]
[TernaryValue, ., UNKNOWN, ;, case, Token, ., THIS, :, if, (, !, right, ., isThis, (, ), ), {, return]
[THIS, :, if, (, !, right, ., isThis, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (]
[!, right, ., isThis, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[!, right, ., isThis, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case]
[), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return]
[(, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., TRUE, ;, case]
[(, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., TRUE, ;, case]
[Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., TRUE, ;, case, Token, ., SHNE, :, case]
[Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., TRUE, ;, case, Token, ., SHNE, :, case]
[Token, ., EQ, :, return, TernaryValue, ., TRUE, ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return]
[Token, ., EQ, :, return, TernaryValue, ., TRUE, ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return]
[., TRUE, ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., FALSE, ;, }, return]
[., TRUE, ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., FALSE, ;, }, return]
[., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[NE, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., STRING, :, if, (]
[., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., STRING, :, if, (, undefinedRight, ), {, return]
[., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., STRING, :, if, (, undefinedRight, ), {, return]
[return, TernaryValue, ., UNKNOWN, ;, case, Token, ., STRING, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (]
[., UNKNOWN, ;, case, Token, ., STRING, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[;, case, Token, ., STRING, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&]
[return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (]
[compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (]
[), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[}, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (]
[return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, ., STRING, !=]
[return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, ., STRING, !=]
[,, op, ), ), ;, }, if, (, Token, ., STRING, !=, right, ., getType, (, ), ), {, return]
[,, op, ), ), ;, }, if, (, Token, ., STRING, !=, right, ., getType, (, ), ), {, return]
[(, Token, ., STRING, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (]
[!=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[!=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case]
[), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return]
[;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, areStringsEqual, (]
[;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, areStringsEqual, (]
[{, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, areStringsEqual, (, left, ., getString, (, ), ,]
[{, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, areStringsEqual, (, left, ., getString, (, ), ,]
[., EQ, :, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString, (, ), ), ;, case]
[., EQ, :, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString, (, ), ), ;, case]
[(, left, ., getString, (, ), ,, right, ., getString, (, ), ), ;, case, Token, ., SHNE, :, case]
[(, left, ., getString, (, ), ,, right, ., getString, (, ), ), ;, case, Token, ., SHNE, :, case]
[), ,, right, ., getString, (, ), ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return]
[), ,, right, ., getString, (, ), ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return]
[right, ., getString, (, ), ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, areStringsEqual, (]
[right, ., getString, (, ), ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, areStringsEqual, (]
[;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, areStringsEqual, (, left, ., getString, (, ), ,]
[;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, areStringsEqual, (, left, ., getString, (, ), ,]
[(, left, ., getString, (, ), ,, right, ., getString, (, ), ), ., not, (, ), ;, }, return]
[(, left, ., getString, (, ), ,, right, ., getString, (, ), ), ., not, (, ), ;, }, return]
[), ,, right, ., getString, (, ), ), ., not, (, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[), ,, right, ., getString, (, ), ), ., not, (, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[), ), ., not, (, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NUMBER, :, if, (]
[(, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NUMBER, :, if, (, undefinedRight, ), {, return]
[(, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NUMBER, :, if, (, undefinedRight, ), {, return]
[return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NUMBER, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (]
[., UNKNOWN, ;, case, Token, ., NUMBER, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[;, case, Token, ., NUMBER, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&]
[return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (]
[compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (]
[), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[}, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (]
[return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, ., NUMBER, !=]
[return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, ., NUMBER, !=]
[,, op, ), ), ;, }, if, (, Token, ., NUMBER, !=, right, ., getType, (, ), ), {, return]
[,, op, ), ), ;, }, if, (, Token, ., NUMBER, !=, right, ., getType, (, ), ), {, return]
[if, (, Token, ., NUMBER, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, return]
[Token, ., NUMBER, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (]
[NUMBER, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,]
[right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left, ,]
[), ), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, case]
[), ), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, case]
[UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, case, Token, ., NAME, :, if, (]
[UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, case, Token, ., NAME, :, if, (]
[}, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, case, Token, ., NAME, :, if, (, leftLiteral, &&]
[op, ,, left, ,, right, ), ;, case, Token, ., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return]
[op, ,, left, ,, right, ), ;, case, Token, ., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return]
[right, ), ;, case, Token, ., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (]
[;, case, Token, ., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[Token, ., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[&&, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =]
[forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =, (]
[forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =, (]
[forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =, (]
[), ;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =, (, left, ., getString, (, ), ., equals, (]
[), {, boolean, undefinedLeft, =, (, left, ., getString, (, ), ., equals, (, "undefined", ), ), ;, if, (]
[=, (, left, ., getString, (, ), ., equals, (, "undefined", ), ), ;, if, (, undefinedLeft, ), {, return]
[=, (, left, ., getString, (, ), ., equals, (, "undefined", ), ), ;, if, (, undefinedLeft, ), {, return]
[getString, (, ), ., equals, (, "undefined", ), ), ;, if, (, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (]
[), ., equals, (, "undefined", ), ), ;, if, (, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[equals, (, "undefined", ), ), ;, if, (, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,]
[(, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, if, (]
[(, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, if, (]
[(, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, if, (]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, if, (, leftLiteral, &&]
[return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, if, (, leftLiteral, &&, nullRight, &&]
[., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (]
[right, ,, op, ), ), ;, }, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[right, ,, op, ), ), ;, }, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[), ;, }, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (]
[}, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[(, leftLiteral, &&, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,]
[), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, if, (]
[), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, if, (]
[), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, if, (]
[TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, if, (, Token, ., NAME, !=]
[TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, if, (, Token, ., NAME, !=]
[op, ), ), ;, }, }, if, (, Token, ., NAME, !=, right, ., getType, (, ), ), {, return]
[op, ), ), ;, }, }, if, (, Token, ., NAME, !=, right, ., getType, (, ), ), {, return]
[Token, ., NAME, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, String, ln, =]
[Token, ., NAME, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, String, ln, =]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, String, ln, =, left, ., getString, (, ), ;, String, rn, =]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, String, ln, =, left, ., getString, (, ), ;, String, rn, =]
[String, ln, =, left, ., getString, (, ), ;, String, rn, =, right, ., getString, (, ), ;, if, (]
[ln, =, left, ., getString, (, ), ;, String, rn, =, right, ., getString, (, ), ;, if, (, !]
[ln, =, left, ., getString, (, ), ;, String, rn, =, right, ., getString, (, ), ;, if, (, !]
[getString, (, ), ;, String, rn, =, right, ., getString, (, ), ;, if, (, !, ln, ., equals, (]
[rn, =, right, ., getString, (, ), ;, if, (, !, ln, ., equals, (, rn, ), ), {, return]
[rn, =, right, ., getString, (, ), ;, if, (, !, ln, ., equals, (, rn, ), ), {, return]
[;, if, (, !, ln, ., equals, (, rn, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (]
[ln, ., equals, (, rn, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[ln, ., equals, (, rn, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., LT, :, case]
[), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., LT, :, case]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., LT, :, case, Token, ., GT, :, return]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., LT, :, case, Token, ., GT, :, return]
[op, ), {, case, Token, ., LT, :, case, Token, ., GT, :, return, TernaryValue, ., FALSE, ;, }, return]
[op, ), {, case, Token, ., LT, :, case, Token, ., GT, :, return, TernaryValue, ., FALSE, ;, }, return]
[., LT, :, case, Token, ., GT, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[., LT, :, case, Token, ., GT, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[GT, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NEG, :, if, (]
[FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NEG, :, if, (, leftLiteral, ), {, if, (]
[TernaryValue, ., UNKNOWN, ;, case, Token, ., NEG, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return]
[TernaryValue, ., UNKNOWN, ;, case, Token, ., NEG, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return]
[case, Token, ., NEG, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (]
[., NEG, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[:, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&]
[return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (]
[compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (]
[), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[}, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return]
[TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case]
[TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case]
[(, left, ,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case]
[(, left, ,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case]
[), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case]
[), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case]
[TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case]
[TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case]
[., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., FUNCTION, :, if, (]
[., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., FUNCTION, :, if, (, leftLiteral, ), {, if, (]
[Token, ., REGEXP, :, case, Token, ., FUNCTION, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return]
[Token, ., REGEXP, :, case, Token, ., FUNCTION, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return]
[case, Token, ., FUNCTION, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (]
[., FUNCTION, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[:, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[(, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&]
[return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (]
[compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return]
[op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (]
[), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[}, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return]
[op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return]
[forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, default, :, return]
[forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, default, :, return]
[TernaryValue, ., UNKNOWN, ;, }, }, private, static, TernaryValue, areStringsEqual, (, String, a, ,, String, b, ), {, if, (]
[TernaryValue, ., UNKNOWN, ;, }, }, private, static, TernaryValue, areStringsEqual, (, String, a, ,, String, b, ), {, if, (]
[TernaryValue, ., UNKNOWN, ;, }, }, private, static, TernaryValue, areStringsEqual, (, String, a, ,, String, b, ), {, if, (]
[TernaryValue, ., UNKNOWN, ;, }, }, private, static, TernaryValue, areStringsEqual, (, String, a, ,, String, b, ), {, if, (]
[}, }, private, static, TernaryValue, areStringsEqual, (, String, a, ,, String, b, ), {, if, (, a, ., indexOf, (]
[static, TernaryValue, areStringsEqual, (, String, a, ,, String, b, ), {, if, (, a, ., indexOf, (, '\u000B', ), !=]
[TernaryValue, areStringsEqual, (, String, a, ,, String, b, ), {, if, (, a, ., indexOf, (, '\u000B', ), !=, -]
[(, String, a, ,, String, b, ), {, if, (, a, ., indexOf, (, '\u000B', ), !=, -, 1, ||]
[(, String, a, ,, String, b, ), {, if, (, a, ., indexOf, (, '\u000B', ), !=, -, 1, ||]
[(, String, a, ,, String, b, ), {, if, (, a, ., indexOf, (, '\u000B', ), !=, -, 1, ||]
[String, b, ), {, if, (, a, ., indexOf, (, '\u000B', ), !=, -, 1, ||, b, ., indexOf, (]
[{, if, (, a, ., indexOf, (, '\u000B', ), !=, -, 1, ||, b, ., indexOf, (, '\u000B', ), !=]
[if, (, a, ., indexOf, (, '\u000B', ), !=, -, 1, ||, b, ., indexOf, (, '\u000B', ), !=, -]
[indexOf, (, '\u000B', ), !=, -, 1, ||, b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return]
[indexOf, (, '\u000B', ), !=, -, 1, ||, b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return]
[b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return]
[b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return]
[b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return]
['\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (]
[-, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, ), ?]
[-, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, ), ?]
[return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, ), ?, TernaryValue, ., TRUE, :]
[return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, ), ?, TernaryValue, ., TRUE, :]
[TRUE, :, TernaryValue, ., FALSE, ;, }, }, private, static, int, getNormalizedNodeType, (, Node, n, ), {, int, type, =]
[TRUE, :, TernaryValue, ., FALSE, ;, }, }, private, static, int, getNormalizedNodeType, (, Node, n, ), {, int, type, =]
[private, static, int, getNormalizedNodeType, (, Node, n, ), {, int, type, =, n, ., getType, (, ), ;, if, (]
[private, static, int, getNormalizedNodeType, (, Node, n, ), {, int, type, =, n, ., getType, (, ), ;, if, (]
[int, getNormalizedNodeType, (, Node, n, ), {, int, type, =, n, ., getType, (, ), ;, if, (, type, ==]
[int, getNormalizedNodeType, (, Node, n, ), {, int, type, =, n, ., getType, (, ), ;, if, (, type, ==]
[type, =, n, ., getType, (, ), ;, if, (, type, ==, Token, ., NOT, ), {, TernaryValue, value, =]
[type, =, n, ., getType, (, ), ;, if, (, type, ==, Token, ., NOT, ), {, TernaryValue, value, =]
[getType, (, ), ;, if, (, type, ==, Token, ., NOT, ), {, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (]
[(, type, ==, Token, ., NOT, ), {, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, switch, (]
[., NOT, ), {, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, switch, (, value, ), {, case]
[{, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, switch, (, value, ), {, case, TRUE, :, return]
[{, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, switch, (, value, ), {, case, TRUE, :, return]
[., getPureBooleanValue, (, n, ), ;, switch, (, value, ), {, case, TRUE, :, return, Token, ., TRUE, ;, case]
[n, ), ;, switch, (, value, ), {, case, TRUE, :, return, Token, ., TRUE, ;, case, FALSE, :, return]
[n, ), ;, switch, (, value, ), {, case, TRUE, :, return, Token, ., TRUE, ;, case, FALSE, :, return]
[value, ), {, case, TRUE, :, return, Token, ., TRUE, ;, case, FALSE, :, return, Token, ., FALSE, ;, case]
[case, TRUE, :, return, Token, ., TRUE, ;, case, FALSE, :, return, Token, ., FALSE, ;, case, UNKNOWN, :, return]
[., TRUE, ;, case, FALSE, :, return, Token, ., FALSE, ;, case, UNKNOWN, :, return, type, ;, }, }, return]
[;, }, private, static, TernaryValue, compareAsNumbers, (, int, op, ,, Node, left, ,, Node, right, ), {, Double, leftValue, =]
[;, }, private, static, TernaryValue, compareAsNumbers, (, int, op, ,, Node, left, ,, Node, right, ), {, Double, leftValue, =]
[TernaryValue, compareAsNumbers, (, int, op, ,, Node, left, ,, Node, right, ), {, Double, leftValue, =, NodeUtil, ., getNumberValue, (]
[,, Node, left, ,, Node, right, ), {, Double, leftValue, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (]
[,, Node, left, ,, Node, right, ), {, Double, leftValue, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (]
[left, ,, Node, right, ), {, Double, leftValue, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (, leftValue, ==]
[), {, Double, leftValue, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (, leftValue, ==, null, ), {, return]
[), {, Double, leftValue, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (, leftValue, ==, null, ), {, return]
[(, left, ), ;, if, (, leftValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =]
[(, left, ), ;, if, (, leftValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =]
[if, (, leftValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValue, ==]
[;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValue, ==, null, ), {, return]
[;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValue, ==, null, ), {, return]
[(, right, ), ;, if, (, rightValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, double, lv, =]
[(, rightValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, double, lv, =, leftValue, ;, double, rv, =]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, double, lv, =, leftValue, ;, double, rv, =, rightValue, ;, switch, (]
[., UNKNOWN, ;, }, double, lv, =, leftValue, ;, double, rv, =, rightValue, ;, switch, (, op, ), {, case]
[., UNKNOWN, ;, }, double, lv, =, leftValue, ;, double, rv, =, rightValue, ;, switch, (, op, ), {, case]
[lv, =, leftValue, ;, double, rv, =, rightValue, ;, switch, (, op, ), {, case, Token, ., SHEQ, :, case]
[lv, =, leftValue, ;, double, rv, =, rightValue, ;, switch, (, op, ), {, case, Token, ., SHEQ, :, case]
[double, rv, =, rightValue, ;, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :]
[double, rv, =, rightValue, ;, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :]
[;, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, Preconditions, ., checkState, (]
[;, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, Preconditions, ., checkState, (]
[;, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, Preconditions, ., checkState, (]
[case, Token, ., SHEQ, :, case, Token, ., EQ, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&]
[case, Token, ., SHEQ, :, case, Token, ., EQ, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&]
[EQ, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return]
[EQ, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return]
[checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (]
[checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (]
[left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, ==]
[), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case]
[), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case]
[(, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case]
[(, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case]
[return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :]
[return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :]
[(, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (]
[(, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (]
[(, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (]
[case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&]
[case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&]
[NE, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return]
[NE, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return]
[checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (]
[checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (]
[left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, !=]
[), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case]
[), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case]
[(, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE, :, return]
[(, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE, :, return]
[return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (]
[return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (]
[., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=]
[!=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case]
[!=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case]
[Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case, Token, ., LT, :, return]
[Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case, Token, ., LT, :, return]
[return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (]
[return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (]
[., forBoolean, (, lv, <=, rv, ), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <]
[<=, rv, ), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case]
[<=, rv, ), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case]
[Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case, Token, ., GE, :, return]
[Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case, Token, ., GE, :, return]
[return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (]
[return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (]
[., forBoolean, (, lv, <, rv, ), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=]
[<, rv, ), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case]
[<, rv, ), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case]
[Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case, Token, ., GT, :, return]
[Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case, Token, ., GT, :, return]
[return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (]
[return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (]
[., forBoolean, (, lv, >=, rv, ), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (, lv, >]
[), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (, lv, >, rv, ), ;, default, :, return]
[), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (, lv, >, rv, ), ;, default, :, return]
[:, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, boolean, compareToUndefined, (, Node, value, ,, int, op, ), {]
[:, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, boolean, compareToUndefined, (, Node, value, ,, int, op, ), {]
[UNKNOWN, ;, }, }, private, static, boolean, compareToUndefined, (, Node, value, ,, int, op, ), {, Preconditions, ., checkState, (]
[UNKNOWN, ;, }, }, private, static, boolean, compareToUndefined, (, Node, value, ,, int, op, ), {, Preconditions, ., checkState, (]
[private, static, boolean, compareToUndefined, (, Node, value, ,, int, op, ), {, Preconditions, ., checkState, (, NodeUtil, ., isLiteralValue, (]
[boolean, compareToUndefined, (, Node, value, ,, int, op, ), {, Preconditions, ., checkState, (, NodeUtil, ., isLiteralValue, (, value, ,]
[op, ), {, Preconditions, ., checkState, (, NodeUtil, ., isLiteralValue, (, value, ,, true, ), ), ;, boolean, valueUndefined, =]
[op, ), {, Preconditions, ., checkState, (, NodeUtil, ., isLiteralValue, (, value, ,, true, ), ), ;, boolean, valueUndefined, =]
[., checkState, (, NodeUtil, ., isLiteralValue, (, value, ,, true, ), ), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (]
[(, value, ,, true, ), ), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =]
[value, ,, true, ), ), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (]
[value, ,, true, ), ), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (]
[value, ,, true, ), ), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (]
[), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token, ., NULL, ==]
[), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token, ., NULL, ==]
[), ;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =]
[), ;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =]
[boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||]
[Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (]
[value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case]
[value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case]
[), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return]
[equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case]
[equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case]
[;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return]
[switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !]
[), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case]
[), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case]
[EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return]
[equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case]
[equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case]
[NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return]
[:, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !]
[equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !, valueUndefined, ;, case]
[equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !, valueUndefined, ;, case]
[SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !, valueUndefined, ;, case, Token, ., LT, :, case]
[SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !, valueUndefined, ;, case, Token, ., LT, :, case]
[case, Token, ., SHNE, :, return, !, valueUndefined, ;, case, Token, ., LT, :, case, Token, ., GT, :, case]
[case, Token, ., SHNE, :, return, !, valueUndefined, ;, case, Token, ., LT, :, case, Token, ., GT, :, case]
[return, !, valueUndefined, ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[return, !, valueUndefined, ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, return]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, return, false, ;, default, :, throw]
[:, case, Token, ., LE, :, case, Token, ., GE, :, return, false, ;, default, :, throw, new, IllegalStateException, (]
[throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, static, boolean, isEqualityOp, (, int, op, ), {, switch, (]
["unexpected.", ), ;, }, }, private, static, boolean, isEqualityOp, (, int, op, ), {, switch, (, op, ), {, case]
["unexpected.", ), ;, }, }, private, static, boolean, isEqualityOp, (, int, op, ), {, switch, (, op, ), {, case]
[private, static, boolean, isEqualityOp, (, int, op, ), {, switch, (, op, ), {, case, Token, ., EQ, :, case]
[private, static, boolean, isEqualityOp, (, int, op, ), {, switch, (, op, ), {, case, Token, ., EQ, :, case]
[int, op, ), {, switch, (, op, ), {, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[int, op, ), {, switch, (, op, ), {, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[(, op, ), {, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[(, op, ), {, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return]
[case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, true, ;, }, return]
[}, return, false, ;, }, private, static, boolean, compareToNull, (, Node, value, ,, int, op, ), {, boolean, valueUndefined, =]
[}, return, false, ;, }, private, static, boolean, compareToNull, (, Node, value, ,, int, op, ), {, boolean, valueUndefined, =]
[}, private, static, boolean, compareToNull, (, Node, value, ,, int, op, ), {, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (]
[Node, value, ,, int, op, ), {, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =]
[value, ,, int, op, ), {, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (]
[value, ,, int, op, ), {, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (]
[value, ,, int, op, ), {, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (]
[), {, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token, ., NULL, ==]
[), {, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token, ., NULL, ==]
[), ;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =]
[), ;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =]
[boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||]
[Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (]
[value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case]
[value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case]
[), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return]
[equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case]
[equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case]
[;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return]
[switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !]
[), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case]
[), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case]
[EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return]
[equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueNull, ;, case]
[equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueNull, ;, case]
[NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueNull, ;, case, Token, ., SHNE, :, return]
[:, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueNull, ;, case, Token, ., SHNE, :, return, !]
[case, Token, ., SHEQ, :, return, valueNull, ;, case, Token, ., SHNE, :, return, !, valueNull, ;, default, :, throw]
[SHEQ, :, return, valueNull, ;, case, Token, ., SHNE, :, return, !, valueNull, ;, default, :, throw, new, IllegalStateException, (]
[;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, Node, tryFoldCtorCall, (, Node, n, ), {]
[;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, Node, tryFoldCtorCall, (, Node, n, ), {]
[new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, Node, tryFoldCtorCall, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, Node, tryFoldCtorCall, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[Node, tryFoldCtorCall, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isNew, (, ), ), ;, if, (]
[(, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isNew, (, ), ), ;, if, (, inForcedStringContext, (]
[Preconditions, ., checkArgument, (, n, ., isNew, (, ), ), ;, if, (, inForcedStringContext, (, n, ), ), {, return]
[checkArgument, (, n, ., isNew, (, ), ), ;, if, (, inForcedStringContext, (, n, ), ), {, return, tryFoldInForcedStringContext, (]
[(, ), ), ;, if, (, inForcedStringContext, (, n, ), ), {, return, tryFoldInForcedStringContext, (, n, ), ;, }, return]
[tryFoldInForcedStringContext, (, n, ), ;, }, return, n, ;, }, private, boolean, inForcedStringContext, (, Node, n, ), {, if, (]
[tryFoldInForcedStringContext, (, n, ), ;, }, return, n, ;, }, private, boolean, inForcedStringContext, (, Node, n, ), {, if, (]
[tryFoldInForcedStringContext, (, n, ), ;, }, return, n, ;, }, private, boolean, inForcedStringContext, (, Node, n, ), {, if, (]
[tryFoldInForcedStringContext, (, n, ), ;, }, return, n, ;, }, private, boolean, inForcedStringContext, (, Node, n, ), {, if, (]
[private, boolean, inForcedStringContext, (, Node, n, ), {, if, (, n, ., getParent, (, ), ., isGetElem, (, ), &&]
[private, boolean, inForcedStringContext, (, Node, n, ), {, if, (, n, ., getParent, (, ), ., isGetElem, (, ), &&]
[private, boolean, inForcedStringContext, (, Node, n, ), {, if, (, n, ., getParent, (, ), ., isGetElem, (, ), &&]
[private, boolean, inForcedStringContext, (, Node, n, ), {, if, (, n, ., getParent, (, ), ., isGetElem, (, ), &&]
[n, ., getParent, (, ), ., isGetElem, (, ), &&, n, ., getParent, (, ), ., getLastChild, (, ), ==]
[), ., isGetElem, (, ), &&, n, ., getParent, (, ), ., getLastChild, (, ), ==, n, ), {, return]
[&&, n, ., getParent, (, ), ., getLastChild, (, ), ==, n, ), {, return, true, ;, }, if, (]
[&&, n, ., getParent, (, ), ., getLastChild, (, ), ==, n, ), {, return, true, ;, }, if, (]
[&&, n, ., getParent, (, ), ., getLastChild, (, ), ==, n, ), {, return, true, ;, }, if, (]
[), {, return, true, ;, }, if, (, n, ., getParent, (, ), ., isAdd, (, ), ), {, return]
[;, }, if, (, n, ., getParent, (, ), ., isAdd, (, ), ), {, return, true, ;, }, return]
[(, ), ), {, return, true, ;, }, return, false, ;, }, private, Node, tryFoldInForcedStringContext, (, Node, n, ), {]
[(, ), ), {, return, true, ;, }, return, false, ;, }, private, Node, tryFoldInForcedStringContext, (, Node, n, ), {]
[return, true, ;, }, return, false, ;, }, private, Node, tryFoldInForcedStringContext, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[return, true, ;, }, return, false, ;, }, private, Node, tryFoldInForcedStringContext, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[tryFoldInForcedStringContext, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isNew, (, ), ), ;, Node, objectType, =]
[tryFoldInForcedStringContext, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isNew, (, ), ), ;, Node, objectType, =]
[checkArgument, (, n, ., isNew, (, ), ), ;, Node, objectType, =, n, ., getFirstChild, (, ), ;, if, (]
[(, n, ., isNew, (, ), ), ;, Node, objectType, =, n, ., getFirstChild, (, ), ;, if, (, !]
[(, n, ., isNew, (, ), ), ;, Node, objectType, =, n, ., getFirstChild, (, ), ;, if, (, !]
[Node, objectType, =, n, ., getFirstChild, (, ), ;, if, (, !, objectType, ., isName, (, ), ), {, return]
[getFirstChild, (, ), ;, if, (, !, objectType, ., isName, (, ), ), {, return, n, ;, }, if, (]
[getFirstChild, (, ), ;, if, (, !, objectType, ., isName, (, ), ), {, return, n, ;, }, if, (]
[getFirstChild, (, ), ;, if, (, !, objectType, ., isName, (, ), ), {, return, n, ;, }, if, (]
[., isName, (, ), ), {, return, n, ;, }, if, (, objectType, ., getString, (, ), ., equals, (]
[n, ;, }, if, (, objectType, ., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =]
[n, ;, }, if, (, objectType, ., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =]
[), ., equals, (, "String", ), ), {, Node, value, =, objectType, ., getNext, (, ), ;, String, stringValue, =]
["String", ), ), {, Node, value, =, objectType, ., getNext, (, ), ;, String, stringValue, =, null, ;, if, (]
["String", ), ), {, Node, value, =, objectType, ., getNext, (, ), ;, String, stringValue, =, null, ;, if, (]
[), {, Node, value, =, objectType, ., getNext, (, ), ;, String, stringValue, =, null, ;, if, (, value, ==]
[value, =, objectType, ., getNext, (, ), ;, String, stringValue, =, null, ;, if, (, value, ==, null, ), {]
[objectType, ., getNext, (, ), ;, String, stringValue, =, null, ;, if, (, value, ==, null, ), {, stringValue, =]
[stringValue, =, null, ;, if, (, value, ==, null, ), {, stringValue, =, "", ;, }, else, {, if, (]
[=, null, ;, if, (, value, ==, null, ), {, stringValue, =, "", ;, }, else, {, if, (, !]
[=, null, ;, if, (, value, ==, null, ), {, stringValue, =, "", ;, }, else, {, if, (, !]
[(, value, ==, null, ), {, stringValue, =, "", ;, }, else, {, if, (, !, NodeUtil, ., isImmutableValue, (]
[{, stringValue, =, "", ;, }, else, {, if, (, !, NodeUtil, ., isImmutableValue, (, value, ), ), {, return]
["", ;, }, else, {, if, (, !, NodeUtil, ., isImmutableValue, (, value, ), ), {, return, n, ;, }]
[}, else, {, if, (, !, NodeUtil, ., isImmutableValue, (, value, ), ), {, return, n, ;, }, stringValue, =]
[}, else, {, if, (, !, NodeUtil, ., isImmutableValue, (, value, ), ), {, return, n, ;, }, stringValue, =]
[(, !, NodeUtil, ., isImmutableValue, (, value, ), ), {, return, n, ;, }, stringValue, =, NodeUtil, ., getStringValue, (]
[value, ), ), {, return, n, ;, }, stringValue, =, NodeUtil, ., getStringValue, (, value, ), ;, }, if, (]
[value, ), ), {, return, n, ;, }, stringValue, =, NodeUtil, ., getStringValue, (, value, ), ;, }, if, (]
[), {, return, n, ;, }, stringValue, =, NodeUtil, ., getStringValue, (, value, ), ;, }, if, (, stringValue, ==]
[;, }, stringValue, =, NodeUtil, ., getStringValue, (, value, ), ;, }, if, (, stringValue, ==, null, ), {, return]
[getStringValue, (, value, ), ;, }, if, (, stringValue, ==, null, ), {, return, n, ;, }, Node, parent, =]
[getStringValue, (, value, ), ;, }, if, (, stringValue, ==, null, ), {, return, n, ;, }, Node, parent, =]
[==, null, ), {, return, n, ;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, newString, =]
[==, null, ), {, return, n, ;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, newString, =]
[return, n, ;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, newString, =, IR, ., string, (]
[}, Node, parent, =, n, ., getParent, (, ), ;, Node, newString, =, IR, ., string, (, stringValue, ), ;]
[}, Node, parent, =, n, ., getParent, (, ), ;, Node, newString, =, IR, ., string, (, stringValue, ), ;]
[n, ., getParent, (, ), ;, Node, newString, =, IR, ., string, (, stringValue, ), ;, parent, ., replaceChild, (]
[getParent, (, ), ;, Node, newString, =, IR, ., string, (, stringValue, ), ;, parent, ., replaceChild, (, n, ,]
[;, Node, newString, =, IR, ., string, (, stringValue, ), ;, parent, ., replaceChild, (, n, ,, newString, ), ;]
[;, Node, newString, =, IR, ., string, (, stringValue, ), ;, parent, ., replaceChild, (, n, ,, newString, ), ;]
[IR, ., string, (, stringValue, ), ;, parent, ., replaceChild, (, n, ,, newString, ), ;, newString, ., copyInformationFrom, (]
[(, stringValue, ), ;, parent, ., replaceChild, (, n, ,, newString, ), ;, newString, ., copyInformationFrom, (, parent, ), ;]
[., replaceChild, (, n, ,, newString, ), ;, newString, ., copyInformationFrom, (, parent, ), ;, reportCodeChange, (, ), ;, return]
[,, newString, ), ;, newString, ., copyInformationFrom, (, parent, ), ;, reportCodeChange, (, ), ;, return, newString, ;, }, return]
[;, }, return, n, ;, }, private, Node, tryFoldGetElem, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[;, }, return, n, ;, }, private, Node, tryFoldGetElem, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[;, }, private, Node, tryFoldGetElem, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, }, private, Node, tryFoldGetElem, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, n, ., isGetElem, (, ), ), ;, if, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, n, ., isGetElem, (, ), ), ;, if, (]
[., checkArgument, (, n, ., isGetElem, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return]
[(, n, ., isGetElem, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (]
[., isGetElem, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,]
[(, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,]
[left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (]
[left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (]
[tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (, left, ., isArrayLit, (, ), ), {, return]
[n, ,, left, ,, right, ), ;, }, if, (, left, ., isArrayLit, (, ), ), {, return, tryFoldArrayAccess, (]
[left, ,, right, ), ;, }, if, (, left, ., isArrayLit, (, ), ), {, return, tryFoldArrayAccess, (, n, ,]
[right, ), ;, }, if, (, left, ., isArrayLit, (, ), ), {, return, tryFoldArrayAccess, (, n, ,, left, ,]
[(, left, ., isArrayLit, (, ), ), {, return, tryFoldArrayAccess, (, n, ,, left, ,, right, ), ;, }, return]
[;, }, return, n, ;, }, private, Node, tryFoldGetProp, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[;, }, return, n, ;, }, private, Node, tryFoldGetProp, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[;, }, private, Node, tryFoldGetProp, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, }, private, Node, tryFoldGetProp, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, n, ., isGetProp, (, ), ), ;, if, (]
[Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, n, ., isGetProp, (, ), ), ;, if, (]
[., checkArgument, (, n, ., isGetProp, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return]
[(, n, ., isGetProp, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (]
[., isGetProp, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,]
[(, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,]
[left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (]
[left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (]
[left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (]
[{, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (, right, ., isString, (, ), &&]
[{, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (, right, ., isString, (, ), &&]
[{, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (, right, ., isString, (, ), &&]
[right, ), ;, }, if, (, right, ., isString, (, ), &&, right, ., getString, (, ), ., equals, (]
[., isString, (, ), &&, right, ., getString, (, ), ., equals, (, "length", ), ), {, int, knownLength, =]
[isString, (, ), &&, right, ., getString, (, ), ., equals, (, "length", ), ), {, int, knownLength, =, -]
[right, ., getString, (, ), ., equals, (, "length", ), ), {, int, knownLength, =, -, 1, ;, switch, (]
[right, ., getString, (, ), ., equals, (, "length", ), ), {, int, knownLength, =, -, 1, ;, switch, (]
["length", ), ), {, int, knownLength, =, -, 1, ;, switch, (, left, ., getType, (, ), ), {, case]
["length", ), ), {, int, knownLength, =, -, 1, ;, switch, (, left, ., getType, (, ), ), {, case]
[=, -, 1, ;, switch, (, left, ., getType, (, ), ), {, case, Token, ., ARRAYLIT, :, if, (]
[1, ;, switch, (, left, ., getType, (, ), ), {, case, Token, ., ARRAYLIT, :, if, (, mayHaveSideEffects, (]
[., getType, (, ), ), {, case, Token, ., ARRAYLIT, :, if, (, mayHaveSideEffects, (, left, ), ), {, return]
[), ), {, case, Token, ., ARRAYLIT, :, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }]
[{, case, Token, ., ARRAYLIT, :, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, knownLength, =]
[{, case, Token, ., ARRAYLIT, :, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, knownLength, =]
[(, left, ), ), {, return, n, ;, }, knownLength, =, left, ., getChildCount, (, ), ;, break, ;, case]
[(, left, ), ), {, return, n, ;, }, knownLength, =, left, ., getChildCount, (, ), ;, break, ;, case]
[{, return, n, ;, }, knownLength, =, left, ., getChildCount, (, ), ;, break, ;, case, Token, ., STRING, :]
[n, ;, }, knownLength, =, left, ., getChildCount, (, ), ;, break, ;, case, Token, ., STRING, :, knownLength, =]
[n, ;, }, knownLength, =, left, ., getChildCount, (, ), ;, break, ;, case, Token, ., STRING, :, knownLength, =]
[n, ;, }, knownLength, =, left, ., getChildCount, (, ), ;, break, ;, case, Token, ., STRING, :, knownLength, =]
[., STRING, :, knownLength, =, left, ., getString, (, ), ., length, (, ), ;, break, ;, default, :, return]
[knownLength, =, left, ., getString, (, ), ., length, (, ), ;, break, ;, default, :, return, n, ;, }]
[knownLength, =, left, ., getString, (, ), ., length, (, ), ;, break, ;, default, :, return, n, ;, }]
[getString, (, ), ., length, (, ), ;, break, ;, default, :, return, n, ;, }, Preconditions, ., checkState, (]
[getString, (, ), ., length, (, ), ;, break, ;, default, :, return, n, ;, }, Preconditions, ., checkState, (]
[), ., length, (, ), ;, break, ;, default, :, return, n, ;, }, Preconditions, ., checkState, (, knownLength, !=]
[., length, (, ), ;, break, ;, default, :, return, n, ;, }, Preconditions, ., checkState, (, knownLength, !=, -]
[;, default, :, return, n, ;, }, Preconditions, ., checkState, (, knownLength, !=, -, 1, ), ;, Node, lengthNode, =]
[;, default, :, return, n, ;, }, Preconditions, ., checkState, (, knownLength, !=, -, 1, ), ;, Node, lengthNode, =]
[n, ;, }, Preconditions, ., checkState, (, knownLength, !=, -, 1, ), ;, Node, lengthNode, =, IR, ., number, (]
[Preconditions, ., checkState, (, knownLength, !=, -, 1, ), ;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;]
[Preconditions, ., checkState, (, knownLength, !=, -, 1, ), ;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;]
[Preconditions, ., checkState, (, knownLength, !=, -, 1, ), ;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;]
[), ;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[Node, lengthNode, =, IR, ., number, (, knownLength, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[IR, ., number, (, knownLength, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, lengthNode, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, lengthNode, ), ;, reportCodeChange, (, ), ;, return]
[getParent, (, ), ., replaceChild, (, n, ,, lengthNode, ), ;, reportCodeChange, (, ), ;, return, lengthNode, ;, }, return]
[;, return, lengthNode, ;, }, return, n, ;, }, private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =]
[;, return, lengthNode, ;, }, return, n, ;, }, private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =]
[}, private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[}, private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[}, private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, (]
[private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, (]
[private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, (]
[Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, (, NodeUtil, ., isAssignmentOp, (]
[{, Node, parent, =, n, ., getParent, (, ), ;, if, (, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&]
[{, Node, parent, =, n, ., getParent, (, ), ;, if, (, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&]
[{, Node, parent, =, n, ., getParent, (, ), ;, if, (, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&]
[getParent, (, ), ;, if, (, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==]
[;, if, (, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[;, if, (, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isInc, (, ), ||]
[isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isInc, (, ), ||]
[(, ), ==, n, ), ||, parent, ., isInc, (, ), ||, parent, ., isDec, (, ), ), {, return]
[), ||, parent, ., isInc, (, ), ||, parent, ., isDec, (, ), ), {, return, true, ;, }, return]
[false, ;, }, private, Node, tryFoldArrayAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, parent, =]
[false, ;, }, private, Node, tryFoldArrayAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, parent, =]
[n, ,, Node, left, ,, Node, right, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[Node, left, ,, Node, right, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, isAssignmentTarget, (]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, isAssignmentTarget, (, n, ), ), {, return]
[n, ., getParent, (, ), ;, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, if, (]
[., getParent, (, ), ;, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, if, (, !]
[., getParent, (, ), ;, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, if, (, !]
[(, n, ), ), {, return, n, ;, }, if, (, !, right, ., isNumber, (, ), ), {, return]
[n, ;, }, if, (, !, right, ., isNumber, (, ), ), {, return, n, ;, }, double, index, =]
[n, ;, }, if, (, !, right, ., isNumber, (, ), ), {, return, n, ;, }, double, index, =]
[(, ), ), {, return, n, ;, }, double, index, =, right, ., getDouble, (, ), ;, int, intIndex, =]
[{, return, n, ;, }, double, index, =, right, ., getDouble, (, ), ;, int, intIndex, =, (, int, )]
[}, double, index, =, right, ., getDouble, (, ), ;, int, intIndex, =, (, int, ), index, ;, if, (]
[}, double, index, =, right, ., getDouble, (, ), ;, int, intIndex, =, (, int, ), index, ;, if, (]
[index, =, right, ., getDouble, (, ), ;, int, intIndex, =, (, int, ), index, ;, if, (, intIndex, !=]
[., getDouble, (, ), ;, int, intIndex, =, (, int, ), index, ;, if, (, intIndex, !=, index, ), {]
[(, ), ;, int, intIndex, =, (, int, ), index, ;, if, (, intIndex, !=, index, ), {, report, (]
[;, int, intIndex, =, (, int, ), index, ;, if, (, intIndex, !=, index, ), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,]
[(, int, ), index, ;, if, (, intIndex, !=, index, ), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return]
[if, (, intIndex, !=, index, ), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if, (]
[if, (, intIndex, !=, index, ), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if, (]
[intIndex, !=, index, ), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if, (, intIndex, <]
[), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if, (, intIndex, <, 0, ), {]
[report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if, (, intIndex, <, 0, ), {, report, (]
[INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if, (, intIndex, <, 0, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,]
[;, return, n, ;, }, if, (, intIndex, <, 0, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return]
[(, intIndex, <, 0, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, Node, current, =]
[(, intIndex, <, 0, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, Node, current, =]
[,, right, ), ;, return, n, ;, }, Node, current, =, left, ., getFirstChild, (, ), ;, Node, elem, =]
[}, Node, current, =, left, ., getFirstChild, (, ), ;, Node, elem, =, null, ;, for, (, int, i, =]
[current, =, left, ., getFirstChild, (, ), ;, Node, elem, =, null, ;, for, (, int, i, =, 0, ;]
[current, =, left, ., getFirstChild, (, ), ;, Node, elem, =, null, ;, for, (, int, i, =, 0, ;]
[left, ., getFirstChild, (, ), ;, Node, elem, =, null, ;, for, (, int, i, =, 0, ;, current, !=]
[getFirstChild, (, ), ;, Node, elem, =, null, ;, for, (, int, i, =, 0, ;, current, !=, null, ;]
[getFirstChild, (, ), ;, Node, elem, =, null, ;, for, (, int, i, =, 0, ;, current, !=, null, ;]
[=, null, ;, for, (, int, i, =, 0, ;, current, !=, null, ;, i, ++, ), {, if, (]
[=, null, ;, for, (, int, i, =, 0, ;, current, !=, null, ;, i, ++, ), {, if, (]
[;, for, (, int, i, =, 0, ;, current, !=, null, ;, i, ++, ), {, if, (, i, !=]
[=, 0, ;, current, !=, null, ;, i, ++, ), {, if, (, i, !=, intIndex, ), {, if, (]
[;, current, !=, null, ;, i, ++, ), {, if, (, i, !=, intIndex, ), {, if, (, mayHaveSideEffects, (]
[i, ++, ), {, if, (, i, !=, intIndex, ), {, if, (, mayHaveSideEffects, (, current, ), ), {, return]
[i, !=, intIndex, ), {, if, (, mayHaveSideEffects, (, current, ), ), {, return, n, ;, }, }, else, {]
[intIndex, ), {, if, (, mayHaveSideEffects, (, current, ), ), {, return, n, ;, }, }, else, {, elem, =]
[if, (, mayHaveSideEffects, (, current, ), ), {, return, n, ;, }, }, else, {, elem, =, current, ;, }]
[mayHaveSideEffects, (, current, ), ), {, return, n, ;, }, }, else, {, elem, =, current, ;, }, current, =]
[mayHaveSideEffects, (, current, ), ), {, return, n, ;, }, }, else, {, elem, =, current, ;, }, current, =]
[}, }, else, {, elem, =, current, ;, }, current, =, current, ., getNext, (, ), ;, }, if, (]
[}, }, else, {, elem, =, current, ;, }, current, =, current, ., getNext, (, ), ;, }, if, (]
[else, {, elem, =, current, ;, }, current, =, current, ., getNext, (, ), ;, }, if, (, elem, ==]
[=, current, ;, }, current, =, current, ., getNext, (, ), ;, }, if, (, elem, ==, null, ), {]
[;, }, current, =, current, ., getNext, (, ), ;, }, if, (, elem, ==, null, ), {, report, (]
[current, =, current, ., getNext, (, ), ;, }, if, (, elem, ==, null, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,]
[getNext, (, ), ;, }, if, (, elem, ==, null, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return]
[if, (, elem, ==, null, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, if, (]
[if, (, elem, ==, null, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, if, (]
[report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, if, (, elem, ., isEmpty, (, ), ), {]
[INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, if, (, elem, ., isEmpty, (, ), ), {, elem, =]
[INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, if, (, elem, ., isEmpty, (, ), ), {, elem, =]
[;, return, n, ;, }, if, (, elem, ., isEmpty, (, ), ), {, elem, =, NodeUtil, ., newUndefinedNode, (]
[(, elem, ., isEmpty, (, ), ), {, elem, =, NodeUtil, ., newUndefinedNode, (, elem, ), ;, }, else, {]
[(, elem, ., isEmpty, (, ), ), {, elem, =, NodeUtil, ., newUndefinedNode, (, elem, ), ;, }, else, {]
[(, ), ), {, elem, =, NodeUtil, ., newUndefinedNode, (, elem, ), ;, }, else, {, left, ., removeChild, (]
[elem, =, NodeUtil, ., newUndefinedNode, (, elem, ), ;, }, else, {, left, ., removeChild, (, elem, ), ;, }]
[elem, =, NodeUtil, ., newUndefinedNode, (, elem, ), ;, }, else, {, left, ., removeChild, (, elem, ), ;, }]
[elem, =, NodeUtil, ., newUndefinedNode, (, elem, ), ;, }, else, {, left, ., removeChild, (, elem, ), ;, }]
[;, }, else, {, left, ., removeChild, (, elem, ), ;, }, n, ., getParent, (, ), ., replaceChild, (]
[else, {, left, ., removeChild, (, elem, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[., removeChild, (, elem, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, elem, ), ;]
[;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, elem, ), ;, reportCodeChange, (, ), ;, return]
[), ;, return, elem, ;, }, private, Node, tryFoldObjectPropAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[), ;, return, elem, ;, }, private, Node, tryFoldObjectPropAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[;, }, private, Node, tryFoldObjectPropAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, }, private, Node, tryFoldObjectPropAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[tryFoldObjectPropAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (]
[left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, n, ), ), ;, if, (]
[left, ,, Node, right, ), {, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, n, ), ), ;, if, (]
[,, Node, right, ), {, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, n, ), ), ;, if, (, !]
[,, Node, right, ), {, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, n, ), ), ;, if, (, !]
[., checkArgument, (, NodeUtil, ., isGet, (, n, ), ), ;, if, (, !, left, ., isObjectLit, (, ), ||]
[checkArgument, (, NodeUtil, ., isGet, (, n, ), ), ;, if, (, !, left, ., isObjectLit, (, ), ||, !]
[checkArgument, (, NodeUtil, ., isGet, (, n, ), ), ;, if, (, !, left, ., isObjectLit, (, ), ||, !]
[), ;, if, (, !, left, ., isObjectLit, (, ), ||, !, right, ., isString, (, ), ), {, return]
[left, ., isObjectLit, (, ), ||, !, right, ., isString, (, ), ), {, return, n, ;, }, if, (]
[isObjectLit, (, ), ||, !, right, ., isString, (, ), ), {, return, n, ;, }, if, (, isAssignmentTarget, (]
[right, ., isString, (, ), ), {, return, n, ;, }, if, (, isAssignmentTarget, (, n, ), ), {, return]
[{, return, n, ;, }, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, Node, key, =]
[if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, Node, key, =, null, ;, Node, value, =]
[{, return, n, ;, }, Node, key, =, null, ;, Node, value, =, null, ;, for, (, Node, c, =]
[{, return, n, ;, }, Node, key, =, null, ;, Node, value, =, null, ;, for, (, Node, c, =]
[key, =, null, ;, Node, value, =, null, ;, for, (, Node, c, =, left, ., getFirstChild, (, ), ;]
[key, =, null, ;, Node, value, =, null, ;, for, (, Node, c, =, left, ., getFirstChild, (, ), ;]
[null, ;, Node, value, =, null, ;, for, (, Node, c, =, left, ., getFirstChild, (, ), ;, c, !=]
[Node, value, =, null, ;, for, (, Node, c, =, left, ., getFirstChild, (, ), ;, c, !=, null, ;]
[=, null, ;, for, (, Node, c, =, left, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[=, null, ;, for, (, Node, c, =, left, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, c, ., getString, (, ), ., equals, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, c, ., getString, (, ), ., equals, (]
[if, (, c, ., getString, (, ), ., equals, (, right, ., getString, (, ), ), ), {, switch, (]
[if, (, c, ., getString, (, ), ., equals, (, right, ., getString, (, ), ), ), {, switch, (]
[equals, (, right, ., getString, (, ), ), ), {, switch, (, c, ., getType, (, ), ), {, case]
[equals, (, right, ., getString, (, ), ), ), {, switch, (, c, ., getType, (, ), ), {, case]
[), ), {, switch, (, c, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, continue, ;, case]
[), ), {, switch, (, c, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, continue, ;, case]
[c, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case]
[c, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case]
[{, case, Token, ., SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (]
[{, case, Token, ., SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (]
[{, case, Token, ., SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (]
[Token, ., SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (, value, !=]
[SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (, value, !=, null, &&]
[continue, ;, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (, value, !=, null, &&, mayHaveSideEffects, (]
[GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (, value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {, return]
[Token, ., STRING_KEY, :, if, (, value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }]
[STRING_KEY, :, if, (, value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }, key, =]
[if, (, value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }, key, =, c, ;]
[value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }, key, =, c, ;, value, =]
[value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }, key, =, c, ;, value, =]
[n, ;, }, key, =, c, ;, value, =, key, ., getFirstChild, (, ), ;, break, ;, default, :, throw]
[., getFirstChild, (, ), ;, break, ;, default, :, throw, new, IllegalStateException, (, ), ;, }, }, else, if, (]
[(, ), ;, break, ;, default, :, throw, new, IllegalStateException, (, ), ;, }, }, else, if, (, mayHaveSideEffects, (]
[(, ), ;, break, ;, default, :, throw, new, IllegalStateException, (, ), ;, }, }, else, if, (, mayHaveSideEffects, (]
[IllegalStateException, (, ), ;, }, }, else, if, (, mayHaveSideEffects, (, c, ., getFirstChild, (, ), ), ), {, return]
[else, if, (, mayHaveSideEffects, (, c, ., getFirstChild, (, ), ), ), {, return, n, ;, }, }, if, (]
[else, if, (, mayHaveSideEffects, (, c, ., getFirstChild, (, ), ), ), {, return, n, ;, }, }, if, (]
[(, mayHaveSideEffects, (, c, ., getFirstChild, (, ), ), ), {, return, n, ;, }, }, if, (, value, ==]
[., getFirstChild, (, ), ), ), {, return, n, ;, }, }, if, (, value, ==, null, ), {, return]
[), {, return, n, ;, }, }, if, (, value, ==, null, ), {, return, n, ;, }, if, (]
[), {, return, n, ;, }, }, if, (, value, ==, null, ), {, return, n, ;, }, if, (]
[), {, return, n, ;, }, }, if, (, value, ==, null, ), {, return, n, ;, }, if, (]
[}, if, (, value, ==, null, ), {, return, n, ;, }, if, (, value, ., isFunction, (, ), &&]
[}, if, (, value, ==, null, ), {, return, n, ;, }, if, (, value, ., isFunction, (, ), &&]
[==, null, ), {, return, n, ;, }, if, (, value, ., isFunction, (, ), &&, NodeUtil, ., referencesThis, (]
[n, ;, }, if, (, value, ., isFunction, (, ), &&, NodeUtil, ., referencesThis, (, value, ), ), {, return]
[., isFunction, (, ), &&, NodeUtil, ., referencesThis, (, value, ), ), {, return, n, ;, }, Node, replacement, =]
[., isFunction, (, ), &&, NodeUtil, ., referencesThis, (, value, ), ), {, return, n, ;, }, Node, replacement, =]
[(, value, ), ), {, return, n, ;, }, Node, replacement, =, value, ., detachFromParent, (, ), ;, if, (]
[(, value, ), ), {, return, n, ;, }, Node, replacement, =, value, ., detachFromParent, (, ), ;, if, (]
[;, }, Node, replacement, =, value, ., detachFromParent, (, ), ;, if, (, key, ., isGetterDef, (, ), ), {]
[Node, replacement, =, value, ., detachFromParent, (, ), ;, if, (, key, ., isGetterDef, (, ), ), {, replacement, =]
[Node, replacement, =, value, ., detachFromParent, (, ), ;, if, (, key, ., isGetterDef, (, ), ), {, replacement, =]
[., detachFromParent, (, ), ;, if, (, key, ., isGetterDef, (, ), ), {, replacement, =, IR, ., call, (]
[), ;, if, (, key, ., isGetterDef, (, ), ), {, replacement, =, IR, ., call, (, replacement, ), ;]
[), ;, if, (, key, ., isGetterDef, (, ), ), {, replacement, =, IR, ., call, (, replacement, ), ;]
[key, ., isGetterDef, (, ), ), {, replacement, =, IR, ., call, (, replacement, ), ;, replacement, ., putBooleanProp, (]
[key, ., isGetterDef, (, ), ), {, replacement, =, IR, ., call, (, replacement, ), ;, replacement, ., putBooleanProp, (]
[), ), {, replacement, =, IR, ., call, (, replacement, ), ;, replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,]
[=, IR, ., call, (, replacement, ), ;, replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }]
[=, IR, ., call, (, replacement, ), ;, replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }]
[=, IR, ., call, (, replacement, ), ;, replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }]
[replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, n, ., getParent, (, ), ., replaceChild, (]
[putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[., FREE_CALL, ,, true, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;]
[;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
