[., util, ., Set, ;, class, InlineFunctions, implements, SpecializationAwareCompilerPass, {, private, final, Map, <, String, ,, FunctionState, >, fns, =]
[., util, ., Set, ;, class, InlineFunctions, implements, SpecializationAwareCompilerPass, {, private, final, Map, <, String, ,, FunctionState, >, fns, =]
[FunctionState, >, fns, =, Maps, ., newHashMap, (, ), ;, private, final, Map, <, Node, ,, String, >, anonFns, =]
[FunctionState, >, fns, =, Maps, ., newHashMap, (, ), ;, private, final, Map, <, Node, ,, String, >, anonFns, =]
[String, >, safeNameIdSupplier, ,, boolean, inlineGlobalFunctions, ,, boolean, inlineLocalFunctions, ,, boolean, blockFunctionInliningEnabled, ,, boolean, assumeStrictThis, ,, boolean, assumeMinimumCapture, ), {]
[String, >, safeNameIdSupplier, ,, boolean, inlineGlobalFunctions, ,, boolean, inlineLocalFunctions, ,, boolean, blockFunctionInliningEnabled, ,, boolean, assumeStrictThis, ,, boolean, assumeMinimumCapture, ), {]
[boolean, inlineGlobalFunctions, ,, boolean, inlineLocalFunctions, ,, boolean, blockFunctionInliningEnabled, ,, boolean, assumeStrictThis, ,, boolean, assumeMinimumCapture, ), {, Preconditions, ., checkArgument, (]
[boolean, inlineGlobalFunctions, ,, boolean, inlineLocalFunctions, ,, boolean, blockFunctionInliningEnabled, ,, boolean, assumeStrictThis, ,, boolean, assumeMinimumCapture, ), {, Preconditions, ., checkArgument, (]
[,, boolean, inlineLocalFunctions, ,, boolean, blockFunctionInliningEnabled, ,, boolean, assumeStrictThis, ,, boolean, assumeMinimumCapture, ), {, Preconditions, ., checkArgument, (, compiler, !=]
[,, boolean, blockFunctionInliningEnabled, ,, boolean, assumeStrictThis, ,, boolean, assumeMinimumCapture, ), {, Preconditions, ., checkArgument, (, compiler, !=, null, ), ;]
[,, boolean, blockFunctionInliningEnabled, ,, boolean, assumeStrictThis, ,, boolean, assumeMinimumCapture, ), {, Preconditions, ., checkArgument, (, compiler, !=, null, ), ;]
[boolean, assumeStrictThis, ,, boolean, assumeMinimumCapture, ), {, Preconditions, ., checkArgument, (, compiler, !=, null, ), ;, Preconditions, ., checkArgument, (]
[boolean, assumeStrictThis, ,, boolean, assumeMinimumCapture, ), {, Preconditions, ., checkArgument, (, compiler, !=, null, ), ;, Preconditions, ., checkArgument, (]
[,, boolean, assumeMinimumCapture, ), {, Preconditions, ., checkArgument, (, compiler, !=, null, ), ;, Preconditions, ., checkArgument, (, safeNameIdSupplier, !=]
[), {, Preconditions, ., checkArgument, (, compiler, !=, null, ), ;, Preconditions, ., checkArgument, (, safeNameIdSupplier, !=, null, ), ;]
[), {, Preconditions, ., checkArgument, (, compiler, !=, null, ), ;, Preconditions, ., checkArgument, (, safeNameIdSupplier, !=, null, ), ;]
[checkArgument, (, compiler, !=, null, ), ;, Preconditions, ., checkArgument, (, safeNameIdSupplier, !=, null, ), ;, this, ., compiler, =]
[compiler, !=, null, ), ;, Preconditions, ., checkArgument, (, safeNameIdSupplier, !=, null, ), ;, this, ., compiler, =, compiler, ;]
[compiler, !=, null, ), ;, Preconditions, ., checkArgument, (, safeNameIdSupplier, !=, null, ), ;, this, ., compiler, =, compiler, ;]
[;, Preconditions, ., checkArgument, (, safeNameIdSupplier, !=, null, ), ;, this, ., compiler, =, compiler, ;, this, ., inlineGlobalFunctions, =]
[., checkArgument, (, safeNameIdSupplier, !=, null, ), ;, this, ., compiler, =, compiler, ;, this, ., inlineGlobalFunctions, =, inlineGlobalFunctions, ;]
[., checkArgument, (, safeNameIdSupplier, !=, null, ), ;, this, ., compiler, =, compiler, ;, this, ., inlineGlobalFunctions, =, inlineGlobalFunctions, ;]
[!=, null, ), ;, this, ., compiler, =, compiler, ;, this, ., inlineGlobalFunctions, =, inlineGlobalFunctions, ;, this, ., inlineLocalFunctions, =]
[), ;, this, ., compiler, =, compiler, ;, this, ., inlineGlobalFunctions, =, inlineGlobalFunctions, ;, this, ., inlineLocalFunctions, =, inlineLocalFunctions, ;]
[), ;, this, ., compiler, =, compiler, ;, this, ., inlineGlobalFunctions, =, inlineGlobalFunctions, ;, this, ., inlineLocalFunctions, =, inlineLocalFunctions, ;]
[compiler, =, compiler, ;, this, ., inlineGlobalFunctions, =, inlineGlobalFunctions, ;, this, ., inlineLocalFunctions, =, inlineLocalFunctions, ;, this, ., blockFunctionInliningEnabled, =]
[compiler, ;, this, ., inlineGlobalFunctions, =, inlineGlobalFunctions, ;, this, ., inlineLocalFunctions, =, inlineLocalFunctions, ;, this, ., blockFunctionInliningEnabled, =, blockFunctionInliningEnabled, ;]
[compiler, ;, this, ., inlineGlobalFunctions, =, inlineGlobalFunctions, ;, this, ., inlineLocalFunctions, =, inlineLocalFunctions, ;, this, ., blockFunctionInliningEnabled, =, blockFunctionInliningEnabled, ;]
[inlineGlobalFunctions, =, inlineGlobalFunctions, ;, this, ., inlineLocalFunctions, =, inlineLocalFunctions, ;, this, ., blockFunctionInliningEnabled, =, blockFunctionInliningEnabled, ;, this, ., assumeMinimumCapture, =]
[inlineGlobalFunctions, ;, this, ., inlineLocalFunctions, =, inlineLocalFunctions, ;, this, ., blockFunctionInliningEnabled, =, blockFunctionInliningEnabled, ;, this, ., assumeMinimumCapture, =, assumeMinimumCapture, ;]
[inlineGlobalFunctions, ;, this, ., inlineLocalFunctions, =, inlineLocalFunctions, ;, this, ., blockFunctionInliningEnabled, =, blockFunctionInliningEnabled, ;, this, ., assumeMinimumCapture, =, assumeMinimumCapture, ;]
[inlineLocalFunctions, =, inlineLocalFunctions, ;, this, ., blockFunctionInliningEnabled, =, blockFunctionInliningEnabled, ;, this, ., assumeMinimumCapture, =, assumeMinimumCapture, ;, this, ., injector, =]
[;, this, ., blockFunctionInliningEnabled, =, blockFunctionInliningEnabled, ;, this, ., assumeMinimumCapture, =, assumeMinimumCapture, ;, this, ., injector, =, new, FunctionInjector, (]
[., blockFunctionInliningEnabled, =, blockFunctionInliningEnabled, ;, this, ., assumeMinimumCapture, =, assumeMinimumCapture, ;, this, ., injector, =, new, FunctionInjector, (, compiler, ,]
[=, blockFunctionInliningEnabled, ;, this, ., assumeMinimumCapture, =, assumeMinimumCapture, ;, this, ., injector, =, new, FunctionInjector, (, compiler, ,, safeNameIdSupplier, ,]
[;, this, ., assumeMinimumCapture, =, assumeMinimumCapture, ;, this, ., injector, =, new, FunctionInjector, (, compiler, ,, safeNameIdSupplier, ,, true, ,]
[., assumeMinimumCapture, =, assumeMinimumCapture, ;, this, ., injector, =, new, FunctionInjector, (, compiler, ,, safeNameIdSupplier, ,, true, ,, assumeStrictThis, ,]
[safeNameIdSupplier, ,, true, ,, assumeStrictThis, ,, assumeMinimumCapture, ), ;, }, FunctionState, getOrCreateFunctionState, (, String, fnName, ), {, FunctionState, fs, =]
[safeNameIdSupplier, ,, true, ,, assumeStrictThis, ,, assumeMinimumCapture, ), ;, }, FunctionState, getOrCreateFunctionState, (, String, fnName, ), {, FunctionState, fs, =]
[assumeStrictThis, ,, assumeMinimumCapture, ), ;, }, FunctionState, getOrCreateFunctionState, (, String, fnName, ), {, FunctionState, fs, =, fns, ., get, (]
[}, FunctionState, getOrCreateFunctionState, (, String, fnName, ), {, FunctionState, fs, =, fns, ., get, (, fnName, ), ;, if, (]
[}, FunctionState, getOrCreateFunctionState, (, String, fnName, ), {, FunctionState, fs, =, fns, ., get, (, fnName, ), ;, if, (]
[getOrCreateFunctionState, (, String, fnName, ), {, FunctionState, fs, =, fns, ., get, (, fnName, ), ;, if, (, fs, ==]
[fnName, ), {, FunctionState, fs, =, fns, ., get, (, fnName, ), ;, if, (, fs, ==, null, ), {]
[{, FunctionState, fs, =, fns, ., get, (, fnName, ), ;, if, (, fs, ==, null, ), {, fs, =]
[., get, (, fnName, ), ;, if, (, fs, ==, null, ), {, fs, =, new, FunctionState, (, ), ;]
[., get, (, fnName, ), ;, if, (, fs, ==, null, ), {, fs, =, new, FunctionState, (, ), ;]
[), ;, if, (, fs, ==, null, ), {, fs, =, new, FunctionState, (, ), ;, fns, ., put, (]
[if, (, fs, ==, null, ), {, fs, =, new, FunctionState, (, ), ;, fns, ., put, (, fnName, ,]
[), {, fs, =, new, FunctionState, (, ), ;, fns, ., put, (, fnName, ,, fs, ), ;, }, return]
[fs, ), ;, }, return, fs, ;, }, @, Override, public, void, enableSpecialization, (, SpecializeModule, ., SpecializationState, specializationState, ), {]
[fs, ), ;, }, return, fs, ;, }, @, Override, public, void, enableSpecialization, (, SpecializeModule, ., SpecializationState, specializationState, ), {]
[return, fs, ;, }, @, Override, public, void, enableSpecialization, (, SpecializeModule, ., SpecializationState, specializationState, ), {, this, ., specializationState, =]
[this, ., specializationState, =, specializationState, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[this, ., specializationState, =, specializationState, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[specializationState, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, Preconditions, ., checkState, (]
[specializationState, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, Preconditions, ., checkState, (]
[specializationState, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, Preconditions, ., checkState, (]
[,, Node, root, ), {, Preconditions, ., checkState, (, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;]
[,, Node, root, ), {, Preconditions, ., checkState, (, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;]
[{, Preconditions, ., checkState, (, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;, NodeTraversal, ., traverse, (]
[., checkState, (, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;, NodeTraversal, ., traverse, (, compiler, ,]
[(, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[(, ), ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, FindCandidateFunctions, (, ), ), ;, if, (]
[(, ), ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, FindCandidateFunctions, (, ), ), ;, if, (]
[root, ,, new, FindCandidateFunctions, (, ), ), ;, if, (, fns, ., isEmpty, (, ), ), {, return, ;, }]
[root, ,, new, FindCandidateFunctions, (, ), ), ;, if, (, fns, ., isEmpty, (, ), ), {, return, ;, }]
[(, ), ), ;, if, (, fns, ., isEmpty, (, ), ), {, return, ;, }, NodeTraversal, ., traverse, (]
[), ;, if, (, fns, ., isEmpty, (, ), ), {, return, ;, }, NodeTraversal, ., traverse, (, compiler, ,]
[if, (, fns, ., isEmpty, (, ), ), {, return, ;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[., isEmpty, (, ), ), {, return, ;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, FindCandidatesReferences, (]
[(, ), ), {, return, ;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, FindCandidatesReferences, (, fns, ,]
[return, ;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, FindCandidatesReferences, (, fns, ,, anonFns, ), ), ;]
[(, compiler, ,, root, ,, new, FindCandidatesReferences, (, fns, ,, anonFns, ), ), ;, trimCanidatesNotMeetingMinimumRequirements, (, ), ;, if, (]
[(, compiler, ,, root, ,, new, FindCandidatesReferences, (, fns, ,, anonFns, ), ), ;, trimCanidatesNotMeetingMinimumRequirements, (, ), ;, if, (]
[), ;, if, (, fns, ., isEmpty, (, ), ), {, return, ;, }, Set, <, String, >, fnNames, =]
[), ;, if, (, fns, ., isEmpty, (, ), ), {, return, ;, }, Set, <, String, >, fnNames, =]
[fns, ., isEmpty, (, ), ), {, return, ;, }, Set, <, String, >, fnNames, =, Sets, ., newHashSet, (]
[fns, ., isEmpty, (, ), ), {, return, ;, }, Set, <, String, >, fnNames, =, Sets, ., newHashSet, (]
[return, ;, }, Set, <, String, >, fnNames, =, Sets, ., newHashSet, (, fns, ., keySet, (, ), ), ;]
[return, ;, }, Set, <, String, >, fnNames, =, Sets, ., newHashSet, (, fns, ., keySet, (, ), ), ;]
[<, String, >, fnNames, =, Sets, ., newHashSet, (, fns, ., keySet, (, ), ), ;, injector, ., setKnownConstants, (]
[fnNames, =, Sets, ., newHashSet, (, fns, ., keySet, (, ), ), ;, injector, ., setKnownConstants, (, fnNames, ), ;]
[fns, ., keySet, (, ), ), ;, injector, ., setKnownConstants, (, fnNames, ), ;, trimCanidatesUsingOnCost, (, ), ;, if, (]
[fns, ., keySet, (, ), ), ;, injector, ., setKnownConstants, (, fnNames, ), ;, trimCanidatesUsingOnCost, (, ), ;, if, (]
[(, fnNames, ), ;, trimCanidatesUsingOnCost, (, ), ;, if, (, fns, ., isEmpty, (, ), ), {, return, ;, }]
[trimCanidatesUsingOnCost, (, ), ;, if, (, fns, ., isEmpty, (, ), ), {, return, ;, }, resolveInlineConflicts, (, ), ;]
[), ;, if, (, fns, ., isEmpty, (, ), ), {, return, ;, }, resolveInlineConflicts, (, ), ;, decomposeExpressions, (]
[(, fns, ., isEmpty, (, ), ), {, return, ;, }, resolveInlineConflicts, (, ), ;, decomposeExpressions, (, fnNames, ), ;]
[(, fns, ., isEmpty, (, ), ), {, return, ;, }, resolveInlineConflicts, (, ), ;, decomposeExpressions, (, fnNames, ), ;]
[(, ), ), {, return, ;, }, resolveInlineConflicts, (, ), ;, decomposeExpressions, (, fnNames, ), ;, NodeTraversal, ., traverse, (]
[), {, return, ;, }, resolveInlineConflicts, (, ), ;, decomposeExpressions, (, fnNames, ), ;, NodeTraversal, ., traverse, (, compiler, ,]
[return, ;, }, resolveInlineConflicts, (, ), ;, decomposeExpressions, (, fnNames, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[resolveInlineConflicts, (, ), ;, decomposeExpressions, (, fnNames, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, CallVisitor, (]
[), ;, decomposeExpressions, (, fnNames, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, CallVisitor, (, fns, ,]
[decomposeExpressions, (, fnNames, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, CallVisitor, (, fns, ,, anonFns, ,]
[), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, CallVisitor, (, fns, ,, anonFns, ,, new, Inline, (]
[NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, CallVisitor, (, fns, ,, anonFns, ,, new, Inline, (, injector, ,]
[,, root, ,, new, CallVisitor, (, fns, ,, anonFns, ,, new, Inline, (, injector, ,, specializationState, ), ), ), ;]
[specializationState, ), ), ), ;, removeInlinedFunctions, (, ), ;, }, private, class, FindCandidateFunctions, implements, Callback, {, private, int, callsSeen, =]
[=, 0, ;, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {, return]
[=, 0, ;, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {, return]
[;, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {, return, inlineLocalFunctions, ||]
[;, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {, return, inlineLocalFunctions, ||]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[}, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, (]
[}, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, (]
[}, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, (]
[(, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, (, t, ., inGlobalScope, (, ), &&]
[,, Node, n, ,, Node, parent, ), {, if, (, (, t, ., inGlobalScope, (, ), &&, inlineGlobalFunctions, ), ||]
[Node, n, ,, Node, parent, ), {, if, (, (, t, ., inGlobalScope, (, ), &&, inlineGlobalFunctions, ), ||, (]
[Node, n, ,, Node, parent, ), {, if, (, (, t, ., inGlobalScope, (, ), &&, inlineGlobalFunctions, ), ||, (]
[n, ,, Node, parent, ), {, if, (, (, t, ., inGlobalScope, (, ), &&, inlineGlobalFunctions, ), ||, (, !]
[n, ,, Node, parent, ), {, if, (, (, t, ., inGlobalScope, (, ), &&, inlineGlobalFunctions, ), ||, (, !]
[if, (, (, t, ., inGlobalScope, (, ), &&, inlineGlobalFunctions, ), ||, (, !, t, ., inGlobalScope, (, ), &&]
[., inGlobalScope, (, ), &&, inlineGlobalFunctions, ), ||, (, !, t, ., inGlobalScope, (, ), &&, inlineLocalFunctions, ), ), {]
[(, ), &&, inlineGlobalFunctions, ), ||, (, !, t, ., inGlobalScope, (, ), &&, inlineLocalFunctions, ), ), {, findNamedFunctions, (]
[&&, inlineGlobalFunctions, ), ||, (, !, t, ., inGlobalScope, (, ), &&, inlineLocalFunctions, ), ), {, findNamedFunctions, (, t, ,]
[), ||, (, !, t, ., inGlobalScope, (, ), &&, inlineLocalFunctions, ), ), {, findNamedFunctions, (, t, ,, n, ,]
[!, t, ., inGlobalScope, (, ), &&, inlineLocalFunctions, ), ), {, findNamedFunctions, (, t, ,, n, ,, parent, ), ;]
[., inGlobalScope, (, ), &&, inlineLocalFunctions, ), ), {, findNamedFunctions, (, t, ,, n, ,, parent, ), ;, findFunctionExpressions, (]
[(, ), &&, inlineLocalFunctions, ), ), {, findNamedFunctions, (, t, ,, n, ,, parent, ), ;, findFunctionExpressions, (, t, ,]
[), ;, }, }, public, void, findNamedFunctions, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, }, public, void, findNamedFunctions, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, !]
[;, }, }, public, void, findNamedFunctions, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, !]
[void, findNamedFunctions, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, !, NodeUtil, ., isStatement, (]
[Node, parent, ), {, if, (, !, NodeUtil, ., isStatement, (, n, ), ), {, return, ;, }, switch, (]
[Node, parent, ), {, if, (, !, NodeUtil, ., isStatement, (, n, ), ), {, return, ;, }, switch, (]
[., isStatement, (, n, ), ), {, return, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[., isStatement, (, n, ), ), {, return, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[), ), {, return, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., VAR, :]
[), ), {, return, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., VAR, :]
[;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., VAR, :, Preconditions, ., checkState, (]
[;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., VAR, :, Preconditions, ., checkState, (]
[{, case, Token, ., VAR, :, Preconditions, ., checkState, (, n, ., hasOneChild, (, ), ), ;, Node, nameNode, =]
[{, case, Token, ., VAR, :, Preconditions, ., checkState, (, n, ., hasOneChild, (, ), ), ;, Node, nameNode, =]
[checkState, (, n, ., hasOneChild, (, ), ), ;, Node, nameNode, =, n, ., getFirstChild, (, ), ;, if, (]
[checkState, (, n, ., hasOneChild, (, ), ), ;, Node, nameNode, =, n, ., getFirstChild, (, ), ;, if, (]
[checkState, (, n, ., hasOneChild, (, ), ), ;, Node, nameNode, =, n, ., getFirstChild, (, ), ;, if, (]
[checkState, (, n, ., hasOneChild, (, ), ), ;, Node, nameNode, =, n, ., getFirstChild, (, ), ;, if, (]
[), ), ;, Node, nameNode, =, n, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&]
[), ), ;, Node, nameNode, =, n, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&]
[n, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&, nameNode, ., hasChildren, (, ), &&]
[n, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&, nameNode, ., hasChildren, (, ), &&]
[n, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&, nameNode, ., hasChildren, (, ), &&]
[(, ), &&, nameNode, ., hasChildren, (, ), &&, nameNode, ., getFirstChild, (, ), ., isFunction, (, ), ), {]
[&&, nameNode, ., hasChildren, (, ), &&, nameNode, ., getFirstChild, (, ), ., isFunction, (, ), ), {, maybeAddFunction, (]
[hasChildren, (, ), &&, nameNode, ., getFirstChild, (, ), ., isFunction, (, ), ), {, maybeAddFunction, (, new, FunctionVar, (]
[&&, nameNode, ., getFirstChild, (, ), ., isFunction, (, ), ), {, maybeAddFunction, (, new, FunctionVar, (, n, ), ,]
[&&, nameNode, ., getFirstChild, (, ), ., isFunction, (, ), ), {, maybeAddFunction, (, new, FunctionVar, (, n, ), ,]
[{, maybeAddFunction, (, new, FunctionVar, (, n, ), ,, t, ., getModule, (, ), ), ;, }, break, ;, case]
[{, maybeAddFunction, (, new, FunctionVar, (, n, ), ,, t, ., getModule, (, ), ), ;, }, break, ;, case]
[FunctionVar, (, n, ), ,, t, ., getModule, (, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :]
[FunctionVar, (, n, ), ,, t, ., getModule, (, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :]
[,, t, ., getModule, (, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (]
[,, t, ., getModule, (, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (]
[,, t, ., getModule, (, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (]
[(, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (]
[;, }, break, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, parent, ), ||]
[;, }, break, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, parent, ), ||]
[Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, parent, ), ||, parent, ., isLabel, (, ), ), ;, if, (]
[., checkState, (, NodeUtil, ., isStatementBlock, (, parent, ), ||, parent, ., isLabel, (, ), ), ;, if, (, !]
[., checkState, (, NodeUtil, ., isStatementBlock, (, parent, ), ||, parent, ., isLabel, (, ), ), ;, if, (, !]
[., isStatementBlock, (, parent, ), ||, parent, ., isLabel, (, ), ), ;, if, (, !, NodeUtil, ., isFunctionExpression, (]
[., isLabel, (, ), ), ;, if, (, !, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Function, fn, =]
[), ), ;, if, (, !, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Function, fn, =, new, NamedFunction, (]
[if, (, !, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Function, fn, =, new, NamedFunction, (, n, ), ;]
[!, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Function, fn, =, new, NamedFunction, (, n, ), ;, maybeAddFunction, (]
[., isFunctionExpression, (, n, ), ), {, Function, fn, =, new, NamedFunction, (, n, ), ;, maybeAddFunction, (, fn, ,]
[., isFunctionExpression, (, n, ), ), {, Function, fn, =, new, NamedFunction, (, n, ), ;, maybeAddFunction, (, fn, ,]
[), ;, }, break, ;, }, }, public, void, findFunctionExpressions, (, NodeTraversal, t, ,, Node, n, ), {, switch, (]
[), ;, }, break, ;, }, }, public, void, findFunctionExpressions, (, NodeTraversal, t, ,, Node, n, ), {, switch, (]
[void, findFunctionExpressions, (, NodeTraversal, t, ,, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[void, findFunctionExpressions, (, NodeTraversal, t, ,, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, Node, fnNode, =]
[(, n, ., getType, (, ), ), {, case, Token, ., CALL, :, Node, fnNode, =, null, ;, if, (]
[(, n, ., getType, (, ), ), {, case, Token, ., CALL, :, Node, fnNode, =, null, ;, if, (]
[(, n, ., getType, (, ), ), {, case, Token, ., CALL, :, Node, fnNode, =, null, ;, if, (]
[CALL, :, Node, fnNode, =, null, ;, if, (, n, ., getFirstChild, (, ), ., isFunction, (, ), ), {]
[Node, fnNode, =, null, ;, if, (, n, ., getFirstChild, (, ), ., isFunction, (, ), ), {, fnNode, =]
[Node, fnNode, =, null, ;, if, (, n, ., getFirstChild, (, ), ., isFunction, (, ), ), {, fnNode, =]
[(, ), ., isFunction, (, ), ), {, fnNode, =, n, ., getFirstChild, (, ), ;, }, else, if, (]
[(, ), ., isFunction, (, ), ), {, fnNode, =, n, ., getFirstChild, (, ), ;, }, else, if, (]
[(, ), ), {, fnNode, =, n, ., getFirstChild, (, ), ;, }, else, if, (, NodeUtil, ., isFunctionObjectCall, (]
[., getFirstChild, (, ), ;, }, else, if, (, NodeUtil, ., isFunctionObjectCall, (, n, ), ), {, Node, fnIdentifingNode, =]
[., getFirstChild, (, ), ;, }, else, if, (, NodeUtil, ., isFunctionObjectCall, (, n, ), ), {, Node, fnIdentifingNode, =]
[., getFirstChild, (, ), ;, }, else, if, (, NodeUtil, ., isFunctionObjectCall, (, n, ), ), {, Node, fnIdentifingNode, =]
[(, n, ), ), {, Node, fnIdentifingNode, =, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, if, (]
[(, n, ), ), {, Node, fnIdentifingNode, =, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, if, (]
[=, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, if, (, fnIdentifingNode, ., isFunction, (, ), ), {]
[., getFirstChild, (, ), ., getFirstChild, (, ), ;, if, (, fnIdentifingNode, ., isFunction, (, ), ), {, fnNode, =]
[(, ), ;, if, (, fnIdentifingNode, ., isFunction, (, ), ), {, fnNode, =, fnIdentifingNode, ;, }, }, if, (]
[(, ), ;, if, (, fnIdentifingNode, ., isFunction, (, ), ), {, fnNode, =, fnIdentifingNode, ;, }, }, if, (]
[;, if, (, fnIdentifingNode, ., isFunction, (, ), ), {, fnNode, =, fnIdentifingNode, ;, }, }, if, (, fnNode, !=]
[(, ), ), {, fnNode, =, fnIdentifingNode, ;, }, }, if, (, fnNode, !=, null, ), {, Function, fn, =]
[{, fnNode, =, fnIdentifingNode, ;, }, }, if, (, fnNode, !=, null, ), {, Function, fn, =, new, FunctionExpression, (]
[=, fnIdentifingNode, ;, }, }, if, (, fnNode, !=, null, ), {, Function, fn, =, new, FunctionExpression, (, fnNode, ,]
[=, fnIdentifingNode, ;, }, }, if, (, fnNode, !=, null, ), {, Function, fn, =, new, FunctionExpression, (, fnNode, ,]
[}, if, (, fnNode, !=, null, ), {, Function, fn, =, new, FunctionExpression, (, fnNode, ,, callsSeen, ++, ), ;]
[(, fnNode, !=, null, ), {, Function, fn, =, new, FunctionExpression, (, fnNode, ,, callsSeen, ++, ), ;, maybeAddFunction, (]
[!=, null, ), {, Function, fn, =, new, FunctionExpression, (, fnNode, ,, callsSeen, ++, ), ;, maybeAddFunction, (, fn, ,]
[!=, null, ), {, Function, fn, =, new, FunctionExpression, (, fnNode, ,, callsSeen, ++, ), ;, maybeAddFunction, (, fn, ,]
[new, FunctionExpression, (, fnNode, ,, callsSeen, ++, ), ;, maybeAddFunction, (, fn, ,, t, ., getModule, (, ), ), ;]
[new, FunctionExpression, (, fnNode, ,, callsSeen, ++, ), ;, maybeAddFunction, (, fn, ,, t, ., getModule, (, ), ), ;]
[,, callsSeen, ++, ), ;, maybeAddFunction, (, fn, ,, t, ., getModule, (, ), ), ;, anonFns, ., put, (]
[++, ), ;, maybeAddFunction, (, fn, ,, t, ., getModule, (, ), ), ;, anonFns, ., put, (, fnNode, ,]
[++, ), ;, maybeAddFunction, (, fn, ,, t, ., getModule, (, ), ), ;, anonFns, ., put, (, fnNode, ,]
[}, break, ;, }, }, }, private, void, maybeAddFunction, (, Function, fn, ,, JSModule, module, ), {, String, name, =]
[}, break, ;, }, }, }, private, void, maybeAddFunction, (, Function, fn, ,, JSModule, module, ), {, String, name, =]
[(, Function, fn, ,, JSModule, module, ), {, String, name, =, fn, ., getName, (, ), ;, FunctionState, fs, =]
[fn, ,, JSModule, module, ), {, String, name, =, fn, ., getName, (, ), ;, FunctionState, fs, =, getOrCreateFunctionState, (]
[{, String, name, =, fn, ., getName, (, ), ;, FunctionState, fs, =, getOrCreateFunctionState, (, name, ), ;, if, (]
[{, String, name, =, fn, ., getName, (, ), ;, FunctionState, fs, =, getOrCreateFunctionState, (, name, ), ;, if, (]
[(, ), ;, FunctionState, fs, =, getOrCreateFunctionState, (, name, ), ;, if, (, fs, ., hasExistingFunctionDefinition, (, ), ), {]
[(, ), ;, FunctionState, fs, =, getOrCreateFunctionState, (, name, ), ;, if, (, fs, ., hasExistingFunctionDefinition, (, ), ), {]
[fs, =, getOrCreateFunctionState, (, name, ), ;, if, (, fs, ., hasExistingFunctionDefinition, (, ), ), {, fs, ., setInline, (]
[(, fs, ., hasExistingFunctionDefinition, (, ), ), {, fs, ., setInline, (, false, ), ;, }, else, {, if, (]
[(, fs, ., hasExistingFunctionDefinition, (, ), ), {, fs, ., setInline, (, false, ), ;, }, else, {, if, (]
[{, fs, ., setInline, (, false, ), ;, }, else, {, if, (, fs, ., canInline, (, ), ), {]
[{, fs, ., setInline, (, false, ), ;, }, else, {, if, (, fs, ., canInline, (, ), ), {]
[(, false, ), ;, }, else, {, if, (, fs, ., canInline, (, ), ), {, fs, ., setFn, (]
[else, {, if, (, fs, ., canInline, (, ), ), {, fs, ., setFn, (, fn, ), ;, if, (]
[else, {, if, (, fs, ., canInline, (, ), ), {, fs, ., setFn, (, fn, ), ;, if, (]
[fs, ., canInline, (, ), ), {, fs, ., setFn, (, fn, ), ;, if, (, injector, ., isDirectCallNodeReplacementPossible, (]
[fs, ., canInline, (, ), ), {, fs, ., setFn, (, fn, ), ;, if, (, injector, ., isDirectCallNodeReplacementPossible, (]
[., setFn, (, fn, ), ;, if, (, injector, ., isDirectCallNodeReplacementPossible, (, fn, ., getFunctionNode, (, ), ), ), {]
[., setFn, (, fn, ), ;, if, (, injector, ., isDirectCallNodeReplacementPossible, (, fn, ., getFunctionNode, (, ), ), ), {]
[), ;, if, (, injector, ., isDirectCallNodeReplacementPossible, (, fn, ., getFunctionNode, (, ), ), ), {, fs, ., inlineDirectly, (]
[isDirectCallNodeReplacementPossible, (, fn, ., getFunctionNode, (, ), ), ), {, fs, ., inlineDirectly, (, true, ), ;, }, if, (]
[(, fn, ., getFunctionNode, (, ), ), ), {, fs, ., inlineDirectly, (, true, ), ;, }, if, (, !]
[., getFunctionNode, (, ), ), ), {, fs, ., inlineDirectly, (, true, ), ;, }, if, (, !, isCandidateFunction, (]
[), ), {, fs, ., inlineDirectly, (, true, ), ;, }, if, (, !, isCandidateFunction, (, fn, ), ), {]
[), ), {, fs, ., inlineDirectly, (, true, ), ;, }, if, (, !, isCandidateFunction, (, fn, ), ), {]
[., inlineDirectly, (, true, ), ;, }, if, (, !, isCandidateFunction, (, fn, ), ), {, fs, ., setInline, (]
[}, if, (, !, isCandidateFunction, (, fn, ), ), {, fs, ., setInline, (, false, ), ;, }, if, (]
[}, if, (, !, isCandidateFunction, (, fn, ), ), {, fs, ., setInline, (, false, ), ;, }, if, (]
[), ), {, fs, ., setInline, (, false, ), ;, }, if, (, fs, ., canInline, (, ), ), {]
[), ), {, fs, ., setInline, (, false, ), ;, }, if, (, fs, ., canInline, (, ), ), {]
[., setInline, (, false, ), ;, }, if, (, fs, ., canInline, (, ), ), {, fs, ., setModule, (]
[}, if, (, fs, ., canInline, (, ), ), {, fs, ., setModule, (, module, ), ;, Node, fnNode, =]
[}, if, (, fs, ., canInline, (, ), ), {, fs, ., setModule, (, module, ), ;, Node, fnNode, =]
[setModule, (, module, ), ;, Node, fnNode, =, fn, ., getFunctionNode, (, ), ;, Set, <, String, >, namesToAlias, =]
[setModule, (, module, ), ;, Node, fnNode, =, fn, ., getFunctionNode, (, ), ;, Set, <, String, >, namesToAlias, =]
[;, Node, fnNode, =, fn, ., getFunctionNode, (, ), ;, Set, <, String, >, namesToAlias, =, FunctionArgumentInjector, ., findModifiedParameters, (]
[., getFunctionNode, (, ), ;, Set, <, String, >, namesToAlias, =, FunctionArgumentInjector, ., findModifiedParameters, (, fnNode, ), ;, if, (]
[getFunctionNode, (, ), ;, Set, <, String, >, namesToAlias, =, FunctionArgumentInjector, ., findModifiedParameters, (, fnNode, ), ;, if, (, !]
[getFunctionNode, (, ), ;, Set, <, String, >, namesToAlias, =, FunctionArgumentInjector, ., findModifiedParameters, (, fnNode, ), ;, if, (, !]
[>, namesToAlias, =, FunctionArgumentInjector, ., findModifiedParameters, (, fnNode, ), ;, if, (, !, namesToAlias, ., isEmpty, (, ), ), {]
[>, namesToAlias, =, FunctionArgumentInjector, ., findModifiedParameters, (, fnNode, ), ;, if, (, !, namesToAlias, ., isEmpty, (, ), ), {]
[., findModifiedParameters, (, fnNode, ), ;, if, (, !, namesToAlias, ., isEmpty, (, ), ), {, fs, ., inlineDirectly, (]
[fnNode, ), ;, if, (, !, namesToAlias, ., isEmpty, (, ), ), {, fs, ., inlineDirectly, (, false, ), ;]
[fnNode, ), ;, if, (, !, namesToAlias, ., isEmpty, (, ), ), {, fs, ., inlineDirectly, (, false, ), ;]
[(, !, namesToAlias, ., isEmpty, (, ), ), {, fs, ., inlineDirectly, (, false, ), ;, fs, ., setNamesToAlias, (]
[), {, fs, ., inlineDirectly, (, false, ), ;, fs, ., setNamesToAlias, (, namesToAlias, ), ;, }, Node, block, =]
[), {, fs, ., inlineDirectly, (, false, ), ;, fs, ., setNamesToAlias, (, namesToAlias, ), ;, }, Node, block, =]
[inlineDirectly, (, false, ), ;, fs, ., setNamesToAlias, (, namesToAlias, ), ;, }, Node, block, =, NodeUtil, ., getFunctionBody, (]
[fs, ., setNamesToAlias, (, namesToAlias, ), ;, }, Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, if, (]
[fs, ., setNamesToAlias, (, namesToAlias, ), ;, }, Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, if, (]
[namesToAlias, ), ;, }, Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, if, (, NodeUtil, ., referencesThis, (]
[Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, if, (, NodeUtil, ., referencesThis, (, block, ), ), {]
[Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, if, (, NodeUtil, ., referencesThis, (, block, ), ), {]
[., getFunctionBody, (, fnNode, ), ;, if, (, NodeUtil, ., referencesThis, (, block, ), ), {, fs, ., setReferencesThis, (]
[if, (, NodeUtil, ., referencesThis, (, block, ), ), {, fs, ., setReferencesThis, (, true, ), ;, }, if, (]
[if, (, NodeUtil, ., referencesThis, (, block, ), ), {, fs, ., setReferencesThis, (, true, ), ;, }, if, (]
[referencesThis, (, block, ), ), {, fs, ., setReferencesThis, (, true, ), ;, }, if, (, NodeUtil, ., containsFunction, (]
[), {, fs, ., setReferencesThis, (, true, ), ;, }, if, (, NodeUtil, ., containsFunction, (, block, ), ), {]
[), {, fs, ., setReferencesThis, (, true, ), ;, }, if, (, NodeUtil, ., containsFunction, (, block, ), ), {]
[setReferencesThis, (, true, ), ;, }, if, (, NodeUtil, ., containsFunction, (, block, ), ), {, fs, ., setHasInnerFunctions, (]
[}, if, (, NodeUtil, ., containsFunction, (, block, ), ), {, fs, ., setHasInnerFunctions, (, true, ), ;, if, (]
[}, if, (, NodeUtil, ., containsFunction, (, block, ), ), {, fs, ., setHasInnerFunctions, (, true, ), ;, if, (]
[if, (, NodeUtil, ., containsFunction, (, block, ), ), {, fs, ., setHasInnerFunctions, (, true, ), ;, if, (, !]
[NodeUtil, ., containsFunction, (, block, ), ), {, fs, ., setHasInnerFunctions, (, true, ), ;, if, (, !, assumeMinimumCapture, &&]
[containsFunction, (, block, ), ), {, fs, ., setHasInnerFunctions, (, true, ), ;, if, (, !, assumeMinimumCapture, &&, hasLocalNames, (]
[), {, fs, ., setHasInnerFunctions, (, true, ), ;, if, (, !, assumeMinimumCapture, &&, hasLocalNames, (, fnNode, ), ), {]
[), {, fs, ., setHasInnerFunctions, (, true, ), ;, if, (, !, assumeMinimumCapture, &&, hasLocalNames, (, fnNode, ), ), {]
[setHasInnerFunctions, (, true, ), ;, if, (, !, assumeMinimumCapture, &&, hasLocalNames, (, fnNode, ), ), {, fs, ., setInline, (]
[assumeMinimumCapture, &&, hasLocalNames, (, fnNode, ), ), {, fs, ., setInline, (, false, ), ;, }, }, }, if, (]
[assumeMinimumCapture, &&, hasLocalNames, (, fnNode, ), ), {, fs, ., setInline, (, false, ), ;, }, }, }, if, (]
[assumeMinimumCapture, &&, hasLocalNames, (, fnNode, ), ), {, fs, ., setInline, (, false, ), ;, }, }, }, if, (]
[), {, fs, ., setInline, (, false, ), ;, }, }, }, if, (, fs, ., canInline, (, ), &&]
[{, fs, ., setInline, (, false, ), ;, }, }, }, if, (, fs, ., canInline, (, ), &&, !]
[{, fs, ., setInline, (, false, ), ;, }, }, }, if, (, fs, ., canInline, (, ), &&, !]
[}, }, if, (, fs, ., canInline, (, ), &&, !, fs, ., canInlineDirectly, (, ), ), {, if, (]
[}, if, (, fs, ., canInline, (, ), &&, !, fs, ., canInlineDirectly, (, ), ), {, if, (, !]
[fs, ., canInline, (, ), &&, !, fs, ., canInlineDirectly, (, ), ), {, if, (, !, blockFunctionInliningEnabled, ), {]
[fs, ., canInline, (, ), &&, !, fs, ., canInlineDirectly, (, ), ), {, if, (, !, blockFunctionInliningEnabled, ), {]
[), &&, !, fs, ., canInlineDirectly, (, ), ), {, if, (, !, blockFunctionInliningEnabled, ), {, fs, ., setInline, (]
[(, false, ), ;, }, }, }, }, }, private, boolean, hasLocalNames, (, Node, fnNode, ), {, Node, block, =]
[(, false, ), ;, }, }, }, }, }, private, boolean, hasLocalNames, (, Node, fnNode, ), {, Node, block, =]
[}, }, }, }, }, private, boolean, hasLocalNames, (, Node, fnNode, ), {, Node, block, =, NodeUtil, ., getFunctionBody, (]
[}, private, boolean, hasLocalNames, (, Node, fnNode, ), {, Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, return]
[}, private, boolean, hasLocalNames, (, Node, fnNode, ), {, Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, return]
[}, private, boolean, hasLocalNames, (, Node, fnNode, ), {, Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, return]
[}, private, boolean, hasLocalNames, (, Node, fnNode, ), {, Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, return]
[(, Node, fnNode, ), {, Node, block, =, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, return, NodeUtil, ., getFunctionParameters, (]
[=, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, return, NodeUtil, ., getFunctionParameters, (, fnNode, ), ., hasChildren, (, ), ||]
[=, NodeUtil, ., getFunctionBody, (, fnNode, ), ;, return, NodeUtil, ., getFunctionParameters, (, fnNode, ), ., hasChildren, (, ), ||]
[(, fnNode, ), ;, return, NodeUtil, ., getFunctionParameters, (, fnNode, ), ., hasChildren, (, ), ||, NodeUtil, ., has, (]
[), ;, return, NodeUtil, ., getFunctionParameters, (, fnNode, ), ., hasChildren, (, ), ||, NodeUtil, ., has, (, block, ,]
[fnNode, ), ., hasChildren, (, ), ||, NodeUtil, ., has, (, block, ,, new, NodeUtil, ., MatchDeclaration, (, ), ,]
[,, new, NodeUtil, ., MatchShallowStatement, (, ), ), ;, }, private, static, Node, getContainingFunction, (, NodeTraversal, t, ), {, return]
[,, new, NodeUtil, ., MatchShallowStatement, (, ), ), ;, }, private, static, Node, getContainingFunction, (, NodeTraversal, t, ), {, return]
[new, NodeUtil, ., MatchShallowStatement, (, ), ), ;, }, private, static, Node, getContainingFunction, (, NodeTraversal, t, ), {, return, (]
[new, NodeUtil, ., MatchShallowStatement, (, ), ), ;, }, private, static, Node, getContainingFunction, (, NodeTraversal, t, ), {, return, (]
[;, }, private, static, Node, getContainingFunction, (, NodeTraversal, t, ), {, return, (, t, ., inGlobalScope, (, ), ), ?]
[private, static, Node, getContainingFunction, (, NodeTraversal, t, ), {, return, (, t, ., inGlobalScope, (, ), ), ?, null, :]
[private, static, Node, getContainingFunction, (, NodeTraversal, t, ), {, return, (, t, ., inGlobalScope, (, ), ), ?, null, :]
[null, :, t, ., getScopeRoot, (, ), ;, }, private, boolean, isCandidateFunction, (, Function, fn, ), {, String, fnName, =]
[null, :, t, ., getScopeRoot, (, ), ;, }, private, boolean, isCandidateFunction, (, Function, fn, ), {, String, fnName, =]
[}, private, boolean, isCandidateFunction, (, Function, fn, ), {, String, fnName, =, fn, ., getName, (, ), ;, if, (]
[}, private, boolean, isCandidateFunction, (, Function, fn, ), {, String, fnName, =, fn, ., getName, (, ), ;, if, (]
[}, private, boolean, isCandidateFunction, (, Function, fn, ), {, String, fnName, =, fn, ., getName, (, ), ;, if, (]
[{, String, fnName, =, fn, ., getName, (, ), ;, if, (, compiler, ., getCodingConvention, (, ), ., isExported, (]
[., getName, (, ), ;, if, (, compiler, ., getCodingConvention, (, ), ., isExported, (, fnName, ), ), {, return]
[if, (, compiler, ., getCodingConvention, (, ), ., isExported, (, fnName, ), ), {, return, false, ;, }, if, (]
[if, (, compiler, ., getCodingConvention, (, ), ., isExported, (, fnName, ), ), {, return, false, ;, }, if, (]
[if, (, compiler, ., getCodingConvention, (, ), ., isExported, (, fnName, ), ), {, return, false, ;, }, if, (]
[), ., isExported, (, fnName, ), ), {, return, false, ;, }, if, (, RenameProperties, ., RENAME_PROPERTY_FUNCTION_NAME, ., equals, (]
[), ), {, return, false, ;, }, if, (, RenameProperties, ., RENAME_PROPERTY_FUNCTION_NAME, ., equals, (, fnName, ), ), {, return]
[;, }, if, (, RenameProperties, ., RENAME_PROPERTY_FUNCTION_NAME, ., equals, (, fnName, ), ), {, return, false, ;, }, if, (]
[;, }, if, (, RenameProperties, ., RENAME_PROPERTY_FUNCTION_NAME, ., equals, (, fnName, ), ), {, return, false, ;, }, if, (]
[;, }, if, (, RenameProperties, ., RENAME_PROPERTY_FUNCTION_NAME, ., equals, (, fnName, ), ), {, return, false, ;, }, if, (]
[if, (, RenameProperties, ., RENAME_PROPERTY_FUNCTION_NAME, ., equals, (, fnName, ), ), {, return, false, ;, }, if, (, specializationState, !=]
[RenameProperties, ., RENAME_PROPERTY_FUNCTION_NAME, ., equals, (, fnName, ), ), {, return, false, ;, }, if, (, specializationState, !=, null, &&]
[., RENAME_PROPERTY_FUNCTION_NAME, ., equals, (, fnName, ), ), {, return, false, ;, }, if, (, specializationState, !=, null, &&, !]
[., RENAME_PROPERTY_FUNCTION_NAME, ., equals, (, fnName, ), ), {, return, false, ;, }, if, (, specializationState, !=, null, &&, !]
[(, fnName, ), ), {, return, false, ;, }, if, (, specializationState, !=, null, &&, !, specializationState, ., canFixupFunction, (]
[(, fnName, ), ), {, return, false, ;, }, if, (, specializationState, !=, null, &&, !, specializationState, ., canFixupFunction, (]
[if, (, specializationState, !=, null, &&, !, specializationState, ., canFixupFunction, (, fn, ., getFunctionNode, (, ), ), ), {, return]
[!, specializationState, ., canFixupFunction, (, fn, ., getFunctionNode, (, ), ), ), {, return, false, ;, }, Node, fnNode, =]
[!, specializationState, ., canFixupFunction, (, fn, ., getFunctionNode, (, ), ), ), {, return, false, ;, }, Node, fnNode, =]
[getFunctionNode, (, ), ), ), {, return, false, ;, }, Node, fnNode, =, fn, ., getFunctionNode, (, ), ;, return]
[getFunctionNode, (, ), ), ), {, return, false, ;, }, Node, fnNode, =, fn, ., getFunctionNode, (, ), ;, return]
[), {, return, false, ;, }, Node, fnNode, =, fn, ., getFunctionNode, (, ), ;, return, injector, ., doesFunctionMeetMinimumRequirements, (]
[return, false, ;, }, Node, fnNode, =, fn, ., getFunctionNode, (, ), ;, return, injector, ., doesFunctionMeetMinimumRequirements, (, fnName, ,]
[Map, <, String, ,, FunctionState, >, fns, ,, Map, <, Node, ,, String, >, anonFns, ,, CallVisitorCallback, callback, ), {]
[Map, <, String, ,, FunctionState, >, fns, ,, Map, <, Node, ,, String, >, anonFns, ,, CallVisitorCallback, callback, ), {]
[FunctionState, >, fns, ,, Map, <, Node, ,, String, >, anonFns, ,, CallVisitorCallback, callback, ), {, this, ., functionMap, =]
[fns, ,, Map, <, Node, ,, String, >, anonFns, ,, CallVisitorCallback, callback, ), {, this, ., functionMap, =, fns, ;]
[fns, ,, Map, <, Node, ,, String, >, anonFns, ,, CallVisitorCallback, callback, ), {, this, ., functionMap, =, fns, ;]
[Node, ,, String, >, anonFns, ,, CallVisitorCallback, callback, ), {, this, ., functionMap, =, fns, ;, this, ., anonFunctionMap, =]
[String, >, anonFns, ,, CallVisitorCallback, callback, ), {, this, ., functionMap, =, fns, ;, this, ., anonFunctionMap, =, anonFns, ;]
[String, >, anonFns, ,, CallVisitorCallback, callback, ), {, this, ., functionMap, =, fns, ;, this, ., anonFunctionMap, =, anonFns, ;]
[CallVisitorCallback, callback, ), {, this, ., functionMap, =, fns, ;, this, ., anonFunctionMap, =, anonFns, ;, this, ., callback, =]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, switch, (]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, switch, (]
[NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, switch, (, n, ., getType, (, ), ), {, case]
[NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, switch, (, n, ., getType, (, ), ), {, case]
[parent, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, Node, child, =]
[parent, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, Node, child, =]
[), ), {, case, Token, ., CALL, :, Node, child, =, n, ., getFirstChild, (, ), ;, String, name, =]
[Token, ., CALL, :, Node, child, =, n, ., getFirstChild, (, ), ;, String, name, =, null, ;, if, (]
[Token, ., CALL, :, Node, child, =, n, ., getFirstChild, (, ), ;, String, name, =, null, ;, if, (]
[n, ., getFirstChild, (, ), ;, String, name, =, null, ;, if, (, child, ., isName, (, ), ), {]
[getFirstChild, (, ), ;, String, name, =, null, ;, if, (, child, ., isName, (, ), ), {, name, =]
[getFirstChild, (, ), ;, String, name, =, null, ;, if, (, child, ., isName, (, ), ), {, name, =]
[(, child, ., isName, (, ), ), {, name, =, child, ., getString, (, ), ;, }, else, if, (]
[(, child, ., isName, (, ), ), {, name, =, child, ., getString, (, ), ;, }, else, if, (]
[{, name, =, child, ., getString, (, ), ;, }, else, if, (, child, ., isFunction, (, ), ), {]
[=, child, ., getString, (, ), ;, }, else, if, (, child, ., isFunction, (, ), ), {, name, =]
[=, child, ., getString, (, ), ;, }, else, if, (, child, ., isFunction, (, ), ), {, name, =]
[(, ), ;, }, else, if, (, child, ., isFunction, (, ), ), {, name, =, anonFunctionMap, ., get, (]
[child, ., isFunction, (, ), ), {, name, =, anonFunctionMap, ., get, (, child, ), ;, }, else, if, (]
[child, ., isFunction, (, ), ), {, name, =, anonFunctionMap, ., get, (, child, ), ;, }, else, if, (]
[), ), {, name, =, anonFunctionMap, ., get, (, child, ), ;, }, else, if, (, NodeUtil, ., isFunctionObjectCall, (]
[=, anonFunctionMap, ., get, (, child, ), ;, }, else, if, (, NodeUtil, ., isFunctionObjectCall, (, n, ), ), {]
[=, anonFunctionMap, ., get, (, child, ), ;, }, else, if, (, NodeUtil, ., isFunctionObjectCall, (, n, ), ), {]
[(, child, ), ;, }, else, if, (, NodeUtil, ., isFunctionObjectCall, (, n, ), ), {, Preconditions, ., checkState, (]
[(, child, ), ;, }, else, if, (, NodeUtil, ., isFunctionObjectCall, (, n, ), ), {, Preconditions, ., checkState, (]
[}, else, if, (, NodeUtil, ., isFunctionObjectCall, (, n, ), ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (]
[(, n, ), ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, child, ), ), ;, Node, fnIdentifingNode, =]
[(, n, ), ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, child, ), ), ;, Node, fnIdentifingNode, =]
[(, NodeUtil, ., isGet, (, child, ), ), ;, Node, fnIdentifingNode, =, child, ., getFirstChild, (, ), ;, if, (]
[(, NodeUtil, ., isGet, (, child, ), ), ;, Node, fnIdentifingNode, =, child, ., getFirstChild, (, ), ;, if, (]
[), ;, Node, fnIdentifingNode, =, child, ., getFirstChild, (, ), ;, if, (, fnIdentifingNode, ., isName, (, ), ), {]
[Node, fnIdentifingNode, =, child, ., getFirstChild, (, ), ;, if, (, fnIdentifingNode, ., isName, (, ), ), {, name, =]
[Node, fnIdentifingNode, =, child, ., getFirstChild, (, ), ;, if, (, fnIdentifingNode, ., isName, (, ), ), {, name, =]
[(, fnIdentifingNode, ., isName, (, ), ), {, name, =, fnIdentifingNode, ., getString, (, ), ;, }, else, if, (]
[(, fnIdentifingNode, ., isName, (, ), ), {, name, =, fnIdentifingNode, ., getString, (, ), ;, }, else, if, (]
[{, name, =, fnIdentifingNode, ., getString, (, ), ;, }, else, if, (, fnIdentifingNode, ., isFunction, (, ), ), {]
[=, fnIdentifingNode, ., getString, (, ), ;, }, else, if, (, fnIdentifingNode, ., isFunction, (, ), ), {, name, =]
[=, fnIdentifingNode, ., getString, (, ), ;, }, else, if, (, fnIdentifingNode, ., isFunction, (, ), ), {, name, =]
[(, ), ;, }, else, if, (, fnIdentifingNode, ., isFunction, (, ), ), {, name, =, anonFunctionMap, ., get, (]
[fnIdentifingNode, ., isFunction, (, ), ), {, name, =, anonFunctionMap, ., get, (, fnIdentifingNode, ), ;, }, }, if, (]
[fnIdentifingNode, ., isFunction, (, ), ), {, name, =, anonFunctionMap, ., get, (, fnIdentifingNode, ), ;, }, }, if, (]
[isFunction, (, ), ), {, name, =, anonFunctionMap, ., get, (, fnIdentifingNode, ), ;, }, }, if, (, name, !=]
[=, anonFunctionMap, ., get, (, fnIdentifingNode, ), ;, }, }, if, (, name, !=, null, ), {, FunctionState, fs, =]
[=, anonFunctionMap, ., get, (, fnIdentifingNode, ), ;, }, }, if, (, name, !=, null, ), {, FunctionState, fs, =]
[(, fnIdentifingNode, ), ;, }, }, if, (, name, !=, null, ), {, FunctionState, fs, =, functionMap, ., get, (]
[}, if, (, name, !=, null, ), {, FunctionState, fs, =, functionMap, ., get, (, name, ), ;, if, (]
[}, if, (, name, !=, null, ), {, FunctionState, fs, =, functionMap, ., get, (, name, ), ;, if, (]
[(, name, !=, null, ), {, FunctionState, fs, =, functionMap, ., get, (, name, ), ;, if, (, fs, !=]
[null, ), {, FunctionState, fs, =, functionMap, ., get, (, name, ), ;, if, (, fs, !=, null, ), {]
[null, ), {, FunctionState, fs, =, functionMap, ., get, (, name, ), ;, if, (, fs, !=, null, ), {]
[fs, =, functionMap, ., get, (, name, ), ;, if, (, fs, !=, null, ), {, callback, ., visitCallSite, (]
[functionMap, ., get, (, name, ), ;, if, (, fs, !=, null, ), {, callback, ., visitCallSite, (, t, ,]
[get, (, name, ), ;, if, (, fs, !=, null, ), {, callback, ., visitCallSite, (, t, ,, n, ,]
[name, ), ;, if, (, fs, !=, null, ), {, callback, ., visitCallSite, (, t, ,, n, ,, parent, ,]
[), ;, }, }, break, ;, }, }, }, static, boolean, isCandidateUsage, (, Node, name, ), {, Node, parent, =]
[), ;, }, }, break, ;, }, }, }, static, boolean, isCandidateUsage, (, Node, name, ), {, Node, parent, =]
[}, }, }, static, boolean, isCandidateUsage, (, Node, name, ), {, Node, parent, =, name, ., getParent, (, ), ;]
[}, }, }, static, boolean, isCandidateUsage, (, Node, name, ), {, Node, parent, =, name, ., getParent, (, ), ;]
[boolean, isCandidateUsage, (, Node, name, ), {, Node, parent, =, name, ., getParent, (, ), ;, Preconditions, ., checkState, (]
[boolean, isCandidateUsage, (, Node, name, ), {, Node, parent, =, name, ., getParent, (, ), ;, Preconditions, ., checkState, (]
[=, name, ., getParent, (, ), ;, Preconditions, ., checkState, (, name, ., isName, (, ), ), ;, if, (]
[=, name, ., getParent, (, ), ;, Preconditions, ., checkState, (, name, ., isName, (, ), ), ;, if, (]
[=, name, ., getParent, (, ), ;, Preconditions, ., checkState, (, name, ., isName, (, ), ), ;, if, (]
[;, Preconditions, ., checkState, (, name, ., isName, (, ), ), ;, if, (, parent, ., isVar, (, ), ||]
[;, Preconditions, ., checkState, (, name, ., isName, (, ), ), ;, if, (, parent, ., isVar, (, ), ||]
[(, ), ), ;, if, (, parent, ., isVar, (, ), ||, parent, ., isFunction, (, ), ), {, return]
[(, parent, ., isVar, (, ), ||, parent, ., isFunction, (, ), ), {, return, true, ;, }, if, (]
[(, parent, ., isVar, (, ), ||, parent, ., isFunction, (, ), ), {, return, true, ;, }, if, (]
[(, parent, ., isVar, (, ), ||, parent, ., isFunction, (, ), ), {, return, true, ;, }, if, (]
[||, parent, ., isFunction, (, ), ), {, return, true, ;, }, if, (, parent, ., isCall, (, ), &&]
[||, parent, ., isFunction, (, ), ), {, return, true, ;, }, if, (, parent, ., isCall, (, ), &&]
[||, parent, ., isFunction, (, ), ), {, return, true, ;, }, if, (, parent, ., isCall, (, ), &&]
[), {, return, true, ;, }, if, (, parent, ., isCall, (, ), &&, parent, ., getFirstChild, (, ), ==]
[;, }, if, (, parent, ., isCall, (, ), &&, parent, ., getFirstChild, (, ), ==, name, ), {, return]
[., isCall, (, ), &&, parent, ., getFirstChild, (, ), ==, name, ), {, return, true, ;, }, if, (]
[., isCall, (, ), &&, parent, ., getFirstChild, (, ), ==, name, ), {, return, true, ;, }, if, (]
[., isCall, (, ), &&, parent, ., getFirstChild, (, ), ==, name, ), {, return, true, ;, }, if, (]
[., isCall, (, ), &&, parent, ., getFirstChild, (, ), ==, name, ), {, return, true, ;, }, if, (]
[., isCall, (, ), &&, parent, ., getFirstChild, (, ), ==, name, ), {, return, true, ;, }, if, (]
[&&, parent, ., getFirstChild, (, ), ==, name, ), {, return, true, ;, }, if, (, NodeUtil, ., isGet, (]
[getFirstChild, (, ), ==, name, ), {, return, true, ;, }, if, (, NodeUtil, ., isGet, (, parent, ), &&]
[getFirstChild, (, ), ==, name, ), {, return, true, ;, }, if, (, NodeUtil, ., isGet, (, parent, ), &&]
[), ==, name, ), {, return, true, ;, }, if, (, NodeUtil, ., isGet, (, parent, ), &&, name, ==]
[), ==, name, ), {, return, true, ;, }, if, (, NodeUtil, ., isGet, (, parent, ), &&, name, ==]
[true, ;, }, if, (, NodeUtil, ., isGet, (, parent, ), &&, name, ==, parent, ., getFirstChild, (, ), &&]
[true, ;, }, if, (, NodeUtil, ., isGet, (, parent, ), &&, name, ==, parent, ., getFirstChild, (, ), &&]
[true, ;, }, if, (, NodeUtil, ., isGet, (, parent, ), &&, name, ==, parent, ., getFirstChild, (, ), &&]
[), &&, name, ==, parent, ., getFirstChild, (, ), &&, name, ., getNext, (, ), ., isString, (, ), &&]
[), &&, name, ==, parent, ., getFirstChild, (, ), &&, name, ., getNext, (, ), ., isString, (, ), &&]
[), &&, name, ==, parent, ., getFirstChild, (, ), &&, name, ., getNext, (, ), ., isString, (, ), &&]
[), &&, name, ==, parent, ., getFirstChild, (, ), &&, name, ., getNext, (, ), ., isString, (, ), &&]
[getNext, (, ), ., isString, (, ), &&, name, ., getNext, (, ), ., getString, (, ), ., equals, (]
[&&, name, ., getNext, (, ), ., getString, (, ), ., equals, (, "call", ), ), {, Node, gramps, =]
[&&, name, ., getNext, (, ), ., getString, (, ), ., equals, (, "call", ), ), {, Node, gramps, =]
[(, ), ., getString, (, ), ., equals, (, "call", ), ), {, Node, gramps, =, name, ., getAncestor, (]
[), ., equals, (, "call", ), ), {, Node, gramps, =, name, ., getAncestor, (, 2, ), ;, if, (]
[), ., equals, (, "call", ), ), {, Node, gramps, =, name, ., getAncestor, (, 2, ), ;, if, (]
[), ., equals, (, "call", ), ), {, Node, gramps, =, name, ., getAncestor, (, 2, ), ;, if, (]
[), {, Node, gramps, =, name, ., getAncestor, (, 2, ), ;, if, (, gramps, ., isCall, (, ), &&]
[), {, Node, gramps, =, name, ., getAncestor, (, 2, ), ;, if, (, gramps, ., isCall, (, ), &&]
[), {, Node, gramps, =, name, ., getAncestor, (, 2, ), ;, if, (, gramps, ., isCall, (, ), &&]
[., getAncestor, (, 2, ), ;, if, (, gramps, ., isCall, (, ), &&, gramps, ., getFirstChild, (, ), ==]
[), ;, if, (, gramps, ., isCall, (, ), &&, gramps, ., getFirstChild, (, ), ==, parent, ), {, return]
[., isCall, (, ), &&, gramps, ., getFirstChild, (, ), ==, parent, ), {, return, true, ;, }, }, return]
[(, Map, <, String, ,, FunctionState, >, fns, ,, Map, <, Node, ,, String, >, anonFns, ), {, super, (]
[<, String, ,, FunctionState, >, fns, ,, Map, <, Node, ,, String, >, anonFns, ), {, super, (, fns, ,]
[,, FunctionState, >, fns, ,, Map, <, Node, ,, String, >, anonFns, ), {, super, (, fns, ,, anonFns, ,]
[fns, ,, Map, <, Node, ,, String, >, anonFns, ), {, super, (, fns, ,, anonFns, ,, null, ), ;]
[fns, ,, Map, <, Node, ,, String, >, anonFns, ), {, super, (, fns, ,, anonFns, ,, null, ), ;]
[Node, ,, String, >, anonFns, ), {, super, (, fns, ,, anonFns, ,, null, ), ;, this, ., callback, =]
[=, this, ;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {]
[=, this, ;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {]
[@, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, super, ., visit, (]
[public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, super, ., visit, (, t, ,]
[visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, super, ., visit, (, t, ,, n, ,]
[Node, n, ,, Node, parent, ), {, super, ., visit, (, t, ,, n, ,, parent, ), ;, if, (]
[Node, n, ,, Node, parent, ), {, super, ., visit, (, t, ,, n, ,, parent, ), ;, if, (]
[super, ., visit, (, t, ,, n, ,, parent, ), ;, if, (, n, ., isName, (, ), ), {]
[visit, (, t, ,, n, ,, parent, ), ;, if, (, n, ., isName, (, ), ), {, checkNameUsage, (]
[t, ,, n, ,, parent, ), ;, if, (, n, ., isName, (, ), ), {, checkNameUsage, (, t, ,]
[n, ,, parent, ), ;, if, (, n, ., isName, (, ), ), {, checkNameUsage, (, t, ,, n, ,]
[}, @, Override, public, void, visitCallSite, (, NodeTraversal, t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {]
[Override, public, void, visitCallSite, (, NodeTraversal, t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {, maybeAddReference, (]
[void, visitCallSite, (, NodeTraversal, t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {, maybeAddReference, (, t, ,]
[(, NodeTraversal, t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {, maybeAddReference, (, t, ,, fs, ,]
[t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {, maybeAddReference, (, t, ,, fs, ,, callNode, ,]
[t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {, maybeAddReference, (, t, ,, fs, ,, callNode, ,]
[;, }, void, maybeAddReference, (, NodeTraversal, t, ,, FunctionState, fs, ,, Node, callNode, ,, JSModule, module, ), {, if, (]
[}, void, maybeAddReference, (, NodeTraversal, t, ,, FunctionState, fs, ,, Node, callNode, ,, JSModule, module, ), {, if, (, !]
[}, void, maybeAddReference, (, NodeTraversal, t, ,, FunctionState, fs, ,, Node, callNode, ,, JSModule, module, ), {, if, (, !]
[JSModule, module, ), {, if, (, !, fs, ., canInline, (, ), ), {, return, ;, }, boolean, referenceAdded, =]
[(, !, fs, ., canInline, (, ), ), {, return, ;, }, boolean, referenceAdded, =, false, ;, InliningMode, mode, =]
[(, !, fs, ., canInline, (, ), ), {, return, ;, }, boolean, referenceAdded, =, false, ;, InliningMode, mode, =]
[(, !, fs, ., canInline, (, ), ), {, return, ;, }, boolean, referenceAdded, =, false, ;, InliningMode, mode, =]
[), ), {, return, ;, }, boolean, referenceAdded, =, false, ;, InliningMode, mode, =, fs, ., canInlineDirectly, (, ), ?]
[), ), {, return, ;, }, boolean, referenceAdded, =, false, ;, InliningMode, mode, =, fs, ., canInlineDirectly, (, ), ?]
[;, }, boolean, referenceAdded, =, false, ;, InliningMode, mode, =, fs, ., canInlineDirectly, (, ), ?, InliningMode, ., DIRECT, :]
[;, }, boolean, referenceAdded, =, false, ;, InliningMode, mode, =, fs, ., canInlineDirectly, (, ), ?, InliningMode, ., DIRECT, :]
[=, false, ;, InliningMode, mode, =, fs, ., canInlineDirectly, (, ), ?, InliningMode, ., DIRECT, :, InliningMode, ., BLOCK, ;]
[;, InliningMode, mode, =, fs, ., canInlineDirectly, (, ), ?, InliningMode, ., DIRECT, :, InliningMode, ., BLOCK, ;, referenceAdded, =]
[mode, =, fs, ., canInlineDirectly, (, ), ?, InliningMode, ., DIRECT, :, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (]
[fs, ., canInlineDirectly, (, ), ?, InliningMode, ., DIRECT, :, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,]
[canInlineDirectly, (, ), ?, InliningMode, ., DIRECT, :, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,]
[), ?, InliningMode, ., DIRECT, :, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,]
[InliningMode, ., DIRECT, :, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,]
[., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, if, (]
[., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, if, (]
[., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, if, (]
[BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, if, (, !]
[referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, if, (, !, referenceAdded, &&]
[referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, if, (, !, referenceAdded, &&]
[maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, if, (, !, referenceAdded, &&, mode, ==]
[maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, if, (, !, referenceAdded, &&, mode, ==]
[fs, ,, callNode, ,, module, ,, mode, ), ;, if, (, !, referenceAdded, &&, mode, ==, InliningMode, ., DIRECT, &&]
[,, module, ,, mode, ), ;, if, (, !, referenceAdded, &&, mode, ==, InliningMode, ., DIRECT, &&, blockFunctionInliningEnabled, ), {]
[,, mode, ), ;, if, (, !, referenceAdded, &&, mode, ==, InliningMode, ., DIRECT, &&, blockFunctionInliningEnabled, ), {, mode, =]
[,, mode, ), ;, if, (, !, referenceAdded, &&, mode, ==, InliningMode, ., DIRECT, &&, blockFunctionInliningEnabled, ), {, mode, =]
[if, (, !, referenceAdded, &&, mode, ==, InliningMode, ., DIRECT, &&, blockFunctionInliningEnabled, ), {, mode, =, InliningMode, ., BLOCK, ;]
[!, referenceAdded, &&, mode, ==, InliningMode, ., DIRECT, &&, blockFunctionInliningEnabled, ), {, mode, =, InliningMode, ., BLOCK, ;, referenceAdded, =]
[&&, mode, ==, InliningMode, ., DIRECT, &&, blockFunctionInliningEnabled, ), {, mode, =, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (]
[==, InliningMode, ., DIRECT, &&, blockFunctionInliningEnabled, ), {, mode, =, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,]
[., DIRECT, &&, blockFunctionInliningEnabled, ), {, mode, =, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,]
[&&, blockFunctionInliningEnabled, ), {, mode, =, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,]
[), {, mode, =, InliningMode, ., BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,]
[BLOCK, ;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, }, if, (]
[;, referenceAdded, =, maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, }, if, (, !]
[maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, }, if, (, !, referenceAdded, ), {]
[maybeAddReferenceUsingMode, (, t, ,, fs, ,, callNode, ,, module, ,, mode, ), ;, }, if, (, !, referenceAdded, ), {]
[fs, ,, callNode, ,, module, ,, mode, ), ;, }, if, (, !, referenceAdded, ), {, fs, ., setRemove, (]
[maybeAddReferenceUsingMode, (, NodeTraversal, t, ,, FunctionState, fs, ,, Node, callNode, ,, JSModule, module, ,, InliningMode, mode, ), {, if, (]
[maybeAddReferenceUsingMode, (, NodeTraversal, t, ,, FunctionState, fs, ,, Node, callNode, ,, JSModule, module, ,, InliningMode, mode, ), {, if, (]
[NodeTraversal, t, ,, FunctionState, fs, ,, Node, callNode, ,, JSModule, module, ,, InliningMode, mode, ), {, if, (, specializationState, !=]
[Node, callNode, ,, JSModule, module, ,, InliningMode, mode, ), {, if, (, specializationState, !=, null, ), {, Node, containingFunction, =]
[,, JSModule, module, ,, InliningMode, mode, ), {, if, (, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (]
[mode, ), {, if, (, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (]
[mode, ), {, if, (, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (]
[mode, ), {, if, (, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (]
[{, if, (, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (, containingFunction, !=]
[(, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (, containingFunction, !=, null, &&]
[specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (, containingFunction, !=, null, &&, !]
[specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (, containingFunction, !=, null, &&, !]
[{, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (, containingFunction, !=, null, &&, !, specializationState, ., canFixupFunction, (]
[(, t, ), ;, if, (, containingFunction, !=, null, &&, !, specializationState, ., canFixupFunction, (, containingFunction, ), ), {, return]
[!=, null, &&, !, specializationState, ., canFixupFunction, (, containingFunction, ), ), {, return, false, ;, }, }, CanInlineResult, result, =]
[!=, null, &&, !, specializationState, ., canFixupFunction, (, containingFunction, ), ), {, return, false, ;, }, }, CanInlineResult, result, =]
[specializationState, ., canFixupFunction, (, containingFunction, ), ), {, return, false, ;, }, }, CanInlineResult, result, =, injector, ., canInlineReferenceToFunction, (]
[canFixupFunction, (, containingFunction, ), ), {, return, false, ;, }, }, CanInlineResult, result, =, injector, ., canInlineReferenceToFunction, (, t, ,]
[containingFunction, ), ), {, return, false, ;, }, }, CanInlineResult, result, =, injector, ., canInlineReferenceToFunction, (, t, ,, callNode, ,]
[containingFunction, ), ), {, return, false, ;, }, }, CanInlineResult, result, =, injector, ., canInlineReferenceToFunction, (, t, ,, callNode, ,]
[containingFunction, ), ), {, return, false, ;, }, }, CanInlineResult, result, =, injector, ., canInlineReferenceToFunction, (, t, ,, callNode, ,]
[result, =, injector, ., canInlineReferenceToFunction, (, t, ,, callNode, ,, fs, ., getFn, (, ), ., getFunctionNode, (, ), ,]
[result, =, injector, ., canInlineReferenceToFunction, (, t, ,, callNode, ,, fs, ., getFn, (, ), ., getFunctionNode, (, ), ,]
[t, ,, callNode, ,, fs, ., getFn, (, ), ., getFunctionNode, (, ), ,, fs, ., getNamesToAlias, (, ), ,]
[callNode, ,, fs, ., getFn, (, ), ., getFunctionNode, (, ), ,, fs, ., getNamesToAlias, (, ), ,, mode, ,]
[callNode, ,, fs, ., getFn, (, ), ., getFunctionNode, (, ), ,, fs, ., getNamesToAlias, (, ), ,, mode, ,]
[), ., getFunctionNode, (, ), ,, fs, ., getNamesToAlias, (, ), ,, mode, ,, fs, ., getReferencesThis, (, ), ,]
[), ., getFunctionNode, (, ), ,, fs, ., getNamesToAlias, (, ), ,, mode, ,, fs, ., getReferencesThis, (, ), ,]
[(, ), ,, mode, ,, fs, ., getReferencesThis, (, ), ,, fs, ., hasInnerFunctions, (, ), ), ;, if, (]
[(, ), ,, mode, ,, fs, ., getReferencesThis, (, ), ,, fs, ., hasInnerFunctions, (, ), ), ;, if, (]
[,, mode, ,, fs, ., getReferencesThis, (, ), ,, fs, ., hasInnerFunctions, (, ), ), ;, if, (, result, !=]
[,, mode, ,, fs, ., getReferencesThis, (, ), ,, fs, ., hasInnerFunctions, (, ), ), ;, if, (, result, !=]
[,, fs, ., hasInnerFunctions, (, ), ), ;, if, (, result, !=, CanInlineResult, ., NO, ), {, boolean, decompose, =]
[fs, ., hasInnerFunctions, (, ), ), ;, if, (, result, !=, CanInlineResult, ., NO, ), {, boolean, decompose, =, (]
[fs, ., hasInnerFunctions, (, ), ), ;, if, (, result, !=, CanInlineResult, ., NO, ), {, boolean, decompose, =, (]
[hasInnerFunctions, (, ), ), ;, if, (, result, !=, CanInlineResult, ., NO, ), {, boolean, decompose, =, (, result, ==]
[hasInnerFunctions, (, ), ), ;, if, (, result, !=, CanInlineResult, ., NO, ), {, boolean, decompose, =, (, result, ==]
[if, (, result, !=, CanInlineResult, ., NO, ), {, boolean, decompose, =, (, result, ==, CanInlineResult, ., AFTER_PREPARATION, ), ;]
[if, (, result, !=, CanInlineResult, ., NO, ), {, boolean, decompose, =, (, result, ==, CanInlineResult, ., AFTER_PREPARATION, ), ;]
[CanInlineResult, ., NO, ), {, boolean, decompose, =, (, result, ==, CanInlineResult, ., AFTER_PREPARATION, ), ;, fs, ., addReference, (]
[), {, boolean, decompose, =, (, result, ==, CanInlineResult, ., AFTER_PREPARATION, ), ;, fs, ., addReference, (, new, Reference, (]
[boolean, decompose, =, (, result, ==, CanInlineResult, ., AFTER_PREPARATION, ), ;, fs, ., addReference, (, new, Reference, (, callNode, ,]
[=, (, result, ==, CanInlineResult, ., AFTER_PREPARATION, ), ;, fs, ., addReference, (, new, Reference, (, callNode, ,, module, ,]
[result, ==, CanInlineResult, ., AFTER_PREPARATION, ), ;, fs, ., addReference, (, new, Reference, (, callNode, ,, module, ,, mode, ,]
[), ;, fs, ., addReference, (, new, Reference, (, callNode, ,, module, ,, mode, ,, decompose, ), ), ;, return]
[addReference, (, new, Reference, (, callNode, ,, module, ,, mode, ,, decompose, ), ), ;, return, true, ;, }, return]
[;, }, return, false, ;, }, private, void, checkNameUsage, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {]
[;, }, return, false, ;, }, private, void, checkNameUsage, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {]
[;, }, private, void, checkNameUsage, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, Preconditions, ., checkState, (]
[;, }, private, void, checkNameUsage, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, Preconditions, ., checkState, (]
[Node, n, ,, Node, parent, ), {, Preconditions, ., checkState, (, n, ., isName, (, ), ), ;, if, (]
[,, Node, parent, ), {, Preconditions, ., checkState, (, n, ., isName, (, ), ), ;, if, (, isCandidateUsage, (]
[., isName, (, ), ), ;, if, (, isCandidateUsage, (, n, ), ), {, return, ;, }, String, name, =]
[., isName, (, ), ), ;, if, (, isCandidateUsage, (, n, ), ), {, return, ;, }, String, name, =]
[(, n, ), ), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, FunctionState, fs, =]
[(, n, ), ), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, FunctionState, fs, =]
[{, return, ;, }, String, name, =, n, ., getString, (, ), ;, FunctionState, fs, =, fns, ., get, (]
[name, =, n, ., getString, (, ), ;, FunctionState, fs, =, fns, ., get, (, name, ), ;, if, (]
[name, =, n, ., getString, (, ), ;, FunctionState, fs, =, fns, ., get, (, name, ), ;, if, (]
[n, ., getString, (, ), ;, FunctionState, fs, =, fns, ., get, (, name, ), ;, if, (, fs, ==]
[=, fns, ., get, (, name, ), ;, if, (, fs, ==, null, ), {, return, ;, }, if, (]
[=, fns, ., get, (, name, ), ;, if, (, fs, ==, null, ), {, return, ;, }, if, (]
[fs, ==, null, ), {, return, ;, }, if, (, parent, ., isNew, (, ), ), {, Node, target, =]
[fs, ==, null, ), {, return, ;, }, if, (, parent, ., isNew, (, ), ), {, Node, target, =]
[if, (, parent, ., isNew, (, ), ), {, Node, target, =, parent, ., getFirstChild, (, ), ;, if, (]
[if, (, parent, ., isNew, (, ), ), {, Node, target, =, parent, ., getFirstChild, (, ), ;, if, (]
[if, (, parent, ., isNew, (, ), ), {, Node, target, =, parent, ., getFirstChild, (, ), ;, if, (]
[), ), {, Node, target, =, parent, ., getFirstChild, (, ), ;, if, (, target, ., isName, (, ), &&]
[), ), {, Node, target, =, parent, ., getFirstChild, (, ), ;, if, (, target, ., isName, (, ), &&]
[), ), {, Node, target, =, parent, ., getFirstChild, (, ), ;, if, (, target, ., isName, (, ), &&]
[getFirstChild, (, ), ;, if, (, target, ., isName, (, ), &&, target, ., getString, (, ), ., equals, (]
[getFirstChild, (, ), ;, if, (, target, ., isName, (, ), &&, target, ., getString, (, ), ., equals, (]
[target, ., isName, (, ), &&, target, ., getString, (, ), ., equals, (, ObjectPropertyStringPreprocess, ., EXTERN_OBJECT_PROPERTY_STRING, ), ), {]
[target, ., isName, (, ), &&, target, ., getString, (, ), ., equals, (, ObjectPropertyStringPreprocess, ., EXTERN_OBJECT_PROPERTY_STRING, ), ), {]
[), &&, target, ., getString, (, ), ., equals, (, ObjectPropertyStringPreprocess, ., EXTERN_OBJECT_PROPERTY_STRING, ), ), {, fs, ., setInline, (]
[., equals, (, ObjectPropertyStringPreprocess, ., EXTERN_OBJECT_PROPERTY_STRING, ), ), {, fs, ., setInline, (, false, ), ;, }, }, if, (]
[., equals, (, ObjectPropertyStringPreprocess, ., EXTERN_OBJECT_PROPERTY_STRING, ), ), {, fs, ., setInline, (, false, ), ;, }, }, if, (]
[., equals, (, ObjectPropertyStringPreprocess, ., EXTERN_OBJECT_PROPERTY_STRING, ), ), {, fs, ., setInline, (, false, ), ;, }, }, if, (]
[), ), {, fs, ., setInline, (, false, ), ;, }, }, if, (, parent, ., isAssign, (, ), &&]
[), ), {, fs, ., setInline, (, false, ), ;, }, }, if, (, parent, ., isAssign, (, ), &&]
[), ), {, fs, ., setInline, (, false, ), ;, }, }, if, (, parent, ., isAssign, (, ), &&]
[(, false, ), ;, }, }, if, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==]
[;, }, }, if, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), {]
[;, }, }, if, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), {]
[(, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), {, fs, ., setInline, (]
[&&, parent, ., getFirstChild, (, ), ==, n, ), {, fs, ., setInline, (, false, ), ;, }, else, {]
[&&, parent, ., getFirstChild, (, ), ==, n, ), {, fs, ., setInline, (, false, ), ;, }, else, {]
[(, ), ==, n, ), {, fs, ., setInline, (, false, ), ;, }, else, {, fs, ., setRemove, (]
[injector, ;, private, final, SpecializeModule, ., SpecializationState, specializationState, ;, Inline, (, FunctionInjector, injector, ,, SpecializeModule, ., SpecializationState, specializationState, ), {]
[injector, ;, private, final, SpecializeModule, ., SpecializationState, specializationState, ;, Inline, (, FunctionInjector, injector, ,, SpecializeModule, ., SpecializationState, specializationState, ), {]
[SpecializeModule, ., SpecializationState, specializationState, ;, Inline, (, FunctionInjector, injector, ,, SpecializeModule, ., SpecializationState, specializationState, ), {, this, ., injector, =]
[SpecializationState, specializationState, ;, Inline, (, FunctionInjector, injector, ,, SpecializeModule, ., SpecializationState, specializationState, ), {, this, ., injector, =, injector, ;]
[SpecializationState, specializationState, ;, Inline, (, FunctionInjector, injector, ,, SpecializeModule, ., SpecializationState, specializationState, ), {, this, ., injector, =, injector, ;]
[(, FunctionInjector, injector, ,, SpecializeModule, ., SpecializationState, specializationState, ), {, this, ., injector, =, injector, ;, this, ., specializationState, =]
[}, @, Override, public, void, visitCallSite, (, NodeTraversal, t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {]
[}, @, Override, public, void, visitCallSite, (, NodeTraversal, t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {]
[void, visitCallSite, (, NodeTraversal, t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {, Preconditions, ., checkState, (]
[void, visitCallSite, (, NodeTraversal, t, ,, Node, callNode, ,, Node, parent, ,, FunctionState, fs, ), {, Preconditions, ., checkState, (]
[Node, parent, ,, FunctionState, fs, ), {, Preconditions, ., checkState, (, fs, ., hasExistingFunctionDefinition, (, ), ), ;, if, (]
[Node, parent, ,, FunctionState, fs, ), {, Preconditions, ., checkState, (, fs, ., hasExistingFunctionDefinition, (, ), ), ;, if, (]
[(, fs, ., hasExistingFunctionDefinition, (, ), ), ;, if, (, fs, ., canInline, (, ), ), {, Reference, ref, =]
[(, fs, ., hasExistingFunctionDefinition, (, ), ), ;, if, (, fs, ., canInline, (, ), ), {, Reference, ref, =]
[(, ), ), ;, if, (, fs, ., canInline, (, ), ), {, Reference, ref, =, fs, ., getReference, (]
[(, fs, ., canInline, (, ), ), {, Reference, ref, =, fs, ., getReference, (, callNode, ), ;, if, (]
[(, fs, ., canInline, (, ), ), {, Reference, ref, =, fs, ., getReference, (, callNode, ), ;, if, (]
[., canInline, (, ), ), {, Reference, ref, =, fs, ., getReference, (, callNode, ), ;, if, (, ref, !=]
[{, Reference, ref, =, fs, ., getReference, (, callNode, ), ;, if, (, ref, !=, null, ), {, if, (]
[{, Reference, ref, =, fs, ., getReference, (, callNode, ), ;, if, (, ref, !=, null, ), {, if, (]
[ref, =, fs, ., getReference, (, callNode, ), ;, if, (, ref, !=, null, ), {, if, (, specializationState, !=]
[callNode, ), ;, if, (, ref, !=, null, ), {, if, (, specializationState, !=, null, ), {, Node, containingFunction, =]
[;, if, (, ref, !=, null, ), {, if, (, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (]
[null, ), {, if, (, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (]
[null, ), {, if, (, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (]
[{, if, (, specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (, containingFunction, !=]
[specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (, containingFunction, !=, null, ), {]
[specializationState, !=, null, ), {, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (, containingFunction, !=, null, ), {]
[{, Node, containingFunction, =, getContainingFunction, (, t, ), ;, if, (, containingFunction, !=, null, ), {, specializationState, ., reportSpecializedFunction, (]
[(, t, ), ;, if, (, containingFunction, !=, null, ), {, specializationState, ., reportSpecializedFunction, (, containingFunction, ), ;, }, }]
[), ;, if, (, containingFunction, !=, null, ), {, specializationState, ., reportSpecializedFunction, (, containingFunction, ), ;, }, }, inlineFunction, (]
[if, (, containingFunction, !=, null, ), {, specializationState, ., reportSpecializedFunction, (, containingFunction, ), ;, }, }, inlineFunction, (, t, ,]
[containingFunction, !=, null, ), {, specializationState, ., reportSpecializedFunction, (, containingFunction, ), ;, }, }, inlineFunction, (, t, ,, callNode, ,]
[null, ), {, specializationState, ., reportSpecializedFunction, (, containingFunction, ), ;, }, }, inlineFunction, (, t, ,, callNode, ,, fs, ,]
[null, ), {, specializationState, ., reportSpecializedFunction, (, containingFunction, ), ;, }, }, inlineFunction, (, t, ,, callNode, ,, fs, ,]
[reportSpecializedFunction, (, containingFunction, ), ;, }, }, inlineFunction, (, t, ,, callNode, ,, fs, ,, ref, ., mode, ), ;]
[reportSpecializedFunction, (, containingFunction, ), ;, }, }, inlineFunction, (, t, ,, callNode, ,, fs, ,, ref, ., mode, ), ;]
[;, }, }, inlineFunction, (, t, ,, callNode, ,, fs, ,, ref, ., mode, ), ;, ref, ., inlined, =]
[private, void, inlineFunction, (, NodeTraversal, t, ,, Node, callNode, ,, FunctionState, fs, ,, InliningMode, mode, ), {, Function, fn, =]
[private, void, inlineFunction, (, NodeTraversal, t, ,, Node, callNode, ,, FunctionState, fs, ,, InliningMode, mode, ), {, Function, fn, =]
[,, FunctionState, fs, ,, InliningMode, mode, ), {, Function, fn, =, fs, ., getFn, (, ), ;, String, fnName, =]
[,, FunctionState, fs, ,, InliningMode, mode, ), {, Function, fn, =, fs, ., getFn, (, ), ;, String, fnName, =]
[fn, =, fs, ., getFn, (, ), ;, String, fnName, =, fn, ., getName, (, ), ;, Node, fnNode, =]
[fn, =, fs, ., getFn, (, ), ;, String, fnName, =, fn, ., getName, (, ), ;, Node, fnNode, =]
[fnName, =, fn, ., getName, (, ), ;, Node, fnNode, =, fs, ., getSafeFnNode, (, ), ;, Node, newCode, =]
[fnName, =, fn, ., getName, (, ), ;, Node, fnNode, =, fs, ., getSafeFnNode, (, ), ;, Node, newCode, =]
[getName, (, ), ;, Node, fnNode, =, fs, ., getSafeFnNode, (, ), ;, Node, newCode, =, injector, ., inline, (]
[), ;, Node, fnNode, =, fs, ., getSafeFnNode, (, ), ;, Node, newCode, =, injector, ., inline, (, t, ,]
[Node, fnNode, =, fs, ., getSafeFnNode, (, ), ;, Node, newCode, =, injector, ., inline, (, t, ,, callNode, ,]
[=, fs, ., getSafeFnNode, (, ), ;, Node, newCode, =, injector, ., inline, (, t, ,, callNode, ,, fnName, ,]
[., getSafeFnNode, (, ), ;, Node, newCode, =, injector, ., inline, (, t, ,, callNode, ,, fnName, ,, fnNode, ,]
[), ;, Node, newCode, =, injector, ., inline, (, t, ,, callNode, ,, fnName, ,, fnNode, ,, mode, ), ;]
[), ;, Node, newCode, =, injector, ., inline, (, t, ,, callNode, ,, fnName, ,, fnNode, ,, mode, ), ;]
[), ;, Node, newCode, =, injector, ., inline, (, t, ,, callNode, ,, fnName, ,, fnNode, ,, mode, ), ;]
[,, callNode, ,, fnName, ,, fnNode, ,, mode, ), ;, t, ., getCompiler, (, ), ., reportCodeChange, (, ), ;]
[,, callNode, ,, fnName, ,, fnNode, ,, mode, ), ;, t, ., getCompiler, (, ), ., reportCodeChange, (, ), ;]
[,, callNode, ,, fnName, ,, fnNode, ,, mode, ), ;, t, ., getCompiler, (, ), ., reportCodeChange, (, ), ;]
[), ;, t, ., getCompiler, (, ), ., reportCodeChange, (, ), ;, t, ., getCompiler, (, ), ., addToDebugLog, (]
[), ;, t, ., getCompiler, (, ), ., reportCodeChange, (, ), ;, t, ., getCompiler, (, ), ., addToDebugLog, (]
[t, ., getCompiler, (, ), ., reportCodeChange, (, ), ;, t, ., getCompiler, (, ), ., addToDebugLog, (, "Inlined function: ", +]
[t, ., getCompiler, (, ), ., reportCodeChange, (, ), ;, t, ., getCompiler, (, ), ., addToDebugLog, (, "Inlined function: ", +]
[}, private, void, trimCanidatesNotMeetingMinimumRequirements, (, ), {, Iterator, <, Entry, <, String, ,, FunctionState, >, >, i, ;, for, (]
[void, trimCanidatesNotMeetingMinimumRequirements, (, ), {, Iterator, <, Entry, <, String, ,, FunctionState, >, >, i, ;, for, (, i, =]
[void, trimCanidatesNotMeetingMinimumRequirements, (, ), {, Iterator, <, Entry, <, String, ,, FunctionState, >, >, i, ;, for, (, i, =]
[void, trimCanidatesNotMeetingMinimumRequirements, (, ), {, Iterator, <, Entry, <, String, ,, FunctionState, >, >, i, ;, for, (, i, =]
[,, FunctionState, >, >, i, ;, for, (, i, =, fns, ., entrySet, (, ), ., iterator, (, ), ;]
[,, FunctionState, >, >, i, ;, for, (, i, =, fns, ., entrySet, (, ), ., iterator, (, ), ;]
[., entrySet, (, ), ., iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, FunctionState, fs, =]
[., entrySet, (, ), ., iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, FunctionState, fs, =]
[., entrySet, (, ), ., iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, FunctionState, fs, =]
[(, ), ;, ), {, FunctionState, fs, =, i, ., next, (, ), ., getValue, (, ), ;, if, (]
[(, ), ;, ), {, FunctionState, fs, =, i, ., next, (, ), ., getValue, (, ), ;, if, (]
[), ;, ), {, FunctionState, fs, =, i, ., next, (, ), ., getValue, (, ), ;, if, (, !]
[), ;, ), {, FunctionState, fs, =, i, ., next, (, ), ., getValue, (, ), ;, if, (, !]
[=, i, ., next, (, ), ., getValue, (, ), ;, if, (, !, fs, ., hasExistingFunctionDefinition, (, ), ||]
[i, ., next, (, ), ., getValue, (, ), ;, if, (, !, fs, ., hasExistingFunctionDefinition, (, ), ||, !]
[i, ., next, (, ), ., getValue, (, ), ;, if, (, !, fs, ., hasExistingFunctionDefinition, (, ), ||, !]
[(, ), ;, if, (, !, fs, ., hasExistingFunctionDefinition, (, ), ||, !, fs, ., canInline, (, ), ), {]
[(, ), ;, if, (, !, fs, ., hasExistingFunctionDefinition, (, ), ||, !, fs, ., canInline, (, ), ), {]
[}, }, void, trimCanidatesUsingOnCost, (, ), {, Iterator, <, Entry, <, String, ,, FunctionState, >, >, i, ;, for, (]
[void, trimCanidatesUsingOnCost, (, ), {, Iterator, <, Entry, <, String, ,, FunctionState, >, >, i, ;, for, (, i, =]
[void, trimCanidatesUsingOnCost, (, ), {, Iterator, <, Entry, <, String, ,, FunctionState, >, >, i, ;, for, (, i, =]
[void, trimCanidatesUsingOnCost, (, ), {, Iterator, <, Entry, <, String, ,, FunctionState, >, >, i, ;, for, (, i, =]
[,, FunctionState, >, >, i, ;, for, (, i, =, fns, ., entrySet, (, ), ., iterator, (, ), ;]
[,, FunctionState, >, >, i, ;, for, (, i, =, fns, ., entrySet, (, ), ., iterator, (, ), ;]
[., entrySet, (, ), ., iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, FunctionState, fs, =]
[., entrySet, (, ), ., iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, FunctionState, fs, =]
[., entrySet, (, ), ., iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, FunctionState, fs, =]
[(, ), ;, ), {, FunctionState, fs, =, i, ., next, (, ), ., getValue, (, ), ;, if, (]
[(, ), ;, ), {, FunctionState, fs, =, i, ., next, (, ), ., getValue, (, ), ;, if, (]
[next, (, ), ., getValue, (, ), ;, if, (, fs, ., hasReferences, (, ), ), {, boolean, lowersCost, =]
[), ., getValue, (, ), ;, if, (, fs, ., hasReferences, (, ), ), {, boolean, lowersCost, =, mimimizeCost, (]
[;, if, (, fs, ., hasReferences, (, ), ), {, boolean, lowersCost, =, mimimizeCost, (, fs, ), ;, if, (]
[if, (, fs, ., hasReferences, (, ), ), {, boolean, lowersCost, =, mimimizeCost, (, fs, ), ;, if, (, !]
[., hasReferences, (, ), ), {, boolean, lowersCost, =, mimimizeCost, (, fs, ), ;, if, (, !, lowersCost, ), {]
[., hasReferences, (, ), ), {, boolean, lowersCost, =, mimimizeCost, (, fs, ), ;, if, (, !, lowersCost, ), {]
[fs, ), ;, if, (, !, lowersCost, ), {, i, ., remove, (, ), ;, }, }, else, if, (]
[), ;, if, (, !, lowersCost, ), {, i, ., remove, (, ), ;, }, }, else, if, (, !]
[), ;, if, (, !, lowersCost, ), {, i, ., remove, (, ), ;, }, }, else, if, (, !]
[{, i, ., remove, (, ), ;, }, }, else, if, (, !, fs, ., canRemove, (, ), ), {]
[{, i, ., remove, (, ), ;, }, }, else, if, (, !, fs, ., canRemove, (, ), ), {]
[{, i, ., remove, (, ), ;, }, }, }, private, boolean, mimimizeCost, (, FunctionState, fs, ), {, if, (]
[i, ., remove, (, ), ;, }, }, }, private, boolean, mimimizeCost, (, FunctionState, fs, ), {, if, (, !]
[remove, (, ), ;, }, }, }, private, boolean, mimimizeCost, (, FunctionState, fs, ), {, if, (, !, inliningLowersCost, (]
[}, private, boolean, mimimizeCost, (, FunctionState, fs, ), {, if, (, !, inliningLowersCost, (, fs, ), ), {, if, (]
[}, private, boolean, mimimizeCost, (, FunctionState, fs, ), {, if, (, !, inliningLowersCost, (, fs, ), ), {, if, (]
[), {, if, (, !, inliningLowersCost, (, fs, ), ), {, if, (, fs, ., hasBlockInliningReferences, (, ), ), {]
[), {, if, (, !, inliningLowersCost, (, fs, ), ), {, if, (, fs, ., hasBlockInliningReferences, (, ), ), {]
[!, inliningLowersCost, (, fs, ), ), {, if, (, fs, ., hasBlockInliningReferences, (, ), ), {, fs, ., setRemove, (]
[fs, ), ), {, if, (, fs, ., hasBlockInliningReferences, (, ), ), {, fs, ., setRemove, (, false, ), ;]
[fs, ), ), {, if, (, fs, ., hasBlockInliningReferences, (, ), ), {, fs, ., setRemove, (, false, ), ;]
[hasBlockInliningReferences, (, ), ), {, fs, ., setRemove, (, false, ), ;, fs, ., removeBlockInliningReferences, (, ), ;, if, (]
[hasBlockInliningReferences, (, ), ), {, fs, ., setRemove, (, false, ), ;, fs, ., removeBlockInliningReferences, (, ), ;, if, (]
[(, ), ), {, fs, ., setRemove, (, false, ), ;, fs, ., removeBlockInliningReferences, (, ), ;, if, (, !]
[(, ), ), {, fs, ., setRemove, (, false, ), ;, fs, ., removeBlockInliningReferences, (, ), ;, if, (, !]
[setRemove, (, false, ), ;, fs, ., removeBlockInliningReferences, (, ), ;, if, (, !, fs, ., hasReferences, (, ), ||]
[(, false, ), ;, fs, ., removeBlockInliningReferences, (, ), ;, if, (, !, fs, ., hasReferences, (, ), ||, !]
[), ;, fs, ., removeBlockInliningReferences, (, ), ;, if, (, !, fs, ., hasReferences, (, ), ||, !, inliningLowersCost, (]
[(, ), ;, if, (, !, fs, ., hasReferences, (, ), ||, !, inliningLowersCost, (, fs, ), ), {, return]
[., hasReferences, (, ), ||, !, inliningLowersCost, (, fs, ), ), {, return, false, ;, }, }, else, {, return]
[!, inliningLowersCost, (, fs, ), ), {, return, false, ;, }, }, else, {, return, false, ;, }, }, return]
[else, {, return, false, ;, }, }, return, true, ;, }, private, boolean, inliningLowersCost, (, FunctionState, fs, ), {, return]
[else, {, return, false, ;, }, }, return, true, ;, }, private, boolean, inliningLowersCost, (, FunctionState, fs, ), {, return]
[;, }, }, return, true, ;, }, private, boolean, inliningLowersCost, (, FunctionState, fs, ), {, return, injector, ., inliningLowersCost, (]
[;, }, }, return, true, ;, }, private, boolean, inliningLowersCost, (, FunctionState, fs, ), {, return, injector, ., inliningLowersCost, (]
[}, private, boolean, inliningLowersCost, (, FunctionState, fs, ), {, return, injector, ., inliningLowersCost, (, fs, ., getModule, (, ), ,]
[}, private, boolean, inliningLowersCost, (, FunctionState, fs, ), {, return, injector, ., inliningLowersCost, (, fs, ., getModule, (, ), ,]
[}, private, boolean, inliningLowersCost, (, FunctionState, fs, ), {, return, injector, ., inliningLowersCost, (, fs, ., getModule, (, ), ,]
[injector, ., inliningLowersCost, (, fs, ., getModule, (, ), ,, fs, ., getFn, (, ), ., getFunctionNode, (, ), ,]
[injector, ., inliningLowersCost, (, fs, ., getModule, (, ), ,, fs, ., getFn, (, ), ., getFunctionNode, (, ), ,]
[getModule, (, ), ,, fs, ., getFn, (, ), ., getFunctionNode, (, ), ,, fs, ., getReferences, (, ), ,]
[getModule, (, ), ,, fs, ., getFn, (, ), ., getFunctionNode, (, ), ,, fs, ., getReferences, (, ), ,]
[getFn, (, ), ., getFunctionNode, (, ), ,, fs, ., getReferences, (, ), ,, fs, ., getNamesToAlias, (, ), ,]
[getFn, (, ), ., getFunctionNode, (, ), ,, fs, ., getReferences, (, ), ,, fs, ., getNamesToAlias, (, ), ,]
[), ,, fs, ., getReferences, (, ), ,, fs, ., getNamesToAlias, (, ), ,, fs, ., canRemove, (, ), ,]
[), ,, fs, ., getReferences, (, ), ,, fs, ., getNamesToAlias, (, ), ,, fs, ., canRemove, (, ), ,]
[,, fs, ., getReferencesThis, (, ), ), ;, }, private, void, resolveInlineConflicts, (, ), {, for, (, FunctionState, fs, :]
[,, fs, ., getReferencesThis, (, ), ), ;, }, private, void, resolveInlineConflicts, (, ), {, for, (, FunctionState, fs, :]
[;, }, private, void, resolveInlineConflicts, (, ), {, for, (, FunctionState, fs, :, fns, ., values, (, ), ), {]
[private, void, resolveInlineConflicts, (, ), {, for, (, FunctionState, fs, :, fns, ., values, (, ), ), {, resolveInlineConflictsForFunction, (]
[), ), {, resolveInlineConflictsForFunction, (, fs, ), ;, }, }, private, void, resolveInlineConflictsForFunction, (, FunctionState, fs, ), {, if, (]
[), ), {, resolveInlineConflictsForFunction, (, fs, ), ;, }, }, private, void, resolveInlineConflictsForFunction, (, FunctionState, fs, ), {, if, (]
[), {, resolveInlineConflictsForFunction, (, fs, ), ;, }, }, private, void, resolveInlineConflictsForFunction, (, FunctionState, fs, ), {, if, (, !]
[), {, resolveInlineConflictsForFunction, (, fs, ), ;, }, }, private, void, resolveInlineConflictsForFunction, (, FunctionState, fs, ), {, if, (, !]
[;, }, }, private, void, resolveInlineConflictsForFunction, (, FunctionState, fs, ), {, if, (, !, fs, ., hasReferences, (, ), ||]
[}, }, private, void, resolveInlineConflictsForFunction, (, FunctionState, fs, ), {, if, (, !, fs, ., hasReferences, (, ), ||, !]
[}, }, private, void, resolveInlineConflictsForFunction, (, FunctionState, fs, ), {, if, (, !, fs, ., hasReferences, (, ), ||, !]
[fs, ., hasReferences, (, ), ||, !, fs, ., canInline, (, ), ), {, return, ;, }, Node, fnNode, =]
[fs, ., hasReferences, (, ), ||, !, fs, ., canInline, (, ), ), {, return, ;, }, Node, fnNode, =]
[fs, ., hasReferences, (, ), ||, !, fs, ., canInline, (, ), ), {, return, ;, }, Node, fnNode, =]
[}, Node, fnNode, =, fs, ., getFn, (, ), ., getFunctionNode, (, ), ;, Set, <, String, >, names, =]
[fnNode, =, fs, ., getFn, (, ), ., getFunctionNode, (, ), ;, Set, <, String, >, names, =, findCalledFunctions, (]
[(, ), ., getFunctionNode, (, ), ;, Set, <, String, >, names, =, findCalledFunctions, (, fnNode, ), ;, if, (]
[), ., getFunctionNode, (, ), ;, Set, <, String, >, names, =, findCalledFunctions, (, fnNode, ), ;, if, (, !]
[), ., getFunctionNode, (, ), ;, Set, <, String, >, names, =, findCalledFunctions, (, fnNode, ), ;, if, (, !]
[findCalledFunctions, (, fnNode, ), ;, if, (, !, names, ., isEmpty, (, ), ), {, for, (, String, name, :]
[(, !, names, ., isEmpty, (, ), ), {, for, (, String, name, :, names, ), {, FunctionState, fsCalled, =]
[(, !, names, ., isEmpty, (, ), ), {, for, (, String, name, :, names, ), {, FunctionState, fsCalled, =]
[isEmpty, (, ), ), {, for, (, String, name, :, names, ), {, FunctionState, fsCalled, =, fns, ., get, (]
[for, (, String, name, :, names, ), {, FunctionState, fsCalled, =, fns, ., get, (, name, ), ;, if, (]
[for, (, String, name, :, names, ), {, FunctionState, fsCalled, =, fns, ., get, (, name, ), ;, if, (]
[for, (, String, name, :, names, ), {, FunctionState, fsCalled, =, fns, ., get, (, name, ), ;, if, (]
[String, name, :, names, ), {, FunctionState, fsCalled, =, fns, ., get, (, name, ), ;, if, (, fsCalled, !=]
[:, names, ), {, FunctionState, fsCalled, =, fns, ., get, (, name, ), ;, if, (, fsCalled, !=, null, &&]
[:, names, ), {, FunctionState, fsCalled, =, fns, ., get, (, name, ), ;, if, (, fsCalled, !=, null, &&]
[fns, ., get, (, name, ), ;, if, (, fsCalled, !=, null, &&, fsCalled, ., canRemove, (, ), ), {]
[fns, ., get, (, name, ), ;, if, (, fsCalled, !=, null, &&, fsCalled, ., canRemove, (, ), ), {]
[name, ), ;, if, (, fsCalled, !=, null, &&, fsCalled, ., canRemove, (, ), ), {, fsCalled, ., setRemove, (]
[fsCalled, !=, null, &&, fsCalled, ., canRemove, (, ), ), {, fsCalled, ., setRemove, (, false, ), ;, if, (]
[!=, null, &&, fsCalled, ., canRemove, (, ), ), {, fsCalled, ., setRemove, (, false, ), ;, if, (, !]
[&&, fsCalled, ., canRemove, (, ), ), {, fsCalled, ., setRemove, (, false, ), ;, if, (, !, mimimizeCost, (]
[(, ), ), {, fsCalled, ., setRemove, (, false, ), ;, if, (, !, mimimizeCost, (, fsCalled, ), ), {]
[(, ), ), {, fsCalled, ., setRemove, (, false, ), ;, if, (, !, mimimizeCost, (, fsCalled, ), ), {]
[fsCalled, ., setRemove, (, false, ), ;, if, (, !, mimimizeCost, (, fsCalled, ), ), {, fsCalled, ., setInline, (]
[;, if, (, !, mimimizeCost, (, fsCalled, ), ), {, fsCalled, ., setInline, (, false, ), ;, }, }, }]
[;, if, (, !, mimimizeCost, (, fsCalled, ), ), {, fsCalled, ., setInline, (, false, ), ;, }, }, }]
[mimimizeCost, (, fsCalled, ), ), {, fsCalled, ., setInline, (, false, ), ;, }, }, }, fs, ., setSafeFnNode, (]
[mimimizeCost, (, fsCalled, ), ), {, fsCalled, ., setInline, (, false, ), ;, }, }, }, fs, ., setSafeFnNode, (]
[mimimizeCost, (, fsCalled, ), ), {, fsCalled, ., setInline, (, false, ), ;, }, }, }, fs, ., setSafeFnNode, (]
[mimimizeCost, (, fsCalled, ), ), {, fsCalled, ., setInline, (, false, ), ;, }, }, }, fs, ., setSafeFnNode, (]
[;, }, }, private, Set, <, String, >, findCalledFunctions, (, Node, node, ), {, Set, <, String, >, changed, =]
[;, }, }, private, Set, <, String, >, findCalledFunctions, (, Node, node, ), {, Set, <, String, >, changed, =]
[String, >, findCalledFunctions, (, Node, node, ), {, Set, <, String, >, changed, =, Sets, ., newHashSet, (, ), ;]
[findCalledFunctions, (, Node, node, ), {, Set, <, String, >, changed, =, Sets, ., newHashSet, (, ), ;, findCalledFunctions, (]
[findCalledFunctions, (, Node, node, ), {, Set, <, String, >, changed, =, Sets, ., newHashSet, (, ), ;, findCalledFunctions, (]
[), {, Set, <, String, >, changed, =, Sets, ., newHashSet, (, ), ;, findCalledFunctions, (, NodeUtil, ., getFunctionBody, (]
[<, String, >, changed, =, Sets, ., newHashSet, (, ), ;, findCalledFunctions, (, NodeUtil, ., getFunctionBody, (, node, ), ,]
[=, Sets, ., newHashSet, (, ), ;, findCalledFunctions, (, NodeUtil, ., getFunctionBody, (, node, ), ,, changed, ), ;, return]
[), ;, return, changed, ;, }, private, void, findCalledFunctions, (, Node, node, ,, Set, <, String, >, changed, ), {]
[), ;, return, changed, ;, }, private, void, findCalledFunctions, (, Node, node, ,, Set, <, String, >, changed, ), {]
[;, }, private, void, findCalledFunctions, (, Node, node, ,, Set, <, String, >, changed, ), {, Preconditions, ., checkArgument, (]
[;, }, private, void, findCalledFunctions, (, Node, node, ,, Set, <, String, >, changed, ), {, Preconditions, ., checkArgument, (]
[private, void, findCalledFunctions, (, Node, node, ,, Set, <, String, >, changed, ), {, Preconditions, ., checkArgument, (, changed, !=]
[node, ,, Set, <, String, >, changed, ), {, Preconditions, ., checkArgument, (, changed, !=, null, ), ;, if, (]
[node, ,, Set, <, String, >, changed, ), {, Preconditions, ., checkArgument, (, changed, !=, null, ), ;, if, (]
[Preconditions, ., checkArgument, (, changed, !=, null, ), ;, if, (, node, ., isName, (, ), ), {, if, (]
[checkArgument, (, changed, !=, null, ), ;, if, (, node, ., isName, (, ), ), {, if, (, isCandidateUsage, (]
[null, ), ;, if, (, node, ., isName, (, ), ), {, if, (, isCandidateUsage, (, node, ), ), {]
[null, ), ;, if, (, node, ., isName, (, ), ), {, if, (, isCandidateUsage, (, node, ), ), {]
[(, node, ., isName, (, ), ), {, if, (, isCandidateUsage, (, node, ), ), {, changed, ., add, (]
[(, node, ., isName, (, ), ), {, if, (, isCandidateUsage, (, node, ), ), {, changed, ., add, (]
[), {, changed, ., add, (, node, ., getString, (, ), ), ;, }, }, for, (, Node, c, =]
[), {, changed, ., add, (, node, ., getString, (, ), ), ;, }, }, for, (, Node, c, =]
[node, ., getString, (, ), ), ;, }, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;]
[node, ., getString, (, ), ), ;, }, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;]
[getString, (, ), ), ;, }, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=]
[), ), ;, }, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;]
[;, }, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[;, }, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[=, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, findCalledFunctions, (]
[(, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, findCalledFunctions, (, c, ,]
[,, changed, ), ;, }, }, private, void, decomposeExpressions, (, Set, <, String, >, fnNames, ), {, ExpressionDecomposer, decomposer, =]
[;, }, }, private, void, decomposeExpressions, (, Set, <, String, >, fnNames, ), {, ExpressionDecomposer, decomposer, =, new, ExpressionDecomposer, (]
[}, private, void, decomposeExpressions, (, Set, <, String, >, fnNames, ), {, ExpressionDecomposer, decomposer, =, new, ExpressionDecomposer, (, compiler, ,]
[}, private, void, decomposeExpressions, (, Set, <, String, >, fnNames, ), {, ExpressionDecomposer, decomposer, =, new, ExpressionDecomposer, (, compiler, ,]
[<, String, >, fnNames, ), {, ExpressionDecomposer, decomposer, =, new, ExpressionDecomposer, (, compiler, ,, compiler, ., getUniqueNameIdSupplier, (, ), ,]
[=, new, ExpressionDecomposer, (, compiler, ,, compiler, ., getUniqueNameIdSupplier, (, ), ,, fnNames, ), ;, for, (, FunctionState, fs, :]
[=, new, ExpressionDecomposer, (, compiler, ,, compiler, ., getUniqueNameIdSupplier, (, ), ,, fnNames, ), ;, for, (, FunctionState, fs, :]
[(, ), ,, fnNames, ), ;, for, (, FunctionState, fs, :, fns, ., values, (, ), ), {, if, (]
[(, ), ,, fnNames, ), ;, for, (, FunctionState, fs, :, fns, ., values, (, ), ), {, if, (]
[., values, (, ), ), {, if, (, fs, ., canInline, (, ), ), {, for, (, Reference, ref, :]
[., values, (, ), ), {, if, (, fs, ., canInline, (, ), ), {, for, (, Reference, ref, :]
[., canInline, (, ), ), {, for, (, Reference, ref, :, fs, ., getReferences, (, ), ), {, if, (]
[., canInline, (, ), ), {, for, (, Reference, ref, :, fs, ., getReferences, (, ), ), {, if, (]
[{, for, (, Reference, ref, :, fs, ., getReferences, (, ), ), {, if, (, ref, ., requiresDecomposition, ), {]
[{, for, (, Reference, ref, :, fs, ., getReferences, (, ), ), {, if, (, ref, ., requiresDecomposition, ), {]
[ref, :, fs, ., getReferences, (, ), ), {, if, (, ref, ., requiresDecomposition, ), {, injector, ., maybePrepareCall, (]
[ref, :, fs, ., getReferences, (, ), ), {, if, (, ref, ., requiresDecomposition, ), {, injector, ., maybePrepareCall, (]
[ref, ., callNode, ), ;, }, }, }, }, }, void, removeInlinedFunctions, (, ), {, for, (, FunctionState, fs, :]
[ref, ., callNode, ), ;, }, }, }, }, }, void, removeInlinedFunctions, (, ), {, for, (, FunctionState, fs, :]
[}, void, removeInlinedFunctions, (, ), {, for, (, FunctionState, fs, :, fns, ., values, (, ), ), {, if, (]
[}, void, removeInlinedFunctions, (, ), {, for, (, FunctionState, fs, :, fns, ., values, (, ), ), {, if, (]
[:, fns, ., values, (, ), ), {, if, (, fs, ., canRemove, (, ), ), {, Function, fn, =]
[:, fns, ., values, (, ), ), {, if, (, fs, ., canRemove, (, ), ), {, Function, fn, =]
[), {, if, (, fs, ., canRemove, (, ), ), {, Function, fn, =, fs, ., getFn, (, ), ;]
[), {, if, (, fs, ., canRemove, (, ), ), {, Function, fn, =, fs, ., getFn, (, ), ;]
[fs, ., canRemove, (, ), ), {, Function, fn, =, fs, ., getFn, (, ), ;, Preconditions, ., checkState, (]
[fs, ., canRemove, (, ), ), {, Function, fn, =, fs, ., getFn, (, ), ;, Preconditions, ., checkState, (]
[Function, fn, =, fs, ., getFn, (, ), ;, Preconditions, ., checkState, (, fs, ., canInline, (, ), ), ;]
[Function, fn, =, fs, ., getFn, (, ), ;, Preconditions, ., checkState, (, fs, ., canInline, (, ), ), ;]
[., getFn, (, ), ;, Preconditions, ., checkState, (, fs, ., canInline, (, ), ), ;, Preconditions, ., checkState, (]
[., getFn, (, ), ;, Preconditions, ., checkState, (, fs, ., canInline, (, ), ), ;, Preconditions, ., checkState, (]
[(, ), ;, Preconditions, ., checkState, (, fs, ., canInline, (, ), ), ;, Preconditions, ., checkState, (, fn, !=]
[Preconditions, ., checkState, (, fs, ., canInline, (, ), ), ;, Preconditions, ., checkState, (, fn, !=, null, ), ;]
[checkState, (, fs, ., canInline, (, ), ), ;, Preconditions, ., checkState, (, fn, !=, null, ), ;, verifyAllReferencesInlined, (]
[(, ), ), ;, Preconditions, ., checkState, (, fn, !=, null, ), ;, verifyAllReferencesInlined, (, fs, ), ;, if, (]
[(, ), ), ;, Preconditions, ., checkState, (, fn, !=, null, ), ;, verifyAllReferencesInlined, (, fs, ), ;, if, (]
[), ;, Preconditions, ., checkState, (, fn, !=, null, ), ;, verifyAllReferencesInlined, (, fs, ), ;, if, (, specializationState, !=]
[., checkState, (, fn, !=, null, ), ;, verifyAllReferencesInlined, (, fs, ), ;, if, (, specializationState, !=, null, ), {]
[., checkState, (, fn, !=, null, ), ;, verifyAllReferencesInlined, (, fs, ), ;, if, (, specializationState, !=, null, ), {]
[!=, null, ), ;, verifyAllReferencesInlined, (, fs, ), ;, if, (, specializationState, !=, null, ), {, specializationState, ., reportRemovedFunction, (]
[!=, null, ), ;, verifyAllReferencesInlined, (, fs, ), ;, if, (, specializationState, !=, null, ), {, specializationState, ., reportRemovedFunction, (]
[fs, ), ;, if, (, specializationState, !=, null, ), {, specializationState, ., reportRemovedFunction, (, fn, ., getFunctionNode, (, ), ,]
[fs, ), ;, if, (, specializationState, !=, null, ), {, specializationState, ., reportRemovedFunction, (, fn, ., getFunctionNode, (, ), ,]
[), {, specializationState, ., reportRemovedFunction, (, fn, ., getFunctionNode, (, ), ,, fn, ., getDeclaringBlock, (, ), ), ;, }]
[), {, specializationState, ., reportRemovedFunction, (, fn, ., getFunctionNode, (, ), ,, fn, ., getDeclaringBlock, (, ), ), ;, }]
[fn, ., getFunctionNode, (, ), ,, fn, ., getDeclaringBlock, (, ), ), ;, }, fn, ., remove, (, ), ;]
[fn, ., getFunctionNode, (, ), ,, fn, ., getDeclaringBlock, (, ), ), ;, }, fn, ., remove, (, ), ;]
[., reportCodeChange, (, ), ;, }, }, }, void, verifyAllReferencesInlined, (, FunctionState, fs, ), {, for, (, Reference, ref, :]
[., reportCodeChange, (, ), ;, }, }, }, void, verifyAllReferencesInlined, (, FunctionState, fs, ), {, for, (, Reference, ref, :]
[verifyAllReferencesInlined, (, FunctionState, fs, ), {, for, (, Reference, ref, :, fs, ., getReferences, (, ), ), {, if, (]
[(, FunctionState, fs, ), {, for, (, Reference, ref, :, fs, ., getReferences, (, ), ), {, if, (, !]
[(, FunctionState, fs, ), {, for, (, Reference, ref, :, fs, ., getReferences, (, ), ), {, if, (, !]
[(, Reference, ref, :, fs, ., getReferences, (, ), ), {, if, (, !, ref, ., inlined, ), {, throw]
[:, fs, ., getReferences, (, ), ), {, if, (, !, ref, ., inlined, ), {, throw, new, IllegalStateException, (]
[:, fs, ., getReferences, (, ), ), {, if, (, !, ref, ., inlined, ), {, throw, new, IllegalStateException, (]
[:, fs, ., getReferences, (, ), ), {, if, (, !, ref, ., inlined, ), {, throw, new, IllegalStateException, (]
[:, fs, ., getReferences, (, ), ), {, if, (, !, ref, ., inlined, ), {, throw, new, IllegalStateException, (]
[., getReferences, (, ), ), {, if, (, !, ref, ., inlined, ), {, throw, new, IllegalStateException, (, "Call site missed.\n call: ", +]
[., getReferences, (, ), ), {, if, (, !, ref, ., inlined, ), {, throw, new, IllegalStateException, (, "Call site missed.\n call: ", +]
[., getReferences, (, ), ), {, if, (, !, ref, ., inlined, ), {, throw, new, IllegalStateException, (, "Call site missed.\n call: ", +]
[!, ref, ., inlined, ), {, throw, new, IllegalStateException, (, "Call site missed.\n call: ", +, ref, ., callNode, ., toStringTree, (, ), +]
[., inlined, ), {, throw, new, IllegalStateException, (, "Call site missed.\n call: ", +, ref, ., callNode, ., toStringTree, (, ), +, "\n parent:  ", +]
[., inlined, ), {, throw, new, IllegalStateException, (, "Call site missed.\n call: ", +, ref, ., callNode, ., toStringTree, (, ), +, "\n parent:  ", +]
[., inlined, ), {, throw, new, IllegalStateException, (, "Call site missed.\n call: ", +, ref, ., callNode, ., toStringTree, (, ), +, "\n parent:  ", +]
[., inlined, ), {, throw, new, IllegalStateException, (, "Call site missed.\n call: ", +, ref, ., callNode, ., toStringTree, (, ), +, "\n parent:  ", +]
[(, ), ., toStringTree, (, ), ), ;, }, }, }, private, static, class, FunctionState, {, private, Function, fn, =]
[), ;, }, }, }, private, static, class, FunctionState, {, private, Function, fn, =, null, ;, private, Node, safeFnNode, =]
[static, class, FunctionState, {, private, Function, fn, =, null, ;, private, Node, safeFnNode, =, null, ;, private, boolean, inline, =]
[fn, =, null, ;, private, Node, safeFnNode, =, null, ;, private, boolean, inline, =, true, ;, private, boolean, remove, =]
[safeFnNode, =, null, ;, private, boolean, inline, =, true, ;, private, boolean, remove, =, true, ;, private, boolean, inlineDirectly, =]
[inline, =, true, ;, private, boolean, remove, =, true, ;, private, boolean, inlineDirectly, =, false, ;, private, boolean, referencesThis, =]
[remove, =, true, ;, private, boolean, inlineDirectly, =, false, ;, private, boolean, referencesThis, =, false, ;, private, boolean, hasInnerFunctions, =]
[boolean, referencesThis, =, false, ;, private, boolean, hasInnerFunctions, =, false, ;, private, Map, <, Node, ,, Reference, >, references, =]
[boolean, hasInnerFunctions, =, false, ;, private, Map, <, Node, ,, Reference, >, references, =, null, ;, private, JSModule, module, =]
[,, Reference, >, references, =, null, ;, private, JSModule, module, =, null, ;, private, Set, <, String, >, namesToAlias, =]
[JSModule, module, =, null, ;, private, Set, <, String, >, namesToAlias, =, null, ;, boolean, hasExistingFunctionDefinition, (, ), {, return]
[module, =, null, ;, private, Set, <, String, >, namesToAlias, =, null, ;, boolean, hasExistingFunctionDefinition, (, ), {, return, (]
[module, =, null, ;, private, Set, <, String, >, namesToAlias, =, null, ;, boolean, hasExistingFunctionDefinition, (, ), {, return, (]
[null, ;, private, Set, <, String, >, namesToAlias, =, null, ;, boolean, hasExistingFunctionDefinition, (, ), {, return, (, fn, !=]
[hasExistingFunctionDefinition, (, ), {, return, (, fn, !=, null, ), ;, }, public, void, setReferencesThis, (, boolean, referencesThis, ), {]
[hasExistingFunctionDefinition, (, ), {, return, (, fn, !=, null, ), ;, }, public, void, setReferencesThis, (, boolean, referencesThis, ), {]
[return, (, fn, !=, null, ), ;, }, public, void, setReferencesThis, (, boolean, referencesThis, ), {, this, ., referencesThis, =]
[setReferencesThis, (, boolean, referencesThis, ), {, this, ., referencesThis, =, referencesThis, ;, }, public, boolean, getReferencesThis, (, ), {, return]
[setReferencesThis, (, boolean, referencesThis, ), {, this, ., referencesThis, =, referencesThis, ;, }, public, boolean, getReferencesThis, (, ), {, return]
[public, boolean, getReferencesThis, (, ), {, return, this, ., referencesThis, ;, }, public, void, setHasInnerFunctions, (, boolean, hasInnerFunctions, ), {]
[public, boolean, getReferencesThis, (, ), {, return, this, ., referencesThis, ;, }, public, void, setHasInnerFunctions, (, boolean, hasInnerFunctions, ), {]
[), {, return, this, ., referencesThis, ;, }, public, void, setHasInnerFunctions, (, boolean, hasInnerFunctions, ), {, this, ., hasInnerFunctions, =]
[setHasInnerFunctions, (, boolean, hasInnerFunctions, ), {, this, ., hasInnerFunctions, =, hasInnerFunctions, ;, }, public, boolean, hasInnerFunctions, (, ), {, return]
[;, }, void, removeBlockInliningReferences, (, ), {, Iterator, <, Entry, <, Node, ,, Reference, >, >, i, ;, for, (]
[void, removeBlockInliningReferences, (, ), {, Iterator, <, Entry, <, Node, ,, Reference, >, >, i, ;, for, (, i, =]
[void, removeBlockInliningReferences, (, ), {, Iterator, <, Entry, <, Node, ,, Reference, >, >, i, ;, for, (, i, =]
[void, removeBlockInliningReferences, (, ), {, Iterator, <, Entry, <, Node, ,, Reference, >, >, i, ;, for, (, i, =]
[>, >, i, ;, for, (, i, =, getReferencesInternal, (, ), ., entrySet, (, ), ., iterator, (, ), ;]
[>, >, i, ;, for, (, i, =, getReferencesInternal, (, ), ., entrySet, (, ), ., iterator, (, ), ;]
[iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, Entry, <, Node, ,, Reference, >, entry, =]
[iterator, (, ), ;, i, ., hasNext, (, ), ;, ), {, Entry, <, Node, ,, Reference, >, entry, =]
[), ;, ), {, Entry, <, Node, ,, Reference, >, entry, =, i, ., next, (, ), ;, if, (]
[), ;, ), {, Entry, <, Node, ,, Reference, >, entry, =, i, ., next, (, ), ;, if, (]
[), ;, ), {, Entry, <, Node, ,, Reference, >, entry, =, i, ., next, (, ), ;, if, (]
[), ;, ), {, Entry, <, Node, ,, Reference, >, entry, =, i, ., next, (, ), ;, if, (]
[Reference, >, entry, =, i, ., next, (, ), ;, if, (, entry, ., getValue, (, ), ., mode, ==]
[Reference, >, entry, =, i, ., next, (, ), ;, if, (, entry, ., getValue, (, ), ., mode, ==]
[., next, (, ), ;, if, (, entry, ., getValue, (, ), ., mode, ==, InliningMode, ., BLOCK, ), {]
[., next, (, ), ;, if, (, entry, ., getValue, (, ), ., mode, ==, InliningMode, ., BLOCK, ), {]
[i, ., remove, (, ), ;, }, }, }, public, boolean, hasBlockInliningReferences, (, ), {, for, (, Reference, r, :]
[i, ., remove, (, ), ;, }, }, }, public, boolean, hasBlockInliningReferences, (, ), {, for, (, Reference, r, :]
[hasBlockInliningReferences, (, ), {, for, (, Reference, r, :, getReferencesInternal, (, ), ., values, (, ), ), {, if, (]
[hasBlockInliningReferences, (, ), {, for, (, Reference, r, :, getReferencesInternal, (, ), ., values, (, ), ), {, if, (]
[hasBlockInliningReferences, (, ), {, for, (, Reference, r, :, getReferencesInternal, (, ), ., values, (, ), ), {, if, (]
[for, (, Reference, r, :, getReferencesInternal, (, ), ., values, (, ), ), {, if, (, r, ., mode, ==]
[for, (, Reference, r, :, getReferencesInternal, (, ), ., values, (, ), ), {, if, (, r, ., mode, ==]
[(, ), ., values, (, ), ), {, if, (, r, ., mode, ==, InliningMode, ., BLOCK, ), {, return]
[), ), {, if, (, r, ., mode, ==, InliningMode, ., BLOCK, ), {, return, true, ;, }, }, return]
[., BLOCK, ), {, return, true, ;, }, }, return, false, ;, }, public, Function, getFn, (, ), {, return]
[;, }, public, Function, getFn, (, ), {, return, fn, ;, }, public, void, setFn, (, Function, fn, ), {]
[;, }, public, Function, getFn, (, ), {, return, fn, ;, }, public, void, setFn, (, Function, fn, ), {]
[getFn, (, ), {, return, fn, ;, }, public, void, setFn, (, Function, fn, ), {, Preconditions, ., checkState, (]
[getFn, (, ), {, return, fn, ;, }, public, void, setFn, (, Function, fn, ), {, Preconditions, ., checkState, (]
[getFn, (, ), {, return, fn, ;, }, public, void, setFn, (, Function, fn, ), {, Preconditions, ., checkState, (]
[return, fn, ;, }, public, void, setFn, (, Function, fn, ), {, Preconditions, ., checkState, (, this, ., fn, ==]
[}, public, void, setFn, (, Function, fn, ), {, Preconditions, ., checkState, (, this, ., fn, ==, null, ), ;]
[}, public, void, setFn, (, Function, fn, ), {, Preconditions, ., checkState, (, this, ., fn, ==, null, ), ;]
[(, Function, fn, ), {, Preconditions, ., checkState, (, this, ., fn, ==, null, ), ;, this, ., fn, =]
[., fn, ==, null, ), ;, this, ., fn, =, fn, ;, }, public, Node, getSafeFnNode, (, ), {, return]
[., fn, ==, null, ), ;, this, ., fn, =, fn, ;, }, public, Node, getSafeFnNode, (, ), {, return]
[fn, ==, null, ), ;, this, ., fn, =, fn, ;, }, public, Node, getSafeFnNode, (, ), {, return, (]
[fn, ==, null, ), ;, this, ., fn, =, fn, ;, }, public, Node, getSafeFnNode, (, ), {, return, (]
[null, ), ;, this, ., fn, =, fn, ;, }, public, Node, getSafeFnNode, (, ), {, return, (, safeFnNode, !=]
[this, ., fn, =, fn, ;, }, public, Node, getSafeFnNode, (, ), {, return, (, safeFnNode, !=, null, ), ?]
[fn, =, fn, ;, }, public, Node, getSafeFnNode, (, ), {, return, (, safeFnNode, !=, null, ), ?, safeFnNode, :]
[fn, =, fn, ;, }, public, Node, getSafeFnNode, (, ), {, return, (, safeFnNode, !=, null, ), ?, safeFnNode, :]
[null, ), ?, safeFnNode, :, fn, ., getFunctionNode, (, ), ;, }, public, void, setSafeFnNode, (, Node, safeFnNode, ), {]
[null, ), ?, safeFnNode, :, fn, ., getFunctionNode, (, ), ;, }, public, void, setSafeFnNode, (, Node, safeFnNode, ), {]
[:, fn, ., getFunctionNode, (, ), ;, }, public, void, setSafeFnNode, (, Node, safeFnNode, ), {, this, ., safeFnNode, =]
[setSafeFnNode, (, Node, safeFnNode, ), {, this, ., safeFnNode, =, safeFnNode, ;, }, public, boolean, canInline, (, ), {, return]
[;, }, public, boolean, canInline, (, ), {, return, inline, ;, }, public, void, setInline, (, boolean, inline, ), {]
[;, }, public, boolean, canInline, (, ), {, return, inline, ;, }, public, void, setInline, (, boolean, inline, ), {]
[canInline, (, ), {, return, inline, ;, }, public, void, setInline, (, boolean, inline, ), {, this, ., inline, =]
[return, inline, ;, }, public, void, setInline, (, boolean, inline, ), {, this, ., inline, =, inline, ;, if, (]
[return, inline, ;, }, public, void, setInline, (, boolean, inline, ), {, this, ., inline, =, inline, ;, if, (]
[;, }, public, void, setInline, (, boolean, inline, ), {, this, ., inline, =, inline, ;, if, (, inline, ==]
[void, setInline, (, boolean, inline, ), {, this, ., inline, =, inline, ;, if, (, inline, ==, false, ), {]
[(, boolean, inline, ), {, this, ., inline, =, inline, ;, if, (, inline, ==, false, ), {, references, =]
[inline, ), {, this, ., inline, =, inline, ;, if, (, inline, ==, false, ), {, references, =, null, ;]
[{, this, ., inline, =, inline, ;, if, (, inline, ==, false, ), {, references, =, null, ;, remove, =]
[false, ), {, references, =, null, ;, remove, =, false, ;, }, }, public, boolean, canRemove, (, ), {, return]
[}, }, public, boolean, canRemove, (, ), {, return, remove, ;, }, public, void, setRemove, (, boolean, remove, ), {]
[}, }, public, boolean, canRemove, (, ), {, return, remove, ;, }, public, void, setRemove, (, boolean, remove, ), {]
[canRemove, (, ), {, return, remove, ;, }, public, void, setRemove, (, boolean, remove, ), {, this, ., remove, =]
[setRemove, (, boolean, remove, ), {, this, ., remove, =, remove, ;, }, public, boolean, canInlineDirectly, (, ), {, return]
[;, }, public, boolean, canInlineDirectly, (, ), {, return, inlineDirectly, ;, }, public, void, inlineDirectly, (, boolean, directReplacement, ), {]
[;, }, public, boolean, canInlineDirectly, (, ), {, return, inlineDirectly, ;, }, public, void, inlineDirectly, (, boolean, directReplacement, ), {]
[canInlineDirectly, (, ), {, return, inlineDirectly, ;, }, public, void, inlineDirectly, (, boolean, directReplacement, ), {, this, ., inlineDirectly, =]
[inlineDirectly, (, boolean, directReplacement, ), {, this, ., inlineDirectly, =, directReplacement, ;, }, public, boolean, hasReferences, (, ), {, return]
[(, boolean, directReplacement, ), {, this, ., inlineDirectly, =, directReplacement, ;, }, public, boolean, hasReferences, (, ), {, return, (]
[(, boolean, directReplacement, ), {, this, ., inlineDirectly, =, directReplacement, ;, }, public, boolean, hasReferences, (, ), {, return, (]
[(, boolean, directReplacement, ), {, this, ., inlineDirectly, =, directReplacement, ;, }, public, boolean, hasReferences, (, ), {, return, (]
[directReplacement, ), {, this, ., inlineDirectly, =, directReplacement, ;, }, public, boolean, hasReferences, (, ), {, return, (, references, !=]
[{, this, ., inlineDirectly, =, directReplacement, ;, }, public, boolean, hasReferences, (, ), {, return, (, references, !=, null, &&]
[this, ., inlineDirectly, =, directReplacement, ;, }, public, boolean, hasReferences, (, ), {, return, (, references, !=, null, &&, !]
[this, ., inlineDirectly, =, directReplacement, ;, }, public, boolean, hasReferences, (, ), {, return, (, references, !=, null, &&, !]
[., isEmpty, (, ), ), ;, }, private, Map, <, Node, ,, Reference, >, getReferencesInternal, (, ), {, if, (]
[., isEmpty, (, ), ), ;, }, private, Map, <, Node, ,, Reference, >, getReferencesInternal, (, ), {, if, (]
[(, ), ), ;, }, private, Map, <, Node, ,, Reference, >, getReferencesInternal, (, ), {, if, (, references, ==]
[}, private, Map, <, Node, ,, Reference, >, getReferencesInternal, (, ), {, if, (, references, ==, null, ), {, return]
[}, private, Map, <, Node, ,, Reference, >, getReferencesInternal, (, ), {, if, (, references, ==, null, ), {, return]
[getReferencesInternal, (, ), {, if, (, references, ==, null, ), {, return, Collections, ., emptyMap, (, ), ;, }, return]
[., emptyMap, (, ), ;, }, return, references, ;, }, public, void, addReference, (, Reference, ref, ), {, if, (]
[., emptyMap, (, ), ;, }, return, references, ;, }, public, void, addReference, (, Reference, ref, ), {, if, (]
[(, ), ;, }, return, references, ;, }, public, void, addReference, (, Reference, ref, ), {, if, (, references, ==]
[}, return, references, ;, }, public, void, addReference, (, Reference, ref, ), {, if, (, references, ==, null, ), {]
[references, ;, }, public, void, addReference, (, Reference, ref, ), {, if, (, references, ==, null, ), {, references, =]
[references, ;, }, public, void, addReference, (, Reference, ref, ), {, if, (, references, ==, null, ), {, references, =]
[Reference, ref, ), {, if, (, references, ==, null, ), {, references, =, Maps, ., newHashMap, (, ), ;, }]
[Reference, ref, ), {, if, (, references, ==, null, ), {, references, =, Maps, ., newHashMap, (, ), ;, }]
[if, (, references, ==, null, ), {, references, =, Maps, ., newHashMap, (, ), ;, }, references, ., put, (]
[if, (, references, ==, null, ), {, references, =, Maps, ., newHashMap, (, ), ;, }, references, ., put, (]
[null, ), {, references, =, Maps, ., newHashMap, (, ), ;, }, references, ., put, (, ref, ., callNode, ,]
[put, (, ref, ., callNode, ,, ref, ), ;, }, public, Collection, <, Reference, >, getReferences, (, ), {, return]
[put, (, ref, ., callNode, ,, ref, ), ;, }, public, Collection, <, Reference, >, getReferences, (, ), {, return]
[{, return, getReferencesInternal, (, ), ., values, (, ), ;, }, public, Reference, getReference, (, Node, n, ), {, return]
[{, return, getReferencesInternal, (, ), ., values, (, ), ;, }, public, Reference, getReference, (, Node, n, ), {, return]
[values, (, ), ;, }, public, Reference, getReference, (, Node, n, ), {, return, getReferencesInternal, (, ), ., get, (]
[(, ), ., get, (, n, ), ;, }, public, Set, <, String, >, getNamesToAlias, (, ), {, if, (]
[(, ), ., get, (, n, ), ;, }, public, Set, <, String, >, getNamesToAlias, (, ), {, if, (]
[., get, (, n, ), ;, }, public, Set, <, String, >, getNamesToAlias, (, ), {, if, (, namesToAlias, ==]
[), ;, }, public, Set, <, String, >, getNamesToAlias, (, ), {, if, (, namesToAlias, ==, null, ), {, return]
[), ;, }, public, Set, <, String, >, getNamesToAlias, (, ), {, if, (, namesToAlias, ==, null, ), {, return]
[getNamesToAlias, (, ), {, if, (, namesToAlias, ==, null, ), {, return, Collections, ., emptySet, (, ), ;, }, return]
[getNamesToAlias, (, ), {, if, (, namesToAlias, ==, null, ), {, return, Collections, ., emptySet, (, ), ;, }, return]
[if, (, namesToAlias, ==, null, ), {, return, Collections, ., emptySet, (, ), ;, }, return, Collections, ., unmodifiableSet, (]
[return, Collections, ., unmodifiableSet, (, namesToAlias, ), ;, }, public, void, setNamesToAlias, (, Set, <, String, >, names, ), {]
[., unmodifiableSet, (, namesToAlias, ), ;, }, public, void, setNamesToAlias, (, Set, <, String, >, names, ), {, namesToAlias, =]
[Set, <, String, >, names, ), {, namesToAlias, =, names, ;, }, public, void, setModule, (, JSModule, module, ), {]
[Set, <, String, >, names, ), {, namesToAlias, =, names, ;, }, public, void, setModule, (, JSModule, module, ), {]
[names, ), {, namesToAlias, =, names, ;, }, public, void, setModule, (, JSModule, module, ), {, this, ., module, =]
[setModule, (, JSModule, module, ), {, this, ., module, =, module, ;, }, public, JSModule, getModule, (, ), {, return]
[}, private, static, class, NamedFunction, implements, Function, {, private, final, Node, fn, ;, public, NamedFunction, (, Node, fn, ), {]
[}, private, static, class, NamedFunction, implements, Function, {, private, final, Node, fn, ;, public, NamedFunction, (, Node, fn, ), {]
[NamedFunction, implements, Function, {, private, final, Node, fn, ;, public, NamedFunction, (, Node, fn, ), {, this, ., fn, =]
[Node, fn, ), {, this, ., fn, =, fn, ;, }, @, Override, public, String, getName, (, ), {, return]
[Node, fn, ), {, this, ., fn, =, fn, ;, }, @, Override, public, String, getName, (, ), {, return]
[Node, fn, ), {, this, ., fn, =, fn, ;, }, @, Override, public, String, getName, (, ), {, return]
[fn, ., getFirstChild, (, ), ., getString, (, ), ;, }, @, Override, public, Node, getFunctionNode, (, ), {, return]
[@, Override, public, Node, getFunctionNode, (, ), {, return, fn, ;, }, @, Override, public, void, remove, (, ), {]
[@, Override, public, Node, getFunctionNode, (, ), {, return, fn, ;, }, @, Override, public, void, remove, (, ), {]
[getFunctionNode, (, ), {, return, fn, ;, }, @, Override, public, void, remove, (, ), {, NodeUtil, ., removeChild, (]
[getFunctionNode, (, ), {, return, fn, ;, }, @, Override, public, void, remove, (, ), {, NodeUtil, ., removeChild, (]
[;, }, @, Override, public, void, remove, (, ), {, NodeUtil, ., removeChild, (, fn, ., getParent, (, ), ,]
[(, fn, ., getParent, (, ), ,, fn, ), ;, }, @, Override, public, Node, getDeclaringBlock, (, ), {, return]
[(, fn, ., getParent, (, ), ,, fn, ), ;, }, @, Override, public, Node, getDeclaringBlock, (, ), {, return]
[}, private, static, class, FunctionVar, implements, Function, {, private, final, Node, var, ;, public, FunctionVar, (, Node, var, ), {]
[}, private, static, class, FunctionVar, implements, Function, {, private, final, Node, var, ;, public, FunctionVar, (, Node, var, ), {]
[FunctionVar, implements, Function, {, private, final, Node, var, ;, public, FunctionVar, (, Node, var, ), {, this, ., var, =]
[Node, var, ), {, this, ., var, =, var, ;, }, @, Override, public, String, getName, (, ), {, return]
[Node, var, ), {, this, ., var, =, var, ;, }, @, Override, public, String, getName, (, ), {, return]
[Node, var, ), {, this, ., var, =, var, ;, }, @, Override, public, String, getName, (, ), {, return]
[var, ., getFirstChild, (, ), ., getString, (, ), ;, }, @, Override, public, Node, getFunctionNode, (, ), {, return]
[var, ., getFirstChild, (, ), ., getString, (, ), ;, }, @, Override, public, Node, getFunctionNode, (, ), {, return]
[var, ., getFirstChild, (, ), ., getString, (, ), ;, }, @, Override, public, Node, getFunctionNode, (, ), {, return]
[return, var, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, @, Override, public, void, remove, (, ), {]
[return, var, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, @, Override, public, void, remove, (, ), {]
[(, ), ., getFirstChild, (, ), ;, }, @, Override, public, void, remove, (, ), {, NodeUtil, ., removeChild, (]
[(, ), ., getFirstChild, (, ), ;, }, @, Override, public, void, remove, (, ), {, NodeUtil, ., removeChild, (]
[;, }, @, Override, public, void, remove, (, ), {, NodeUtil, ., removeChild, (, var, ., getParent, (, ), ,]
[(, var, ., getParent, (, ), ,, var, ), ;, }, @, Override, public, Node, getDeclaringBlock, (, ), {, return]
[(, var, ., getParent, (, ), ,, var, ), ;, }, @, Override, public, Node, getDeclaringBlock, (, ), {, return]
[private, final, Node, fn, ;, private, final, String, fakeName, ;, public, FunctionExpression, (, Node, fn, ,, int, index, ), {]
[private, final, Node, fn, ;, private, final, String, fakeName, ;, public, FunctionExpression, (, Node, fn, ,, int, index, ), {]
[;, private, final, String, fakeName, ;, public, FunctionExpression, (, Node, fn, ,, int, index, ), {, this, ., fn, =]
[final, String, fakeName, ;, public, FunctionExpression, (, Node, fn, ,, int, index, ), {, this, ., fn, =, fn, ;]
[final, String, fakeName, ;, public, FunctionExpression, (, Node, fn, ,, int, index, ), {, this, ., fn, =, fn, ;]
[public, FunctionExpression, (, Node, fn, ,, int, index, ), {, this, ., fn, =, fn, ;, this, ., fakeName, =]
[public, FunctionExpression, (, Node, fn, ,, int, index, ), {, this, ., fn, =, fn, ;, this, ., fakeName, =]
[fn, ,, int, index, ), {, this, ., fn, =, fn, ;, this, ., fakeName, =, String, ., valueOf, (]
[., fakeName, =, String, ., valueOf, (, index, ), ;, }, @, Override, public, String, getName, (, ), {, return]
[Override, public, String, getName, (, ), {, return, fakeName, ;, }, @, Override, public, Node, getFunctionNode, (, ), {, return]
[;, }, @, Override, public, void, remove, (, ), {, }, @, Override, public, Node, getDeclaringBlock, (, ), {, return]
[{, return, null, ;, }, }, class, Reference, extends, FunctionInjector, ., Reference, {, final, boolean, requiresDecomposition, ;, boolean, inlined, =]
[=, false, ;, Reference, (, Node, callNode, ,, JSModule, module, ,, InliningMode, mode, ,, boolean, decompose, ), {, super, (]
[;, Reference, (, Node, callNode, ,, JSModule, module, ,, InliningMode, mode, ,, boolean, decompose, ), {, super, (, callNode, ,]
[(, Node, callNode, ,, JSModule, module, ,, InliningMode, mode, ,, boolean, decompose, ), {, super, (, callNode, ,, module, ,]
[,, JSModule, module, ,, InliningMode, mode, ,, boolean, decompose, ), {, super, (, callNode, ,, module, ,, mode, ), ;]
[,, JSModule, module, ,, InliningMode, mode, ,, boolean, decompose, ), {, super, (, callNode, ,, module, ,, mode, ), ;]
[InliningMode, mode, ,, boolean, decompose, ), {, super, (, callNode, ,, module, ,, mode, ), ;, this, ., requiresDecomposition, =]
