[sortedList, ;, private, final, List, <, INPUT, >, noProvides, ;, private, final, Map, <, String, ,, INPUT, >, provideMap, =]
[sortedList, ;, private, final, List, <, INPUT, >, noProvides, ;, private, final, Map, <, String, ,, INPUT, >, provideMap, =]
[provideMap, =, Maps, ., newHashMap, (, ), ;, public, SortedDependencies, (, List, <, INPUT, >, inputs, ), throws, CircularDependencyException, {]
[provideMap, =, Maps, ., newHashMap, (, ), ;, public, SortedDependencies, (, List, <, INPUT, >, inputs, ), throws, CircularDependencyException, {]
[newHashMap, (, ), ;, public, SortedDependencies, (, List, <, INPUT, >, inputs, ), throws, CircularDependencyException, {, this, ., inputs, =]
[newHashMap, (, ), ;, public, SortedDependencies, (, List, <, INPUT, >, inputs, ), throws, CircularDependencyException, {, this, ., inputs, =]
[public, SortedDependencies, (, List, <, INPUT, >, inputs, ), throws, CircularDependencyException, {, this, ., inputs, =, Lists, ., newArrayList, (]
[List, <, INPUT, >, inputs, ), throws, CircularDependencyException, {, this, ., inputs, =, Lists, ., newArrayList, (, inputs, ), ;]
[INPUT, >, inputs, ), throws, CircularDependencyException, {, this, ., inputs, =, Lists, ., newArrayList, (, inputs, ), ;, noProvides, =]
[INPUT, >, inputs, ), throws, CircularDependencyException, {, this, ., inputs, =, Lists, ., newArrayList, (, inputs, ), ;, noProvides, =]
[Lists, ., newArrayList, (, inputs, ), ;, noProvides, =, Lists, ., newArrayList, (, ), ;, for, (, INPUT, input, :]
[Lists, ., newArrayList, (, ), ;, for, (, INPUT, input, :, inputs, ), {, Collection, <, String, >, currentProvides, =]
[Lists, ., newArrayList, (, ), ;, for, (, INPUT, input, :, inputs, ), {, Collection, <, String, >, currentProvides, =]
[INPUT, input, :, inputs, ), {, Collection, <, String, >, currentProvides, =, input, ., getProvides, (, ), ;, if, (]
[INPUT, input, :, inputs, ), {, Collection, <, String, >, currentProvides, =, input, ., getProvides, (, ), ;, if, (]
[<, String, >, currentProvides, =, input, ., getProvides, (, ), ;, if, (, currentProvides, ., isEmpty, (, ), ), {]
[<, String, >, currentProvides, =, input, ., getProvides, (, ), ;, if, (, currentProvides, ., isEmpty, (, ), ), {]
[=, input, ., getProvides, (, ), ;, if, (, currentProvides, ., isEmpty, (, ), ), {, noProvides, ., add, (]
[currentProvides, ., isEmpty, (, ), ), {, noProvides, ., add, (, input, ), ;, }, for, (, String, provide, :]
[(, ), ), {, noProvides, ., add, (, input, ), ;, }, for, (, String, provide, :, currentProvides, ), {]
[(, ), ), {, noProvides, ., add, (, input, ), ;, }, for, (, String, provide, :, currentProvides, ), {]
[noProvides, ., add, (, input, ), ;, }, for, (, String, provide, :, currentProvides, ), {, provideMap, ., put, (]
[add, (, input, ), ;, }, for, (, String, provide, :, currentProvides, ), {, provideMap, ., put, (, provide, ,]
[provideMap, ., put, (, provide, ,, input, ), ;, }, }, final, Multimap, <, INPUT, ,, INPUT, >, deps, =]
[provideMap, ., put, (, provide, ,, input, ), ;, }, }, final, Multimap, <, INPUT, ,, INPUT, >, deps, =]
[final, Multimap, <, INPUT, ,, INPUT, >, deps, =, HashMultimap, ., create, (, ), ;, for, (, INPUT, input, :]
[=, HashMultimap, ., create, (, ), ;, for, (, INPUT, input, :, inputs, ), {, for, (, String, req, :]
[=, HashMultimap, ., create, (, ), ;, for, (, INPUT, input, :, inputs, ), {, for, (, String, req, :]
[input, :, inputs, ), {, for, (, String, req, :, input, ., getRequires, (, ), ), {, INPUT, dep, =]
[input, :, inputs, ), {, for, (, String, req, :, input, ., getRequires, (, ), ), {, INPUT, dep, =]
[{, for, (, String, req, :, input, ., getRequires, (, ), ), {, INPUT, dep, =, provideMap, ., get, (]
[:, input, ., getRequires, (, ), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (]
[:, input, ., getRequires, (, ), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (]
[:, input, ., getRequires, (, ), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (]
[., getRequires, (, ), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=]
[(, ), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=, null, &&]
[(, ), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=, null, &&]
[), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=, null, &&, dep, !=]
[dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=, null, &&, dep, !=, input, ), {]
[dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=, null, &&, dep, !=, input, ), {]
[get, (, req, ), ;, if, (, dep, !=, null, &&, dep, !=, input, ), {, deps, ., put, (]
[req, ), ;, if, (, dep, !=, null, &&, dep, !=, input, ), {, deps, ., put, (, input, ,]
[!=, null, &&, dep, !=, input, ), {, deps, ., put, (, input, ,, dep, ), ;, }, }, }]
[&&, dep, !=, input, ), {, deps, ., put, (, input, ,, dep, ), ;, }, }, }, sortedList, =]
[!=, input, ), {, deps, ., put, (, input, ,, dep, ), ;, }, }, }, sortedList, =, topologicalStableSort, (]
[), {, deps, ., put, (, input, ,, dep, ), ;, }, }, }, sortedList, =, topologicalStableSort, (, inputs, ,]
[(, input, ,, dep, ), ;, }, }, }, sortedList, =, topologicalStableSort, (, inputs, ,, deps, ), ;, if, (]
[(, input, ,, dep, ), ;, }, }, }, sortedList, =, topologicalStableSort, (, inputs, ,, deps, ), ;, if, (]
[(, input, ,, dep, ), ;, }, }, }, sortedList, =, topologicalStableSort, (, inputs, ,, deps, ), ;, if, (]
[}, }, }, sortedList, =, topologicalStableSort, (, inputs, ,, deps, ), ;, if, (, sortedList, ., size, (, ), <]
[}, }, }, sortedList, =, topologicalStableSort, (, inputs, ,, deps, ), ;, if, (, sortedList, ., size, (, ), <]
[(, sortedList, ., size, (, ), <, inputs, ., size, (, ), ), {, List, <, INPUT, >, subGraph, =]
[(, sortedList, ., size, (, ), <, inputs, ., size, (, ), ), {, List, <, INPUT, >, subGraph, =]
[(, ), <, inputs, ., size, (, ), ), {, List, <, INPUT, >, subGraph, =, Lists, ., newArrayList, (]
[inputs, ., size, (, ), ), {, List, <, INPUT, >, subGraph, =, Lists, ., newArrayList, (, inputs, ), ;]
[inputs, ., size, (, ), ), {, List, <, INPUT, >, subGraph, =, Lists, ., newArrayList, (, inputs, ), ;]
[), ), {, List, <, INPUT, >, subGraph, =, Lists, ., newArrayList, (, inputs, ), ;, subGraph, ., removeAll, (]
[<, INPUT, >, subGraph, =, Lists, ., newArrayList, (, inputs, ), ;, subGraph, ., removeAll, (, sortedList, ), ;, throw]
[subGraph, =, Lists, ., newArrayList, (, inputs, ), ;, subGraph, ., removeAll, (, sortedList, ), ;, throw, new, CircularDependencyException, (]
[Lists, ., newArrayList, (, inputs, ), ;, subGraph, ., removeAll, (, sortedList, ), ;, throw, new, CircularDependencyException, (, cycleToString, (]
[newArrayList, (, inputs, ), ;, subGraph, ., removeAll, (, sortedList, ), ;, throw, new, CircularDependencyException, (, cycleToString, (, findCycle, (]
[inputs, ), ;, subGraph, ., removeAll, (, sortedList, ), ;, throw, new, CircularDependencyException, (, cycleToString, (, findCycle, (, subGraph, ,]
[,, deps, ), ), ), ;, }, }, public, INPUT, getInputProviding, (, String, symbol, ), throws, MissingProvideException, {, if, (]
[,, deps, ), ), ), ;, }, }, public, INPUT, getInputProviding, (, String, symbol, ), throws, MissingProvideException, {, if, (]
[), ;, }, }, public, INPUT, getInputProviding, (, String, symbol, ), throws, MissingProvideException, {, if, (, provideMap, ., containsKey, (]
[INPUT, getInputProviding, (, String, symbol, ), throws, MissingProvideException, {, if, (, provideMap, ., containsKey, (, symbol, ), ), {, return]
[INPUT, getInputProviding, (, String, symbol, ), throws, MissingProvideException, {, if, (, provideMap, ., containsKey, (, symbol, ), ), {, return]
[symbol, ), throws, MissingProvideException, {, if, (, provideMap, ., containsKey, (, symbol, ), ), {, return, provideMap, ., get, (]
[if, (, provideMap, ., containsKey, (, symbol, ), ), {, return, provideMap, ., get, (, symbol, ), ;, }, throw]
[., containsKey, (, symbol, ), ), {, return, provideMap, ., get, (, symbol, ), ;, }, throw, new, MissingProvideException, (]
[), ;, }, throw, new, MissingProvideException, (, symbol, ), ;, }, public, INPUT, maybeGetInputProviding, (, String, symbol, ), {, return]
[), ;, }, throw, new, MissingProvideException, (, symbol, ), ;, }, public, INPUT, maybeGetInputProviding, (, String, symbol, ), {, return]
[new, MissingProvideException, (, symbol, ), ;, }, public, INPUT, maybeGetInputProviding, (, String, symbol, ), {, return, provideMap, ., get, (]
[INPUT, >, findCycle, (, List, <, INPUT, >, subGraph, ,, Multimap, <, INPUT, ,, INPUT, >, deps, ), {, return]
[findCycle, (, List, <, INPUT, >, subGraph, ,, Multimap, <, INPUT, ,, INPUT, >, deps, ), {, return, findCycle, (]
[findCycle, (, List, <, INPUT, >, subGraph, ,, Multimap, <, INPUT, ,, INPUT, >, deps, ), {, return, findCycle, (]
[INPUT, >, subGraph, ,, Multimap, <, INPUT, ,, INPUT, >, deps, ), {, return, findCycle, (, subGraph, ., get, (]
[,, Multimap, <, INPUT, ,, INPUT, >, deps, ), {, return, findCycle, (, subGraph, ., get, (, 0, ), ,]
[,, Multimap, <, INPUT, ,, INPUT, >, deps, ), {, return, findCycle, (, subGraph, ., get, (, 0, ), ,]
[deps, ), {, return, findCycle, (, subGraph, ., get, (, 0, ), ,, Sets, ., <, INPUT, >, newHashSet, (]
[return, findCycle, (, subGraph, ., get, (, 0, ), ,, Sets, ., <, INPUT, >, newHashSet, (, subGraph, ), ,]
[(, subGraph, ., get, (, 0, ), ,, Sets, ., <, INPUT, >, newHashSet, (, subGraph, ), ,, deps, ,]
[(, subGraph, ., get, (, 0, ), ,, Sets, ., <, INPUT, >, newHashSet, (, subGraph, ), ,, deps, ,]
[>, subGraph, ,, Multimap, <, INPUT, ,, INPUT, >, deps, ,, Set, <, INPUT, >, covered, ), {, if, (]
[>, subGraph, ,, Multimap, <, INPUT, ,, INPUT, >, deps, ,, Set, <, INPUT, >, covered, ), {, if, (]
[<, INPUT, ,, INPUT, >, deps, ,, Set, <, INPUT, >, covered, ), {, if, (, covered, ., add, (]
[>, covered, ), {, if, (, covered, ., add, (, current, ), ), {, List, <, INPUT, >, cycle, =]
[), {, if, (, covered, ., add, (, current, ), ), {, List, <, INPUT, >, cycle, =, findCycle, (]
[if, (, covered, ., add, (, current, ), ), {, List, <, INPUT, >, cycle, =, findCycle, (, findRequireInSubGraphOrFail, (]
[covered, ., add, (, current, ), ), {, List, <, INPUT, >, cycle, =, findCycle, (, findRequireInSubGraphOrFail, (, current, ,]
[(, current, ), ), {, List, <, INPUT, >, cycle, =, findCycle, (, findRequireInSubGraphOrFail, (, current, ,, subGraph, ), ,]
[), ), {, List, <, INPUT, >, cycle, =, findCycle, (, findRequireInSubGraphOrFail, (, current, ,, subGraph, ), ,, subGraph, ,]
[{, List, <, INPUT, >, cycle, =, findCycle, (, findRequireInSubGraphOrFail, (, current, ,, subGraph, ), ,, subGraph, ,, deps, ,]
[cycle, =, findCycle, (, findRequireInSubGraphOrFail, (, current, ,, subGraph, ), ,, subGraph, ,, deps, ,, covered, ), ;, if, (]
[cycle, =, findCycle, (, findRequireInSubGraphOrFail, (, current, ,, subGraph, ), ,, subGraph, ,, deps, ,, covered, ), ;, if, (]
[cycle, =, findCycle, (, findRequireInSubGraphOrFail, (, current, ,, subGraph, ), ,, subGraph, ,, deps, ,, covered, ), ;, if, (]
[findRequireInSubGraphOrFail, (, current, ,, subGraph, ), ,, subGraph, ,, deps, ,, covered, ), ;, if, (, cycle, ., get, (]
[,, subGraph, ), ,, subGraph, ,, deps, ,, covered, ), ;, if, (, cycle, ., get, (, 0, ), !=]
[,, subGraph, ), ,, subGraph, ,, deps, ,, covered, ), ;, if, (, cycle, ., get, (, 0, ), !=]
[subGraph, ,, deps, ,, covered, ), ;, if, (, cycle, ., get, (, 0, ), !=, cycle, ., get, (]
[subGraph, ,, deps, ,, covered, ), ;, if, (, cycle, ., get, (, 0, ), !=, cycle, ., get, (]
[subGraph, ,, deps, ,, covered, ), ;, if, (, cycle, ., get, (, 0, ), !=, cycle, ., get, (]
[;, if, (, cycle, ., get, (, 0, ), !=, cycle, ., get, (, cycle, ., size, (, ), -]
[., get, (, 0, ), !=, cycle, ., get, (, cycle, ., size, (, ), -, 1, ), ), {]
[., get, (, 0, ), !=, cycle, ., get, (, cycle, ., size, (, ), -, 1, ), ), {]
[), !=, cycle, ., get, (, cycle, ., size, (, ), -, 1, ), ), {, cycle, ., add, (]
[(, cycle, ., size, (, ), -, 1, ), ), {, cycle, ., add, (, current, ), ;, }, return]
[cycle, ., add, (, current, ), ;, }, return, cycle, ;, }, else, {, List, <, INPUT, >, cycle, =]
[cycle, ., add, (, current, ), ;, }, return, cycle, ;, }, else, {, List, <, INPUT, >, cycle, =]
[cycle, ;, }, else, {, List, <, INPUT, >, cycle, =, Lists, ., <, INPUT, >, newArrayList, (, ), ;]
[cycle, ;, }, else, {, List, <, INPUT, >, cycle, =, Lists, ., <, INPUT, >, newArrayList, (, ), ;]
[{, List, <, INPUT, >, cycle, =, Lists, ., <, INPUT, >, newArrayList, (, ), ;, cycle, ., add, (]
[>, cycle, =, Lists, ., <, INPUT, >, newArrayList, (, ), ;, cycle, ., add, (, current, ), ;, return]
[}, private, INPUT, findRequireInSubGraphOrFail, (, INPUT, input, ,, Set, <, INPUT, >, subGraph, ), {, for, (, String, symbol, :]
[}, private, INPUT, findRequireInSubGraphOrFail, (, INPUT, input, ,, Set, <, INPUT, >, subGraph, ), {, for, (, String, symbol, :]
[INPUT, >, subGraph, ), {, for, (, String, symbol, :, input, ., getRequires, (, ), ), {, INPUT, candidate, =]
[INPUT, >, subGraph, ), {, for, (, String, symbol, :, input, ., getRequires, (, ), ), {, INPUT, candidate, =]
[{, for, (, String, symbol, :, input, ., getRequires, (, ), ), {, INPUT, candidate, =, provideMap, ., get, (]
[:, input, ., getRequires, (, ), ), {, INPUT, candidate, =, provideMap, ., get, (, symbol, ), ;, if, (]
[:, input, ., getRequires, (, ), ), {, INPUT, candidate, =, provideMap, ., get, (, symbol, ), ;, if, (]
[(, ), ), {, INPUT, candidate, =, provideMap, ., get, (, symbol, ), ;, if, (, subGraph, ., contains, (]
[candidate, =, provideMap, ., get, (, symbol, ), ;, if, (, subGraph, ., contains, (, candidate, ), ), {, return]
[(, symbol, ), ;, if, (, subGraph, ., contains, (, candidate, ), ), {, return, candidate, ;, }, }, throw]
[;, if, (, subGraph, ., contains, (, candidate, ), ), {, return, candidate, ;, }, }, throw, new, IllegalStateException, (]
[), ;, }, private, String, cycleToString, (, List, <, INPUT, >, cycle, ), {, List, <, String, >, symbols, =]
[), ;, }, private, String, cycleToString, (, List, <, INPUT, >, cycle, ), {, List, <, String, >, symbols, =]
[cycle, ), {, List, <, String, >, symbols, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =]
[cycle, ), {, List, <, String, >, symbols, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =]
[cycle, ), {, List, <, String, >, symbols, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =]
[>, symbols, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =, cycle, ., size, (, ), -]
[=, Lists, ., newArrayList, (, ), ;, for, (, int, i, =, cycle, ., size, (, ), -, 1, ;]
[=, Lists, ., newArrayList, (, ), ;, for, (, int, i, =, cycle, ., size, (, ), -, 1, ;]
[., newArrayList, (, ), ;, for, (, int, i, =, cycle, ., size, (, ), -, 1, ;, i, >=]
[(, ), ;, for, (, int, i, =, cycle, ., size, (, ), -, 1, ;, i, >=, 0, ;]
[(, ), ;, for, (, int, i, =, cycle, ., size, (, ), -, 1, ;, i, >=, 0, ;]
[(, int, i, =, cycle, ., size, (, ), -, 1, ;, i, >=, 0, ;, i, --, ), {]
[(, int, i, =, cycle, ., size, (, ), -, 1, ;, i, >=, 0, ;, i, --, ), {]
[cycle, ., size, (, ), -, 1, ;, i, >=, 0, ;, i, --, ), {, symbols, ., add, (]
[cycle, ., size, (, ), -, 1, ;, i, >=, 0, ;, i, --, ), {, symbols, ., add, (]
[cycle, ., size, (, ), -, 1, ;, i, >=, 0, ;, i, --, ), {, symbols, ., add, (]
[cycle, ., size, (, ), -, 1, ;, i, >=, 0, ;, i, --, ), {, symbols, ., add, (]
[cycle, ., size, (, ), -, 1, ;, i, >=, 0, ;, i, --, ), {, symbols, ., add, (]
[), -, 1, ;, i, >=, 0, ;, i, --, ), {, symbols, ., add, (, cycle, ., get, (]
[., get, (, i, ), ., getProvides, (, ), ., iterator, (, ), ., next, (, ), ), ;, }]
[., get, (, i, ), ., getProvides, (, ), ., iterator, (, ), ., next, (, ), ), ;, }]
[), ., getProvides, (, ), ., iterator, (, ), ., next, (, ), ), ;, }, symbols, ., add, (]
[), ., getProvides, (, ), ., iterator, (, ), ., next, (, ), ), ;, }, symbols, ., add, (]
[), ., iterator, (, ), ., next, (, ), ), ;, }, symbols, ., add, (, symbols, ., get, (]
[., next, (, ), ), ;, }, symbols, ., add, (, symbols, ., get, (, 0, ), ), ;, return]
[., next, (, ), ), ;, }, symbols, ., add, (, symbols, ., get, (, 0, ), ), ;, return]
[., next, (, ), ), ;, }, symbols, ., add, (, symbols, ., get, (, 0, ), ), ;, return]
[), ;, }, symbols, ., add, (, symbols, ., get, (, 0, ), ), ;, return, Joiner, ., on, (]
[add, (, symbols, ., get, (, 0, ), ), ;, return, Joiner, ., on, (, " -> ", ), ., join, (]
[(, " -> ", ), ., join, (, symbols, ), ;, }, public, List, <, INPUT, >, getSortedList, (, ), {, return]
[(, " -> ", ), ., join, (, symbols, ), ;, }, public, List, <, INPUT, >, getSortedList, (, ), {, return]
[), ;, }, public, List, <, INPUT, >, getSortedList, (, ), {, return, Collections, ., <, INPUT, >, unmodifiableList, (]
[(, sortedList, ), ;, }, public, List, <, INPUT, >, getSortedDependenciesOf, (, List, <, INPUT, >, roots, ), {, return]
[), ;, }, public, List, <, INPUT, >, getSortedDependenciesOf, (, List, <, INPUT, >, roots, ), {, return, getDependenciesOf, (]
[}, public, List, <, INPUT, >, getSortedDependenciesOf, (, List, <, INPUT, >, roots, ), {, return, getDependenciesOf, (, roots, ,]
[), ;, }, public, List, <, INPUT, >, getDependenciesOf, (, List, <, INPUT, >, roots, ,, boolean, sorted, ), {]
[), ;, }, public, List, <, INPUT, >, getDependenciesOf, (, List, <, INPUT, >, roots, ,, boolean, sorted, ), {]
[List, <, INPUT, >, getDependenciesOf, (, List, <, INPUT, >, roots, ,, boolean, sorted, ), {, Preconditions, ., checkArgument, (]
[List, <, INPUT, >, getDependenciesOf, (, List, <, INPUT, >, roots, ,, boolean, sorted, ), {, Preconditions, ., checkArgument, (]
[getDependenciesOf, (, List, <, INPUT, >, roots, ,, boolean, sorted, ), {, Preconditions, ., checkArgument, (, inputs, ., containsAll, (]
[), {, Preconditions, ., checkArgument, (, inputs, ., containsAll, (, roots, ), ), ;, Set, <, INPUT, >, included, =]
[), {, Preconditions, ., checkArgument, (, inputs, ., containsAll, (, roots, ), ), ;, Set, <, INPUT, >, included, =]
[), ;, Set, <, INPUT, >, included, =, Sets, ., newHashSet, (, ), ;, Deque, <, INPUT, >, worklist, =]
[included, =, Sets, ., newHashSet, (, ), ;, Deque, <, INPUT, >, worklist, =, new, ArrayDeque, <, INPUT, >, (]
[(, ), ;, Deque, <, INPUT, >, worklist, =, new, ArrayDeque, <, INPUT, >, (, roots, ), ;, while, (]
[), ;, Deque, <, INPUT, >, worklist, =, new, ArrayDeque, <, INPUT, >, (, roots, ), ;, while, (, !]
[), ;, Deque, <, INPUT, >, worklist, =, new, ArrayDeque, <, INPUT, >, (, roots, ), ;, while, (, !]
[<, INPUT, >, (, roots, ), ;, while, (, !, worklist, ., isEmpty, (, ), ), {, INPUT, current, =]
[<, INPUT, >, (, roots, ), ;, while, (, !, worklist, ., isEmpty, (, ), ), {, INPUT, current, =]
[(, !, worklist, ., isEmpty, (, ), ), {, INPUT, current, =, worklist, ., pop, (, ), ;, if, (]
[(, !, worklist, ., isEmpty, (, ), ), {, INPUT, current, =, worklist, ., pop, (, ), ;, if, (]
[isEmpty, (, ), ), {, INPUT, current, =, worklist, ., pop, (, ), ;, if, (, included, ., add, (]
[., pop, (, ), ;, if, (, included, ., add, (, current, ), ), {, for, (, String, req, :]
[., pop, (, ), ;, if, (, included, ., add, (, current, ), ), {, for, (, String, req, :]
[(, current, ), ), {, for, (, String, req, :, current, ., getRequires, (, ), ), {, INPUT, dep, =]
[(, current, ), ), {, for, (, String, req, :, current, ., getRequires, (, ), ), {, INPUT, dep, =]
[{, for, (, String, req, :, current, ., getRequires, (, ), ), {, INPUT, dep, =, provideMap, ., get, (]
[:, current, ., getRequires, (, ), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (]
[:, current, ., getRequires, (, ), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (]
[., getRequires, (, ), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=]
[), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=, null, ), {]
[), ), {, INPUT, dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=, null, ), {]
[dep, =, provideMap, ., get, (, req, ), ;, if, (, dep, !=, null, ), {, worklist, ., add, (]
[{, worklist, ., add, (, dep, ), ;, }, }, }, }, ImmutableList, ., Builder, <, INPUT, >, builder, =]
[{, worklist, ., add, (, dep, ), ;, }, }, }, }, ImmutableList, ., Builder, <, INPUT, >, builder, =]
[}, ImmutableList, ., Builder, <, INPUT, >, builder, =, ImmutableList, ., builder, (, ), ;, for, (, INPUT, current, :]
[ImmutableList, ., Builder, <, INPUT, >, builder, =, ImmutableList, ., builder, (, ), ;, for, (, INPUT, current, :, (]
[ImmutableList, ., Builder, <, INPUT, >, builder, =, ImmutableList, ., builder, (, ), ;, for, (, INPUT, current, :, (]
[Builder, <, INPUT, >, builder, =, ImmutableList, ., builder, (, ), ;, for, (, INPUT, current, :, (, sorted, ?]
[INPUT, >, builder, =, ImmutableList, ., builder, (, ), ;, for, (, INPUT, current, :, (, sorted, ?, sortedList, :]
[builder, (, ), ;, for, (, INPUT, current, :, (, sorted, ?, sortedList, :, inputs, ), ), {, if, (]
[builder, (, ), ;, for, (, INPUT, current, :, (, sorted, ?, sortedList, :, inputs, ), ), {, if, (]
[for, (, INPUT, current, :, (, sorted, ?, sortedList, :, inputs, ), ), {, if, (, included, ., contains, (]
[:, (, sorted, ?, sortedList, :, inputs, ), ), {, if, (, included, ., contains, (, current, ), ), {]
[:, (, sorted, ?, sortedList, :, inputs, ), ), {, if, (, included, ., contains, (, current, ), ), {]
[sortedList, :, inputs, ), ), {, if, (, included, ., contains, (, current, ), ), {, builder, ., add, (]
[if, (, included, ., contains, (, current, ), ), {, builder, ., add, (, current, ), ;, }, }, return]
[if, (, included, ., contains, (, current, ), ), {, builder, ., add, (, current, ), ;, }, }, return]
[}, }, return, builder, ., build, (, ), ;, }, public, List, <, INPUT, >, getInputsWithoutProvides, (, ), {, return]
[}, }, return, builder, ., build, (, ), ;, }, public, List, <, INPUT, >, getInputsWithoutProvides, (, ), {, return]
[), ;, }, public, List, <, INPUT, >, getInputsWithoutProvides, (, ), {, return, Collections, ., <, INPUT, >, unmodifiableList, (]
[>, topologicalStableSort, (, List, <, T, >, items, ,, Multimap, <, T, ,, T, >, deps, ), {, if, (]
[>, topologicalStableSort, (, List, <, T, >, items, ,, Multimap, <, T, ,, T, >, deps, ), {, if, (]
[>, topologicalStableSort, (, List, <, T, >, items, ,, Multimap, <, T, ,, T, >, deps, ), {, if, (]
[>, items, ,, Multimap, <, T, ,, T, >, deps, ), {, if, (, items, ., size, (, ), ==]
[<, T, ,, T, >, deps, ), {, if, (, items, ., size, (, ), ==, 0, ), {, return]
[<, T, ,, T, >, deps, ), {, if, (, items, ., size, (, ), ==, 0, ), {, return]
[0, ), {, return, Lists, ., newArrayList, (, ), ;, }, final, Map, <, T, ,, Integer, >, originalIndex, =]
[0, ), {, return, Lists, ., newArrayList, (, ), ;, }, final, Map, <, T, ,, Integer, >, originalIndex, =]
[final, Map, <, T, ,, Integer, >, originalIndex, =, Maps, ., newHashMap, (, ), ;, for, (, int, i, =]
[<, T, ,, Integer, >, originalIndex, =, Maps, ., newHashMap, (, ), ;, for, (, int, i, =, 0, ;]
[<, T, ,, Integer, >, originalIndex, =, Maps, ., newHashMap, (, ), ;, for, (, int, i, =, 0, ;]
[,, Integer, >, originalIndex, =, Maps, ., newHashMap, (, ), ;, for, (, int, i, =, 0, ;, i, <]
[,, Integer, >, originalIndex, =, Maps, ., newHashMap, (, ), ;, for, (, int, i, =, 0, ;, i, <]
[., newHashMap, (, ), ;, for, (, int, i, =, 0, ;, i, <, items, ., size, (, ), ;]
[., newHashMap, (, ), ;, for, (, int, i, =, 0, ;, i, <, items, ., size, (, ), ;]
[;, for, (, int, i, =, 0, ;, i, <, items, ., size, (, ), ;, i, ++, ), {]
[;, for, (, int, i, =, 0, ;, i, <, items, ., size, (, ), ;, i, ++, ), {]
[i, =, 0, ;, i, <, items, ., size, (, ), ;, i, ++, ), {, originalIndex, ., put, (]
[i, =, 0, ;, i, <, items, ., size, (, ), ;, i, ++, ), {, originalIndex, ., put, (]
[i, <, items, ., size, (, ), ;, i, ++, ), {, originalIndex, ., put, (, items, ., get, (]
[., size, (, ), ;, i, ++, ), {, originalIndex, ., put, (, items, ., get, (, i, ), ,]
[., put, (, items, ., get, (, i, ), ,, i, ), ;, }, PriorityQueue, <, T, >, inDegreeZero, =]
[(, i, ), ,, i, ), ;, }, PriorityQueue, <, T, >, inDegreeZero, =, new, PriorityQueue, <, T, >, (]
[(, i, ), ,, i, ), ;, }, PriorityQueue, <, T, >, inDegreeZero, =, new, PriorityQueue, <, T, >, (]
[;, }, PriorityQueue, <, T, >, inDegreeZero, =, new, PriorityQueue, <, T, >, (, items, ., size, (, ), ,]
[<, T, >, (, ), {, @, Override, public, int, compare, (, T, a, ,, T, b, ), {, return]
[<, T, >, (, ), {, @, Override, public, int, compare, (, T, a, ,, T, b, ), {, return]
[<, T, >, (, ), {, @, Override, public, int, compare, (, T, a, ,, T, b, ), {, return]
[<, T, >, (, ), {, @, Override, public, int, compare, (, T, a, ,, T, b, ), {, return]
[), {, @, Override, public, int, compare, (, T, a, ,, T, b, ), {, return, originalIndex, ., get, (]
[(, T, a, ,, T, b, ), {, return, originalIndex, ., get, (, a, ), ., intValue, (, ), -]
[(, T, a, ,, T, b, ), {, return, originalIndex, ., get, (, a, ), ., intValue, (, ), -]
[(, T, a, ,, T, b, ), {, return, originalIndex, ., get, (, a, ), ., intValue, (, ), -]
[T, b, ), {, return, originalIndex, ., get, (, a, ), ., intValue, (, ), -, originalIndex, ., get, (]
[., get, (, b, ), ., intValue, (, ), ;, }, }, ), ;, List, <, T, >, result, =]
[., get, (, b, ), ., intValue, (, ), ;, }, }, ), ;, List, <, T, >, result, =]
[), ;, List, <, T, >, result, =, Lists, ., newArrayList, (, ), ;, Multiset, <, T, >, inDegree, =]
[), ;, List, <, T, >, result, =, Lists, ., newArrayList, (, ), ;, Multiset, <, T, >, inDegree, =]
[Multiset, <, T, >, inDegree, =, HashMultiset, ., create, (, ), ;, Multimap, <, T, ,, T, >, reverseDeps, =]
[Multiset, <, T, >, inDegree, =, HashMultiset, ., create, (, ), ;, Multimap, <, T, ,, T, >, reverseDeps, =]
[HashMultiset, ., create, (, ), ;, Multimap, <, T, ,, T, >, reverseDeps, =, ArrayListMultimap, ., create, (, ), ;]
[HashMultiset, ., create, (, ), ;, Multimap, <, T, ,, T, >, reverseDeps, =, ArrayListMultimap, ., create, (, ), ;]
[), ;, Multimap, <, T, ,, T, >, reverseDeps, =, ArrayListMultimap, ., create, (, ), ;, Multimaps, ., invertFrom, (]
[Multimap, <, T, ,, T, >, reverseDeps, =, ArrayListMultimap, ., create, (, ), ;, Multimaps, ., invertFrom, (, deps, ,]
[ArrayListMultimap, ., create, (, ), ;, Multimaps, ., invertFrom, (, deps, ,, reverseDeps, ), ;, for, (, T, item, :]
[(, deps, ,, reverseDeps, ), ;, for, (, T, item, :, items, ), {, Collection, <, T, >, itemDeps, =]
[(, deps, ,, reverseDeps, ), ;, for, (, T, item, :, items, ), {, Collection, <, T, >, itemDeps, =]
[), ;, for, (, T, item, :, items, ), {, Collection, <, T, >, itemDeps, =, deps, ., get, (]
[(, T, item, :, items, ), {, Collection, <, T, >, itemDeps, =, deps, ., get, (, item, ), ;]
[(, T, item, :, items, ), {, Collection, <, T, >, itemDeps, =, deps, ., get, (, item, ), ;]
[items, ), {, Collection, <, T, >, itemDeps, =, deps, ., get, (, item, ), ;, inDegree, ., add, (]
[{, Collection, <, T, >, itemDeps, =, deps, ., get, (, item, ), ;, inDegree, ., add, (, item, ,]
[{, Collection, <, T, >, itemDeps, =, deps, ., get, (, item, ), ;, inDegree, ., add, (, item, ,]
[get, (, item, ), ;, inDegree, ., add, (, item, ,, itemDeps, ., size, (, ), ), ;, if, (]
[get, (, item, ), ;, inDegree, ., add, (, item, ,, itemDeps, ., size, (, ), ), ;, if, (]
[add, (, item, ,, itemDeps, ., size, (, ), ), ;, if, (, itemDeps, ., isEmpty, (, ), ), {]
[add, (, item, ,, itemDeps, ., size, (, ), ), ;, if, (, itemDeps, ., isEmpty, (, ), ), {]
[itemDeps, ., size, (, ), ), ;, if, (, itemDeps, ., isEmpty, (, ), ), {, inDegreeZero, ., add, (]
[if, (, itemDeps, ., isEmpty, (, ), ), {, inDegreeZero, ., add, (, item, ), ;, }, }, while, (]
[(, itemDeps, ., isEmpty, (, ), ), {, inDegreeZero, ., add, (, item, ), ;, }, }, while, (, !]
[(, itemDeps, ., isEmpty, (, ), ), {, inDegreeZero, ., add, (, item, ), ;, }, }, while, (, !]
[add, (, item, ), ;, }, }, while, (, !, inDegreeZero, ., isEmpty, (, ), ), {, T, item, =]
[add, (, item, ), ;, }, }, while, (, !, inDegreeZero, ., isEmpty, (, ), ), {, T, item, =]
[}, while, (, !, inDegreeZero, ., isEmpty, (, ), ), {, T, item, =, inDegreeZero, ., remove, (, ), ;]
[}, while, (, !, inDegreeZero, ., isEmpty, (, ), ), {, T, item, =, inDegreeZero, ., remove, (, ), ;]
[inDegreeZero, ., isEmpty, (, ), ), {, T, item, =, inDegreeZero, ., remove, (, ), ;, result, ., add, (]
[item, =, inDegreeZero, ., remove, (, ), ;, result, ., add, (, item, ), ;, for, (, T, inWaiting, :]
[item, =, inDegreeZero, ., remove, (, ), ;, result, ., add, (, item, ), ;, for, (, T, inWaiting, :]
[remove, (, ), ;, result, ., add, (, item, ), ;, for, (, T, inWaiting, :, reverseDeps, ., get, (]
[result, ., add, (, item, ), ;, for, (, T, inWaiting, :, reverseDeps, ., get, (, item, ), ), {]
[result, ., add, (, item, ), ;, for, (, T, inWaiting, :, reverseDeps, ., get, (, item, ), ), {]
[item, ), ;, for, (, T, inWaiting, :, reverseDeps, ., get, (, item, ), ), {, inDegree, ., remove, (]
[;, for, (, T, inWaiting, :, reverseDeps, ., get, (, item, ), ), {, inDegree, ., remove, (, inWaiting, ,]
[:, reverseDeps, ., get, (, item, ), ), {, inDegree, ., remove, (, inWaiting, ,, 1, ), ;, if, (]
[:, reverseDeps, ., get, (, item, ), ), {, inDegree, ., remove, (, inWaiting, ,, 1, ), ;, if, (]
[:, reverseDeps, ., get, (, item, ), ), {, inDegree, ., remove, (, inWaiting, ,, 1, ), ;, if, (]
[(, item, ), ), {, inDegree, ., remove, (, inWaiting, ,, 1, ), ;, if, (, inDegree, ., count, (]
[), {, inDegree, ., remove, (, inWaiting, ,, 1, ), ;, if, (, inDegree, ., count, (, inWaiting, ), ==]
[., remove, (, inWaiting, ,, 1, ), ;, if, (, inDegree, ., count, (, inWaiting, ), ==, 0, ), {]
[., remove, (, inWaiting, ,, 1, ), ;, if, (, inDegree, ., count, (, inWaiting, ), ==, 0, ), {]
[,, 1, ), ;, if, (, inDegree, ., count, (, inWaiting, ), ==, 0, ), {, inDegreeZero, ., add, (]
[., count, (, inWaiting, ), ==, 0, ), {, inDegreeZero, ., add, (, inWaiting, ), ;, }, }, }, return]
[}, return, result, ;, }, public, static, class, CircularDependencyException, extends, Exception, {, CircularDependencyException, (, String, message, ), {, super, (]
[message, ), ;, }, }, public, static, class, MissingProvideException, extends, Exception, {, MissingProvideException, (, String, provide, ), {, super, (]
