[S, >, tree, ;, private, double, size, ;, private, Vector, <, S, >, barycenter, ;, protected, AbstractRegion, (, ), {]
[tree, ;, private, double, size, ;, private, Vector, <, S, >, barycenter, ;, protected, AbstractRegion, (, ), {, tree, =]
[private, Vector, <, S, >, barycenter, ;, protected, AbstractRegion, (, ), {, tree, =, new, BSPTree, <, S, >, (]
[private, Vector, <, S, >, barycenter, ;, protected, AbstractRegion, (, ), {, tree, =, new, BSPTree, <, S, >, (]
[S, >, (, Boolean, ., TRUE, ), ;, }, protected, AbstractRegion, (, final, BSPTree, <, S, >, tree, ), {]
[S, >, (, Boolean, ., TRUE, ), ;, }, protected, AbstractRegion, (, final, BSPTree, <, S, >, tree, ), {]
[., TRUE, ), ;, }, protected, AbstractRegion, (, final, BSPTree, <, S, >, tree, ), {, this, ., tree, =]
[=, tree, ;, }, protected, AbstractRegion, (, final, Collection, <, SubHyperplane, <, S, >, >, boundary, ), {, if, (]
[=, tree, ;, }, protected, AbstractRegion, (, final, Collection, <, SubHyperplane, <, S, >, >, boundary, ), {, if, (]
[=, tree, ;, }, protected, AbstractRegion, (, final, Collection, <, SubHyperplane, <, S, >, >, boundary, ), {, if, (]
[(, final, Collection, <, SubHyperplane, <, S, >, >, boundary, ), {, if, (, boundary, ., size, (, ), ==]
[<, SubHyperplane, <, S, >, >, boundary, ), {, if, (, boundary, ., size, (, ), ==, 0, ), {]
[<, S, >, >, boundary, ), {, if, (, boundary, ., size, (, ), ==, 0, ), {, tree, =]
[{, if, (, boundary, ., size, (, ), ==, 0, ), {, tree, =, new, BSPTree, <, S, >, (]
[{, if, (, boundary, ., size, (, ), ==, 0, ), {, tree, =, new, BSPTree, <, S, >, (]
[>, (, Boolean, ., TRUE, ), ;, }, else, {, final, TreeSet, <, SubHyperplane, <, S, >, >, ordered, =]
[{, final, TreeSet, <, SubHyperplane, <, S, >, >, ordered, =, new, TreeSet, <, SubHyperplane, <, S, >, >, (]
[(, final, SubHyperplane, <, S, >, o1, ,, final, SubHyperplane, <, S, >, o2, ), {, final, double, size1, =]
[(, final, SubHyperplane, <, S, >, o1, ,, final, SubHyperplane, <, S, >, o2, ), {, final, double, size1, =]
[<, S, >, o2, ), {, final, double, size1, =, o1, ., getSize, (, ), ;, final, double, size2, =]
[<, S, >, o2, ), {, final, double, size1, =, o1, ., getSize, (, ), ;, final, double, size2, =]
[double, size1, =, o1, ., getSize, (, ), ;, final, double, size2, =, o2, ., getSize, (, ), ;, return]
[double, size1, =, o1, ., getSize, (, ), ;, final, double, size2, =, o2, ., getSize, (, ), ;, return]
[size1, =, o1, ., getSize, (, ), ;, final, double, size2, =, o2, ., getSize, (, ), ;, return, (]
[size1, =, o1, ., getSize, (, ), ;, final, double, size2, =, o2, ., getSize, (, ), ;, return, (]
[o1, ., getSize, (, ), ;, final, double, size2, =, o2, ., getSize, (, ), ;, return, (, size2, <]
[(, ), ;, final, double, size2, =, o2, ., getSize, (, ), ;, return, (, size2, <, size1, ), ?]
[), ;, final, double, size2, =, o2, ., getSize, (, ), ;, return, (, size2, <, size1, ), ?, -]
[final, double, size2, =, o2, ., getSize, (, ), ;, return, (, size2, <, size1, ), ?, -, 1, :]
[double, size2, =, o2, ., getSize, (, ), ;, return, (, size2, <, size1, ), ?, -, 1, :, (]
[double, size2, =, o2, ., getSize, (, ), ;, return, (, size2, <, size1, ), ?, -, 1, :, (]
[size2, =, o2, ., getSize, (, ), ;, return, (, size2, <, size1, ), ?, -, 1, :, (, (]
[size2, =, o2, ., getSize, (, ), ;, return, (, size2, <, size1, ), ?, -, 1, :, (, (]
[o2, ., getSize, (, ), ;, return, (, size2, <, size1, ), ?, -, 1, :, (, (, o1, ==]
[(, ), ;, return, (, size2, <, size1, ), ?, -, 1, :, (, (, o1, ==, o2, ), ?]
[;, return, (, size2, <, size1, ), ?, -, 1, :, (, (, o1, ==, o2, ), ?, 0, :]
[return, (, size2, <, size1, ), ?, -, 1, :, (, (, o1, ==, o2, ), ?, 0, :, +]
[-, 1, :, (, (, o1, ==, o2, ), ?, 0, :, +, 1, ), ;, }, }, ), ;]
[-, 1, :, (, (, o1, ==, o2, ), ?, 0, :, +, 1, ), ;, }, }, ), ;]
[(, o1, ==, o2, ), ?, 0, :, +, 1, ), ;, }, }, ), ;, ordered, ., addAll, (]
[o2, ), ?, 0, :, +, 1, ), ;, }, }, ), ;, ordered, ., addAll, (, boundary, ), ;]
[?, 0, :, +, 1, ), ;, }, }, ), ;, ordered, ., addAll, (, boundary, ), ;, tree, =]
[}, ), ;, ordered, ., addAll, (, boundary, ), ;, tree, =, new, BSPTree, <, S, >, (, ), ;]
[;, ordered, ., addAll, (, boundary, ), ;, tree, =, new, BSPTree, <, S, >, (, ), ;, insertCuts, (]
[., addAll, (, boundary, ), ;, tree, =, new, BSPTree, <, S, >, (, ), ;, insertCuts, (, tree, ,]
[boundary, ), ;, tree, =, new, BSPTree, <, S, >, (, ), ;, insertCuts, (, tree, ,, ordered, ), ;]
[boundary, ), ;, tree, =, new, BSPTree, <, S, >, (, ), ;, insertCuts, (, tree, ,, ordered, ), ;]
[=, new, BSPTree, <, S, >, (, ), ;, insertCuts, (, tree, ,, ordered, ), ;, tree, ., visit, (]
[BSPTreeVisitor, <, S, >, (, ), {, public, Order, visitOrder, (, final, BSPTree, <, S, >, node, ), {, return]
[BSPTreeVisitor, <, S, >, (, ), {, public, Order, visitOrder, (, final, BSPTree, <, S, >, node, ), {, return]
[BSPTree, <, S, >, node, ), {, }, public, void, visitLeafNode, (, final, BSPTree, <, S, >, node, ), {]
[BSPTree, <, S, >, node, ), {, }, public, void, visitLeafNode, (, final, BSPTree, <, S, >, node, ), {]
[node, ), {, }, public, void, visitLeafNode, (, final, BSPTree, <, S, >, node, ), {, node, ., setAttribute, (]
[node, ), {, }, public, void, visitLeafNode, (, final, BSPTree, <, S, >, node, ), {, node, ., setAttribute, (]
[), {, }, public, void, visitLeafNode, (, final, BSPTree, <, S, >, node, ), {, node, ., setAttribute, (, (]
[), {, }, public, void, visitLeafNode, (, final, BSPTree, <, S, >, node, ), {, node, ., setAttribute, (, (]
[}, public, void, visitLeafNode, (, final, BSPTree, <, S, >, node, ), {, node, ., setAttribute, (, (, node, ==]
[}, public, void, visitLeafNode, (, final, BSPTree, <, S, >, node, ), {, node, ., setAttribute, (, (, node, ==]
[}, public, void, visitLeafNode, (, final, BSPTree, <, S, >, node, ), {, node, ., setAttribute, (, (, node, ==]
[), {, node, ., setAttribute, (, (, node, ==, node, ., getParent, (, ), ., getPlus, (, ), ), ?]
[), {, node, ., setAttribute, (, (, node, ==, node, ., getParent, (, ), ., getPlus, (, ), ), ?]
[setAttribute, (, (, node, ==, node, ., getParent, (, ), ., getPlus, (, ), ), ?, Boolean, ., FALSE, :]
[setAttribute, (, (, node, ==, node, ., getParent, (, ), ., getPlus, (, ), ), ?, Boolean, ., FALSE, :]
[}, ), ;, }, }, public, AbstractRegion, (, final, Hyperplane, <, S, >, [, ], hyperplanes, ), {, if, (]
[}, ), ;, }, }, public, AbstractRegion, (, final, Hyperplane, <, S, >, [, ], hyperplanes, ), {, if, (]
[), ;, }, }, public, AbstractRegion, (, final, Hyperplane, <, S, >, [, ], hyperplanes, ), {, if, (, (]
[), ;, }, }, public, AbstractRegion, (, final, Hyperplane, <, S, >, [, ], hyperplanes, ), {, if, (, (]
[}, }, public, AbstractRegion, (, final, Hyperplane, <, S, >, [, ], hyperplanes, ), {, if, (, (, hyperplanes, ==]
[AbstractRegion, (, final, Hyperplane, <, S, >, [, ], hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||]
[(, final, Hyperplane, <, S, >, [, ], hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||, (]
[(, final, Hyperplane, <, S, >, [, ], hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||, (]
[(, final, Hyperplane, <, S, >, [, ], hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||, (]
[S, >, [, ], hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||, (, hyperplanes, ., length, ==]
[hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||, (, hyperplanes, ., length, ==, 0, ), ), {]
[{, if, (, (, hyperplanes, ==, null, ), ||, (, hyperplanes, ., length, ==, 0, ), ), {, tree, =]
[null, ), ||, (, hyperplanes, ., length, ==, 0, ), ), {, tree, =, new, BSPTree, <, S, >, (]
[null, ), ||, (, hyperplanes, ., length, ==, 0, ), ), {, tree, =, new, BSPTree, <, S, >, (]
[0, ), ), {, tree, =, new, BSPTree, <, S, >, (, Boolean, ., FALSE, ), ;, }, else, {]
[), {, tree, =, new, BSPTree, <, S, >, (, Boolean, ., FALSE, ), ;, }, else, {, tree, =]
[), {, tree, =, new, BSPTree, <, S, >, (, Boolean, ., FALSE, ), ;, }, else, {, tree, =]
[), {, tree, =, new, BSPTree, <, S, >, (, Boolean, ., FALSE, ), ;, }, else, {, tree, =]
[), {, tree, =, new, BSPTree, <, S, >, (, Boolean, ., FALSE, ), ;, }, else, {, tree, =]
[tree, =, new, BSPTree, <, S, >, (, Boolean, ., FALSE, ), ;, }, else, {, tree, =, hyperplanes, []
[., FALSE, ), ;, }, else, {, tree, =, hyperplanes, [, 0, ], ., wholeSpace, (, ), ., getTree, (]
[hyperplanes, [, 0, ], ., wholeSpace, (, ), ., getTree, (, false, ), ;, BSPTree, <, S, >, node, =]
[0, ], ., wholeSpace, (, ), ., getTree, (, false, ), ;, BSPTree, <, S, >, node, =, tree, ;]
[0, ], ., wholeSpace, (, ), ., getTree, (, false, ), ;, BSPTree, <, S, >, node, =, tree, ;]
[(, ), ., getTree, (, false, ), ;, BSPTree, <, S, >, node, =, tree, ;, node, ., setAttribute, (]
[(, ), ., getTree, (, false, ), ;, BSPTree, <, S, >, node, =, tree, ;, node, ., setAttribute, (]
[tree, ;, node, ., setAttribute, (, Boolean, ., TRUE, ), ;, for, (, final, Hyperplane, <, S, >, hyperplane, :]
[(, Boolean, ., TRUE, ), ;, for, (, final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (]
[(, Boolean, ., TRUE, ), ;, for, (, final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (]
[), ;, for, (, final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (, node, ., insertCut, (]
[final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {]
[final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {]
[>, hyperplane, :, hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {, node, ., setAttribute, (]
[hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;]
[hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;]
[hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;]
[(, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (]
[(, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (]
[node, ., setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;]
[setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;, node, =]
[setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;, node, =]
[., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;, node, =, node, ., getMinus, (, ), ;]
[., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;, node, =, node, ., getMinus, (, ), ;]
[., setAttribute, (, Boolean, ., FALSE, ), ;, node, =, node, ., getMinus, (, ), ;, node, ., setAttribute, (]
[., setAttribute, (, Boolean, ., FALSE, ), ;, node, =, node, ., getMinus, (, ), ;, node, ., setAttribute, (]
[Collection, <, SubHyperplane, <, S, >, >, boundary, ), {, final, Iterator, <, SubHyperplane, <, S, >, >, iterator, =]
[Collection, <, SubHyperplane, <, S, >, >, boundary, ), {, final, Iterator, <, SubHyperplane, <, S, >, >, iterator, =]
[<, SubHyperplane, <, S, >, >, iterator, =, boundary, ., iterator, (, ), ;, Hyperplane, <, S, >, inserted, =]
[>, >, iterator, =, boundary, ., iterator, (, ), ;, Hyperplane, <, S, >, inserted, =, null, ;, while, (]
[>, >, iterator, =, boundary, ., iterator, (, ), ;, Hyperplane, <, S, >, inserted, =, null, ;, while, (]
[>, iterator, =, boundary, ., iterator, (, ), ;, Hyperplane, <, S, >, inserted, =, null, ;, while, (, (]
[>, iterator, =, boundary, ., iterator, (, ), ;, Hyperplane, <, S, >, inserted, =, null, ;, while, (, (]
[=, boundary, ., iterator, (, ), ;, Hyperplane, <, S, >, inserted, =, null, ;, while, (, (, inserted, ==]
[iterator, (, ), ;, Hyperplane, <, S, >, inserted, =, null, ;, while, (, (, inserted, ==, null, ), &&]
[iterator, (, ), ;, Hyperplane, <, S, >, inserted, =, null, ;, while, (, (, inserted, ==, null, ), &&]
[>, inserted, =, null, ;, while, (, (, inserted, ==, null, ), &&, iterator, ., hasNext, (, ), ), {]
[=, null, ;, while, (, (, inserted, ==, null, ), &&, iterator, ., hasNext, (, ), ), {, inserted, =]
[=, null, ;, while, (, (, inserted, ==, null, ), &&, iterator, ., hasNext, (, ), ), {, inserted, =]
[=, null, ;, while, (, (, inserted, ==, null, ), &&, iterator, ., hasNext, (, ), ), {, inserted, =]
[., hasNext, (, ), ), {, inserted, =, iterator, ., next, (, ), ., getHyperplane, (, ), ;, if, (]
[hasNext, (, ), ), {, inserted, =, iterator, ., next, (, ), ., getHyperplane, (, ), ;, if, (, !]
[hasNext, (, ), ), {, inserted, =, iterator, ., next, (, ), ., getHyperplane, (, ), ;, if, (, !]
[{, inserted, =, iterator, ., next, (, ), ., getHyperplane, (, ), ;, if, (, !, node, ., insertCut, (]
[{, inserted, =, iterator, ., next, (, ), ., getHyperplane, (, ), ;, if, (, !, node, ., insertCut, (]
[., getHyperplane, (, ), ;, if, (, !, node, ., insertCut, (, inserted, ., copySelf, (, ), ), ), {]
[(, ), ;, if, (, !, node, ., insertCut, (, inserted, ., copySelf, (, ), ), ), {, inserted, =]
[node, ., insertCut, (, inserted, ., copySelf, (, ), ), ), {, inserted, =, null, ;, }, }, if, (]
[., insertCut, (, inserted, ., copySelf, (, ), ), ), {, inserted, =, null, ;, }, }, if, (, !]
[., insertCut, (, inserted, ., copySelf, (, ), ), ), {, inserted, =, null, ;, }, }, if, (, !]
[iterator, ., hasNext, (, ), ), {, return, ;, }, final, ArrayList, <, SubHyperplane, <, S, >, >, plusList, =]
[ArrayList, <, SubHyperplane, <, S, >, >, (, ), ;, final, ArrayList, <, SubHyperplane, <, S, >, >, minusList, =]
[SubHyperplane, <, S, >, >, minusList, =, new, ArrayList, <, SubHyperplane, <, S, >, >, (, ), ;, while, (]
[SubHyperplane, <, S, >, >, minusList, =, new, ArrayList, <, SubHyperplane, <, S, >, >, (, ), ;, while, (]
[>, (, ), ;, while, (, iterator, ., hasNext, (, ), ), {, final, SubHyperplane, <, S, >, other, =]
[>, (, ), ;, while, (, iterator, ., hasNext, (, ), ), {, final, SubHyperplane, <, S, >, other, =]
[hasNext, (, ), ), {, final, SubHyperplane, <, S, >, other, =, iterator, ., next, (, ), ;, switch, (]
[hasNext, (, ), ), {, final, SubHyperplane, <, S, >, other, =, iterator, ., next, (, ), ;, switch, (]
[{, final, SubHyperplane, <, S, >, other, =, iterator, ., next, (, ), ;, switch, (, other, ., side, (]
[>, other, =, iterator, ., next, (, ), ;, switch, (, other, ., side, (, inserted, ), ), {, case]
[=, iterator, ., next, (, ), ;, switch, (, other, ., side, (, inserted, ), ), {, case, PLUS, :]
[=, iterator, ., next, (, ), ;, switch, (, other, ., side, (, inserted, ), ), {, case, PLUS, :]
[(, ), ;, switch, (, other, ., side, (, inserted, ), ), {, case, PLUS, :, plusList, ., add, (]
[., side, (, inserted, ), ), {, case, PLUS, :, plusList, ., add, (, other, ), ;, break, ;, case]
[(, inserted, ), ), {, case, PLUS, :, plusList, ., add, (, other, ), ;, break, ;, case, MINUS, :]
[(, inserted, ), ), {, case, PLUS, :, plusList, ., add, (, other, ), ;, break, ;, case, MINUS, :]
[{, case, PLUS, :, plusList, ., add, (, other, ), ;, break, ;, case, MINUS, :, minusList, ., add, (]
[add, (, other, ), ;, break, ;, case, MINUS, :, minusList, ., add, (, other, ), ;, break, ;, case]
[., add, (, other, ), ;, break, ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =]
[., add, (, other, ), ;, break, ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =]
[), ;, break, ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, other, ., split, (]
[;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, other, ., split, (, inserted, ), ;]
[;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, other, ., split, (, inserted, ), ;]
[final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, other, ., split, (, inserted, ), ;, plusList, ., add, (]
[final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, other, ., split, (, inserted, ), ;, plusList, ., add, (]
[split, =, other, ., split, (, inserted, ), ;, plusList, ., add, (, split, ., getPlus, (, ), ), ;]
[split, =, other, ., split, (, inserted, ), ;, plusList, ., add, (, split, ., getPlus, (, ), ), ;]
[split, (, inserted, ), ;, plusList, ., add, (, split, ., getPlus, (, ), ), ;, minusList, ., add, (]
[split, (, inserted, ), ;, plusList, ., add, (, split, ., getPlus, (, ), ), ;, minusList, ., add, (]
[), ), ;, minusList, ., add, (, split, ., getMinus, (, ), ), ;, break, ;, default, :, }, }]
[;, minusList, ., add, (, split, ., getMinus, (, ), ), ;, break, ;, default, :, }, }, insertCuts, (]
[;, minusList, ., add, (, split, ., getMinus, (, ), ), ;, break, ;, default, :, }, }, insertCuts, (]
[., getMinus, (, ), ), ;, break, ;, default, :, }, }, insertCuts, (, node, ., getPlus, (, ), ,]
[), ), ;, break, ;, default, :, }, }, insertCuts, (, node, ., getPlus, (, ), ,, plusList, ), ;]
[;, break, ;, default, :, }, }, insertCuts, (, node, ., getPlus, (, ), ,, plusList, ), ;, insertCuts, (]
[;, break, ;, default, :, }, }, insertCuts, (, node, ., getPlus, (, ), ,, plusList, ), ;, insertCuts, (]
[}, insertCuts, (, node, ., getPlus, (, ), ,, plusList, ), ;, insertCuts, (, node, ., getMinus, (, ), ,]
[getMinus, (, ), ,, minusList, ), ;, }, public, AbstractRegion, <, S, ,, T, >, copySelf, (, ), {, return]
[), ,, minusList, ), ;, }, public, AbstractRegion, <, S, ,, T, >, copySelf, (, ), {, return, buildNew, (]
[), ,, minusList, ), ;, }, public, AbstractRegion, <, S, ,, T, >, copySelf, (, ), {, return, buildNew, (]
[), {, return, buildNew, (, tree, ., copySelf, (, ), ), ;, }, public, boolean, isEmpty, (, ), {, return]
[return, buildNew, (, tree, ., copySelf, (, ), ), ;, }, public, boolean, isEmpty, (, ), {, return, isEmpty, (]
[isEmpty, (, tree, ), ;, }, public, boolean, isEmpty, (, final, BSPTree, <, S, >, node, ), {, if, (]
[isEmpty, (, tree, ), ;, }, public, boolean, isEmpty, (, final, BSPTree, <, S, >, node, ), {, if, (]
[isEmpty, (, tree, ), ;, }, public, boolean, isEmpty, (, final, BSPTree, <, S, >, node, ), {, if, (]
[public, boolean, isEmpty, (, final, BSPTree, <, S, >, node, ), {, if, (, node, ., getCut, (, ), ==]
[final, BSPTree, <, S, >, node, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return]
[BSPTree, <, S, >, node, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, !]
[<, S, >, node, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, !, (]
[node, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, !, (, (, Boolean, )]
[node, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, !, (, (, Boolean, )]
[), ==, null, ), {, return, !, (, (, Boolean, ), node, ., getAttribute, (, ), ), ;, }, return]
[), ==, null, ), {, return, !, (, (, Boolean, ), node, ., getAttribute, (, ), ), ;, }, return]
[null, ), {, return, !, (, (, Boolean, ), node, ., getAttribute, (, ), ), ;, }, return, isEmpty, (]
[null, ), {, return, !, (, (, Boolean, ), node, ., getAttribute, (, ), ), ;, }, return, isEmpty, (]
[Boolean, ), node, ., getAttribute, (, ), ), ;, }, return, isEmpty, (, node, ., getMinus, (, ), ), &&]
[node, ., getAttribute, (, ), ), ;, }, return, isEmpty, (, node, ., getMinus, (, ), ), &&, isEmpty, (]
[node, ., getAttribute, (, ), ), ;, }, return, isEmpty, (, node, ., getMinus, (, ), ), &&, isEmpty, (]
[., getPlus, (, ), ), ;, }, public, boolean, contains, (, final, Region, <, S, >, region, ), {, return]
[., getPlus, (, ), ), ;, }, public, boolean, contains, (, final, Region, <, S, >, region, ), {, return]
[., getPlus, (, ), ), ;, }, public, boolean, contains, (, final, Region, <, S, >, region, ), {, return]
[(, final, Region, <, S, >, region, ), {, return, new, RegionFactory, <, S, >, (, ), ., difference, (]
[Region, <, S, >, region, ), {, return, new, RegionFactory, <, S, >, (, ), ., difference, (, region, ,]
[), ., isEmpty, (, ), ;, }, public, Location, checkPoint, (, final, Vector, <, S, >, point, ), {, return]
[isEmpty, (, ), ;, }, public, Location, checkPoint, (, final, Vector, <, S, >, point, ), {, return, checkPoint, (]
[), ;, }, public, Location, checkPoint, (, final, Vector, <, S, >, point, ), {, return, checkPoint, (, tree, ,]
[<, S, >, node, ,, final, Vector, <, S, >, point, ), {, final, BSPTree, <, S, >, cell, =]
[<, S, >, node, ,, final, Vector, <, S, >, point, ), {, final, BSPTree, <, S, >, cell, =]
[,, final, Vector, <, S, >, point, ), {, final, BSPTree, <, S, >, cell, =, node, ., getCell, (]
[>, point, ), {, final, BSPTree, <, S, >, cell, =, node, ., getCell, (, point, ), ;, if, (]
[>, point, ), {, final, BSPTree, <, S, >, cell, =, node, ., getCell, (, point, ), ;, if, (]
[>, point, ), {, final, BSPTree, <, S, >, cell, =, node, ., getCell, (, point, ), ;, if, (]
[<, S, >, cell, =, node, ., getCell, (, point, ), ;, if, (, cell, ., getCut, (, ), ==]
[=, node, ., getCell, (, point, ), ;, if, (, cell, ., getCut, (, ), ==, null, ), {, return]
[=, node, ., getCell, (, point, ), ;, if, (, cell, ., getCut, (, ), ==, null, ), {, return]
[node, ., getCell, (, point, ), ;, if, (, cell, ., getCut, (, ), ==, null, ), {, return, (]
[(, point, ), ;, if, (, cell, ., getCut, (, ), ==, null, ), {, return, (, (, Boolean, )]
[(, point, ), ;, if, (, cell, ., getCut, (, ), ==, null, ), {, return, (, (, Boolean, )]
[., getCut, (, ), ==, null, ), {, return, (, (, Boolean, ), cell, ., getAttribute, (, ), ), ?]
[., getCut, (, ), ==, null, ), {, return, (, (, Boolean, ), cell, ., getAttribute, (, ), ), ?]
[==, null, ), {, return, (, (, Boolean, ), cell, ., getAttribute, (, ), ), ?, Location, ., INSIDE, :]
[==, null, ), {, return, (, (, Boolean, ), cell, ., getAttribute, (, ), ), ?, Location, ., INSIDE, :]
[cell, ., getAttribute, (, ), ), ?, Location, ., INSIDE, :, Location, ., OUTSIDE, ;, }, final, Location, minusCode, =]
[getAttribute, (, ), ), ?, Location, ., INSIDE, :, Location, ., OUTSIDE, ;, }, final, Location, minusCode, =, checkPoint, (]
[getAttribute, (, ), ), ?, Location, ., INSIDE, :, Location, ., OUTSIDE, ;, }, final, Location, minusCode, =, checkPoint, (]
[., INSIDE, :, Location, ., OUTSIDE, ;, }, final, Location, minusCode, =, checkPoint, (, cell, ., getMinus, (, ), ,]
[}, final, Location, minusCode, =, checkPoint, (, cell, ., getMinus, (, ), ,, point, ), ;, final, Location, plusCode, =]
[Location, minusCode, =, checkPoint, (, cell, ., getMinus, (, ), ,, point, ), ;, final, Location, plusCode, =, checkPoint, (]
[Location, minusCode, =, checkPoint, (, cell, ., getMinus, (, ), ,, point, ), ;, final, Location, plusCode, =, checkPoint, (]
[., getMinus, (, ), ,, point, ), ;, final, Location, plusCode, =, checkPoint, (, cell, ., getPlus, (, ), ,]
[,, point, ), ;, final, Location, plusCode, =, checkPoint, (, cell, ., getPlus, (, ), ,, point, ), ;, return]
[,, point, ), ;, final, Location, plusCode, =, checkPoint, (, cell, ., getPlus, (, ), ,, point, ), ;, return]
[point, ), ;, final, Location, plusCode, =, checkPoint, (, cell, ., getPlus, (, ), ,, point, ), ;, return, (]
[point, ), ;, final, Location, plusCode, =, checkPoint, (, cell, ., getPlus, (, ), ,, point, ), ;, return, (]
[;, final, Location, plusCode, =, checkPoint, (, cell, ., getPlus, (, ), ,, point, ), ;, return, (, minusCode, ==]
[plusCode, =, checkPoint, (, cell, ., getPlus, (, ), ,, point, ), ;, return, (, minusCode, ==, plusCode, ), ?]
[checkPoint, (, cell, ., getPlus, (, ), ,, point, ), ;, return, (, minusCode, ==, plusCode, ), ?, minusCode, :]
[checkPoint, (, cell, ., getPlus, (, ), ,, point, ), ;, return, (, minusCode, ==, plusCode, ), ?, minusCode, :]
[:, Location, ., BOUNDARY, ;, }, public, BSPTree, <, S, >, getTree, (, final, boolean, includeBoundaryAttributes, ), {, if, (]
[:, Location, ., BOUNDARY, ;, }, public, BSPTree, <, S, >, getTree, (, final, boolean, includeBoundaryAttributes, ), {, if, (]
[:, Location, ., BOUNDARY, ;, }, public, BSPTree, <, S, >, getTree, (, final, boolean, includeBoundaryAttributes, ), {, if, (]
[., BOUNDARY, ;, }, public, BSPTree, <, S, >, getTree, (, final, boolean, includeBoundaryAttributes, ), {, if, (, includeBoundaryAttributes, &&]
[BOUNDARY, ;, }, public, BSPTree, <, S, >, getTree, (, final, boolean, includeBoundaryAttributes, ), {, if, (, includeBoundaryAttributes, &&, (]
[BOUNDARY, ;, }, public, BSPTree, <, S, >, getTree, (, final, boolean, includeBoundaryAttributes, ), {, if, (, includeBoundaryAttributes, &&, (]
[BOUNDARY, ;, }, public, BSPTree, <, S, >, getTree, (, final, boolean, includeBoundaryAttributes, ), {, if, (, includeBoundaryAttributes, &&, (]
[S, >, getTree, (, final, boolean, includeBoundaryAttributes, ), {, if, (, includeBoundaryAttributes, &&, (, tree, ., getCut, (, ), !=]
[(, final, boolean, includeBoundaryAttributes, ), {, if, (, includeBoundaryAttributes, &&, (, tree, ., getCut, (, ), !=, null, ), &&]
[final, boolean, includeBoundaryAttributes, ), {, if, (, includeBoundaryAttributes, &&, (, tree, ., getCut, (, ), !=, null, ), &&, (]
[final, boolean, includeBoundaryAttributes, ), {, if, (, includeBoundaryAttributes, &&, (, tree, ., getCut, (, ), !=, null, ), &&, (]
[final, boolean, includeBoundaryAttributes, ), {, if, (, includeBoundaryAttributes, &&, (, tree, ., getCut, (, ), !=, null, ), &&, (]
[(, includeBoundaryAttributes, &&, (, tree, ., getCut, (, ), !=, null, ), &&, (, tree, ., getAttribute, (, ), ==]
[tree, ., getCut, (, ), !=, null, ), &&, (, tree, ., getAttribute, (, ), ==, null, ), ), {]
[tree, ., getCut, (, ), !=, null, ), &&, (, tree, ., getAttribute, (, ), ==, null, ), ), {]
[), !=, null, ), &&, (, tree, ., getAttribute, (, ), ==, null, ), ), {, tree, ., visit, (]
[==, null, ), ), {, tree, ., visit, (, new, BoundaryBuilder, <, S, >, (, ), ), ;, }, return]
[Space, >, implements, BSPTreeVisitor, <, S, >, {, public, Order, visitOrder, (, BSPTree, <, S, >, node, ), {, return]
[Space, >, implements, BSPTreeVisitor, <, S, >, {, public, Order, visitOrder, (, BSPTree, <, S, >, node, ), {, return]
[PLUS_MINUS_SUB, ;, }, public, void, visitInternalNode, (, BSPTree, <, S, >, node, ), {, SubHyperplane, <, S, >, plusOutside, =]
[<, S, >, node, ), {, SubHyperplane, <, S, >, plusOutside, =, null, ;, SubHyperplane, <, S, >, plusInside, =]
[>, node, ), {, SubHyperplane, <, S, >, plusOutside, =, null, ;, SubHyperplane, <, S, >, plusInside, =, null, ;]
[{, SubHyperplane, <, S, >, plusOutside, =, null, ;, SubHyperplane, <, S, >, plusInside, =, null, ;, @, SuppressWarnings, (]
[S, >, plusInside, =, null, ;, @, SuppressWarnings, (, "unchecked", ), final, SubHyperplane, <, S, >, [, ], plusChar, =]
[(, "unchecked", ), final, SubHyperplane, <, S, >, [, ], plusChar, =, (, SubHyperplane, <, S, >, [, ], )]
[(, "unchecked", ), final, SubHyperplane, <, S, >, [, ], plusChar, =, (, SubHyperplane, <, S, >, [, ], )]
[SubHyperplane, <, S, >, [, ], plusChar, =, (, SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (]
[[, ], plusChar, =, (, SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,]
[=, (, SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;]
[SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (]
[SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (]
[), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getPlus, (, ), ,]
[), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getPlus, (, ), ,]
[), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getPlus, (, ), ,]
[), ;, characterize, (, node, ., getPlus, (, ), ,, node, ., getCut, (, ), ., copySelf, (, ), ,]
[., getPlus, (, ), ,, node, ., getCut, (, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (]
[., getPlus, (, ), ,, node, ., getCut, (, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (]
[., getPlus, (, ), ,, node, ., getCut, (, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (]
[., getPlus, (, ), ,, node, ., getCut, (, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (]
[(, ), ,, node, ., getCut, (, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (, plusChar, []
[node, ., getCut, (, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (, plusChar, [, 0, ], !=]
[getCut, (, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (, plusChar, [, 0, ], !=, null, &&]
[(, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (, plusChar, [, 0, ], !=, null, &&, !]
[(, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (, plusChar, [, 0, ], !=, null, &&, !]
[(, ), ., copySelf, (, ), ,, plusChar, ), ;, if, (, plusChar, [, 0, ], !=, null, &&, !]
[., copySelf, (, ), ,, plusChar, ), ;, if, (, plusChar, [, 0, ], !=, null, &&, !, plusChar, []
[if, (, plusChar, [, 0, ], !=, null, &&, !, plusChar, [, 0, ], ., isEmpty, (, ), ), {]
[[, 0, ], !=, null, &&, !, plusChar, [, 0, ], ., isEmpty, (, ), ), {, @, SuppressWarnings, (]
[., isEmpty, (, ), ), {, @, SuppressWarnings, (, "unchecked", ), final, SubHyperplane, <, S, >, [, ], minusChar, =]
[(, "unchecked", ), final, SubHyperplane, <, S, >, [, ], minusChar, =, (, SubHyperplane, <, S, >, [, ], )]
[(, "unchecked", ), final, SubHyperplane, <, S, >, [, ], minusChar, =, (, SubHyperplane, <, S, >, [, ], )]
[SubHyperplane, <, S, >, [, ], minusChar, =, (, SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (]
[[, ], minusChar, =, (, SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,]
[=, (, SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;]
[SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (]
[SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (]
[), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getMinus, (, ), ,]
[), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getMinus, (, ), ,]
[., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, []
[SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 0, ], ,]
[), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (]
[), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (]
[), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (]
[), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (]
[characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (, minusChar, []
[., getMinus, (, ), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (, minusChar, [, 1, ], !=]
[(, ), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (, minusChar, [, 1, ], !=, null, &&]
[), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (, minusChar, [, 1, ], !=, null, &&, !]
[), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (, minusChar, [, 1, ], !=, null, &&, !]
[), ,, plusChar, [, 0, ], ,, minusChar, ), ;, if, (, minusChar, [, 1, ], !=, null, &&, !]
[plusChar, [, 0, ], ,, minusChar, ), ;, if, (, minusChar, [, 1, ], !=, null, &&, !, minusChar, []
[if, (, minusChar, [, 1, ], !=, null, &&, !, minusChar, [, 1, ], ., isEmpty, (, ), ), {]
[minusChar, [, 1, ], !=, null, &&, !, minusChar, [, 1, ], ., isEmpty, (, ), ), {, plusOutside, =]
[minusChar, [, 1, ], !=, null, &&, !, minusChar, [, 1, ], ., isEmpty, (, ), ), {, plusOutside, =]
[1, ], !=, null, &&, !, minusChar, [, 1, ], ., isEmpty, (, ), ), {, plusOutside, =, minusChar, []
[[, 1, ], ., isEmpty, (, ), ), {, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (]
[[, 1, ], ., isEmpty, (, ), ), {, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (]
[[, 1, ], ., isEmpty, (, ), ), {, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (]
[[, 1, ], ., isEmpty, (, ), ), {, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (]
[], ., isEmpty, (, ), ), {, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (, plusChar, []
[(, ), ), {, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (, plusChar, [, 1, ], !=]
[), {, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (, plusChar, [, 1, ], !=, null, &&]
[{, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (, plusChar, [, 1, ], !=, null, &&, !]
[{, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (, plusChar, [, 1, ], !=, null, &&, !]
[{, plusOutside, =, minusChar, [, 1, ], ;, }, }, if, (, plusChar, [, 1, ], !=, null, &&, !]
[=, minusChar, [, 1, ], ;, }, }, if, (, plusChar, [, 1, ], !=, null, &&, !, plusChar, []
[if, (, plusChar, [, 1, ], !=, null, &&, !, plusChar, [, 1, ], ., isEmpty, (, ), ), {]
[[, 1, ], !=, null, &&, !, plusChar, [, 1, ], ., isEmpty, (, ), ), {, @, SuppressWarnings, (]
[., isEmpty, (, ), ), {, @, SuppressWarnings, (, "unchecked", ), final, SubHyperplane, <, S, >, [, ], minusChar, =]
[(, "unchecked", ), final, SubHyperplane, <, S, >, [, ], minusChar, =, (, SubHyperplane, <, S, >, [, ], )]
[(, "unchecked", ), final, SubHyperplane, <, S, >, [, ], minusChar, =, (, SubHyperplane, <, S, >, [, ], )]
[SubHyperplane, <, S, >, [, ], minusChar, =, (, SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (]
[[, ], minusChar, =, (, SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,]
[=, (, SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;]
[SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (]
[SubHyperplane, <, S, >, [, ], ), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (]
[), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getMinus, (, ), ,]
[), Array, ., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getMinus, (, ), ,]
[., newInstance, (, SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, []
[SubHyperplane, ., class, ,, 2, ), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 1, ], ,]
[), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (]
[), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (]
[), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (]
[), ;, characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (]
[characterize, (, node, ., getMinus, (, ), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (, minusChar, []
[., getMinus, (, ), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (, minusChar, [, 0, ], !=]
[(, ), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (, minusChar, [, 0, ], !=, null, &&]
[), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (, minusChar, [, 0, ], !=, null, &&, !]
[), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (, minusChar, [, 0, ], !=, null, &&, !]
[), ,, plusChar, [, 1, ], ,, minusChar, ), ;, if, (, minusChar, [, 0, ], !=, null, &&, !]
[plusChar, [, 1, ], ,, minusChar, ), ;, if, (, minusChar, [, 0, ], !=, null, &&, !, minusChar, []
[if, (, minusChar, [, 0, ], !=, null, &&, !, minusChar, [, 0, ], ., isEmpty, (, ), ), {]
[minusChar, [, 0, ], !=, null, &&, !, minusChar, [, 0, ], ., isEmpty, (, ), ), {, plusInside, =]
[minusChar, [, 0, ], !=, null, &&, !, minusChar, [, 0, ], ., isEmpty, (, ), ), {, plusInside, =]
[0, ], !=, null, &&, !, minusChar, [, 0, ], ., isEmpty, (, ), ), {, plusInside, =, minusChar, []
[!, minusChar, [, 0, ], ., isEmpty, (, ), ), {, plusInside, =, minusChar, [, 0, ], ;, }, }]
[!, minusChar, [, 0, ], ., isEmpty, (, ), ), {, plusInside, =, minusChar, [, 0, ], ;, }, }]
[], ., isEmpty, (, ), ), {, plusInside, =, minusChar, [, 0, ], ;, }, }, node, ., setAttribute, (]
[{, plusInside, =, minusChar, [, 0, ], ;, }, }, node, ., setAttribute, (, new, BoundaryAttribute, <, S, >, (]
[=, minusChar, [, 0, ], ;, }, }, node, ., setAttribute, (, new, BoundaryAttribute, <, S, >, (, plusOutside, ,]
[,, final, SubHyperplane, <, S, >, sub, ,, final, SubHyperplane, <, S, >, [, ], characterization, ), {, if, (]
[,, final, SubHyperplane, <, S, >, sub, ,, final, SubHyperplane, <, S, >, [, ], characterization, ), {, if, (]
[,, final, SubHyperplane, <, S, >, sub, ,, final, SubHyperplane, <, S, >, [, ], characterization, ), {, if, (]
[sub, ,, final, SubHyperplane, <, S, >, [, ], characterization, ), {, if, (, node, ., getCut, (, ), ==]
[[, ], characterization, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, final, boolean, inside, =]
[), {, if, (, node, ., getCut, (, ), ==, null, ), {, final, boolean, inside, =, (, Boolean, )]
[), {, if, (, node, ., getCut, (, ), ==, null, ), {, final, boolean, inside, =, (, Boolean, )]
[), ==, null, ), {, final, boolean, inside, =, (, Boolean, ), node, ., getAttribute, (, ), ;, if, (]
[final, boolean, inside, =, (, Boolean, ), node, ., getAttribute, (, ), ;, if, (, inside, ), {, if, (]
[final, boolean, inside, =, (, Boolean, ), node, ., getAttribute, (, ), ;, if, (, inside, ), {, if, (]
[final, boolean, inside, =, (, Boolean, ), node, ., getAttribute, (, ), ;, if, (, inside, ), {, if, (]
[inside, =, (, Boolean, ), node, ., getAttribute, (, ), ;, if, (, inside, ), {, if, (, characterization, []
[Boolean, ), node, ., getAttribute, (, ), ;, if, (, inside, ), {, if, (, characterization, [, 1, ], ==]
[., getAttribute, (, ), ;, if, (, inside, ), {, if, (, characterization, [, 1, ], ==, null, ), {]
[., getAttribute, (, ), ;, if, (, inside, ), {, if, (, characterization, [, 1, ], ==, null, ), {]
[(, ), ;, if, (, inside, ), {, if, (, characterization, [, 1, ], ==, null, ), {, characterization, []
[if, (, inside, ), {, if, (, characterization, [, 1, ], ==, null, ), {, characterization, [, 1, ], =]
[if, (, characterization, [, 1, ], ==, null, ), {, characterization, [, 1, ], =, sub, ;, }, else, {]
[if, (, characterization, [, 1, ], ==, null, ), {, characterization, [, 1, ], =, sub, ;, }, else, {]
[characterization, [, 1, ], ==, null, ), {, characterization, [, 1, ], =, sub, ;, }, else, {, characterization, []
[], ==, null, ), {, characterization, [, 1, ], =, sub, ;, }, else, {, characterization, [, 1, ], =]
[], ==, null, ), {, characterization, [, 1, ], =, sub, ;, }, else, {, characterization, [, 1, ], =]
[], ==, null, ), {, characterization, [, 1, ], =, sub, ;, }, else, {, characterization, [, 1, ], =]
[null, ), {, characterization, [, 1, ], =, sub, ;, }, else, {, characterization, [, 1, ], =, characterization, []
[1, ], =, sub, ;, }, else, {, characterization, [, 1, ], =, characterization, [, 1, ], ., reunite, (]
[[, 1, ], =, characterization, [, 1, ], ., reunite, (, sub, ), ;, }, }, else, {, if, (]
[[, 1, ], =, characterization, [, 1, ], ., reunite, (, sub, ), ;, }, }, else, {, if, (]
[[, 1, ], =, characterization, [, 1, ], ., reunite, (, sub, ), ;, }, }, else, {, if, (]
[], =, characterization, [, 1, ], ., reunite, (, sub, ), ;, }, }, else, {, if, (, characterization, []
[[, 1, ], ., reunite, (, sub, ), ;, }, }, else, {, if, (, characterization, [, 0, ], ==]
[., reunite, (, sub, ), ;, }, }, else, {, if, (, characterization, [, 0, ], ==, null, ), {]
[., reunite, (, sub, ), ;, }, }, else, {, if, (, characterization, [, 0, ], ==, null, ), {]
[(, sub, ), ;, }, }, else, {, if, (, characterization, [, 0, ], ==, null, ), {, characterization, []
[;, }, }, else, {, if, (, characterization, [, 0, ], ==, null, ), {, characterization, [, 0, ], =]
[if, (, characterization, [, 0, ], ==, null, ), {, characterization, [, 0, ], =, sub, ;, }, else, {]
[if, (, characterization, [, 0, ], ==, null, ), {, characterization, [, 0, ], =, sub, ;, }, else, {]
[characterization, [, 0, ], ==, null, ), {, characterization, [, 0, ], =, sub, ;, }, else, {, characterization, []
[], ==, null, ), {, characterization, [, 0, ], =, sub, ;, }, else, {, characterization, [, 0, ], =]
[], ==, null, ), {, characterization, [, 0, ], =, sub, ;, }, else, {, characterization, [, 0, ], =]
[], ==, null, ), {, characterization, [, 0, ], =, sub, ;, }, else, {, characterization, [, 0, ], =]
[null, ), {, characterization, [, 0, ], =, sub, ;, }, else, {, characterization, [, 0, ], =, characterization, []
[0, ], =, sub, ;, }, else, {, characterization, [, 0, ], =, characterization, [, 0, ], ., reunite, (]
[0, ], ., reunite, (, sub, ), ;, }, }, }, else, {, final, Hyperplane, <, S, >, hyperplane, =]
[0, ], ., reunite, (, sub, ), ;, }, }, }, else, {, final, Hyperplane, <, S, >, hyperplane, =]
[0, ], ., reunite, (, sub, ), ;, }, }, }, else, {, final, Hyperplane, <, S, >, hyperplane, =]
[{, final, Hyperplane, <, S, >, hyperplane, =, node, ., getCut, (, ), ., getHyperplane, (, ), ;, switch, (]
[{, final, Hyperplane, <, S, >, hyperplane, =, node, ., getCut, (, ), ., getHyperplane, (, ), ;, switch, (]
[S, >, hyperplane, =, node, ., getCut, (, ), ., getHyperplane, (, ), ;, switch, (, sub, ., side, (]
[., getCut, (, ), ., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case]
[(, ), ., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :]
[., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, characterize, (]
[., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, characterize, (]
[(, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, characterize, (, node, ., getPlus, (, ), ,]
[., side, (, hyperplane, ), ), {, case, PLUS, :, characterize, (, node, ., getPlus, (, ), ,, sub, ,]
[{, case, PLUS, :, characterize, (, node, ., getPlus, (, ), ,, sub, ,, characterization, ), ;, break, ;, case]
[PLUS, :, characterize, (, node, ., getPlus, (, ), ,, sub, ,, characterization, ), ;, break, ;, case, MINUS, :]
[characterize, (, node, ., getPlus, (, ), ,, sub, ,, characterization, ), ;, break, ;, case, MINUS, :, characterize, (]
[characterize, (, node, ., getPlus, (, ), ,, sub, ,, characterization, ), ;, break, ;, case, MINUS, :, characterize, (]
[), ,, sub, ,, characterization, ), ;, break, ;, case, MINUS, :, characterize, (, node, ., getMinus, (, ), ,]
[sub, ,, characterization, ), ;, break, ;, case, MINUS, :, characterize, (, node, ., getMinus, (, ), ,, sub, ,]
[;, case, MINUS, :, characterize, (, node, ., getMinus, (, ), ,, sub, ,, characterization, ), ;, break, ;, case]
[,, sub, ,, characterization, ), ;, break, ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =]
[,, sub, ,, characterization, ), ;, break, ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =]
[), ;, break, ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, sub, ., split, (]
[;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, sub, ., split, (, hyperplane, ), ;]
[BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, sub, ., split, (, hyperplane, ), ;, characterize, (]
[BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, sub, ., split, (, hyperplane, ), ;, characterize, (]
[<, S, >, split, =, sub, ., split, (, hyperplane, ), ;, characterize, (, node, ., getPlus, (, ), ,]
[<, S, >, split, =, sub, ., split, (, hyperplane, ), ;, characterize, (, node, ., getPlus, (, ), ,]
[., split, (, hyperplane, ), ;, characterize, (, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,]
[hyperplane, ), ;, characterize, (, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,, characterization, ), ;]
[;, characterize, (, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,, characterization, ), ;, characterize, (]
[;, characterize, (, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,, characterization, ), ;, characterize, (]
[(, ), ,, split, ., getPlus, (, ), ,, characterization, ), ;, characterize, (, node, ., getMinus, (, ), ,]
[(, ), ,, split, ., getPlus, (, ), ,, characterization, ), ;, characterize, (, node, ., getMinus, (, ), ,]
[(, ), ,, characterization, ), ;, characterize, (, node, ., getMinus, (, ), ,, split, ., getMinus, (, ), ,]
[node, ., getMinus, (, ), ,, split, ., getMinus, (, ), ,, characterization, ), ;, break, ;, default, :, throw]
[(, ), ;, }, }, }, }, public, double, getBoundarySize, (, ), {, final, BoundarySizeVisitor, <, S, >, visitor, =]
[double, getBoundarySize, (, ), {, final, BoundarySizeVisitor, <, S, >, visitor, =, new, BoundarySizeVisitor, <, S, >, (, ), ;]
[double, getBoundarySize, (, ), {, final, BoundarySizeVisitor, <, S, >, visitor, =, new, BoundarySizeVisitor, <, S, >, (, ), ;]
[(, ), {, final, BoundarySizeVisitor, <, S, >, visitor, =, new, BoundarySizeVisitor, <, S, >, (, ), ;, getTree, (]
[<, S, >, visitor, =, new, BoundarySizeVisitor, <, S, >, (, ), ;, getTree, (, true, ), ., visit, (]
[=, new, BoundarySizeVisitor, <, S, >, (, ), ;, getTree, (, true, ), ., visit, (, visitor, ), ;, return]
[=, new, BoundarySizeVisitor, <, S, >, (, ), ;, getTree, (, true, ), ., visit, (, visitor, ), ;, return]
[(, visitor, ), ;, return, visitor, ., getSize, (, ), ;, }, public, double, getSize, (, ), {, if, (]
[(, visitor, ), ;, return, visitor, ., getSize, (, ), ;, }, public, double, getSize, (, ), {, if, (]
[), ;, return, visitor, ., getSize, (, ), ;, }, public, double, getSize, (, ), {, if, (, barycenter, ==]
[visitor, ., getSize, (, ), ;, }, public, double, getSize, (, ), {, if, (, barycenter, ==, null, ), {]
[}, public, double, getSize, (, ), {, if, (, barycenter, ==, null, ), {, computeGeometricalProperties, (, ), ;, }, return]
[), {, computeGeometricalProperties, (, ), ;, }, return, size, ;, }, protected, void, setSize, (, final, double, size, ), {]
[), {, computeGeometricalProperties, (, ), ;, }, return, size, ;, }, protected, void, setSize, (, final, double, size, ), {]
[), ;, }, return, size, ;, }, protected, void, setSize, (, final, double, size, ), {, this, ., size, =]
[), {, this, ., size, =, size, ;, }, public, Vector, <, S, >, getBarycenter, (, ), {, if, (]
[), {, this, ., size, =, size, ;, }, public, Vector, <, S, >, getBarycenter, (, ), {, if, (]
[this, ., size, =, size, ;, }, public, Vector, <, S, >, getBarycenter, (, ), {, if, (, barycenter, ==]
[=, size, ;, }, public, Vector, <, S, >, getBarycenter, (, ), {, if, (, barycenter, ==, null, ), {]
[<, S, >, getBarycenter, (, ), {, if, (, barycenter, ==, null, ), {, computeGeometricalProperties, (, ), ;, }, return]
[(, ), ;, }, return, barycenter, ;, }, protected, void, setBarycenter, (, final, Vector, <, S, >, barycenter, ), {]
[(, ), ;, }, return, barycenter, ;, }, protected, void, setBarycenter, (, final, Vector, <, S, >, barycenter, ), {]
[return, barycenter, ;, }, protected, void, setBarycenter, (, final, Vector, <, S, >, barycenter, ), {, this, ., barycenter, =]
[computeGeometricalProperties, (, ), ;, public, Side, side, (, final, Hyperplane, <, S, >, hyperplane, ), {, final, Sides, sides, =]
[Side, side, (, final, Hyperplane, <, S, >, hyperplane, ), {, final, Sides, sides, =, new, Sides, (, ), ;]
[(, final, Hyperplane, <, S, >, hyperplane, ), {, final, Sides, sides, =, new, Sides, (, ), ;, recurseSides, (]
[Hyperplane, <, S, >, hyperplane, ), {, final, Sides, sides, =, new, Sides, (, ), ;, recurseSides, (, tree, ,]
[Hyperplane, <, S, >, hyperplane, ), {, final, Sides, sides, =, new, Sides, (, ), ;, recurseSides, (, tree, ,]
[{, final, Sides, sides, =, new, Sides, (, ), ;, recurseSides, (, tree, ,, hyperplane, ., wholeHyperplane, (, ), ,]
[=, new, Sides, (, ), ;, recurseSides, (, tree, ,, hyperplane, ., wholeHyperplane, (, ), ,, sides, ), ;, return]
[=, new, Sides, (, ), ;, recurseSides, (, tree, ,, hyperplane, ., wholeHyperplane, (, ), ,, sides, ), ;, return]
[=, new, Sides, (, ), ;, recurseSides, (, tree, ,, hyperplane, ., wholeHyperplane, (, ), ,, sides, ), ;, return]
[recurseSides, (, tree, ,, hyperplane, ., wholeHyperplane, (, ), ,, sides, ), ;, return, sides, ., plusFound, (, ), ?]
[(, tree, ,, hyperplane, ., wholeHyperplane, (, ), ,, sides, ), ;, return, sides, ., plusFound, (, ), ?, (]
[(, tree, ,, hyperplane, ., wholeHyperplane, (, ), ,, sides, ), ;, return, sides, ., plusFound, (, ), ?, (]
[(, tree, ,, hyperplane, ., wholeHyperplane, (, ), ,, sides, ), ;, return, sides, ., plusFound, (, ), ?, (]
[(, ), ,, sides, ), ;, return, sides, ., plusFound, (, ), ?, (, sides, ., minusFound, (, ), ?]
[(, ), ,, sides, ), ;, return, sides, ., plusFound, (, ), ?, (, sides, ., minusFound, (, ), ?]
[), ;, return, sides, ., plusFound, (, ), ?, (, sides, ., minusFound, (, ), ?, Side, ., BOTH, :]
[), ;, return, sides, ., plusFound, (, ), ?, (, sides, ., minusFound, (, ), ?, Side, ., BOTH, :]
[plusFound, (, ), ?, (, sides, ., minusFound, (, ), ?, Side, ., BOTH, :, Side, ., PLUS, ), :]
[(, ), ?, (, sides, ., minusFound, (, ), ?, Side, ., BOTH, :, Side, ., PLUS, ), :, (]
[(, ), ?, (, sides, ., minusFound, (, ), ?, Side, ., BOTH, :, Side, ., PLUS, ), :, (]
[(, ), ?, (, sides, ., minusFound, (, ), ?, Side, ., BOTH, :, Side, ., PLUS, ), :, (]
[minusFound, (, ), ?, Side, ., BOTH, :, Side, ., PLUS, ), :, (, sides, ., minusFound, (, ), ?]
[minusFound, (, ), ?, Side, ., BOTH, :, Side, ., PLUS, ), :, (, sides, ., minusFound, (, ), ?]
[Side, ., BOTH, :, Side, ., PLUS, ), :, (, sides, ., minusFound, (, ), ?, Side, ., MINUS, :]
[Side, ., BOTH, :, Side, ., PLUS, ), :, (, sides, ., minusFound, (, ), ?, Side, ., MINUS, :]
[BSPTree, <, S, >, node, ,, final, SubHyperplane, <, S, >, sub, ,, final, Sides, sides, ), {, if, (]
[BSPTree, <, S, >, node, ,, final, SubHyperplane, <, S, >, sub, ,, final, Sides, sides, ), {, if, (]
[BSPTree, <, S, >, node, ,, final, SubHyperplane, <, S, >, sub, ,, final, Sides, sides, ), {, if, (]
[final, SubHyperplane, <, S, >, sub, ,, final, Sides, sides, ), {, if, (, node, ., getCut, (, ), ==]
[sub, ,, final, Sides, sides, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, if, (]
[Sides, sides, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, if, (, (, Boolean, )]
[Sides, sides, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, if, (, (, Boolean, )]
[., getCut, (, ), ==, null, ), {, if, (, (, Boolean, ), node, ., getAttribute, (, ), ), {]
[., getCut, (, ), ==, null, ), {, if, (, (, Boolean, ), node, ., getAttribute, (, ), ), {]
[), {, if, (, (, Boolean, ), node, ., getAttribute, (, ), ), {, sides, ., rememberPlusFound, (, ), ;]
[), {, if, (, (, Boolean, ), node, ., getAttribute, (, ), ), {, sides, ., rememberPlusFound, (, ), ;]
[(, ), ;, sides, ., rememberMinusFound, (, ), ;, }, return, ;, }, final, Hyperplane, <, S, >, hyperplane, =]
[(, ), ;, sides, ., rememberMinusFound, (, ), ;, }, return, ;, }, final, Hyperplane, <, S, >, hyperplane, =]
[(, ), ;, sides, ., rememberMinusFound, (, ), ;, }, return, ;, }, final, Hyperplane, <, S, >, hyperplane, =]
[}, final, Hyperplane, <, S, >, hyperplane, =, node, ., getCut, (, ), ., getHyperplane, (, ), ;, switch, (]
[}, final, Hyperplane, <, S, >, hyperplane, =, node, ., getCut, (, ), ., getHyperplane, (, ), ;, switch, (]
[S, >, hyperplane, =, node, ., getCut, (, ), ., getHyperplane, (, ), ;, switch, (, sub, ., side, (]
[., getCut, (, ), ., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case]
[., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, if, (]
[., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, if, (]
[., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, if, (]
[., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, if, (]
[., side, (, hyperplane, ), ), {, case, PLUS, :, if, (, node, ., getCut, (, ), ., side, (]
[., side, (, hyperplane, ), ), {, case, PLUS, :, if, (, node, ., getCut, (, ), ., side, (]
[case, PLUS, :, if, (, node, ., getCut, (, ), ., side, (, sub, ., getHyperplane, (, ), ), ==]
[case, PLUS, :, if, (, node, ., getCut, (, ), ., side, (, sub, ., getHyperplane, (, ), ), ==]
[getCut, (, ), ., side, (, sub, ., getHyperplane, (, ), ), ==, Side, ., PLUS, ), {, if, (]
[(, ), ., side, (, sub, ., getHyperplane, (, ), ), ==, Side, ., PLUS, ), {, if, (, !]
[., side, (, sub, ., getHyperplane, (, ), ), ==, Side, ., PLUS, ), {, if, (, !, isEmpty, (]
[., side, (, sub, ., getHyperplane, (, ), ), ==, Side, ., PLUS, ), {, if, (, !, isEmpty, (]
[), ==, Side, ., PLUS, ), {, if, (, !, isEmpty, (, node, ., getMinus, (, ), ), ), {]
[), ==, Side, ., PLUS, ), {, if, (, !, isEmpty, (, node, ., getMinus, (, ), ), ), {]
[node, ., getMinus, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, }, else, {, if, (]
[., getMinus, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, }, else, {, if, (, !]
[(, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, }, else, {, if, (, !, isEmpty, (]
[(, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, }, else, {, if, (, !, isEmpty, (]
[(, ), ;, }, }, else, {, if, (, !, isEmpty, (, node, ., getMinus, (, ), ), ), {]
[(, ), ;, }, }, else, {, if, (, !, isEmpty, (, node, ., getMinus, (, ), ), ), {]
[isEmpty, (, node, ., getMinus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (]
[(, node, ., getMinus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !]
[node, ., getMinus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (]
[node, ., getMinus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (]
[node, ., getMinus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (]
[), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (, sides, ., plusFound, (, ), &&]
[), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (, sides, ., plusFound, (, ), &&]
[}, }, if, (, !, (, sides, ., plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {]
[if, (, !, (, sides, ., plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (]
[if, (, !, (, sides, ., plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (]
[plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (, node, ., getPlus, (, ), ,]
[), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (, node, ., getPlus, (, ), ,, sub, ,]
[), ), {, recurseSides, (, node, ., getPlus, (, ), ,, sub, ,, sides, ), ;, }, break, ;, case]
[(, node, ., getPlus, (, ), ,, sub, ,, sides, ), ;, }, break, ;, case, MINUS, :, if, (]
[(, node, ., getPlus, (, ), ,, sub, ,, sides, ), ;, }, break, ;, case, MINUS, :, if, (]
[(, node, ., getPlus, (, ), ,, sub, ,, sides, ), ;, }, break, ;, case, MINUS, :, if, (]
[(, node, ., getPlus, (, ), ,, sub, ,, sides, ), ;, }, break, ;, case, MINUS, :, if, (]
[,, sides, ), ;, }, break, ;, case, MINUS, :, if, (, node, ., getCut, (, ), ., side, (]
[,, sides, ), ;, }, break, ;, case, MINUS, :, if, (, node, ., getCut, (, ), ., side, (]
[case, MINUS, :, if, (, node, ., getCut, (, ), ., side, (, sub, ., getHyperplane, (, ), ), ==]
[case, MINUS, :, if, (, node, ., getCut, (, ), ., side, (, sub, ., getHyperplane, (, ), ), ==]
[getCut, (, ), ., side, (, sub, ., getHyperplane, (, ), ), ==, Side, ., PLUS, ), {, if, (]
[(, ), ., side, (, sub, ., getHyperplane, (, ), ), ==, Side, ., PLUS, ), {, if, (, !]
[., side, (, sub, ., getHyperplane, (, ), ), ==, Side, ., PLUS, ), {, if, (, !, isEmpty, (]
[., side, (, sub, ., getHyperplane, (, ), ), ==, Side, ., PLUS, ), {, if, (, !, isEmpty, (]
[), ==, Side, ., PLUS, ), {, if, (, !, isEmpty, (, node, ., getPlus, (, ), ), ), {]
[), ==, Side, ., PLUS, ), {, if, (, !, isEmpty, (, node, ., getPlus, (, ), ), ), {]
[node, ., getPlus, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, }, else, {, if, (]
[., getPlus, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, }, else, {, if, (, !]
[(, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, }, else, {, if, (, !, isEmpty, (]
[(, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, }, else, {, if, (, !, isEmpty, (]
[(, ), ;, }, }, else, {, if, (, !, isEmpty, (, node, ., getPlus, (, ), ), ), {]
[(, ), ;, }, }, else, {, if, (, !, isEmpty, (, node, ., getPlus, (, ), ), ), {]
[isEmpty, (, node, ., getPlus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (]
[(, node, ., getPlus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !]
[node, ., getPlus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (]
[node, ., getPlus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (]
[node, ., getPlus, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (]
[), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (, sides, ., plusFound, (, ), &&]
[), {, sides, ., rememberMinusFound, (, ), ;, }, }, if, (, !, (, sides, ., plusFound, (, ), &&]
[}, }, if, (, !, (, sides, ., plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {]
[if, (, !, (, sides, ., plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (]
[if, (, !, (, sides, ., plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (]
[plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (, node, ., getMinus, (, ), ,]
[), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (, node, ., getMinus, (, ), ,, sub, ,]
[), ), {, recurseSides, (, node, ., getMinus, (, ), ,, sub, ,, sides, ), ;, }, break, ;, case]
[sub, ,, sides, ), ;, }, break, ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =]
[sub, ,, sides, ), ;, }, break, ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =]
[;, }, break, ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, sub, ., split, (]
[;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, sub, ., split, (, hyperplane, ), ;]
[BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, sub, ., split, (, hyperplane, ), ;, recurseSides, (]
[BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, sub, ., split, (, hyperplane, ), ;, recurseSides, (]
[<, S, >, split, =, sub, ., split, (, hyperplane, ), ;, recurseSides, (, node, ., getPlus, (, ), ,]
[<, S, >, split, =, sub, ., split, (, hyperplane, ), ;, recurseSides, (, node, ., getPlus, (, ), ,]
[., split, (, hyperplane, ), ;, recurseSides, (, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,]
[;, recurseSides, (, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,, sides, ), ;, if, (]
[recurseSides, (, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,, sides, ), ;, if, (, !]
[(, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,, sides, ), ;, if, (, !, (]
[(, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,, sides, ), ;, if, (, !, (]
[(, node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ,, sides, ), ;, if, (, !, (]
[,, split, ., getPlus, (, ), ,, sides, ), ;, if, (, !, (, sides, ., plusFound, (, ), &&]
[,, split, ., getPlus, (, ), ,, sides, ), ;, if, (, !, (, sides, ., plusFound, (, ), &&]
[), ;, if, (, !, (, sides, ., plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {]
[if, (, !, (, sides, ., plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (]
[if, (, !, (, sides, ., plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (]
[plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (, node, ., getMinus, (, ), ,]
[plusFound, (, ), &&, sides, ., minusFound, (, ), ), ), {, recurseSides, (, node, ., getMinus, (, ), ,]
[minusFound, (, ), ), ), {, recurseSides, (, node, ., getMinus, (, ), ,, split, ., getMinus, (, ), ,]
[getMinus, (, ), ,, split, ., getMinus, (, ), ,, sides, ), ;, }, break, ;, default, :, if, (]
[getMinus, (, ), ,, split, ., getMinus, (, ), ,, sides, ), ;, }, break, ;, default, :, if, (]
[getMinus, (, ), ,, split, ., getMinus, (, ), ,, sides, ), ;, }, break, ;, default, :, if, (]
[getMinus, (, ), ,, split, ., getMinus, (, ), ,, sides, ), ;, }, break, ;, default, :, if, (]
[;, }, break, ;, default, :, if, (, node, ., getCut, (, ), ., getHyperplane, (, ), ., sameOrientationAs, (]
[;, }, break, ;, default, :, if, (, node, ., getCut, (, ), ., getHyperplane, (, ), ., sameOrientationAs, (]
[getCut, (, ), ., getHyperplane, (, ), ., sameOrientationAs, (, sub, ., getHyperplane, (, ), ), ), {, if, (]
[getCut, (, ), ., getHyperplane, (, ), ., sameOrientationAs, (, sub, ., getHyperplane, (, ), ), ), {, if, (]
[(, ), ., getHyperplane, (, ), ., sameOrientationAs, (, sub, ., getHyperplane, (, ), ), ), {, if, (, (]
[(, ), ., getHyperplane, (, ), ., sameOrientationAs, (, sub, ., getHyperplane, (, ), ), ), {, if, (, (]
[(, ), ., getHyperplane, (, ), ., sameOrientationAs, (, sub, ., getHyperplane, (, ), ), ), {, if, (, (]
[(, ), ., getHyperplane, (, ), ., sameOrientationAs, (, sub, ., getHyperplane, (, ), ), ), {, if, (, (]
[., getHyperplane, (, ), ), ), {, if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=]
[), ), ), {, if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||]
[), ), {, if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||, (]
[if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[!=, null, ), ||, (, (, Boolean, ), node, ., getPlus, (, ), ., getAttribute, (, ), ), ), {]
[!=, null, ), ||, (, (, Boolean, ), node, ., getPlus, (, ), ., getAttribute, (, ), ), ), {]
[., getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, if, (]
[., getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, if, (]
[getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, if, (, (]
[getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, if, (, (]
[getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, if, (, (]
[getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberPlusFound, (, ), ;, }, if, (, (]
[sides, ., rememberPlusFound, (, ), ;, }, if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=]
[(, ), ;, }, if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||]
[), ;, }, if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||, (]
[if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[!=, null, ), ||, (, (, Boolean, ), node, ., getMinus, (, ), ., getAttribute, (, ), ), ), {]
[!=, null, ), ||, (, (, Boolean, ), node, ., getMinus, (, ), ., getAttribute, (, ), ), ), {]
[), ., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, else, {, if, (]
[), ., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, else, {, if, (]
[., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, else, {, if, (, (]
[., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, else, {, if, (, (]
[., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, else, {, if, (, (]
[., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, }, else, {, if, (, (]
[(, ), ;, }, }, else, {, if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=]
[}, }, else, {, if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||]
[}, else, {, if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||, (]
[if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[if, (, (, node, ., getPlus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[!=, null, ), ||, (, (, Boolean, ), node, ., getPlus, (, ), ., getAttribute, (, ), ), ), {]
[!=, null, ), ||, (, (, Boolean, ), node, ., getPlus, (, ), ., getAttribute, (, ), ), ), {]
[., getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, if, (]
[., getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, if, (]
[getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, if, (, (]
[getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, if, (, (]
[getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, if, (, (]
[getPlus, (, ), ., getAttribute, (, ), ), ), {, sides, ., rememberMinusFound, (, ), ;, }, if, (, (]
[sides, ., rememberMinusFound, (, ), ;, }, if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=]
[(, ), ;, }, if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||]
[), ;, }, if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||, (]
[if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[if, (, (, node, ., getMinus, (, ), ., getCut, (, ), !=, null, ), ||, (, (, Boolean, )]
[!=, null, ), ||, (, (, Boolean, ), node, ., getMinus, (, ), ., getAttribute, (, ), ), ), {]
[!=, null, ), ||, (, (, Boolean, ), node, ., getMinus, (, ), ., getAttribute, (, ), ), ), {]
[}, private, static, final, class, Sides, {, private, boolean, plusFound, ;, private, boolean, minusFound, ;, public, Sides, (, ), {]
[static, final, class, Sides, {, private, boolean, plusFound, ;, private, boolean, minusFound, ;, public, Sides, (, ), {, plusFound, =]
[class, Sides, {, private, boolean, plusFound, ;, private, boolean, minusFound, ;, public, Sides, (, ), {, plusFound, =, false, ;]
[{, private, boolean, plusFound, ;, private, boolean, minusFound, ;, public, Sides, (, ), {, plusFound, =, false, ;, minusFound, =]
[public, Sides, (, ), {, plusFound, =, false, ;, minusFound, =, false, ;, }, public, void, rememberPlusFound, (, ), {]
[(, ), {, plusFound, =, false, ;, minusFound, =, false, ;, }, public, void, rememberPlusFound, (, ), {, plusFound, =]
[;, }, public, void, rememberPlusFound, (, ), {, plusFound, =, true, ;, }, public, boolean, plusFound, (, ), {, return]
[=, true, ;, }, public, boolean, plusFound, (, ), {, return, plusFound, ;, }, public, void, rememberMinusFound, (, ), {]
[;, }, public, boolean, plusFound, (, ), {, return, plusFound, ;, }, public, void, rememberMinusFound, (, ), {, minusFound, =]
[;, }, public, void, rememberMinusFound, (, ), {, minusFound, =, true, ;, }, public, boolean, minusFound, (, ), {, return]
[minusFound, ;, }, }, public, SubHyperplane, <, S, >, intersection, (, final, SubHyperplane, <, S, >, sub, ), {, return]
[}, }, public, SubHyperplane, <, S, >, intersection, (, final, SubHyperplane, <, S, >, sub, ), {, return, recurseIntersection, (]
[public, SubHyperplane, <, S, >, intersection, (, final, SubHyperplane, <, S, >, sub, ), {, return, recurseIntersection, (, tree, ,]
[>, recurseIntersection, (, final, BSPTree, <, S, >, node, ,, final, SubHyperplane, <, S, >, sub, ), {, if, (]
[>, recurseIntersection, (, final, BSPTree, <, S, >, node, ,, final, SubHyperplane, <, S, >, sub, ), {, if, (]
[>, recurseIntersection, (, final, BSPTree, <, S, >, node, ,, final, SubHyperplane, <, S, >, sub, ), {, if, (]
[S, >, node, ,, final, SubHyperplane, <, S, >, sub, ), {, if, (, node, ., getCut, (, ), ==]
[final, SubHyperplane, <, S, >, sub, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return]
[final, SubHyperplane, <, S, >, sub, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return]
[S, >, sub, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, (, Boolean, )]
[S, >, sub, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, (, Boolean, )]
[(, node, ., getCut, (, ), ==, null, ), {, return, (, Boolean, ), node, ., getAttribute, (, ), ?]
[(, node, ., getCut, (, ), ==, null, ), {, return, (, Boolean, ), node, ., getAttribute, (, ), ?]
[==, null, ), {, return, (, Boolean, ), node, ., getAttribute, (, ), ?, sub, ., copySelf, (, ), :]
[getAttribute, (, ), ?, sub, ., copySelf, (, ), :, null, ;, }, final, Hyperplane, <, S, >, hyperplane, =]
[getAttribute, (, ), ?, sub, ., copySelf, (, ), :, null, ;, }, final, Hyperplane, <, S, >, hyperplane, =]
[getAttribute, (, ), ?, sub, ., copySelf, (, ), :, null, ;, }, final, Hyperplane, <, S, >, hyperplane, =]
[}, final, Hyperplane, <, S, >, hyperplane, =, node, ., getCut, (, ), ., getHyperplane, (, ), ;, switch, (]
[}, final, Hyperplane, <, S, >, hyperplane, =, node, ., getCut, (, ), ., getHyperplane, (, ), ;, switch, (]
[S, >, hyperplane, =, node, ., getCut, (, ), ., getHyperplane, (, ), ;, switch, (, sub, ., side, (]
[., getCut, (, ), ., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case]
[), ., getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, return]
[getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, return, recurseIntersection, (]
[getHyperplane, (, ), ;, switch, (, sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, return, recurseIntersection, (]
[sub, ., side, (, hyperplane, ), ), {, case, PLUS, :, return, recurseIntersection, (, node, ., getPlus, (, ), ,]
[hyperplane, ), ), {, case, PLUS, :, return, recurseIntersection, (, node, ., getPlus, (, ), ,, sub, ), ;, case]
[{, case, PLUS, :, return, recurseIntersection, (, node, ., getPlus, (, ), ,, sub, ), ;, case, MINUS, :, return]
[PLUS, :, return, recurseIntersection, (, node, ., getPlus, (, ), ,, sub, ), ;, case, MINUS, :, return, recurseIntersection, (]
[PLUS, :, return, recurseIntersection, (, node, ., getPlus, (, ), ,, sub, ), ;, case, MINUS, :, return, recurseIntersection, (]
[., getPlus, (, ), ,, sub, ), ;, case, MINUS, :, return, recurseIntersection, (, node, ., getMinus, (, ), ,]
[,, sub, ), ;, case, MINUS, :, return, recurseIntersection, (, node, ., getMinus, (, ), ,, sub, ), ;, case]
[., getMinus, (, ), ,, sub, ), ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =]
[., getMinus, (, ), ,, sub, ), ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =]
[,, sub, ), ;, case, BOTH, :, final, SubHyperplane, ., SplitSubHyperplane, <, S, >, split, =, sub, ., split, (]
[SplitSubHyperplane, <, S, >, split, =, sub, ., split, (, hyperplane, ), ;, final, SubHyperplane, <, S, >, plus, =]
[S, >, split, =, sub, ., split, (, hyperplane, ), ;, final, SubHyperplane, <, S, >, plus, =, recurseIntersection, (]
[S, >, split, =, sub, ., split, (, hyperplane, ), ;, final, SubHyperplane, <, S, >, plus, =, recurseIntersection, (]
[split, (, hyperplane, ), ;, final, SubHyperplane, <, S, >, plus, =, recurseIntersection, (, node, ., getPlus, (, ), ,]
[split, (, hyperplane, ), ;, final, SubHyperplane, <, S, >, plus, =, recurseIntersection, (, node, ., getPlus, (, ), ,]
[node, ., getPlus, (, ), ,, split, ., getPlus, (, ), ), ;, final, SubHyperplane, <, S, >, minus, =]
[getPlus, (, ), ,, split, ., getPlus, (, ), ), ;, final, SubHyperplane, <, S, >, minus, =, recurseIntersection, (]
[getPlus, (, ), ,, split, ., getPlus, (, ), ), ;, final, SubHyperplane, <, S, >, minus, =, recurseIntersection, (]
[getPlus, (, ), ), ;, final, SubHyperplane, <, S, >, minus, =, recurseIntersection, (, node, ., getMinus, (, ), ,]
[getPlus, (, ), ), ;, final, SubHyperplane, <, S, >, minus, =, recurseIntersection, (, node, ., getMinus, (, ), ,]
[>, minus, =, recurseIntersection, (, node, ., getMinus, (, ), ,, split, ., getMinus, (, ), ), ;, if, (]
[>, minus, =, recurseIntersection, (, node, ., getMinus, (, ), ,, split, ., getMinus, (, ), ), ;, if, (]
[=, recurseIntersection, (, node, ., getMinus, (, ), ,, split, ., getMinus, (, ), ), ;, if, (, plus, ==]
[., getMinus, (, ), ,, split, ., getMinus, (, ), ), ;, if, (, plus, ==, null, ), {, return]
[., getMinus, (, ), ), ;, if, (, plus, ==, null, ), {, return, minus, ;, }, else, if, (]
[., getMinus, (, ), ), ;, if, (, plus, ==, null, ), {, return, minus, ;, }, else, if, (]
[(, ), ), ;, if, (, plus, ==, null, ), {, return, minus, ;, }, else, if, (, minus, ==]
[if, (, plus, ==, null, ), {, return, minus, ;, }, else, if, (, minus, ==, null, ), {, return]
[{, return, minus, ;, }, else, if, (, minus, ==, null, ), {, return, plus, ;, }, else, {, return]
[{, return, minus, ;, }, else, if, (, minus, ==, null, ), {, return, plus, ;, }, else, {, return]
[}, else, if, (, minus, ==, null, ), {, return, plus, ;, }, else, {, return, plus, ., reunite, (]
[), {, return, plus, ;, }, else, {, return, plus, ., reunite, (, minus, ), ;, }, default, :, return]
[return, plus, ;, }, else, {, return, plus, ., reunite, (, minus, ), ;, }, default, :, return, recurseIntersection, (]
[return, plus, ;, }, else, {, return, plus, ., reunite, (, minus, ), ;, }, default, :, return, recurseIntersection, (]
[return, plus, ., reunite, (, minus, ), ;, }, default, :, return, recurseIntersection, (, node, ., getPlus, (, ), ,]
[., reunite, (, minus, ), ;, }, default, :, return, recurseIntersection, (, node, ., getPlus, (, ), ,, recurseIntersection, (]
[., reunite, (, minus, ), ;, }, default, :, return, recurseIntersection, (, node, ., getPlus, (, ), ,, recurseIntersection, (]
[}, default, :, return, recurseIntersection, (, node, ., getPlus, (, ), ,, recurseIntersection, (, node, ., getMinus, (, ), ,]
[public, AbstractRegion, <, S, ,, T, >, applyTransform, (, final, Transform, <, S, ,, T, >, transform, ), {, return]
[<, S, ,, T, >, applyTransform, (, final, Transform, <, S, ,, T, >, transform, ), {, return, buildNew, (]
[,, T, >, applyTransform, (, final, Transform, <, S, ,, T, >, transform, ), {, return, buildNew, (, recurseTransform, (]
[>, applyTransform, (, final, Transform, <, S, ,, T, >, transform, ), {, return, buildNew, (, recurseTransform, (, getTree, (]
[final, Transform, <, S, ,, T, >, transform, ), {, return, buildNew, (, recurseTransform, (, getTree, (, false, ), ,]
[T, >, transform, ), {, return, buildNew, (, recurseTransform, (, getTree, (, false, ), ,, transform, ), ), ;, }]
[), {, return, buildNew, (, recurseTransform, (, getTree, (, false, ), ,, transform, ), ), ;, }, @, SuppressWarnings, (]
[(, final, BSPTree, <, S, >, node, ,, final, Transform, <, S, ,, T, >, transform, ), {, if, (]
[(, final, BSPTree, <, S, >, node, ,, final, Transform, <, S, ,, T, >, transform, ), {, if, (]
[(, final, BSPTree, <, S, >, node, ,, final, Transform, <, S, ,, T, >, transform, ), {, if, (]
[node, ,, final, Transform, <, S, ,, T, >, transform, ), {, if, (, node, ., getCut, (, ), ==]
[<, S, ,, T, >, transform, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return]
[), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, new, BSPTree, <, S, >, (]
[), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, new, BSPTree, <, S, >, (]
[BSPTree, <, S, >, (, node, ., getAttribute, (, ), ), ;, }, final, SubHyperplane, <, S, >, sub, =]
[BSPTree, <, S, >, (, node, ., getAttribute, (, ), ), ;, }, final, SubHyperplane, <, S, >, sub, =]
[final, SubHyperplane, <, S, >, sub, =, node, ., getCut, (, ), ;, final, SubHyperplane, <, S, >, tSub, =]
[final, SubHyperplane, <, S, >, sub, =, node, ., getCut, (, ), ;, final, SubHyperplane, <, S, >, tSub, =]
[SubHyperplane, <, S, >, sub, =, node, ., getCut, (, ), ;, final, SubHyperplane, <, S, >, tSub, =, (]
[getCut, (, ), ;, final, SubHyperplane, <, S, >, tSub, =, (, (, AbstractSubHyperplane, <, S, ,, T, >, )]
[SubHyperplane, <, S, >, tSub, =, (, (, AbstractSubHyperplane, <, S, ,, T, >, ), sub, ), ., applyTransform, (]
[<, S, ,, T, >, ), sub, ), ., applyTransform, (, transform, ), ;, BoundaryAttribute, <, S, >, attribute, =]
[sub, ), ., applyTransform, (, transform, ), ;, BoundaryAttribute, <, S, >, attribute, =, (, BoundaryAttribute, <, S, >, )]
[sub, ), ., applyTransform, (, transform, ), ;, BoundaryAttribute, <, S, >, attribute, =, (, BoundaryAttribute, <, S, >, )]
[BoundaryAttribute, <, S, >, attribute, =, (, BoundaryAttribute, <, S, >, ), node, ., getAttribute, (, ), ;, if, (]
[BoundaryAttribute, <, S, >, attribute, =, (, BoundaryAttribute, <, S, >, ), node, ., getAttribute, (, ), ;, if, (]
[S, >, attribute, =, (, BoundaryAttribute, <, S, >, ), node, ., getAttribute, (, ), ;, if, (, attribute, !=]
[node, ., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, tPO, =]
[node, ., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, tPO, =]
[., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, tPO, =, (]
[., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, tPO, =, (]
[., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, tPO, =, (]
[(, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, tPO, =, (, attribute, ., getPlusOutside, (, ), ==]
[null, ), {, final, SubHyperplane, <, S, >, tPO, =, (, attribute, ., getPlusOutside, (, ), ==, null, ), ?]
[{, final, SubHyperplane, <, S, >, tPO, =, (, attribute, ., getPlusOutside, (, ), ==, null, ), ?, null, :]
[{, final, SubHyperplane, <, S, >, tPO, =, (, attribute, ., getPlusOutside, (, ), ==, null, ), ?, null, :]
[final, SubHyperplane, <, S, >, tPO, =, (, attribute, ., getPlusOutside, (, ), ==, null, ), ?, null, :, (]
[attribute, ., getPlusOutside, (, ), ==, null, ), ?, null, :, (, (, AbstractSubHyperplane, <, S, ,, T, >, )]
[attribute, ., getPlusOutside, (, ), ==, null, ), ?, null, :, (, (, AbstractSubHyperplane, <, S, ,, T, >, )]
[null, :, (, (, AbstractSubHyperplane, <, S, ,, T, >, ), attribute, ., getPlusOutside, (, ), ), ., applyTransform, (]
[), attribute, ., getPlusOutside, (, ), ), ., applyTransform, (, transform, ), ;, final, SubHyperplane, <, S, >, tPI, =]
[), attribute, ., getPlusOutside, (, ), ), ., applyTransform, (, transform, ), ;, final, SubHyperplane, <, S, >, tPI, =]
[attribute, ., getPlusOutside, (, ), ), ., applyTransform, (, transform, ), ;, final, SubHyperplane, <, S, >, tPI, =, (]
[attribute, ., getPlusOutside, (, ), ), ., applyTransform, (, transform, ), ;, final, SubHyperplane, <, S, >, tPI, =, (]
[attribute, ., getPlusOutside, (, ), ), ., applyTransform, (, transform, ), ;, final, SubHyperplane, <, S, >, tPI, =, (]
[., applyTransform, (, transform, ), ;, final, SubHyperplane, <, S, >, tPI, =, (, attribute, ., getPlusInside, (, ), ==]
[transform, ), ;, final, SubHyperplane, <, S, >, tPI, =, (, attribute, ., getPlusInside, (, ), ==, null, ), ?]
[;, final, SubHyperplane, <, S, >, tPI, =, (, attribute, ., getPlusInside, (, ), ==, null, ), ?, null, :]
[;, final, SubHyperplane, <, S, >, tPI, =, (, attribute, ., getPlusInside, (, ), ==, null, ), ?, null, :]
[final, SubHyperplane, <, S, >, tPI, =, (, attribute, ., getPlusInside, (, ), ==, null, ), ?, null, :, (]
[attribute, ., getPlusInside, (, ), ==, null, ), ?, null, :, (, (, AbstractSubHyperplane, <, S, ,, T, >, )]
[attribute, ., getPlusInside, (, ), ==, null, ), ?, null, :, (, (, AbstractSubHyperplane, <, S, ,, T, >, )]
[null, :, (, (, AbstractSubHyperplane, <, S, ,, T, >, ), attribute, ., getPlusInside, (, ), ), ., applyTransform, (]
[(, AbstractSubHyperplane, <, S, ,, T, >, ), attribute, ., getPlusInside, (, ), ), ., applyTransform, (, transform, ), ;]
[<, S, ,, T, >, ), attribute, ., getPlusInside, (, ), ), ., applyTransform, (, transform, ), ;, attribute, =]
[attribute, ., getPlusInside, (, ), ), ., applyTransform, (, transform, ), ;, attribute, =, new, BoundaryAttribute, <, S, >, (]
[getPlusInside, (, ), ), ., applyTransform, (, transform, ), ;, attribute, =, new, BoundaryAttribute, <, S, >, (, tPO, ,]
[applyTransform, (, transform, ), ;, attribute, =, new, BoundaryAttribute, <, S, >, (, tPO, ,, tPI, ), ;, }, return]
[=, new, BoundaryAttribute, <, S, >, (, tPO, ,, tPI, ), ;, }, return, new, BSPTree, <, S, >, (]
[BoundaryAttribute, <, S, >, (, tPO, ,, tPI, ), ;, }, return, new, BSPTree, <, S, >, (, tSub, ,]
[S, >, (, tPO, ,, tPI, ), ;, }, return, new, BSPTree, <, S, >, (, tSub, ,, recurseTransform, (]
[S, >, (, tPO, ,, tPI, ), ;, }, return, new, BSPTree, <, S, >, (, tSub, ,, recurseTransform, (]
[), ;, }, return, new, BSPTree, <, S, >, (, tSub, ,, recurseTransform, (, node, ., getPlus, (, ), ,]
[return, new, BSPTree, <, S, >, (, tSub, ,, recurseTransform, (, node, ., getPlus, (, ), ,, transform, ), ,]
[BSPTree, <, S, >, (, tSub, ,, recurseTransform, (, node, ., getPlus, (, ), ,, transform, ), ,, recurseTransform, (]
[BSPTree, <, S, >, (, tSub, ,, recurseTransform, (, node, ., getPlus, (, ), ,, transform, ), ,, recurseTransform, (]
[,, recurseTransform, (, node, ., getPlus, (, ), ,, transform, ), ,, recurseTransform, (, node, ., getMinus, (, ), ,]
[node, ., getPlus, (, ), ,, transform, ), ,, recurseTransform, (, node, ., getMinus, (, ), ,, transform, ), ,]
