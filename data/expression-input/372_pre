[,, Void, >, >, colorings, ;, private, final, boolean, usePseudoNames, ;, private, static, final, Comparator, <, Var, >, coloringTieBreaker, =]
[<, Var, >, (, ), {, @, Override, public, int, compare, (, Var, v1, ,, Var, v2, ), {, return]
[<, Var, >, (, ), {, @, Override, public, int, compare, (, Var, v1, ,, Var, v2, ), {, return]
[<, Var, >, (, ), {, @, Override, public, int, compare, (, Var, v1, ,, Var, v2, ), {, return]
[), {, @, Override, public, int, compare, (, Var, v1, ,, Var, v2, ), {, return, v1, ., index, -]
[), {, @, Override, public, int, compare, (, Var, v1, ,, Var, v2, ), {, return, v1, ., index, -]
[v1, ., index, -, v2, ., index, ;, }, }, ;, CoalesceVariableNames, (, AbstractCompiler, compiler, ,, boolean, usePseudoNames, ), {]
[v1, ., index, -, v2, ., index, ;, }, }, ;, CoalesceVariableNames, (, AbstractCompiler, compiler, ,, boolean, usePseudoNames, ), {]
[v2, ., index, ;, }, }, ;, CoalesceVariableNames, (, AbstractCompiler, compiler, ,, boolean, usePseudoNames, ), {, Preconditions, ., checkState, (]
[., index, ;, }, }, ;, CoalesceVariableNames, (, AbstractCompiler, compiler, ,, boolean, usePseudoNames, ), {, Preconditions, ., checkState, (, !]
[., index, ;, }, }, ;, CoalesceVariableNames, (, AbstractCompiler, compiler, ,, boolean, usePseudoNames, ), {, Preconditions, ., checkState, (, !]
[., index, ;, }, }, ;, CoalesceVariableNames, (, AbstractCompiler, compiler, ,, boolean, usePseudoNames, ), {, Preconditions, ., checkState, (, !]
[boolean, usePseudoNames, ), {, Preconditions, ., checkState, (, !, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;]
[boolean, usePseudoNames, ), {, Preconditions, ., checkState, (, !, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;]
[Preconditions, ., checkState, (, !, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;, this, ., compiler, =]
[checkState, (, !, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;, this, ., compiler, =, compiler, ;]
[!, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;, this, ., compiler, =, compiler, ;, colorings, =]
[!, compiler, ., getLifeCycleStage, (, ), ., isNormalized, (, ), ), ;, this, ., compiler, =, compiler, ;, colorings, =]
[., isNormalized, (, ), ), ;, this, ., compiler, =, compiler, ;, colorings, =, Lists, ., newLinkedList, (, ), ;]
[., isNormalized, (, ), ), ;, this, ., compiler, =, compiler, ;, colorings, =, Lists, ., newLinkedList, (, ), ;]
[), ;, this, ., compiler, =, compiler, ;, colorings, =, Lists, ., newLinkedList, (, ), ;, this, ., usePseudoNames, =]
[this, ., usePseudoNames, =, usePseudoNames, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[this, ., usePseudoNames, =, usePseudoNames, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[usePseudoNames, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, NodeTraversal, ., traverse, (]
[}, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, NodeTraversal, ., traverse, (, compiler, ,]
[Override, public, void, process, (, Node, externs, ,, Node, root, ), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[(, compiler, ,, root, ,, this, ), ;, }, private, static, boolean, shouldOptimizeScope, (, Scope, scope, ), {, if, (]
[(, compiler, ,, root, ,, this, ), ;, }, private, static, boolean, shouldOptimizeScope, (, Scope, scope, ), {, if, (]
[}, private, static, boolean, shouldOptimizeScope, (, Scope, scope, ), {, if, (, scope, ., isGlobal, (, ), ), {, return]
[(, Scope, scope, ), {, if, (, scope, ., isGlobal, (, ), ), {, return, false, ;, }, if, (]
[(, Scope, scope, ), {, if, (, scope, ., isGlobal, (, ), ), {, return, false, ;, }, if, (]
[(, Scope, scope, ), {, if, (, scope, ., isGlobal, (, ), ), {, return, false, ;, }, if, (]
[{, if, (, scope, ., isGlobal, (, ), ), {, return, false, ;, }, if, (, LiveVariablesAnalysis, ., MAX_VARIABLES_TO_ANALYZE, <]
[{, if, (, scope, ., isGlobal, (, ), ), {, return, false, ;, }, if, (, LiveVariablesAnalysis, ., MAX_VARIABLES_TO_ANALYZE, <]
[), {, return, false, ;, }, if, (, LiveVariablesAnalysis, ., MAX_VARIABLES_TO_ANALYZE, <, scope, ., getVarCount, (, ), ), {, return]
[;, }, if, (, LiveVariablesAnalysis, ., MAX_VARIABLES_TO_ANALYZE, <, scope, ., getVarCount, (, ), ), {, return, false, ;, }, return]
[false, ;, }, return, true, ;, }, @, Override, public, void, enterScope, (, NodeTraversal, t, ), {, Scope, scope, =]
[false, ;, }, return, true, ;, }, @, Override, public, void, enterScope, (, NodeTraversal, t, ), {, Scope, scope, =]
[Override, public, void, enterScope, (, NodeTraversal, t, ), {, Scope, scope, =, t, ., getScope, (, ), ;, if, (]
[public, void, enterScope, (, NodeTraversal, t, ), {, Scope, scope, =, t, ., getScope, (, ), ;, if, (, !]
[enterScope, (, NodeTraversal, t, ), {, Scope, scope, =, t, ., getScope, (, ), ;, if, (, !, shouldOptimizeScope, (]
[), ;, if, (, !, shouldOptimizeScope, (, scope, ), ), {, return, ;, }, ControlFlowGraph, <, Node, >, cfg, =]
[), ;, if, (, !, shouldOptimizeScope, (, scope, ), ), {, return, ;, }, ControlFlowGraph, <, Node, >, cfg, =]
[), {, return, ;, }, ControlFlowGraph, <, Node, >, cfg, =, t, ., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =]
[;, }, ControlFlowGraph, <, Node, >, cfg, =, t, ., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =, new, LiveVariablesAnalysis, (]
[ControlFlowGraph, <, Node, >, cfg, =, t, ., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,]
[Node, >, cfg, =, t, ., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,]
[., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;, if, (]
[., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;, if, (]
[., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;, if, (]
[., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;, if, (]
[., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;, if, (]
[., getControlFlowGraph, (, ), ;, LiveVariablesAnalysis, liveness, =, new, LiveVariablesAnalysis, (, cfg, ,, scope, ,, compiler, ), ;, if, (]
[if, (, scope, ., getRootNode, (, ), ., getFirstChild, (, ), ., getNext, (, ), ., getChildCount, (, ), ==]
[., getRootNode, (, ), ., getFirstChild, (, ), ., getNext, (, ), ., getChildCount, (, ), ==, 2, ), {]
[., getRootNode, (, ), ., getFirstChild, (, ), ., getNext, (, ), ., getChildCount, (, ), ==, 2, ), {]
[), ., getNext, (, ), ., getChildCount, (, ), ==, 2, ), {, liveness, ., markAllParametersEscaped, (, ), ;, }]
[), ., getNext, (, ), ., getChildCount, (, ), ==, 2, ), {, liveness, ., markAllParametersEscaped, (, ), ;, }]
[., markAllParametersEscaped, (, ), ;, }, liveness, ., analyze, (, ), ;, UndiGraph, <, Var, ,, Void, >, interferenceGraph, =]
[(, ), ;, }, liveness, ., analyze, (, ), ;, UndiGraph, <, Var, ,, Void, >, interferenceGraph, =, computeVariableNamesInterferenceGraph, (]
[;, }, liveness, ., analyze, (, ), ;, UndiGraph, <, Var, ,, Void, >, interferenceGraph, =, computeVariableNamesInterferenceGraph, (, t, ,]
[liveness, ., analyze, (, ), ;, UndiGraph, <, Var, ,, Void, >, interferenceGraph, =, computeVariableNamesInterferenceGraph, (, t, ,, cfg, ,]
[liveness, ., analyze, (, ), ;, UndiGraph, <, Var, ,, Void, >, interferenceGraph, =, computeVariableNamesInterferenceGraph, (, t, ,, cfg, ,]
[(, t, ,, cfg, ,, liveness, ., getEscapedLocals, (, ), ), ;, GraphColoring, <, Var, ,, Void, >, coloring, =]
[(, ), ), ;, GraphColoring, <, Var, ,, Void, >, coloring, =, new, GreedyGraphColoring, <, Var, ,, Void, >, (]
[), ;, GraphColoring, <, Var, ,, Void, >, coloring, =, new, GreedyGraphColoring, <, Var, ,, Void, >, (, interferenceGraph, ,]
[<, Var, ,, Void, >, coloring, =, new, GreedyGraphColoring, <, Var, ,, Void, >, (, interferenceGraph, ,, coloringTieBreaker, ), ;]
[<, Var, ,, Void, >, coloring, =, new, GreedyGraphColoring, <, Var, ,, Void, >, (, interferenceGraph, ,, coloringTieBreaker, ), ;]
[=, new, GreedyGraphColoring, <, Var, ,, Void, >, (, interferenceGraph, ,, coloringTieBreaker, ), ;, coloring, ., color, (, ), ;]
[=, new, GreedyGraphColoring, <, Var, ,, Void, >, (, interferenceGraph, ,, coloringTieBreaker, ), ;, coloring, ., color, (, ), ;]
[Var, ,, Void, >, (, interferenceGraph, ,, coloringTieBreaker, ), ;, coloring, ., color, (, ), ;, colorings, ., push, (]
[colorings, ., push, (, coloring, ), ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, if, (]
[., push, (, coloring, ), ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, if, (, !]
[(, coloring, ), ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, if, (, !, shouldOptimizeScope, (]
[(, coloring, ), ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, if, (, !, shouldOptimizeScope, (]
[NodeTraversal, t, ), {, if, (, !, shouldOptimizeScope, (, t, ., getScope, (, ), ), ), {, return, ;, }]
[NodeTraversal, t, ), {, if, (, !, shouldOptimizeScope, (, t, ., getScope, (, ), ), ), {, return, ;, }]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, colorings, ., isEmpty, (, ), ||]
[(, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, colorings, ., isEmpty, (, ), ||, !]
[(, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, colorings, ., isEmpty, (, ), ||, !]
[,, Node, parent, ), {, if, (, colorings, ., isEmpty, (, ), ||, !, n, ., isName, (, ), ||]
[,, Node, parent, ), {, if, (, colorings, ., isEmpty, (, ), ||, !, n, ., isName, (, ), ||]
[!, n, ., isName, (, ), ||, parent, ., isFunction, (, ), ), {, return, ;, }, Var, var, =]
[!, n, ., isName, (, ), ||, parent, ., isFunction, (, ), ), {, return, ;, }, Var, var, =]
[!, n, ., isName, (, ), ||, parent, ., isFunction, (, ), ), {, return, ;, }, Var, var, =]
[., isFunction, (, ), ), {, return, ;, }, Var, var, =, t, ., getScope, (, ), ., getVar, (]
[., isFunction, (, ), ), {, return, ;, }, Var, var, =, t, ., getScope, (, ), ., getVar, (]
[(, ), ., getVar, (, n, ., getString, (, ), ), ;, GraphNode, <, Var, ,, ?, >, vNode, =]
[(, ), ., getVar, (, n, ., getString, (, ), ), ;, GraphNode, <, Var, ,, ?, >, vNode, =]
[(, ), ., getVar, (, n, ., getString, (, ), ), ;, GraphNode, <, Var, ,, ?, >, vNode, =]
[(, ), ., getVar, (, n, ., getString, (, ), ), ;, GraphNode, <, Var, ,, ?, >, vNode, =]
[GraphNode, <, Var, ,, ?, >, vNode, =, colorings, ., peek, (, ), ., getGraph, (, ), ., getNode, (]
[>, vNode, =, colorings, ., peek, (, ), ., getGraph, (, ), ., getNode, (, var, ), ;, if, (]
[>, vNode, =, colorings, ., peek, (, ), ., getGraph, (, ), ., getNode, (, var, ), ;, if, (]
[=, colorings, ., peek, (, ), ., getGraph, (, ), ., getNode, (, var, ), ;, if, (, vNode, ==]
[), ., getNode, (, var, ), ;, if, (, vNode, ==, null, ), {, return, ;, }, Var, coalescedVar, =]
[), ., getNode, (, var, ), ;, if, (, vNode, ==, null, ), {, return, ;, }, Var, coalescedVar, =]
[), ., getNode, (, var, ), ;, if, (, vNode, ==, null, ), {, return, ;, }, Var, coalescedVar, =]
[(, vNode, ==, null, ), {, return, ;, }, Var, coalescedVar, =, colorings, ., peek, (, ), ., getPartitionSuperNode, (]
[{, return, ;, }, Var, coalescedVar, =, colorings, ., peek, (, ), ., getPartitionSuperNode, (, var, ), ;, if, (]
[return, ;, }, Var, coalescedVar, =, colorings, ., peek, (, ), ., getPartitionSuperNode, (, var, ), ;, if, (, !]
[=, colorings, ., peek, (, ), ., getPartitionSuperNode, (, var, ), ;, if, (, !, usePseudoNames, ), {, if, (]
[=, colorings, ., peek, (, ), ., getPartitionSuperNode, (, var, ), ;, if, (, !, usePseudoNames, ), {, if, (]
[=, colorings, ., peek, (, ), ., getPartitionSuperNode, (, var, ), ;, if, (, !, usePseudoNames, ), {, if, (]
[(, var, ), ;, if, (, !, usePseudoNames, ), {, if, (, vNode, ., getValue, (, ), ., equals, (]
[usePseudoNames, ), {, if, (, vNode, ., getValue, (, ), ., equals, (, coalescedVar, ), ), {, return, ;, }]
[usePseudoNames, ), {, if, (, vNode, ., getValue, (, ), ., equals, (, coalescedVar, ), ), {, return, ;, }]
[(, vNode, ., getValue, (, ), ., equals, (, coalescedVar, ), ), {, return, ;, }, n, ., setString, (]
[(, vNode, ., getValue, (, ), ., equals, (, coalescedVar, ), ), {, return, ;, }, n, ., setString, (]
[), ., equals, (, coalescedVar, ), ), {, return, ;, }, n, ., setString, (, coalescedVar, ., name, ), ;]
[), ., equals, (, coalescedVar, ), ), {, return, ;, }, n, ., setString, (, coalescedVar, ., name, ), ;]
[return, ;, }, n, ., setString, (, coalescedVar, ., name, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (]
[return, ;, }, n, ., setString, (, coalescedVar, ., name, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (]
[coalescedVar, ., name, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (, parent, ., isVar, (, ), ), {]
[name, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (, parent, ., isVar, (, ), ), {, removeVarDeclaration, (]
[(, parent, ., isVar, (, ), ), {, removeVarDeclaration, (, n, ), ;, }, }, else, {, String, pseudoName, =]
[removeVarDeclaration, (, n, ), ;, }, }, else, {, String, pseudoName, =, null, ;, Set, <, String, >, allMergedNames, =]
[removeVarDeclaration, (, n, ), ;, }, }, else, {, String, pseudoName, =, null, ;, Set, <, String, >, allMergedNames, =]
[Set, <, String, >, allMergedNames, =, Sets, ., newTreeSet, (, ), ;, for, (, Iterator, <, Var, >, i, =]
[Set, <, String, >, allMergedNames, =, Sets, ., newTreeSet, (, ), ;, for, (, Iterator, <, Var, >, i, =]
[Set, <, String, >, allMergedNames, =, Sets, ., newTreeSet, (, ), ;, for, (, Iterator, <, Var, >, i, =]
[), ;, for, (, Iterator, <, Var, >, i, =, t, ., getScope, (, ), ., getVars, (, ), ;]
[), ;, for, (, Iterator, <, Var, >, i, =, t, ., getScope, (, ), ., getVars, (, ), ;]
[., getScope, (, ), ., getVars, (, ), ;, i, ., hasNext, (, ), ;, ), {, Var, iVar, =]
[., getScope, (, ), ., getVars, (, ), ;, i, ., hasNext, (, ), ;, ), {, Var, iVar, =]
[;, i, ., hasNext, (, ), ;, ), {, Var, iVar, =, i, ., next, (, ), ;, if, (]
[;, i, ., hasNext, (, ), ;, ), {, Var, iVar, =, i, ., next, (, ), ;, if, (]
[;, i, ., hasNext, (, ), ;, ), {, Var, iVar, =, i, ., next, (, ), ;, if, (]
[;, i, ., hasNext, (, ), ;, ), {, Var, iVar, =, i, ., next, (, ), ;, if, (]
[;, i, ., hasNext, (, ), ;, ), {, Var, iVar, =, i, ., next, (, ), ;, if, (]
[;, i, ., hasNext, (, ), ;, ), {, Var, iVar, =, i, ., next, (, ), ;, if, (]
[i, ., next, (, ), ;, if, (, colorings, ., peek, (, ), ., getGraph, (, ), ., getNode, (]
[(, ), ;, if, (, colorings, ., peek, (, ), ., getGraph, (, ), ., getNode, (, iVar, ), !=]
[;, if, (, colorings, ., peek, (, ), ., getGraph, (, ), ., getNode, (, iVar, ), !=, null, &&]
[;, if, (, colorings, ., peek, (, ), ., getGraph, (, ), ., getNode, (, iVar, ), !=, null, &&]
[., peek, (, ), ., getGraph, (, ), ., getNode, (, iVar, ), !=, null, &&, coalescedVar, ., equals, (]
[., peek, (, ), ., getGraph, (, ), ., getNode, (, iVar, ), !=, null, &&, coalescedVar, ., equals, (]
[., peek, (, ), ., getGraph, (, ), ., getNode, (, iVar, ), !=, null, &&, coalescedVar, ., equals, (]
[., getNode, (, iVar, ), !=, null, &&, coalescedVar, ., equals, (, colorings, ., peek, (, ), ., getPartitionSuperNode, (]
[!=, null, &&, coalescedVar, ., equals, (, colorings, ., peek, (, ), ., getPartitionSuperNode, (, iVar, ), ), ), {]
[!=, null, &&, coalescedVar, ., equals, (, colorings, ., peek, (, ), ., getPartitionSuperNode, (, iVar, ), ), ), {]
[., equals, (, colorings, ., peek, (, ), ., getPartitionSuperNode, (, iVar, ), ), ), {, allMergedNames, ., add, (]
[., equals, (, colorings, ., peek, (, ), ., getPartitionSuperNode, (, iVar, ), ), ), {, allMergedNames, ., add, (]
[getPartitionSuperNode, (, iVar, ), ), ), {, allMergedNames, ., add, (, iVar, ., name, ), ;, }, }, if, (]
[getPartitionSuperNode, (, iVar, ), ), ), {, allMergedNames, ., add, (, iVar, ., name, ), ;, }, }, if, (]
[getPartitionSuperNode, (, iVar, ), ), ), {, allMergedNames, ., add, (, iVar, ., name, ), ;, }, }, if, (]
[{, allMergedNames, ., add, (, iVar, ., name, ), ;, }, }, if, (, allMergedNames, ., size, (, ), ==]
[., name, ), ;, }, }, if, (, allMergedNames, ., size, (, ), ==, 1, ), {, return, ;, }]
[), ;, }, }, if, (, allMergedNames, ., size, (, ), ==, 1, ), {, return, ;, }, pseudoName, =]
[), ;, }, }, if, (, allMergedNames, ., size, (, ), ==, 1, ), {, return, ;, }, pseudoName, =]
[), ;, }, }, if, (, allMergedNames, ., size, (, ), ==, 1, ), {, return, ;, }, pseudoName, =]
[if, (, allMergedNames, ., size, (, ), ==, 1, ), {, return, ;, }, pseudoName, =, Joiner, ., on, (]
[(, ), ==, 1, ), {, return, ;, }, pseudoName, =, Joiner, ., on, (, "_", ), ., join, (]
[{, return, ;, }, pseudoName, =, Joiner, ., on, (, "_", ), ., join, (, allMergedNames, ), ;, while, (]
[{, return, ;, }, pseudoName, =, Joiner, ., on, (, "_", ), ., join, (, allMergedNames, ), ;, while, (]
[{, return, ;, }, pseudoName, =, Joiner, ., on, (, "_", ), ., join, (, allMergedNames, ), ;, while, (]
[on, (, "_", ), ., join, (, allMergedNames, ), ;, while, (, t, ., getScope, (, ), ., isDeclared, (]
["_", ), ., join, (, allMergedNames, ), ;, while, (, t, ., getScope, (, ), ., isDeclared, (, pseudoName, ,]
[(, allMergedNames, ), ;, while, (, t, ., getScope, (, ), ., isDeclared, (, pseudoName, ,, true, ), ), {]
[), ;, while, (, t, ., getScope, (, ), ., isDeclared, (, pseudoName, ,, true, ), ), {, pseudoName, +=]
[(, t, ., getScope, (, ), ., isDeclared, (, pseudoName, ,, true, ), ), {, pseudoName, +=, "$", ;, }]
[(, t, ., getScope, (, ), ., isDeclared, (, pseudoName, ,, true, ), ), {, pseudoName, +=, "$", ;, }]
[(, ), ., isDeclared, (, pseudoName, ,, true, ), ), {, pseudoName, +=, "$", ;, }, n, ., setString, (]
[isDeclared, (, pseudoName, ,, true, ), ), {, pseudoName, +=, "$", ;, }, n, ., setString, (, pseudoName, ), ;]
[isDeclared, (, pseudoName, ,, true, ), ), {, pseudoName, +=, "$", ;, }, n, ., setString, (, pseudoName, ), ;]
[pseudoName, +=, "$", ;, }, n, ., setString, (, pseudoName, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (]
[pseudoName, +=, "$", ;, }, n, ., setString, (, pseudoName, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (]
[+=, "$", ;, }, n, ., setString, (, pseudoName, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (, !]
[+=, "$", ;, }, n, ., setString, (, pseudoName, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (, !]
[+=, "$", ;, }, n, ., setString, (, pseudoName, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (, !]
[pseudoName, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (, !, vNode, ., getValue, (, ), ., equals, (]
[compiler, ., reportCodeChange, (, ), ;, if, (, !, vNode, ., getValue, (, ), ., equals, (, coalescedVar, ), &&]
[compiler, ., reportCodeChange, (, ), ;, if, (, !, vNode, ., getValue, (, ), ., equals, (, coalescedVar, ), &&]
[(, !, vNode, ., getValue, (, ), ., equals, (, coalescedVar, ), &&, parent, ., isVar, (, ), ), {]
[vNode, ., getValue, (, ), ., equals, (, coalescedVar, ), &&, parent, ., isVar, (, ), ), {, removeVarDeclaration, (]
[<, Node, >, cfg, ,, Set, <, Var, >, escaped, ), {, UndiGraph, <, Var, ,, Void, >, interferenceGraph, =]
[<, Node, >, cfg, ,, Set, <, Var, >, escaped, ), {, UndiGraph, <, Var, ,, Void, >, interferenceGraph, =]
[escaped, ), {, UndiGraph, <, Var, ,, Void, >, interferenceGraph, =, LinkedUndirectedGraph, ., create, (, ), ;, Scope, scope, =]
[escaped, ), {, UndiGraph, <, Var, ,, Void, >, interferenceGraph, =, LinkedUndirectedGraph, ., create, (, ), ;, Scope, scope, =]
[(, ), ;, Scope, scope, =, t, ., getScope, (, ), ;, for, (, Iterator, <, Var, >, i, =]
[(, ), ;, Scope, scope, =, t, ., getScope, (, ), ;, for, (, Iterator, <, Var, >, i, =]
[t, ., getScope, (, ), ;, for, (, Iterator, <, Var, >, i, =, scope, ., getVars, (, ), ;]
[t, ., getScope, (, ), ;, for, (, Iterator, <, Var, >, i, =, scope, ., getVars, (, ), ;]
[>, i, =, scope, ., getVars, (, ), ;, i, ., hasNext, (, ), ;, ), {, Var, v, =]
[>, i, =, scope, ., getVars, (, ), ;, i, ., hasNext, (, ), ;, ), {, Var, v, =]
[;, i, ., hasNext, (, ), ;, ), {, Var, v, =, i, ., next, (, ), ;, if, (]
[i, ., hasNext, (, ), ;, ), {, Var, v, =, i, ., next, (, ), ;, if, (, !]
[i, ., hasNext, (, ), ;, ), {, Var, v, =, i, ., next, (, ), ;, if, (, !]
[), ;, ), {, Var, v, =, i, ., next, (, ), ;, if, (, !, escaped, ., contains, (]
[=, i, ., next, (, ), ;, if, (, !, escaped, ., contains, (, v, ), ), {, if, (]
[i, ., next, (, ), ;, if, (, !, escaped, ., contains, (, v, ), ), {, if, (, !]
[i, ., next, (, ), ;, if, (, !, escaped, ., contains, (, v, ), ), {, if, (, !]
[i, ., next, (, ), ;, if, (, !, escaped, ., contains, (, v, ), ), {, if, (, !]
[contains, (, v, ), ), {, if, (, !, v, ., getParentNode, (, ), ., isFunction, (, ), ), {]
[contains, (, v, ), ), {, if, (, !, v, ., getParentNode, (, ), ., isFunction, (, ), ), {]
[), {, if, (, !, v, ., getParentNode, (, ), ., isFunction, (, ), ), {, interferenceGraph, ., createNode, (]
[), {, interferenceGraph, ., createNode, (, v, ), ;, }, }, }, for, (, Iterator, <, Var, >, i1, =]
[), {, interferenceGraph, ., createNode, (, v, ), ;, }, }, }, for, (, Iterator, <, Var, >, i1, =]
[v, ), ;, }, }, }, for, (, Iterator, <, Var, >, i1, =, scope, ., getVars, (, ), ;]
[v, ), ;, }, }, }, for, (, Iterator, <, Var, >, i1, =, scope, ., getVars, (, ), ;]
[>, i1, =, scope, ., getVars, (, ), ;, i1, ., hasNext, (, ), ;, ), {, Var, v1, =]
[>, i1, =, scope, ., getVars, (, ), ;, i1, ., hasNext, (, ), ;, ), {, Var, v1, =]
[{, Var, v1, =, i1, ., next, (, ), ;, NEXT_VAR_PAIR, :, for, (, Iterator, <, Var, >, i2, =]
[{, Var, v1, =, i1, ., next, (, ), ;, NEXT_VAR_PAIR, :, for, (, Iterator, <, Var, >, i2, =]
[next, (, ), ;, NEXT_VAR_PAIR, :, for, (, Iterator, <, Var, >, i2, =, scope, ., getVars, (, ), ;]
[next, (, ), ;, NEXT_VAR_PAIR, :, for, (, Iterator, <, Var, >, i2, =, scope, ., getVars, (, ), ;]
[>, i2, =, scope, ., getVars, (, ), ;, i2, ., hasNext, (, ), ;, ), {, Var, v2, =]
[>, i2, =, scope, ., getVars, (, ), ;, i2, ., hasNext, (, ), ;, ), {, Var, v2, =]
[;, i2, ., hasNext, (, ), ;, ), {, Var, v2, =, i2, ., next, (, ), ;, if, (]
[;, i2, ., hasNext, (, ), ;, ), {, Var, v2, =, i2, ., next, (, ), ;, if, (]
[;, i2, ., hasNext, (, ), ;, ), {, Var, v2, =, i2, ., next, (, ), ;, if, (]
[(, ), ;, ), {, Var, v2, =, i2, ., next, (, ), ;, if, (, v1, ., index, >=]
[(, ), ;, ), {, Var, v2, =, i2, ., next, (, ), ;, if, (, v1, ., index, >=]
[next, (, ), ;, if, (, v1, ., index, >=, v2, ., index, ), {, continue, ;, }, if, (]
[next, (, ), ;, if, (, v1, ., index, >=, v2, ., index, ), {, continue, ;, }, if, (]
[(, ), ;, if, (, v1, ., index, >=, v2, ., index, ), {, continue, ;, }, if, (, !]
[(, ), ;, if, (, v1, ., index, >=, v2, ., index, ), {, continue, ;, }, if, (, !]
[(, v1, ., index, >=, v2, ., index, ), {, continue, ;, }, if, (, !, interferenceGraph, ., hasNode, (]
[index, >=, v2, ., index, ), {, continue, ;, }, if, (, !, interferenceGraph, ., hasNode, (, v1, ), ||]
[>=, v2, ., index, ), {, continue, ;, }, if, (, !, interferenceGraph, ., hasNode, (, v1, ), ||, !]
[>=, v2, ., index, ), {, continue, ;, }, if, (, !, interferenceGraph, ., hasNode, (, v1, ), ||, !]
[), {, continue, ;, }, if, (, !, interferenceGraph, ., hasNode, (, v1, ), ||, !, interferenceGraph, ., hasNode, (]
[hasNode, (, v1, ), ||, !, interferenceGraph, ., hasNode, (, v2, ), ), {, continue, NEXT_VAR_PAIR, ;, }, if, (]
[hasNode, (, v1, ), ||, !, interferenceGraph, ., hasNode, (, v2, ), ), {, continue, NEXT_VAR_PAIR, ;, }, if, (]
[hasNode, (, v1, ), ||, !, interferenceGraph, ., hasNode, (, v2, ), ), {, continue, NEXT_VAR_PAIR, ;, }, if, (]
[hasNode, (, v1, ), ||, !, interferenceGraph, ., hasNode, (, v2, ), ), {, continue, NEXT_VAR_PAIR, ;, }, if, (]
[v2, ), ), {, continue, NEXT_VAR_PAIR, ;, }, if, (, v1, ., getParentNode, (, ), ., isParamList, (, ), &&]
[v2, ), ), {, continue, NEXT_VAR_PAIR, ;, }, if, (, v1, ., getParentNode, (, ), ., isParamList, (, ), &&]
[v2, ), ), {, continue, NEXT_VAR_PAIR, ;, }, if, (, v1, ., getParentNode, (, ), ., isParamList, (, ), &&]
[., getParentNode, (, ), ., isParamList, (, ), &&, v2, ., getParentNode, (, ), ., isParamList, (, ), ), {]
[., getParentNode, (, ), ., isParamList, (, ), &&, v2, ., getParentNode, (, ), ., isParamList, (, ), ), {]
[., isParamList, (, ), &&, v2, ., getParentNode, (, ), ., isParamList, (, ), ), {, interferenceGraph, ., connectIfNotFound, (]
[(, ), &&, v2, ., getParentNode, (, ), ., isParamList, (, ), ), {, interferenceGraph, ., connectIfNotFound, (, v1, ,]
[&&, v2, ., getParentNode, (, ), ., isParamList, (, ), ), {, interferenceGraph, ., connectIfNotFound, (, v1, ,, null, ,]
[,, v2, ), ;, continue, NEXT_VAR_PAIR, ;, }, NEXT_CROSS_CFG_NODE, :, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :]
[,, v2, ), ;, continue, NEXT_VAR_PAIR, ;, }, NEXT_CROSS_CFG_NODE, :, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :]
[:, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (]
[:, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (]
[<, Node, ,, Branch, >, cfgNode, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (, cfg, ., isImplicitReturn, (]
[if, (, cfg, ., isImplicitReturn, (, cfgNode, ), ), {, continue, NEXT_CROSS_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =]
[if, (, cfg, ., isImplicitReturn, (, cfgNode, ), ), {, continue, NEXT_CROSS_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =]
[), {, continue, NEXT_CROSS_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, if, (]
[), {, continue, NEXT_CROSS_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, if, (]
[{, continue, NEXT_CROSS_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, if, (, (]
[{, continue, NEXT_CROSS_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, if, (, (]
[{, continue, NEXT_CROSS_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, if, (, (]
[{, continue, NEXT_CROSS_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, if, (, (]
[>, state, =, cfgNode, ., getAnnotation, (, ), ;, if, (, (, state, ., getIn, (, ), ., isLive, (]
[cfgNode, ., getAnnotation, (, ), ;, if, (, (, state, ., getIn, (, ), ., isLive, (, v1, ), &&]
[cfgNode, ., getAnnotation, (, ), ;, if, (, (, state, ., getIn, (, ), ., isLive, (, v1, ), &&]
[cfgNode, ., getAnnotation, (, ), ;, if, (, (, state, ., getIn, (, ), ., isLive, (, v1, ), &&]
[(, state, ., getIn, (, ), ., isLive, (, v1, ), &&, state, ., getIn, (, ), ., isLive, (]
[(, ), ., isLive, (, v1, ), &&, state, ., getIn, (, ), ., isLive, (, v2, ), ), ||]
[), ., isLive, (, v1, ), &&, state, ., getIn, (, ), ., isLive, (, v2, ), ), ||, (]
[), ., isLive, (, v1, ), &&, state, ., getIn, (, ), ., isLive, (, v2, ), ), ||, (]
[), ., isLive, (, v1, ), &&, state, ., getIn, (, ), ., isLive, (, v2, ), ), ||, (]
[), ., isLive, (, v1, ), &&, state, ., getIn, (, ), ., isLive, (, v2, ), ), ||, (]
[., getIn, (, ), ., isLive, (, v2, ), ), ||, (, state, ., getOut, (, ), ., isLive, (]
[), ., isLive, (, v2, ), ), ||, (, state, ., getOut, (, ), ., isLive, (, v1, ), &&]
[), ., isLive, (, v2, ), ), ||, (, state, ., getOut, (, ), ., isLive, (, v1, ), &&]
[), ., isLive, (, v2, ), ), ||, (, state, ., getOut, (, ), ., isLive, (, v1, ), &&]
[(, state, ., getOut, (, ), ., isLive, (, v1, ), &&, state, ., getOut, (, ), ., isLive, (]
[), ., isLive, (, v1, ), &&, state, ., getOut, (, ), ., isLive, (, v2, ), ), ), {]
[), ., isLive, (, v1, ), &&, state, ., getOut, (, ), ., isLive, (, v2, ), ), ), {]
[v1, ), &&, state, ., getOut, (, ), ., isLive, (, v2, ), ), ), {, interferenceGraph, ., connectIfNotFound, (]
[&&, state, ., getOut, (, ), ., isLive, (, v2, ), ), ), {, interferenceGraph, ., connectIfNotFound, (, v1, ,]
[., getOut, (, ), ., isLive, (, v2, ), ), ), {, interferenceGraph, ., connectIfNotFound, (, v1, ,, null, ,]
[v2, ), ;, continue, NEXT_VAR_PAIR, ;, }, }, NEXT_INTRA_CFG_NODE, :, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :]
[v2, ), ;, continue, NEXT_VAR_PAIR, ;, }, }, NEXT_INTRA_CFG_NODE, :, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :]
[:, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (]
[:, for, (, DiGraphNode, <, Node, ,, Branch, >, cfgNode, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (]
[<, Node, ,, Branch, >, cfgNode, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (, cfg, ., isImplicitReturn, (]
[if, (, cfg, ., isImplicitReturn, (, cfgNode, ), ), {, continue, NEXT_INTRA_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =]
[if, (, cfg, ., isImplicitReturn, (, cfgNode, ), ), {, continue, NEXT_INTRA_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =]
[{, continue, NEXT_INTRA_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, boolean, v1OutLive, =]
[{, continue, NEXT_INTRA_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, boolean, v1OutLive, =]
[{, continue, NEXT_INTRA_CFG_NODE, ;, }, FlowState, <, LiveVariableLattice, >, state, =, cfgNode, ., getAnnotation, (, ), ;, boolean, v1OutLive, =]
[>, state, =, cfgNode, ., getAnnotation, (, ), ;, boolean, v1OutLive, =, state, ., getOut, (, ), ., isLive, (]
[(, ), ;, boolean, v1OutLive, =, state, ., getOut, (, ), ., isLive, (, v1, ), ;, boolean, v2OutLive, =]
[(, ), ;, boolean, v1OutLive, =, state, ., getOut, (, ), ., isLive, (, v1, ), ;, boolean, v2OutLive, =]
[(, ), ;, boolean, v1OutLive, =, state, ., getOut, (, ), ., isLive, (, v1, ), ;, boolean, v2OutLive, =]
[getOut, (, ), ., isLive, (, v1, ), ;, boolean, v2OutLive, =, state, ., getOut, (, ), ., isLive, (]
[v1, ), ;, boolean, v2OutLive, =, state, ., getOut, (, ), ., isLive, (, v2, ), ;, CombinedLiveRangeChecker, checker, =]
[boolean, v2OutLive, =, state, ., getOut, (, ), ., isLive, (, v2, ), ;, CombinedLiveRangeChecker, checker, =, new, CombinedLiveRangeChecker, (]
[state, ., getOut, (, ), ., isLive, (, v2, ), ;, CombinedLiveRangeChecker, checker, =, new, CombinedLiveRangeChecker, (, new, LiveRangeChecker, (]
[getOut, (, ), ., isLive, (, v2, ), ;, CombinedLiveRangeChecker, checker, =, new, CombinedLiveRangeChecker, (, new, LiveRangeChecker, (, v1, ,]
[getOut, (, ), ., isLive, (, v2, ), ;, CombinedLiveRangeChecker, checker, =, new, CombinedLiveRangeChecker, (, new, LiveRangeChecker, (, v1, ,]
[), ., isLive, (, v2, ), ;, CombinedLiveRangeChecker, checker, =, new, CombinedLiveRangeChecker, (, new, LiveRangeChecker, (, v1, ,, v2OutLive, ?]
[isLive, (, v2, ), ;, CombinedLiveRangeChecker, checker, =, new, CombinedLiveRangeChecker, (, new, LiveRangeChecker, (, v1, ,, v2OutLive, ?, null, :]
[), ;, CombinedLiveRangeChecker, checker, =, new, CombinedLiveRangeChecker, (, new, LiveRangeChecker, (, v1, ,, v2OutLive, ?, null, :, v2, ), ,]
[checker, =, new, CombinedLiveRangeChecker, (, new, LiveRangeChecker, (, v1, ,, v2OutLive, ?, null, :, v2, ), ,, new, LiveRangeChecker, (]
[new, CombinedLiveRangeChecker, (, new, LiveRangeChecker, (, v1, ,, v2OutLive, ?, null, :, v2, ), ,, new, LiveRangeChecker, (, v2, ,]
[new, CombinedLiveRangeChecker, (, new, LiveRangeChecker, (, v1, ,, v2OutLive, ?, null, :, v2, ), ,, new, LiveRangeChecker, (, v2, ,]
[(, new, LiveRangeChecker, (, v1, ,, v2OutLive, ?, null, :, v2, ), ,, new, LiveRangeChecker, (, v2, ,, v1OutLive, ?]
[LiveRangeChecker, (, v1, ,, v2OutLive, ?, null, :, v2, ), ,, new, LiveRangeChecker, (, v2, ,, v1OutLive, ?, null, :]
[v2OutLive, ?, null, :, v2, ), ,, new, LiveRangeChecker, (, v2, ,, v1OutLive, ?, null, :, v1, ), ), ;]
[v2OutLive, ?, null, :, v2, ), ,, new, LiveRangeChecker, (, v2, ,, v1OutLive, ?, null, :, v1, ), ), ;]
[v2, ), ,, new, LiveRangeChecker, (, v2, ,, v1OutLive, ?, null, :, v1, ), ), ;, NodeTraversal, ., traverse, (]
[,, new, LiveRangeChecker, (, v2, ,, v1OutLive, ?, null, :, v1, ), ), ;, NodeTraversal, ., traverse, (, compiler, ,]
[,, new, LiveRangeChecker, (, v2, ,, v1OutLive, ?, null, :, v1, ), ), ;, NodeTraversal, ., traverse, (, compiler, ,]
[v1OutLive, ?, null, :, v1, ), ), ;, NodeTraversal, ., traverse, (, compiler, ,, cfgNode, ., getValue, (, ), ,]
[), ), ;, NodeTraversal, ., traverse, (, compiler, ,, cfgNode, ., getValue, (, ), ,, checker, ), ;, if, (]
[), ), ;, NodeTraversal, ., traverse, (, compiler, ,, cfgNode, ., getValue, (, ), ,, checker, ), ;, if, (]
[., traverse, (, compiler, ,, cfgNode, ., getValue, (, ), ,, checker, ), ;, if, (, checker, ., connectIfCrossed, (]
[), ;, if, (, checker, ., connectIfCrossed, (, interferenceGraph, ), ), {, continue, NEXT_VAR_PAIR, ;, }, }, }, }, return]
[{, private, final, LiveRangeChecker, callback1, ;, private, final, LiveRangeChecker, callback2, ;, CombinedLiveRangeChecker, (, LiveRangeChecker, callback1, ,, LiveRangeChecker, callback2, ), {]
[{, private, final, LiveRangeChecker, callback1, ;, private, final, LiveRangeChecker, callback2, ;, CombinedLiveRangeChecker, (, LiveRangeChecker, callback1, ,, LiveRangeChecker, callback2, ), {]
[callback1, ;, private, final, LiveRangeChecker, callback2, ;, CombinedLiveRangeChecker, (, LiveRangeChecker, callback1, ,, LiveRangeChecker, callback2, ), {, this, ., callback1, =]
[private, final, LiveRangeChecker, callback2, ;, CombinedLiveRangeChecker, (, LiveRangeChecker, callback1, ,, LiveRangeChecker, callback2, ), {, this, ., callback1, =, callback1, ;]
[private, final, LiveRangeChecker, callback2, ;, CombinedLiveRangeChecker, (, LiveRangeChecker, callback1, ,, LiveRangeChecker, callback2, ), {, this, ., callback1, =, callback1, ;]
[;, CombinedLiveRangeChecker, (, LiveRangeChecker, callback1, ,, LiveRangeChecker, callback2, ), {, this, ., callback1, =, callback1, ;, this, ., callback2, =]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, LiveRangeChecker, ., shouldVisit, (]
[NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, LiveRangeChecker, ., shouldVisit, (, n, ), ), {]
[NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, LiveRangeChecker, ., shouldVisit, (, n, ), ), {]
[n, ,, Node, parent, ), {, if, (, LiveRangeChecker, ., shouldVisit, (, n, ), ), {, callback1, ., visit, (]
[Node, parent, ), {, if, (, LiveRangeChecker, ., shouldVisit, (, n, ), ), {, callback1, ., visit, (, t, ,]
[), {, if, (, LiveRangeChecker, ., shouldVisit, (, n, ), ), {, callback1, ., visit, (, t, ,, n, ,]
[(, LiveRangeChecker, ., shouldVisit, (, n, ), ), {, callback1, ., visit, (, t, ,, n, ,, parent, ), ;]
[(, LiveRangeChecker, ., shouldVisit, (, n, ), ), {, callback1, ., visit, (, t, ,, n, ,, parent, ), ;]
[(, n, ), ), {, callback1, ., visit, (, t, ,, n, ,, parent, ), ;, callback2, ., visit, (]
[), ), {, callback1, ., visit, (, t, ,, n, ,, parent, ), ;, callback2, ., visit, (, t, ,]
[{, callback1, ., visit, (, t, ,, n, ,, parent, ), ;, callback2, ., visit, (, t, ,, n, ,]
[,, parent, ), ;, }, }, boolean, connectIfCrossed, (, UndiGraph, <, Var, ,, Void, >, interferenceGraph, ), {, if, (]
[,, parent, ), ;, }, }, boolean, connectIfCrossed, (, UndiGraph, <, Var, ,, Void, >, interferenceGraph, ), {, if, (]
[,, parent, ), ;, }, }, boolean, connectIfCrossed, (, UndiGraph, <, Var, ,, Void, >, interferenceGraph, ), {, if, (]
[}, }, boolean, connectIfCrossed, (, UndiGraph, <, Var, ,, Void, >, interferenceGraph, ), {, if, (, callback1, ., crossed, ||]
[}, }, boolean, connectIfCrossed, (, UndiGraph, <, Var, ,, Void, >, interferenceGraph, ), {, if, (, callback1, ., crossed, ||]
[,, Void, >, interferenceGraph, ), {, if, (, callback1, ., crossed, ||, callback2, ., crossed, ), {, Var, v1, =]
[,, Void, >, interferenceGraph, ), {, if, (, callback1, ., crossed, ||, callback2, ., crossed, ), {, Var, v1, =]
[., crossed, ||, callback2, ., crossed, ), {, Var, v1, =, callback1, ., getDef, (, ), ;, Var, v2, =]
[., crossed, ||, callback2, ., crossed, ), {, Var, v1, =, callback1, ., getDef, (, ), ;, Var, v2, =]
[), {, Var, v1, =, callback1, ., getDef, (, ), ;, Var, v2, =, callback2, ., getDef, (, ), ;]
[), {, Var, v1, =, callback1, ., getDef, (, ), ;, Var, v2, =, callback2, ., getDef, (, ), ;]
[=, callback1, ., getDef, (, ), ;, Var, v2, =, callback2, ., getDef, (, ), ;, interferenceGraph, ., connectIfNotFound, (]
[., getDef, (, ), ;, Var, v2, =, callback2, ., getDef, (, ), ;, interferenceGraph, ., connectIfNotFound, (, v1, ,]
[(, ), ;, Var, v2, =, callback2, ., getDef, (, ), ;, interferenceGraph, ., connectIfNotFound, (, v1, ,, null, ,]
[v2, =, callback2, ., getDef, (, ), ;, interferenceGraph, ., connectIfNotFound, (, v1, ,, null, ,, v2, ), ;, return]
[getDef, (, ), ;, interferenceGraph, ., connectIfNotFound, (, v1, ,, null, ,, v2, ), ;, return, true, ;, }, return]
[return, true, ;, }, return, false, ;, }, }, private, void, removeVarDeclaration, (, Node, name, ), {, Node, var, =]
[return, true, ;, }, return, false, ;, }, }, private, void, removeVarDeclaration, (, Node, name, ), {, Node, var, =]
[private, void, removeVarDeclaration, (, Node, name, ), {, Node, var, =, name, ., getParent, (, ), ;, Node, parent, =]
[private, void, removeVarDeclaration, (, Node, name, ), {, Node, var, =, name, ., getParent, (, ), ;, Node, parent, =]
[Node, var, =, name, ., getParent, (, ), ;, Node, parent, =, var, ., getParent, (, ), ;, if, (]
[Node, var, =, name, ., getParent, (, ), ;, Node, parent, =, var, ., getParent, (, ), ;, if, (]
[., getParent, (, ), ;, Node, parent, =, var, ., getParent, (, ), ;, if, (, NodeUtil, ., isForIn, (]
[;, Node, parent, =, var, ., getParent, (, ), ;, if, (, NodeUtil, ., isForIn, (, parent, ), ), {]
[;, Node, parent, =, var, ., getParent, (, ), ;, if, (, NodeUtil, ., isForIn, (, parent, ), ), {]
[var, ., getParent, (, ), ;, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, var, ., removeChild, (]
[(, ), ;, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, var, ., removeChild, (, name, ), ;]
[(, ), ;, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, var, ., removeChild, (, name, ), ;]
[(, NodeUtil, ., isForIn, (, parent, ), ), {, var, ., removeChild, (, name, ), ;, parent, ., replaceChild, (]
[., isForIn, (, parent, ), ), {, var, ., removeChild, (, name, ), ;, parent, ., replaceChild, (, var, ,]
[var, ., removeChild, (, name, ), ;, parent, ., replaceChild, (, var, ,, name, ), ;, }, else, if, (]
[var, ., removeChild, (, name, ), ;, parent, ., replaceChild, (, var, ,, name, ), ;, }, else, if, (]
[replaceChild, (, var, ,, name, ), ;, }, else, if, (, var, ., hasOneChild, (, ), ), {, if, (]
[replaceChild, (, var, ,, name, ), ;, }, else, if, (, var, ., hasOneChild, (, ), ), {, if, (]
[(, var, ., hasOneChild, (, ), ), {, if, (, name, ., hasChildren, (, ), ), {, Node, value, =]
[(, var, ., hasOneChild, (, ), ), {, if, (, name, ., hasChildren, (, ), ), {, Node, value, =]
[), {, if, (, name, ., hasChildren, (, ), ), {, Node, value, =, name, ., removeFirstChild, (, ), ;]
[), {, if, (, name, ., hasChildren, (, ), ), {, Node, value, =, name, ., removeFirstChild, (, ), ;]
[name, ., hasChildren, (, ), ), {, Node, value, =, name, ., removeFirstChild, (, ), ;, var, ., removeChild, (]
[{, Node, value, =, name, ., removeFirstChild, (, ), ;, var, ., removeChild, (, name, ), ;, Node, assign, =]
[{, Node, value, =, name, ., removeFirstChild, (, ), ;, var, ., removeChild, (, name, ), ;, Node, assign, =]
[{, Node, value, =, name, ., removeFirstChild, (, ), ;, var, ., removeChild, (, name, ), ;, Node, assign, =]
[name, ., removeFirstChild, (, ), ;, var, ., removeChild, (, name, ), ;, Node, assign, =, IR, ., assign, (]
[removeFirstChild, (, ), ;, var, ., removeChild, (, name, ), ;, Node, assign, =, IR, ., assign, (, name, ,]
[., removeChild, (, name, ), ;, Node, assign, =, IR, ., assign, (, name, ,, value, ), ., srcref, (]
[;, Node, assign, =, IR, ., assign, (, name, ,, value, ), ., srcref, (, name, ), ;, if, (]
[Node, assign, =, IR, ., assign, (, name, ,, value, ), ., srcref, (, name, ), ;, if, (, !]
[Node, assign, =, IR, ., assign, (, name, ,, value, ), ., srcref, (, name, ), ;, if, (, !]
[name, ,, value, ), ., srcref, (, name, ), ;, if, (, !, parent, ., isFor, (, ), ), {]
[value, ), ., srcref, (, name, ), ;, if, (, !, parent, ., isFor, (, ), ), {, assign, =]
[value, ), ., srcref, (, name, ), ;, if, (, !, parent, ., isFor, (, ), ), {, assign, =]
[(, name, ), ;, if, (, !, parent, ., isFor, (, ), ), {, assign, =, NodeUtil, ., newExpr, (]
[if, (, !, parent, ., isFor, (, ), ), {, assign, =, NodeUtil, ., newExpr, (, assign, ), ;, }]
[if, (, !, parent, ., isFor, (, ), ), {, assign, =, NodeUtil, ., newExpr, (, assign, ), ;, }]
[., isFor, (, ), ), {, assign, =, NodeUtil, ., newExpr, (, assign, ), ;, }, parent, ., replaceChild, (]
[(, ), ), {, assign, =, NodeUtil, ., newExpr, (, assign, ), ;, }, parent, ., replaceChild, (, var, ,]
[NodeUtil, ., newExpr, (, assign, ), ;, }, parent, ., replaceChild, (, var, ,, assign, ), ;, }, else, {]
[NodeUtil, ., newExpr, (, assign, ), ;, }, parent, ., replaceChild, (, var, ,, assign, ), ;, }, else, {]
[assign, ), ;, }, parent, ., replaceChild, (, var, ,, assign, ), ;, }, else, {, NodeUtil, ., removeChild, (]
[;, }, parent, ., replaceChild, (, var, ,, assign, ), ;, }, else, {, NodeUtil, ., removeChild, (, parent, ,]
[), ;, }, else, {, NodeUtil, ., removeChild, (, parent, ,, var, ), ;, }, }, else, {, if, (]
[;, }, else, {, NodeUtil, ., removeChild, (, parent, ,, var, ), ;, }, }, else, {, if, (, !]
[;, }, else, {, NodeUtil, ., removeChild, (, parent, ,, var, ), ;, }, }, else, {, if, (, !]
[(, parent, ,, var, ), ;, }, }, else, {, if, (, !, name, ., hasChildren, (, ), ), {]
[(, parent, ,, var, ), ;, }, }, else, {, if, (, !, name, ., hasChildren, (, ), ), {]
[), ;, }, }, else, {, if, (, !, name, ., hasChildren, (, ), ), {, var, ., removeChild, (]
[var, ., removeChild, (, name, ), ;, }, }, }, private, static, class, LiveRangeChecker, extends, AbstractCfgNodeTraversalCallback, {, boolean, defFound, =]
[), ;, }, }, }, private, static, class, LiveRangeChecker, extends, AbstractCfgNodeTraversalCallback, {, boolean, defFound, =, false, ;, boolean, crossed, =]
[private, final, Var, def, ;, private, final, Var, use, ;, public, LiveRangeChecker, (, Var, def, ,, Var, use, ), {]
[private, final, Var, def, ;, private, final, Var, use, ;, public, LiveRangeChecker, (, Var, def, ,, Var, use, ), {]
[;, private, final, Var, use, ;, public, LiveRangeChecker, (, Var, def, ,, Var, use, ), {, this, ., def, =]
[final, Var, use, ;, public, LiveRangeChecker, (, Var, def, ,, Var, use, ), {, this, ., def, =, def, ;]
[final, Var, use, ;, public, LiveRangeChecker, (, Var, def, ,, Var, use, ), {, this, ., def, =, def, ;]
[public, LiveRangeChecker, (, Var, def, ,, Var, use, ), {, this, ., def, =, def, ;, this, ., use, =]
[{, this, ., def, =, def, ;, this, ., use, =, use, ;, }, Var, getDef, (, ), {, return]
[}, Var, getDef, (, ), {, return, def, ;, }, public, static, boolean, shouldVisit, (, Node, n, ), {, return]
[Var, getDef, (, ), {, return, def, ;, }, public, static, boolean, shouldVisit, (, Node, n, ), {, return, (]
[Var, getDef, (, ), {, return, def, ;, }, public, static, boolean, shouldVisit, (, Node, n, ), {, return, (]
[Var, getDef, (, ), {, return, def, ;, }, public, static, boolean, shouldVisit, (, Node, n, ), {, return, (]
[def, ;, }, public, static, boolean, shouldVisit, (, Node, n, ), {, return, (, n, ., isName, (, ), ||]
[;, }, public, static, boolean, shouldVisit, (, Node, n, ), {, return, (, n, ., isName, (, ), ||, (]
[;, }, public, static, boolean, shouldVisit, (, Node, n, ), {, return, (, n, ., isName, (, ), ||, (]
[;, }, public, static, boolean, shouldVisit, (, Node, n, ), {, return, (, n, ., isName, (, ), ||, (]
[(, Node, n, ), {, return, (, n, ., isName, (, ), ||, (, n, ., hasChildren, (, ), &&]
[(, Node, n, ), {, return, (, n, ., isName, (, ), ||, (, n, ., hasChildren, (, ), &&]
[(, Node, n, ), {, return, (, n, ., isName, (, ), ||, (, n, ., hasChildren, (, ), &&]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[}, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, !]
[Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, !, defFound, &&]
[void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, !, defFound, &&, isAssignTo, (]
[(, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, !, defFound, &&, isAssignTo, (, def, ,]
[t, ,, Node, n, ,, Node, parent, ), {, if, (, !, defFound, &&, isAssignTo, (, def, ,, n, ,]
[,, Node, parent, ), {, if, (, !, defFound, &&, isAssignTo, (, def, ,, n, ,, parent, ), ), {]
[parent, ), {, if, (, !, defFound, &&, isAssignTo, (, def, ,, n, ,, parent, ), ), {, defFound, =]
[!, defFound, &&, isAssignTo, (, def, ,, n, ,, parent, ), ), {, defFound, =, true, ;, }, if, (]
[!, defFound, &&, isAssignTo, (, def, ,, n, ,, parent, ), ), {, defFound, =, true, ;, }, if, (]
[&&, isAssignTo, (, def, ,, n, ,, parent, ), ), {, defFound, =, true, ;, }, if, (, defFound, &&]
[isAssignTo, (, def, ,, n, ,, parent, ), ), {, defFound, =, true, ;, }, if, (, defFound, &&, (]
[isAssignTo, (, def, ,, n, ,, parent, ), ), {, defFound, =, true, ;, }, if, (, defFound, &&, (]
[isAssignTo, (, def, ,, n, ,, parent, ), ), {, defFound, =, true, ;, }, if, (, defFound, &&, (]
[def, ,, n, ,, parent, ), ), {, defFound, =, true, ;, }, if, (, defFound, &&, (, use, ==]
[n, ,, parent, ), ), {, defFound, =, true, ;, }, if, (, defFound, &&, (, use, ==, null, ||]
[parent, ), ), {, defFound, =, true, ;, }, if, (, defFound, &&, (, use, ==, null, ||, isReadFrom, (]
[), {, defFound, =, true, ;, }, if, (, defFound, &&, (, use, ==, null, ||, isReadFrom, (, use, ,]
[;, }, if, (, defFound, &&, (, use, ==, null, ||, isReadFrom, (, use, ,, n, ), ), ), {]
[if, (, defFound, &&, (, use, ==, null, ||, isReadFrom, (, use, ,, n, ), ), ), {, crossed, =]
[;, }, }, private, static, boolean, isAssignTo, (, Var, var, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, }, private, static, boolean, isAssignTo, (, Var, var, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, }, private, static, boolean, isAssignTo, (, Var, var, ,, Node, n, ,, Node, parent, ), {, if, (]
[;, }, }, private, static, boolean, isAssignTo, (, Var, var, ,, Node, n, ,, Node, parent, ), {, if, (]
[isAssignTo, (, Var, var, ,, Node, n, ,, Node, parent, ), {, if, (, n, ., isName, (, ), &&]
[isAssignTo, (, Var, var, ,, Node, n, ,, Node, parent, ), {, if, (, n, ., isName, (, ), &&]
[isAssignTo, (, Var, var, ,, Node, n, ,, Node, parent, ), {, if, (, n, ., isName, (, ), &&]
[Node, parent, ), {, if, (, n, ., isName, (, ), &&, var, ., getName, (, ), ., equals, (]
[Node, parent, ), {, if, (, n, ., isName, (, ), &&, var, ., getName, (, ), ., equals, (]
[., isName, (, ), &&, var, ., getName, (, ), ., equals, (, n, ., getString, (, ), ), &&]
[., isName, (, ), &&, var, ., getName, (, ), ., equals, (, n, ., getString, (, ), ), &&]
[(, ), &&, var, ., getName, (, ), ., equals, (, n, ., getString, (, ), ), &&, parent, !=]
[getName, (, ), ., equals, (, n, ., getString, (, ), ), &&, parent, !=, null, ), {, if, (]
[getName, (, ), ., equals, (, n, ., getString, (, ), ), &&, parent, !=, null, ), {, if, (]
[getString, (, ), ), &&, parent, !=, null, ), {, if, (, parent, ., isParamList, (, ), ), {, return]
[!=, null, ), {, if, (, parent, ., isParamList, (, ), ), {, return, true, ;, }, else, if, (]
[!=, null, ), {, if, (, parent, ., isParamList, (, ), ), {, return, true, ;, }, else, if, (]
[isParamList, (, ), ), {, return, true, ;, }, else, if, (, parent, ., isVar, (, ), ), {, return]
[isParamList, (, ), ), {, return, true, ;, }, else, if, (, parent, ., isVar, (, ), ), {, return]
[}, else, if, (, parent, ., isVar, (, ), ), {, return, n, ., hasChildren, (, ), ;, }, return]
[), ), {, return, n, ., hasChildren, (, ), ;, }, return, false, ;, }, else, {, Node, name, =]
[), ), {, return, n, ., hasChildren, (, ), ;, }, return, false, ;, }, else, {, Node, name, =]
[(, ), ;, }, return, false, ;, }, else, {, Node, name, =, n, ., getFirstChild, (, ), ;, return]
[(, ), ;, }, return, false, ;, }, else, {, Node, name, =, n, ., getFirstChild, (, ), ;, return]
[(, ), ;, }, return, false, ;, }, else, {, Node, name, =, n, ., getFirstChild, (, ), ;, return]
[(, ), ;, }, return, false, ;, }, else, {, Node, name, =, n, ., getFirstChild, (, ), ;, return]
[(, ), ;, }, return, false, ;, }, else, {, Node, name, =, n, ., getFirstChild, (, ), ;, return]
[;, }, return, false, ;, }, else, {, Node, name, =, n, ., getFirstChild, (, ), ;, return, name, !=]
[return, false, ;, }, else, {, Node, name, =, n, ., getFirstChild, (, ), ;, return, name, !=, null, &&]
[return, false, ;, }, else, {, Node, name, =, n, ., getFirstChild, (, ), ;, return, name, !=, null, &&]
[Node, name, =, n, ., getFirstChild, (, ), ;, return, name, !=, null, &&, name, ., isName, (, ), &&]
[Node, name, =, n, ., getFirstChild, (, ), ;, return, name, !=, null, &&, name, ., isName, (, ), &&]
[Node, name, =, n, ., getFirstChild, (, ), ;, return, name, !=, null, &&, name, ., isName, (, ), &&]
[;, return, name, !=, null, &&, name, ., isName, (, ), &&, var, ., getName, (, ), ., equals, (]
[;, return, name, !=, null, &&, name, ., isName, (, ), &&, var, ., getName, (, ), ., equals, (]
[., isName, (, ), &&, var, ., getName, (, ), ., equals, (, name, ., getString, (, ), ), &&]
[., isName, (, ), &&, var, ., getName, (, ), ., equals, (, name, ., getString, (, ), ), &&]
[&&, var, ., getName, (, ), ., equals, (, name, ., getString, (, ), ), &&, NodeUtil, ., isAssignmentOp, (]
[isAssignmentOp, (, n, ), ;, }, }, private, static, boolean, isReadFrom, (, Var, var, ,, Node, name, ), {, return]
[isAssignmentOp, (, n, ), ;, }, }, private, static, boolean, isReadFrom, (, Var, var, ,, Node, name, ), {, return]
[isAssignmentOp, (, n, ), ;, }, }, private, static, boolean, isReadFrom, (, Var, var, ,, Node, name, ), {, return]
[isAssignmentOp, (, n, ), ;, }, }, private, static, boolean, isReadFrom, (, Var, var, ,, Node, name, ), {, return]
[isAssignmentOp, (, n, ), ;, }, }, private, static, boolean, isReadFrom, (, Var, var, ,, Node, name, ), {, return]
[n, ), ;, }, }, private, static, boolean, isReadFrom, (, Var, var, ,, Node, name, ), {, return, name, !=]
[;, }, }, private, static, boolean, isReadFrom, (, Var, var, ,, Node, name, ), {, return, name, !=, null, &&]
[;, }, }, private, static, boolean, isReadFrom, (, Var, var, ,, Node, name, ), {, return, name, !=, null, &&]
[isReadFrom, (, Var, var, ,, Node, name, ), {, return, name, !=, null, &&, name, ., isName, (, ), &&]
[isReadFrom, (, Var, var, ,, Node, name, ), {, return, name, !=, null, &&, name, ., isName, (, ), &&]
[isReadFrom, (, Var, var, ,, Node, name, ), {, return, name, !=, null, &&, name, ., isName, (, ), &&]
[{, return, name, !=, null, &&, name, ., isName, (, ), &&, var, ., getName, (, ), ., equals, (]
[{, return, name, !=, null, &&, name, ., isName, (, ), &&, var, ., getName, (, ), ., equals, (]
[., isName, (, ), &&, var, ., getName, (, ), ., equals, (, name, ., getString, (, ), ), &&]
[isName, (, ), &&, var, ., getName, (, ), ., equals, (, name, ., getString, (, ), ), &&, !]
[isName, (, ), &&, var, ., getName, (, ), ., equals, (, name, ., getString, (, ), ), &&, !]
[var, ., getName, (, ), ., equals, (, name, ., getString, (, ), ), &&, !, NodeUtil, ., isVarOrSimpleAssignLhs, (]
[getName, (, ), ., equals, (, name, ., getString, (, ), ), &&, !, NodeUtil, ., isVarOrSimpleAssignLhs, (, name, ,]
[getName, (, ), ., equals, (, name, ., getString, (, ), ), &&, !, NodeUtil, ., isVarOrSimpleAssignLhs, (, name, ,]
