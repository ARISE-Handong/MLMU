[NestedLoops, >, surrounded, ;, private, Region, <, Euclidean2D, >, polygon, ;, private, boolean, originalIsClockwise, ;, public, NestedLoops, (, ), {]
[surrounded, ;, private, Region, <, Euclidean2D, >, polygon, ;, private, boolean, originalIsClockwise, ;, public, NestedLoops, (, ), {, surrounded, =]
[NestedLoops, >, (, ), ;, }, private, NestedLoops, (, final, Vector2D, [, ], loop, ), throws, MathIllegalArgumentException, {, if, (]
[NestedLoops, >, (, ), ;, }, private, NestedLoops, (, final, Vector2D, [, ], loop, ), throws, MathIllegalArgumentException, {, if, (]
[NestedLoops, >, (, ), ;, }, private, NestedLoops, (, final, Vector2D, [, ], loop, ), throws, MathIllegalArgumentException, {, if, (]
[(, ), ;, }, private, NestedLoops, (, final, Vector2D, [, ], loop, ), throws, MathIllegalArgumentException, {, if, (, loop, []
[}, private, NestedLoops, (, final, Vector2D, [, ], loop, ), throws, MathIllegalArgumentException, {, if, (, loop, [, 0, ], ==]
[final, Vector2D, [, ], loop, ), throws, MathIllegalArgumentException, {, if, (, loop, [, 0, ], ==, null, ), {, throw]
[], loop, ), throws, MathIllegalArgumentException, {, if, (, loop, [, 0, ], ==, null, ), {, throw, new, MathIllegalArgumentException, (]
[], loop, ), throws, MathIllegalArgumentException, {, if, (, loop, [, 0, ], ==, null, ), {, throw, new, MathIllegalArgumentException, (]
[if, (, loop, [, 0, ], ==, null, ), {, throw, new, MathIllegalArgumentException, (, LocalizedFormats, ., OUTLINE_BOUNDARY_LOOP_OPEN, ), ;, }]
[if, (, loop, [, 0, ], ==, null, ), {, throw, new, MathIllegalArgumentException, (, LocalizedFormats, ., OUTLINE_BOUNDARY_LOOP_OPEN, ), ;, }]
[0, ], ==, null, ), {, throw, new, MathIllegalArgumentException, (, LocalizedFormats, ., OUTLINE_BOUNDARY_LOOP_OPEN, ), ;, }, this, ., loop, =]
[==, null, ), {, throw, new, MathIllegalArgumentException, (, LocalizedFormats, ., OUTLINE_BOUNDARY_LOOP_OPEN, ), ;, }, this, ., loop, =, loop, ;]
[), {, throw, new, MathIllegalArgumentException, (, LocalizedFormats, ., OUTLINE_BOUNDARY_LOOP_OPEN, ), ;, }, this, ., loop, =, loop, ;, surrounded, =]
[surrounded, =, new, ArrayList, <, NestedLoops, >, (, ), ;, final, ArrayList, <, SubHyperplane, <, Euclidean2D, >, >, edges, =]
[<, Euclidean2D, >, >, edges, =, new, ArrayList, <, SubHyperplane, <, Euclidean2D, >, >, (, ), ;, Vector2D, current, =]
[<, Euclidean2D, >, >, edges, =, new, ArrayList, <, SubHyperplane, <, Euclidean2D, >, >, (, ), ;, Vector2D, current, =]
[>, >, edges, =, new, ArrayList, <, SubHyperplane, <, Euclidean2D, >, >, (, ), ;, Vector2D, current, =, loop, []
[>, >, edges, =, new, ArrayList, <, SubHyperplane, <, Euclidean2D, >, >, (, ), ;, Vector2D, current, =, loop, []
[>, >, edges, =, new, ArrayList, <, SubHyperplane, <, Euclidean2D, >, >, (, ), ;, Vector2D, current, =, loop, []
[new, ArrayList, <, SubHyperplane, <, Euclidean2D, >, >, (, ), ;, Vector2D, current, =, loop, [, loop, ., length, -]
[(, ), ;, Vector2D, current, =, loop, [, loop, ., length, -, 1, ], ;, for, (, int, i, =]
[;, Vector2D, current, =, loop, [, loop, ., length, -, 1, ], ;, for, (, int, i, =, 0, ;]
[;, Vector2D, current, =, loop, [, loop, ., length, -, 1, ], ;, for, (, int, i, =, 0, ;]
[current, =, loop, [, loop, ., length, -, 1, ], ;, for, (, int, i, =, 0, ;, i, <]
[current, =, loop, [, loop, ., length, -, 1, ], ;, for, (, int, i, =, 0, ;, i, <]
[loop, ., length, -, 1, ], ;, for, (, int, i, =, 0, ;, i, <, loop, ., length, ;]
[., length, -, 1, ], ;, for, (, int, i, =, 0, ;, i, <, loop, ., length, ;, ++]
[(, int, i, =, 0, ;, i, <, loop, ., length, ;, ++, i, ), {, final, Vector2D, previous, =]
[i, =, 0, ;, i, <, loop, ., length, ;, ++, i, ), {, final, Vector2D, previous, =, current, ;]
[0, ;, i, <, loop, ., length, ;, ++, i, ), {, final, Vector2D, previous, =, current, ;, current, =]
[0, ;, i, <, loop, ., length, ;, ++, i, ), {, final, Vector2D, previous, =, current, ;, current, =]
[i, <, loop, ., length, ;, ++, i, ), {, final, Vector2D, previous, =, current, ;, current, =, loop, []
[i, ), {, final, Vector2D, previous, =, current, ;, current, =, loop, [, i, ], ;, final, Line, line, =]
[final, Vector2D, previous, =, current, ;, current, =, loop, [, i, ], ;, final, Line, line, =, new, Line, (]
[previous, =, current, ;, current, =, loop, [, i, ], ;, final, Line, line, =, new, Line, (, previous, ,]
[[, i, ], ;, final, Line, line, =, new, Line, (, previous, ,, current, ), ;, final, IntervalsSet, region, =]
[;, final, Line, line, =, new, Line, (, previous, ,, current, ), ;, final, IntervalsSet, region, =, new, IntervalsSet, (]
[;, final, Line, line, =, new, Line, (, previous, ,, current, ), ;, final, IntervalsSet, region, =, new, IntervalsSet, (]
[;, final, Line, line, =, new, Line, (, previous, ,, current, ), ;, final, IntervalsSet, region, =, new, IntervalsSet, (]
[=, new, Line, (, previous, ,, current, ), ;, final, IntervalsSet, region, =, new, IntervalsSet, (, line, ., toSubSpace, (]
[), ;, final, IntervalsSet, region, =, new, IntervalsSet, (, line, ., toSubSpace, (, previous, ), ., getX, (, ), ,]
[), ;, final, IntervalsSet, region, =, new, IntervalsSet, (, line, ., toSubSpace, (, previous, ), ., getX, (, ), ,]
[), ;, final, IntervalsSet, region, =, new, IntervalsSet, (, line, ., toSubSpace, (, previous, ), ., getX, (, ), ,]
[region, =, new, IntervalsSet, (, line, ., toSubSpace, (, previous, ), ., getX, (, ), ,, line, ., toSubSpace, (]
[(, previous, ), ., getX, (, ), ,, line, ., toSubSpace, (, current, ), ., getX, (, ), ), ;]
[(, previous, ), ., getX, (, ), ,, line, ., toSubSpace, (, current, ), ., getX, (, ), ), ;]
[getX, (, ), ,, line, ., toSubSpace, (, current, ), ., getX, (, ), ), ;, edges, ., add, (]
[,, line, ., toSubSpace, (, current, ), ., getX, (, ), ), ;, edges, ., add, (, new, SubLine, (]
[., toSubSpace, (, current, ), ., getX, (, ), ), ;, edges, ., add, (, new, SubLine, (, line, ,]
[., getX, (, ), ), ;, edges, ., add, (, new, SubLine, (, line, ,, region, ), ), ;, }]
[(, ), ), ;, edges, ., add, (, new, SubLine, (, line, ,, region, ), ), ;, }, polygon, =]
[;, edges, ., add, (, new, SubLine, (, line, ,, region, ), ), ;, }, polygon, =, new, PolygonsSet, (]
[new, SubLine, (, line, ,, region, ), ), ;, }, polygon, =, new, PolygonsSet, (, edges, ), ;, if, (]
[new, SubLine, (, line, ,, region, ), ), ;, }, polygon, =, new, PolygonsSet, (, edges, ), ;, if, (]
[,, region, ), ), ;, }, polygon, =, new, PolygonsSet, (, edges, ), ;, if, (, Double, ., isInfinite, (]
[,, region, ), ), ;, }, polygon, =, new, PolygonsSet, (, edges, ), ;, if, (, Double, ., isInfinite, (]
[new, PolygonsSet, (, edges, ), ;, if, (, Double, ., isInfinite, (, polygon, ., getSize, (, ), ), ), {]
[(, edges, ), ;, if, (, Double, ., isInfinite, (, polygon, ., getSize, (, ), ), ), {, polygon, =]
[(, edges, ), ;, if, (, Double, ., isInfinite, (, polygon, ., getSize, (, ), ), ), {, polygon, =]
[polygon, ., getSize, (, ), ), ), {, polygon, =, new, RegionFactory, <, Euclidean2D, >, (, ), ., getComplement, (]
[(, ), ), ), {, polygon, =, new, RegionFactory, <, Euclidean2D, >, (, ), ., getComplement, (, polygon, ), ;]
[), ), {, polygon, =, new, RegionFactory, <, Euclidean2D, >, (, ), ., getComplement, (, polygon, ), ;, originalIsClockwise, =]
[new, RegionFactory, <, Euclidean2D, >, (, ), ., getComplement, (, polygon, ), ;, originalIsClockwise, =, false, ;, }, else, {]
[<, Euclidean2D, >, (, ), ., getComplement, (, polygon, ), ;, originalIsClockwise, =, false, ;, }, else, {, originalIsClockwise, =]
[{, originalIsClockwise, =, true, ;, }, }, public, void, add, (, final, Vector2D, [, ], bLoop, ), throws, MathIllegalArgumentException, {]
[=, true, ;, }, }, public, void, add, (, final, Vector2D, [, ], bLoop, ), throws, MathIllegalArgumentException, {, add, (]
[}, }, public, void, add, (, final, Vector2D, [, ], bLoop, ), throws, MathIllegalArgumentException, {, add, (, new, NestedLoops, (]
[), ;, }, private, void, add, (, final, NestedLoops, node, ), throws, MathIllegalArgumentException, {, for, (, final, NestedLoops, child, :]
[add, (, final, NestedLoops, node, ), throws, MathIllegalArgumentException, {, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (]
[add, (, final, NestedLoops, node, ), throws, MathIllegalArgumentException, {, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (]
[add, (, final, NestedLoops, node, ), throws, MathIllegalArgumentException, {, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (]
[throws, MathIllegalArgumentException, {, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (, child, ., polygon, ., contains, (]
[throws, MathIllegalArgumentException, {, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (, child, ., polygon, ., contains, (]
[NestedLoops, child, :, surrounded, ), {, if, (, child, ., polygon, ., contains, (, node, ., polygon, ), ), {]
[NestedLoops, child, :, surrounded, ), {, if, (, child, ., polygon, ., contains, (, node, ., polygon, ), ), {]
[), {, if, (, child, ., polygon, ., contains, (, node, ., polygon, ), ), {, child, ., add, (]
[child, ., add, (, node, ), ;, return, ;, }, }, for, (, final, Iterator, <, NestedLoops, >, iterator, =]
[child, ., add, (, node, ), ;, return, ;, }, }, for, (, final, Iterator, <, NestedLoops, >, iterator, =]
[;, return, ;, }, }, for, (, final, Iterator, <, NestedLoops, >, iterator, =, surrounded, ., iterator, (, ), ;]
[;, return, ;, }, }, for, (, final, Iterator, <, NestedLoops, >, iterator, =, surrounded, ., iterator, (, ), ;]
[iterator, =, surrounded, ., iterator, (, ), ;, iterator, ., hasNext, (, ), ;, ), {, final, NestedLoops, child, =]
[iterator, =, surrounded, ., iterator, (, ), ;, iterator, ., hasNext, (, ), ;, ), {, final, NestedLoops, child, =]
[iterator, ., hasNext, (, ), ;, ), {, final, NestedLoops, child, =, iterator, ., next, (, ), ;, if, (]
[iterator, ., hasNext, (, ), ;, ), {, final, NestedLoops, child, =, iterator, ., next, (, ), ;, if, (]
[iterator, ., hasNext, (, ), ;, ), {, final, NestedLoops, child, =, iterator, ., next, (, ), ;, if, (]
[), {, final, NestedLoops, child, =, iterator, ., next, (, ), ;, if, (, node, ., polygon, ., contains, (]
[), {, final, NestedLoops, child, =, iterator, ., next, (, ), ;, if, (, node, ., polygon, ., contains, (]
[iterator, ., next, (, ), ;, if, (, node, ., polygon, ., contains, (, child, ., polygon, ), ), {]
[iterator, ., next, (, ), ;, if, (, node, ., polygon, ., contains, (, child, ., polygon, ), ), {]
[iterator, ., next, (, ), ;, if, (, node, ., polygon, ., contains, (, child, ., polygon, ), ), {]
[if, (, node, ., polygon, ., contains, (, child, ., polygon, ), ), {, node, ., surrounded, ., add, (]
[., polygon, ., contains, (, child, ., polygon, ), ), {, node, ., surrounded, ., add, (, child, ), ;]
[., polygon, ., contains, (, child, ., polygon, ), ), {, node, ., surrounded, ., add, (, child, ), ;]
[., add, (, child, ), ;, iterator, ., remove, (, ), ;, }, }, RegionFactory, <, Euclidean2D, >, factory, =]
[RegionFactory, <, Euclidean2D, >, factory, =, new, RegionFactory, <, Euclidean2D, >, (, ), ;, for, (, final, NestedLoops, child, :]
[=, new, RegionFactory, <, Euclidean2D, >, (, ), ;, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (]
[new, RegionFactory, <, Euclidean2D, >, (, ), ;, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (, !]
[new, RegionFactory, <, Euclidean2D, >, (, ), ;, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (, !]
[new, RegionFactory, <, Euclidean2D, >, (, ), ;, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (, !]
[>, (, ), ;, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (, !, factory, ., intersection, (]
[>, (, ), ;, for, (, final, NestedLoops, child, :, surrounded, ), {, if, (, !, factory, ., intersection, (]
[for, (, final, NestedLoops, child, :, surrounded, ), {, if, (, !, factory, ., intersection, (, node, ., polygon, ,]
[for, (, final, NestedLoops, child, :, surrounded, ), {, if, (, !, factory, ., intersection, (, node, ., polygon, ,]
[!, factory, ., intersection, (, node, ., polygon, ,, child, ., polygon, ), ., isEmpty, (, ), ), {, throw]
[intersection, (, node, ., polygon, ,, child, ., polygon, ), ., isEmpty, (, ), ), {, throw, new, MathIllegalArgumentException, (]
[intersection, (, node, ., polygon, ,, child, ., polygon, ), ., isEmpty, (, ), ), {, throw, new, MathIllegalArgumentException, (]
[., polygon, ), ., isEmpty, (, ), ), {, throw, new, MathIllegalArgumentException, (, LocalizedFormats, ., CROSSING_BOUNDARY_LOOPS, ), ;, }, }]
[., polygon, ), ., isEmpty, (, ), ), {, throw, new, MathIllegalArgumentException, (, LocalizedFormats, ., CROSSING_BOUNDARY_LOOPS, ), ;, }, }]
[isEmpty, (, ), ), {, throw, new, MathIllegalArgumentException, (, LocalizedFormats, ., CROSSING_BOUNDARY_LOOPS, ), ;, }, }, surrounded, ., add, (]
[}, surrounded, ., add, (, node, ), ;, }, public, void, correctOrientation, (, ), {, for, (, NestedLoops, child, :]
[add, (, node, ), ;, }, public, void, correctOrientation, (, ), {, for, (, NestedLoops, child, :, surrounded, ), {]
[add, (, node, ), ;, }, public, void, correctOrientation, (, ), {, for, (, NestedLoops, child, :, surrounded, ), {]
[;, }, public, void, correctOrientation, (, ), {, for, (, NestedLoops, child, :, surrounded, ), {, child, ., setClockWise, (]
[child, ., setClockWise, (, true, ), ;, }, }, private, void, setClockWise, (, final, boolean, clockwise, ), {, if, (]
[child, ., setClockWise, (, true, ), ;, }, }, private, void, setClockWise, (, final, boolean, clockwise, ), {, if, (]
[setClockWise, (, true, ), ;, }, }, private, void, setClockWise, (, final, boolean, clockwise, ), {, if, (, originalIsClockwise, ^]
[}, private, void, setClockWise, (, final, boolean, clockwise, ), {, if, (, originalIsClockwise, ^, clockwise, ), {, int, min, =]
[private, void, setClockWise, (, final, boolean, clockwise, ), {, if, (, originalIsClockwise, ^, clockwise, ), {, int, min, =, -]
[boolean, clockwise, ), {, if, (, originalIsClockwise, ^, clockwise, ), {, int, min, =, -, 1, ;, int, max, =]
[boolean, clockwise, ), {, if, (, originalIsClockwise, ^, clockwise, ), {, int, min, =, -, 1, ;, int, max, =]
[originalIsClockwise, ^, clockwise, ), {, int, min, =, -, 1, ;, int, max, =, loop, ., length, ;, while, (]
[originalIsClockwise, ^, clockwise, ), {, int, min, =, -, 1, ;, int, max, =, loop, ., length, ;, while, (]
[^, clockwise, ), {, int, min, =, -, 1, ;, int, max, =, loop, ., length, ;, while, (, ++]
[), {, int, min, =, -, 1, ;, int, max, =, loop, ., length, ;, while, (, ++, min, <]
[{, int, min, =, -, 1, ;, int, max, =, loop, ., length, ;, while, (, ++, min, <, --]
[int, max, =, loop, ., length, ;, while, (, ++, min, <, --, max, ), {, final, Vector2D, tmp, =]
[int, max, =, loop, ., length, ;, while, (, ++, min, <, --, max, ), {, final, Vector2D, tmp, =]
[=, loop, ., length, ;, while, (, ++, min, <, --, max, ), {, final, Vector2D, tmp, =, loop, []
[length, ;, while, (, ++, min, <, --, max, ), {, final, Vector2D, tmp, =, loop, [, min, ], ;]
[length, ;, while, (, ++, min, <, --, max, ), {, final, Vector2D, tmp, =, loop, [, min, ], ;]
[while, (, ++, min, <, --, max, ), {, final, Vector2D, tmp, =, loop, [, min, ], ;, loop, []
[min, <, --, max, ), {, final, Vector2D, tmp, =, loop, [, min, ], ;, loop, [, min, ], =]
[min, <, --, max, ), {, final, Vector2D, tmp, =, loop, [, min, ], ;, loop, [, min, ], =]
[--, max, ), {, final, Vector2D, tmp, =, loop, [, min, ], ;, loop, [, min, ], =, loop, []
[{, final, Vector2D, tmp, =, loop, [, min, ], ;, loop, [, min, ], =, loop, [, max, ], ;]
[{, final, Vector2D, tmp, =, loop, [, min, ], ;, loop, [, min, ], =, loop, [, max, ], ;]
[Vector2D, tmp, =, loop, [, min, ], ;, loop, [, min, ], =, loop, [, max, ], ;, loop, []
[loop, [, min, ], ;, loop, [, min, ], =, loop, [, max, ], ;, loop, [, max, ], =]
[loop, [, max, ], ;, loop, [, max, ], =, tmp, ;, }, }, for, (, final, NestedLoops, child, :]
[], ;, loop, [, max, ], =, tmp, ;, }, }, for, (, final, NestedLoops, child, :, surrounded, ), {]
[], ;, loop, [, max, ], =, tmp, ;, }, }, for, (, final, NestedLoops, child, :, surrounded, ), {]
[max, ], =, tmp, ;, }, }, for, (, final, NestedLoops, child, :, surrounded, ), {, child, ., setClockWise, (]
[], =, tmp, ;, }, }, for, (, final, NestedLoops, child, :, surrounded, ), {, child, ., setClockWise, (, !]
