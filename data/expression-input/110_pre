[., Token, ;, public, class, StatementFusion, extends, AbstractPeepholeOptimization, {, @, Override, Node, optimizeSubtree, (, Node, n, ), {, if, (]
[., Token, ;, public, class, StatementFusion, extends, AbstractPeepholeOptimization, {, @, Override, Node, optimizeSubtree, (, Node, n, ), {, if, (]
[Token, ;, public, class, StatementFusion, extends, AbstractPeepholeOptimization, {, @, Override, Node, optimizeSubtree, (, Node, n, ), {, if, (, !]
[Token, ;, public, class, StatementFusion, extends, AbstractPeepholeOptimization, {, @, Override, Node, optimizeSubtree, (, Node, n, ), {, if, (, !]
[Token, ;, public, class, StatementFusion, extends, AbstractPeepholeOptimization, {, @, Override, Node, optimizeSubtree, (, Node, n, ), {, if, (, !]
[Node, optimizeSubtree, (, Node, n, ), {, if, (, !, n, ., getParent, (, ), ., isFunction, (, ), &&]
[(, Node, n, ), {, if, (, !, n, ., getParent, (, ), ., isFunction, (, ), &&, canFuseIntoOneStatement, (]
[{, if, (, !, n, ., getParent, (, ), ., isFunction, (, ), &&, canFuseIntoOneStatement, (, n, ), ), {]
[(, !, n, ., getParent, (, ), ., isFunction, (, ), &&, canFuseIntoOneStatement, (, n, ), ), {, fuseIntoOneStatement, (]
[., getParent, (, ), ., isFunction, (, ), &&, canFuseIntoOneStatement, (, n, ), ), {, fuseIntoOneStatement, (, n, ), ;]
[(, ), &&, canFuseIntoOneStatement, (, n, ), ), {, fuseIntoOneStatement, (, n, ), ;, reportCodeChange, (, ), ;, }, return]
[;, reportCodeChange, (, ), ;, }, return, n, ;, }, private, boolean, canFuseIntoOneStatement, (, Node, block, ), {, if, (]
[reportCodeChange, (, ), ;, }, return, n, ;, }, private, boolean, canFuseIntoOneStatement, (, Node, block, ), {, if, (, !]
[reportCodeChange, (, ), ;, }, return, n, ;, }, private, boolean, canFuseIntoOneStatement, (, Node, block, ), {, if, (, !]
[}, private, boolean, canFuseIntoOneStatement, (, Node, block, ), {, if, (, !, block, ., isBlock, (, ), ), {, return]
[Node, block, ), {, if, (, !, block, ., isBlock, (, ), ), {, return, false, ;, }, if, (]
[Node, block, ), {, if, (, !, block, ., isBlock, (, ), ), {, return, false, ;, }, if, (]
[block, ), {, if, (, !, block, ., isBlock, (, ), ), {, return, false, ;, }, if, (, !]
[block, ), {, if, (, !, block, ., isBlock, (, ), ), {, return, false, ;, }, if, (, !]
[block, ., isBlock, (, ), ), {, return, false, ;, }, if, (, !, block, ., hasChildren, (, ), ||]
[block, ., isBlock, (, ), ), {, return, false, ;, }, if, (, !, block, ., hasChildren, (, ), ||]
[false, ;, }, if, (, !, block, ., hasChildren, (, ), ||, block, ., hasOneChild, (, ), ), {, return]
[block, ., hasChildren, (, ), ||, block, ., hasOneChild, (, ), ), {, return, false, ;, }, Node, last, =]
[block, ., hasChildren, (, ), ||, block, ., hasOneChild, (, ), ), {, return, false, ;, }, Node, last, =]
[), {, return, false, ;, }, Node, last, =, block, ., getLastChild, (, ), ;, for, (, Node, c, =]
[), {, return, false, ;, }, Node, last, =, block, ., getLastChild, (, ), ;, for, (, Node, c, =]
[Node, last, =, block, ., getLastChild, (, ), ;, for, (, Node, c, =, block, ., getFirstChild, (, ), ;]
[Node, last, =, block, ., getLastChild, (, ), ;, for, (, Node, c, =, block, ., getFirstChild, (, ), ;]
[=, block, ., getLastChild, (, ), ;, for, (, Node, c, =, block, ., getFirstChild, (, ), ;, c, !=]
[., getLastChild, (, ), ;, for, (, Node, c, =, block, ., getFirstChild, (, ), ;, c, !=, null, ;]
[(, ), ;, for, (, Node, c, =, block, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[(, ), ;, for, (, Node, c, =, block, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !]
[getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !]
[null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !, c, ., isExprResult, (, ), &&]
[null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !, c, ., isExprResult, (, ), &&]
[c, =, c, ., getNext, (, ), ), {, if, (, !, c, ., isExprResult, (, ), &&, c, !=]
[getNext, (, ), ), {, if, (, !, c, ., isExprResult, (, ), &&, c, !=, last, ), {, return]
[(, !, c, ., isExprResult, (, ), &&, c, !=, last, ), {, return, false, ;, }, }, switch, (]
[(, !, c, ., isExprResult, (, ), &&, c, !=, last, ), {, return, false, ;, }, }, switch, (]
[c, !=, last, ), {, return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {, case]
[c, !=, last, ), {, return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {, case]
[return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., THROW, :, case]
[switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., THROW, :, case]
[(, ), ), {, case, Token, ., IF, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case]
[(, ), ), {, case, Token, ., IF, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case]
[Token, ., IF, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, return]
[:, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, return, true, ;, case]
[:, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, return, true, ;, case]
[:, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, return, true, ;, case, Token, ., RETURN, :, return]
[:, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, return, true, ;, case, Token, ., RETURN, :, return]
[Token, ., EXPR_RESULT, :, return, true, ;, case, Token, ., RETURN, :, return, last, ., hasChildren, (, ), ;, case]
[Token, ., EXPR_RESULT, :, return, true, ;, case, Token, ., RETURN, :, return, last, ., hasChildren, (, ), ;, case]
[true, ;, case, Token, ., RETURN, :, return, last, ., hasChildren, (, ), ;, case, Token, ., FOR, :, return]
[true, ;, case, Token, ., RETURN, :, return, last, ., hasChildren, (, ), ;, case, Token, ., FOR, :, return]
[true, ;, case, Token, ., RETURN, :, return, last, ., hasChildren, (, ), ;, case, Token, ., FOR, :, return]
[., RETURN, :, return, last, ., hasChildren, (, ), ;, case, Token, ., FOR, :, return, NodeUtil, ., isForIn, (]
[return, last, ., hasChildren, (, ), ;, case, Token, ., FOR, :, return, NodeUtil, ., isForIn, (, last, ), &&]
[last, ., hasChildren, (, ), ;, case, Token, ., FOR, :, return, NodeUtil, ., isForIn, (, last, ), &&, !]
[hasChildren, (, ), ;, case, Token, ., FOR, :, return, NodeUtil, ., isForIn, (, last, ), &&, !, mayHaveSideEffects, (]
[hasChildren, (, ), ;, case, Token, ., FOR, :, return, NodeUtil, ., isForIn, (, last, ), &&, !, mayHaveSideEffects, (]
[return, NodeUtil, ., isForIn, (, last, ), &&, !, mayHaveSideEffects, (, last, ., getFirstChild, (, ), ), ;, }, return]
[(, ), ), ;, }, return, false, ;, }, private, void, fuseIntoOneStatement, (, Node, block, ), {, Node, cur, =]
[(, ), ), ;, }, return, false, ;, }, private, void, fuseIntoOneStatement, (, Node, block, ), {, Node, cur, =]
[private, void, fuseIntoOneStatement, (, Node, block, ), {, Node, cur, =, block, ., removeFirstChild, (, ), ;, Node, commaTree, =]
[private, void, fuseIntoOneStatement, (, Node, block, ), {, Node, cur, =, block, ., removeFirstChild, (, ), ;, Node, commaTree, =]
[Node, cur, =, block, ., removeFirstChild, (, ), ;, Node, commaTree, =, cur, ., removeFirstChild, (, ), ;, while, (]
[Node, cur, =, block, ., removeFirstChild, (, ), ;, Node, commaTree, =, cur, ., removeFirstChild, (, ), ;, while, (]
[commaTree, =, cur, ., removeFirstChild, (, ), ;, while, (, block, ., hasMoreThanOneChild, (, ), ), {, Node, next, =]
[commaTree, =, cur, ., removeFirstChild, (, ), ;, while, (, block, ., hasMoreThanOneChild, (, ), ), {, Node, next, =]
[commaTree, =, cur, ., removeFirstChild, (, ), ;, while, (, block, ., hasMoreThanOneChild, (, ), ), {, Node, next, =]
[block, ., hasMoreThanOneChild, (, ), ), {, Node, next, =, block, ., removeFirstChild, (, ), ., removeFirstChild, (, ), ;]
[hasMoreThanOneChild, (, ), ), {, Node, next, =, block, ., removeFirstChild, (, ), ., removeFirstChild, (, ), ;, commaTree, =]
[), ), {, Node, next, =, block, ., removeFirstChild, (, ), ., removeFirstChild, (, ), ;, commaTree, =, fuseExpressionIntoExpression, (]
[{, Node, next, =, block, ., removeFirstChild, (, ), ., removeFirstChild, (, ), ;, commaTree, =, fuseExpressionIntoExpression, (, commaTree, ,]
[block, ., removeFirstChild, (, ), ., removeFirstChild, (, ), ;, commaTree, =, fuseExpressionIntoExpression, (, commaTree, ,, next, ), ;, }]
[block, ., removeFirstChild, (, ), ., removeFirstChild, (, ), ;, commaTree, =, fuseExpressionIntoExpression, (, commaTree, ,, next, ), ;, }]
[), ., removeFirstChild, (, ), ;, commaTree, =, fuseExpressionIntoExpression, (, commaTree, ,, next, ), ;, }, Preconditions, ., checkState, (]
[), ., removeFirstChild, (, ), ;, commaTree, =, fuseExpressionIntoExpression, (, commaTree, ,, next, ), ;, }, Preconditions, ., checkState, (]
[commaTree, ,, next, ), ;, }, Preconditions, ., checkState, (, block, ., hasOneChild, (, ), ), ;, Node, last, =]
[commaTree, ,, next, ), ;, }, Preconditions, ., checkState, (, block, ., hasOneChild, (, ), ), ;, Node, last, =]
[checkState, (, block, ., hasOneChild, (, ), ), ;, Node, last, =, block, ., getLastChild, (, ), ;, switch, (]
[checkState, (, block, ., hasOneChild, (, ), ), ;, Node, last, =, block, ., getLastChild, (, ), ;, switch, (]
[;, Node, last, =, block, ., getLastChild, (, ), ;, switch, (, last, ., getType, (, ), ), {, case]
[;, Node, last, =, block, ., getLastChild, (, ), ;, switch, (, last, ., getType, (, ), ), {, case]
[., getLastChild, (, ), ;, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[., getLastChild, (, ), ;, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., RETURN, :, case]
[switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., RETURN, :, case]
[(, ), ), {, case, Token, ., IF, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, case]
[(, ), ), {, case, Token, ., IF, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, case]
[Token, ., IF, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case]
[Token, ., IF, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case]
[case, Token, ., RETURN, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :]
[., RETURN, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (]
[:, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,]
[case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;, case]
[case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;, case]
[Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;, case, Token, ., FOR, :, if, (]
[Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;, case, Token, ., FOR, :, if, (]
[fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (]
[last, ), ;, return, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, last, ), ), {]
[;, return, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, last, ), ), {, fuseExpresssonIntoSecondChild, (]
[;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, last, ), ), {, fuseExpresssonIntoSecondChild, (, commaTree, ,]
[., isForIn, (, last, ), ), {, fuseExpresssonIntoSecondChild, (, commaTree, ,, last, ), ;, }, return, ;, default, :, throw]
[last, ), ), {, fuseExpresssonIntoSecondChild, (, commaTree, ,, last, ), ;, }, return, ;, default, :, throw, new, IllegalStateException, (]
["Statement fusion missing.", ), ;, }, }, private, static, Node, fuseExpressionIntoExpression, (, Node, exp1, ,, Node, exp2, ), {, Node, comma, =]
[}, }, private, static, Node, fuseExpressionIntoExpression, (, Node, exp1, ,, Node, exp2, ), {, Node, comma, =, new, Node, (]
[}, }, private, static, Node, fuseExpressionIntoExpression, (, Node, exp1, ,, Node, exp2, ), {, Node, comma, =, new, Node, (]
[Node, fuseExpressionIntoExpression, (, Node, exp1, ,, Node, exp2, ), {, Node, comma, =, new, Node, (, Token, ., COMMA, ,]
[Node, exp1, ,, Node, exp2, ), {, Node, comma, =, new, Node, (, Token, ., COMMA, ,, exp1, ), ;]
[Node, exp1, ,, Node, exp2, ), {, Node, comma, =, new, Node, (, Token, ., COMMA, ,, exp1, ), ;]
[exp2, ), {, Node, comma, =, new, Node, (, Token, ., COMMA, ,, exp1, ), ;, comma, ., copyInformationFrom, (]
[=, new, Node, (, Token, ., COMMA, ,, exp1, ), ;, comma, ., copyInformationFrom, (, exp2, ), ;, if, (]
[=, new, Node, (, Token, ., COMMA, ,, exp1, ), ;, comma, ., copyInformationFrom, (, exp2, ), ;, if, (]
[;, comma, ., copyInformationFrom, (, exp2, ), ;, if, (, exp2, ., isComma, (, ), ), {, Node, leftMostChild, =]
[(, exp2, ), ;, if, (, exp2, ., isComma, (, ), ), {, Node, leftMostChild, =, exp2, ;, while, (]
[(, exp2, ), ;, if, (, exp2, ., isComma, (, ), ), {, Node, leftMostChild, =, exp2, ;, while, (]
[., isComma, (, ), ), {, Node, leftMostChild, =, exp2, ;, while, (, leftMostChild, ., isComma, (, ), ), {]
[(, ), ), {, Node, leftMostChild, =, exp2, ;, while, (, leftMostChild, ., isComma, (, ), ), {, leftMostChild, =]
[(, ), ), {, Node, leftMostChild, =, exp2, ;, while, (, leftMostChild, ., isComma, (, ), ), {, leftMostChild, =]
[(, leftMostChild, ., isComma, (, ), ), {, leftMostChild, =, leftMostChild, ., getFirstChild, (, ), ;, }, Node, parent, =]
[(, leftMostChild, ., isComma, (, ), ), {, leftMostChild, =, leftMostChild, ., getFirstChild, (, ), ;, }, Node, parent, =]
[), {, leftMostChild, =, leftMostChild, ., getFirstChild, (, ), ;, }, Node, parent, =, leftMostChild, ., getParent, (, ), ;]
[), {, leftMostChild, =, leftMostChild, ., getFirstChild, (, ), ;, }, Node, parent, =, leftMostChild, ., getParent, (, ), ;]
[leftMostChild, ., getFirstChild, (, ), ;, }, Node, parent, =, leftMostChild, ., getParent, (, ), ;, comma, ., addChildToBack, (]
[leftMostChild, ., getFirstChild, (, ), ;, }, Node, parent, =, leftMostChild, ., getParent, (, ), ;, comma, ., addChildToBack, (]
[Node, parent, =, leftMostChild, ., getParent, (, ), ;, comma, ., addChildToBack, (, leftMostChild, ., detachFromParent, (, ), ), ;]
[Node, parent, =, leftMostChild, ., getParent, (, ), ;, comma, ., addChildToBack, (, leftMostChild, ., detachFromParent, (, ), ), ;]
[., getParent, (, ), ;, comma, ., addChildToBack, (, leftMostChild, ., detachFromParent, (, ), ), ;, parent, ., addChildToFront, (]
[;, comma, ., addChildToBack, (, leftMostChild, ., detachFromParent, (, ), ), ;, parent, ., addChildToFront, (, comma, ), ;, return]
[leftMostChild, ., detachFromParent, (, ), ), ;, parent, ., addChildToFront, (, comma, ), ;, return, exp2, ;, }, else, {]
[leftMostChild, ., detachFromParent, (, ), ), ;, parent, ., addChildToFront, (, comma, ), ;, return, exp2, ;, }, else, {]
[), ), ;, parent, ., addChildToFront, (, comma, ), ;, return, exp2, ;, }, else, {, comma, ., addChildToBack, (]
[., addChildToFront, (, comma, ), ;, return, exp2, ;, }, else, {, comma, ., addChildToBack, (, exp2, ), ;, return]
[return, comma, ;, }, }, private, static, void, fuseExpresssonIntoFirstChild, (, Node, exp, ,, Node, stmt, ), {, Node, val, =]
[return, comma, ;, }, }, private, static, void, fuseExpresssonIntoFirstChild, (, Node, exp, ,, Node, stmt, ), {, Node, val, =]
[(, Node, exp, ,, Node, stmt, ), {, Node, val, =, stmt, ., removeFirstChild, (, ), ;, Node, comma, =]
[exp, ,, Node, stmt, ), {, Node, val, =, stmt, ., removeFirstChild, (, ), ;, Node, comma, =, fuseExpressionIntoExpression, (]
[Node, stmt, ), {, Node, val, =, stmt, ., removeFirstChild, (, ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,]
[{, Node, val, =, stmt, ., removeFirstChild, (, ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;]
[{, Node, val, =, stmt, ., removeFirstChild, (, ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;]
[stmt, ., removeFirstChild, (, ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;, stmt, ., addChildToFront, (]
[(, comma, ), ;, }, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,, Node, stmt, ), {, Node, val, =]
[(, comma, ), ;, }, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,, Node, stmt, ), {, Node, val, =]
[}, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,, Node, stmt, ), {, Node, val, =, stmt, ., removeChildAfter, (]
[}, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,, Node, stmt, ), {, Node, val, =, stmt, ., removeChildAfter, (]
[stmt, ), {, Node, val, =, stmt, ., removeChildAfter, (, stmt, ., getFirstChild, (, ), ), ;, Node, comma, =]
[{, Node, val, =, stmt, ., removeChildAfter, (, stmt, ., getFirstChild, (, ), ), ;, Node, comma, =, fuseExpressionIntoExpression, (]
[val, =, stmt, ., removeChildAfter, (, stmt, ., getFirstChild, (, ), ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,]
[., removeChildAfter, (, stmt, ., getFirstChild, (, ), ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;]
[., removeChildAfter, (, stmt, ., getFirstChild, (, ), ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;]
[., getFirstChild, (, ), ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;, stmt, ., addChildAfter, (]
[(, ), ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;, stmt, ., addChildAfter, (, comma, ,]
[(, ), ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;, stmt, ., addChildAfter, (, comma, ,]
