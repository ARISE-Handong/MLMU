[;, private, static, final, int, DEFAULT_ULPS, =, 10, ;, private, final, double, epsilon, ;, private, final, int, maxUlps, ;, public]
[;, private, final, double, epsilon, ;, private, final, int, maxUlps, ;, public, SimplexSolver, (, ), {, this, (, DEFAULT_EPSILON, ,]
[,, DEFAULT_ULPS, ), ;, }, public, SimplexSolver, (, final, double, epsilon, ,, final, int, maxUlps, ), {, this, ., epsilon]
[), ;, }, public, SimplexSolver, (, final, double, epsilon, ,, final, int, maxUlps, ), {, this, ., epsilon, =, epsilon]
[=, epsilon, ;, this, ., maxUlps, =, maxUlps, ;, }, private, Integer, getPivotColumn, (, SimplexTableau, tableau, ), {, double, minValue]
[., epsilon, =, epsilon, ;, this, ., maxUlps, =, maxUlps, ;, }, private, Integer, getPivotColumn, (, SimplexTableau, tableau, ), {]
[;, this, ., maxUlps, =, maxUlps, ;, }, private, Integer, getPivotColumn, (, SimplexTableau, tableau, ), {, double, minValue, =, 0]
[=, maxUlps, ;, }, private, Integer, getPivotColumn, (, SimplexTableau, tableau, ), {, double, minValue, =, 0, ;, Integer, minPos, =]
[., maxUlps, =, maxUlps, ;, }, private, Integer, getPivotColumn, (, SimplexTableau, tableau, ), {, double, minValue, =, 0, ;, Integer]
[;, }, private, Integer, getPivotColumn, (, SimplexTableau, tableau, ), {, double, minValue, =, 0, ;, Integer, minPos, =, null, ;]
[;, Integer, minPos, =, null, ;, for, (, int, i, =, tableau, ., getNumObjectiveFunctions, (, ), ;, i, <, tableau]
[;, for, (, int, i, =, tableau, ., getNumObjectiveFunctions, (, ), ;, i, <, tableau, ., getWidth, (, ), -]
[;, i, <, tableau, ., getWidth, (, ), -, 1, ;, i, ++, ), {, final, double, entry, =, tableau]
[., getNumObjectiveFunctions, (, ), ;, i, <, tableau, ., getWidth, (, ), -, 1, ;, i, ++, ), {, final]
[;, i, ++, ), {, final, double, entry, =, tableau, ., getEntry, (, 0, ,, i, ), ;, if, (]
[<, tableau, ., getWidth, (, ), -, 1, ;, i, ++, ), {, final, double, entry, =, tableau, ., getEntry]
[;, i, ++, ), {, final, double, entry, =, tableau, ., getEntry, (, 0, ,, i, ), ;, if, (]
[-, 1, ;, i, ++, ), {, final, double, entry, =, tableau, ., getEntry, (, 0, ,, i, ), ;]
[., getWidth, (, ), -, 1, ;, i, ++, ), {, final, double, entry, =, tableau, ., getEntry, (, 0]
[;, i, ++, ), {, final, double, entry, =, tableau, ., getEntry, (, 0, ,, i, ), ;, if, (]
[), {, final, double, entry, =, tableau, ., getEntry, (, 0, ,, i, ), ;, if, (, entry, <, minValue]
[++, ), {, final, double, entry, =, tableau, ., getEntry, (, 0, ,, i, ), ;, if, (, entry, <]
[;, if, (, entry, <, minValue, ), {, minValue, =, entry, ;, minPos, =, i, ;, }, }, return, minPos]
[., getEntry, (, 0, ,, i, ), ;, if, (, entry, <, minValue, ), {, minValue, =, entry, ;, minPos]
[,, i, ), ;, if, (, entry, <, minValue, ), {, minValue, =, entry, ;, minPos, =, i, ;, }]
[), ;, if, (, entry, <, minValue, ), {, minValue, =, entry, ;, minPos, =, i, ;, }, }, return]
[), {, minValue, =, entry, ;, minPos, =, i, ;, }, }, return, minPos, ;, }, private, Integer, getPivotRow, (]
[<, minValue, ), {, minValue, =, entry, ;, minPos, =, i, ;, }, }, return, minPos, ;, }, private, Integer]
[), {, minValue, =, entry, ;, minPos, =, i, ;, }, }, return, minPos, ;, }, private, Integer, getPivotRow, (]
[=, entry, ;, minPos, =, i, ;, }, }, return, minPos, ;, }, private, Integer, getPivotRow, (, SimplexTableau, tableau, ,]
[;, minPos, =, i, ;, }, }, return, minPos, ;, }, private, Integer, getPivotRow, (, SimplexTableau, tableau, ,, final, int]
[=, i, ;, }, }, return, minPos, ;, }, private, Integer, getPivotRow, (, SimplexTableau, tableau, ,, final, int, col, )]
[;, }, }, return, minPos, ;, }, private, Integer, getPivotRow, (, SimplexTableau, tableau, ,, final, int, col, ), {, List]
[;, }, private, Integer, getPivotRow, (, SimplexTableau, tableau, ,, final, int, col, ), {, List, <, Integer, >, minRatioPositions, =]
[;, double, minRatio, =, Double, ., MAX_VALUE, ;, for, (, int, i, =, tableau, ., getNumObjectiveFunctions, (, ), ;, i]
[;, for, (, int, i, =, tableau, ., getNumObjectiveFunctions, (, ), ;, i, <, tableau, ., getHeight, (, ), ;]
[., MAX_VALUE, ;, for, (, int, i, =, tableau, ., getNumObjectiveFunctions, (, ), ;, i, <, tableau, ., getHeight, (]
[;, i, <, tableau, ., getHeight, (, ), ;, i, ++, ), {, final, double, rhs, =, tableau, ., getEntry]
[., getNumObjectiveFunctions, (, ), ;, i, <, tableau, ., getHeight, (, ), ;, i, ++, ), {, final, double, rhs]
[;, i, ++, ), {, final, double, rhs, =, tableau, ., getEntry, (, i, ,, tableau, ., getWidth, (, )]
[<, tableau, ., getHeight, (, ), ;, i, ++, ), {, final, double, rhs, =, tableau, ., getEntry, (, i]
[;, i, ++, ), {, final, double, rhs, =, tableau, ., getEntry, (, i, ,, tableau, ., getWidth, (, )]
[., getHeight, (, ), ;, i, ++, ), {, final, double, rhs, =, tableau, ., getEntry, (, i, ,, tableau]
[), {, final, double, rhs, =, tableau, ., getEntry, (, i, ,, tableau, ., getWidth, (, ), -, 1, )]
[++, ), {, final, double, rhs, =, tableau, ., getEntry, (, i, ,, tableau, ., getWidth, (, ), -, 1]
[;, final, double, entry, =, tableau, ., getEntry, (, i, ,, col, ), ;, if, (, Precision, ., compareTo, (]
[., getEntry, (, i, ,, tableau, ., getWidth, (, ), -, 1, ), ;, final, double, entry, =, tableau, .]
[,, tableau, ., getWidth, (, ), -, 1, ), ;, final, double, entry, =, tableau, ., getEntry, (, i, ,]
[), ;, final, double, entry, =, tableau, ., getEntry, (, i, ,, col, ), ;, if, (, Precision, ., compareTo]
[-, 1, ), ;, final, double, entry, =, tableau, ., getEntry, (, i, ,, col, ), ;, if, (, Precision]
[., getWidth, (, ), -, 1, ), ;, final, double, entry, =, tableau, ., getEntry, (, i, ,, col, )]
[), ;, final, double, entry, =, tableau, ., getEntry, (, i, ,, col, ), ;, if, (, Precision, ., compareTo]
[;, if, (, Precision, ., compareTo, (, entry, ,, 0d, ,, maxUlps, ), >, 0, ), {, final, double, ratio]
[., getEntry, (, i, ,, col, ), ;, if, (, Precision, ., compareTo, (, entry, ,, 0d, ,, maxUlps, )]
[,, col, ), ;, if, (, Precision, ., compareTo, (, entry, ,, 0d, ,, maxUlps, ), >, 0, ), {]
[), ;, if, (, Precision, ., compareTo, (, entry, ,, 0d, ,, maxUlps, ), >, 0, ), {, final, double]
[), {, final, double, ratio, =, rhs, /, entry, ;, final, int, cmp, =, Double, ., compare, (, ratio, ,]
[>, 0, ), {, final, double, ratio, =, rhs, /, entry, ;, final, int, cmp, =, Double, ., compare, (]
[., compareTo, (, entry, ,, 0d, ,, maxUlps, ), >, 0, ), {, final, double, ratio, =, rhs, /, entry]
[,, 0d, ,, maxUlps, ), >, 0, ), {, final, double, ratio, =, rhs, /, entry, ;, final, int, cmp]
[,, maxUlps, ), >, 0, ), {, final, double, ratio, =, rhs, /, entry, ;, final, int, cmp, =, Double]
[), >, 0, ), {, final, double, ratio, =, rhs, /, entry, ;, final, int, cmp, =, Double, ., compare]
[), {, final, double, ratio, =, rhs, /, entry, ;, final, int, cmp, =, Double, ., compare, (, ratio, ,]
[;, final, int, cmp, =, Double, ., compare, (, ratio, ,, minRatio, ), ;, if, (, cmp, ==, 0, )]
[/, entry, ;, final, int, cmp, =, Double, ., compare, (, ratio, ,, minRatio, ), ;, if, (, cmp, ==]
[;, final, int, cmp, =, Double, ., compare, (, ratio, ,, minRatio, ), ;, if, (, cmp, ==, 0, )]
[;, if, (, cmp, ==, 0, ), {, minRatioPositions, ., add, (, i, ), ;, }, else, if, (, cmp]
[., compare, (, ratio, ,, minRatio, ), ;, if, (, cmp, ==, 0, ), {, minRatioPositions, ., add, (, i]
[,, minRatio, ), ;, if, (, cmp, ==, 0, ), {, minRatioPositions, ., add, (, i, ), ;, }, else]
[), ;, if, (, cmp, ==, 0, ), {, minRatioPositions, ., add, (, i, ), ;, }, else, if, (]
[), {, minRatioPositions, ., add, (, i, ), ;, }, else, if, (, cmp, <, 0, ), {, minRatio, =]
[==, 0, ), {, minRatioPositions, ., add, (, i, ), ;, }, else, if, (, cmp, <, 0, ), {]
[), {, minRatioPositions, ., add, (, i, ), ;, }, else, if, (, cmp, <, 0, ), {, minRatio, =]
[;, }, else, if, (, cmp, <, 0, ), {, minRatio, =, ratio, ;, minRatioPositions, =, new, ArrayList, <, Integer]
[., add, (, i, ), ;, }, else, if, (, cmp, <, 0, ), {, minRatio, =, ratio, ;, minRatioPositions]
[), ;, }, else, if, (, cmp, <, 0, ), {, minRatio, =, ratio, ;, minRatioPositions, =, new, ArrayList, <]
[), {, minRatio, =, ratio, ;, minRatioPositions, =, new, ArrayList, <, Integer, >, (, ), ;, minRatioPositions, ., add, (]
[<, 0, ), {, minRatio, =, ratio, ;, minRatioPositions, =, new, ArrayList, <, Integer, >, (, ), ;, minRatioPositions, .]
[), {, minRatio, =, ratio, ;, minRatioPositions, =, new, ArrayList, <, Integer, >, (, ), ;, minRatioPositions, ., add, (]
[=, ratio, ;, minRatioPositions, =, new, ArrayList, <, Integer, >, (, ), ;, minRatioPositions, ., add, (, i, ), ;]
[;, minRatioPositions, =, new, ArrayList, <, Integer, >, (, ), ;, minRatioPositions, ., add, (, i, ), ;, }, }]
[=, new, ArrayList, <, Integer, >, (, ), ;, minRatioPositions, ., add, (, i, ), ;, }, }, }, if]
[;, minRatioPositions, ., add, (, i, ), ;, }, }, }, if, (, minRatioPositions, ., size, (, ), ==, 0]
[;, }, }, }, if, (, minRatioPositions, ., size, (, ), ==, 0, ), {, return, null, ;, }, else]
[., add, (, i, ), ;, }, }, }, if, (, minRatioPositions, ., size, (, ), ==, 0, ), {]
[), ;, }, }, }, if, (, minRatioPositions, ., size, (, ), ==, 0, ), {, return, null, ;, }]
[), {, return, null, ;, }, else, if, (, minRatioPositions, ., size, (, ), >, 1, ), {, if, (]
[==, 0, ), {, return, null, ;, }, else, if, (, minRatioPositions, ., size, (, ), >, 1, ), {]
[., size, (, ), ==, 0, ), {, return, null, ;, }, else, if, (, minRatioPositions, ., size, (, )]
[), {, return, null, ;, }, else, if, (, minRatioPositions, ., size, (, ), >, 1, ), {, if, (]
[;, }, else, if, (, minRatioPositions, ., size, (, ), >, 1, ), {, if, (, tableau, ., getNumArtificialVariables, (]
[), {, if, (, tableau, ., getNumArtificialVariables, (, ), >, 0, ), {, for, (, Integer, row, :, minRatioPositions, )]
[>, 1, ), {, if, (, tableau, ., getNumArtificialVariables, (, ), >, 0, ), {, for, (, Integer, row, :]
[., size, (, ), >, 1, ), {, if, (, tableau, ., getNumArtificialVariables, (, ), >, 0, ), {, for]
[), {, if, (, tableau, ., getNumArtificialVariables, (, ), >, 0, ), {, for, (, Integer, row, :, minRatioPositions, )]
[), {, for, (, Integer, row, :, minRatioPositions, ), {, for, (, int, i, =, 0, ;, i, <, tableau]
[>, 0, ), {, for, (, Integer, row, :, minRatioPositions, ), {, for, (, int, i, =, 0, ;, i]
[., getNumArtificialVariables, (, ), >, 0, ), {, for, (, Integer, row, :, minRatioPositions, ), {, for, (, int, i]
[), {, for, (, Integer, row, :, minRatioPositions, ), {, for, (, int, i, =, 0, ;, i, <, tableau]
[), {, for, (, int, i, =, 0, ;, i, <, tableau, ., getNumArtificialVariables, (, ), ;, i, ++, )]
[;, i, <, tableau, ., getNumArtificialVariables, (, ), ;, i, ++, ), {, int, column, =, i, +, tableau, .]
[;, i, ++, ), {, int, column, =, i, +, tableau, ., getArtificialVariableOffset, (, ), ;, final, double, entry, =]
[<, tableau, ., getNumArtificialVariables, (, ), ;, i, ++, ), {, int, column, =, i, +, tableau, ., getArtificialVariableOffset, (]
[;, i, ++, ), {, int, column, =, i, +, tableau, ., getArtificialVariableOffset, (, ), ;, final, double, entry, =]
[., getNumArtificialVariables, (, ), ;, i, ++, ), {, int, column, =, i, +, tableau, ., getArtificialVariableOffset, (, ), ;]
[), {, int, column, =, i, +, tableau, ., getArtificialVariableOffset, (, ), ;, final, double, entry, =, tableau, ., getEntry]
[++, ), {, int, column, =, i, +, tableau, ., getArtificialVariableOffset, (, ), ;, final, double, entry, =, tableau, .]
[;, final, double, entry, =, tableau, ., getEntry, (, row, ,, column, ), ;, if, (, Precision, ., equals, (]
[+, tableau, ., getArtificialVariableOffset, (, ), ;, final, double, entry, =, tableau, ., getEntry, (, row, ,, column, ), ;]
[;, final, double, entry, =, tableau, ., getEntry, (, row, ,, column, ), ;, if, (, Precision, ., equals, (]
[., getArtificialVariableOffset, (, ), ;, final, double, entry, =, tableau, ., getEntry, (, row, ,, column, ), ;, if, (]
[;, if, (, Precision, ., equals, (, entry, ,, 1d, ,, maxUlps, ), &&, row, ., equals, (, tableau, .]
[., getEntry, (, row, ,, column, ), ;, if, (, Precision, ., equals, (, entry, ,, 1d, ,, maxUlps, )]
[,, column, ), ;, if, (, Precision, ., equals, (, entry, ,, 1d, ,, maxUlps, ), &&, row, ., equals]
[), ;, if, (, Precision, ., equals, (, entry, ,, 1d, ,, maxUlps, ), &&, row, ., equals, (, tableau]
[), {, return, row, ;, }, }, }, }, if, (, getIterations, (, ), <, getMaxIterations, (, ), /, 2]
[&&, row, ., equals, (, tableau, ., getBasicRow, (, column, ), ), ), {, return, row, ;, }, }, }]
[., equals, (, entry, ,, 1d, ,, maxUlps, ), &&, row, ., equals, (, tableau, ., getBasicRow, (, column, )]
[,, 1d, ,, maxUlps, ), &&, row, ., equals, (, tableau, ., getBasicRow, (, column, ), ), ), {, return]
[,, maxUlps, ), &&, row, ., equals, (, tableau, ., getBasicRow, (, column, ), ), ), {, return, row, ;]
[), &&, row, ., equals, (, tableau, ., getBasicRow, (, column, ), ), ), {, return, row, ;, }, }]
[), {, return, row, ;, }, }, }, }, if, (, getIterations, (, ), <, getMaxIterations, (, ), /, 2]
[., equals, (, tableau, ., getBasicRow, (, column, ), ), ), {, return, row, ;, }, }, }, }, if]
[), ), {, return, row, ;, }, }, }, }, if, (, getIterations, (, ), <, getMaxIterations, (, ), /]
[., getBasicRow, (, column, ), ), ), {, return, row, ;, }, }, }, }, if, (, getIterations, (, )]
[), ), ), {, return, row, ;, }, }, }, }, if, (, getIterations, (, ), <, getMaxIterations, (, )]
[;, }, }, }, }, if, (, getIterations, (, ), <, getMaxIterations, (, ), /, 2, ), {, Integer, minRow]
[), {, Integer, minRow, =, null, ;, int, minIndex, =, tableau, ., getWidth, (, ), ;, final, int, varStart, =]
[<, getMaxIterations, (, ), /, 2, ), {, Integer, minRow, =, null, ;, int, minIndex, =, tableau, ., getWidth, (]
[), {, Integer, minRow, =, null, ;, int, minIndex, =, tableau, ., getWidth, (, ), ;, final, int, varStart, =]
[/, 2, ), {, Integer, minRow, =, null, ;, int, minIndex, =, tableau, ., getWidth, (, ), ;, final, int]
[), {, Integer, minRow, =, null, ;, int, minIndex, =, tableau, ., getWidth, (, ), ;, final, int, varStart, =]
[;, int, minIndex, =, tableau, ., getWidth, (, ), ;, final, int, varStart, =, tableau, ., getNumObjectiveFunctions, (, ), ;]
[;, final, int, varStart, =, tableau, ., getNumObjectiveFunctions, (, ), ;, final, int, varEnd, =, tableau, ., getWidth, (, )]
[., getWidth, (, ), ;, final, int, varStart, =, tableau, ., getNumObjectiveFunctions, (, ), ;, final, int, varEnd, =, tableau]
[;, final, int, varEnd, =, tableau, ., getWidth, (, ), -, 1, ;, for, (, Integer, row, :, minRatioPositions, )]
[., getNumObjectiveFunctions, (, ), ;, final, int, varEnd, =, tableau, ., getWidth, (, ), -, 1, ;, for, (, Integer]
[;, for, (, Integer, row, :, minRatioPositions, ), {, for, (, int, i, =, varStart, ;, i, <, varEnd, &&]
[-, 1, ;, for, (, Integer, row, :, minRatioPositions, ), {, for, (, int, i, =, varStart, ;, i, <]
[., getWidth, (, ), -, 1, ;, for, (, Integer, row, :, minRatioPositions, ), {, for, (, int, i, =]
[;, for, (, Integer, row, :, minRatioPositions, ), {, for, (, int, i, =, varStart, ;, i, <, varEnd, &&]
[), {, for, (, int, i, =, varStart, ;, i, <, varEnd, &&, !, row, ., equals, (, minRow, )]
[;, i, <, varEnd, &&, !, row, ., equals, (, minRow, ), ;, i, ++, ), {, final, Integer, basicRow]
[;, i, ++, ), {, final, Integer, basicRow, =, tableau, ., getBasicRow, (, i, ), ;, if, (, basicRow, !=]
[&&, !, row, ., equals, (, minRow, ), ;, i, ++, ), {, final, Integer, basicRow, =, tableau, ., getBasicRow]
[<, varEnd, &&, !, row, ., equals, (, minRow, ), ;, i, ++, ), {, final, Integer, basicRow, =, tableau]
[&&, !, row, ., equals, (, minRow, ), ;, i, ++, ), {, final, Integer, basicRow, =, tableau, ., getBasicRow]
[;, i, ++, ), {, final, Integer, basicRow, =, tableau, ., getBasicRow, (, i, ), ;, if, (, basicRow, !=]
[;, i, ++, ), {, final, Integer, basicRow, =, tableau, ., getBasicRow, (, i, ), ;, if, (, basicRow, !=]
[., equals, (, minRow, ), ;, i, ++, ), {, final, Integer, basicRow, =, tableau, ., getBasicRow, (, i, )]
[), ;, i, ++, ), {, final, Integer, basicRow, =, tableau, ., getBasicRow, (, i, ), ;, if, (, basicRow]
[), {, final, Integer, basicRow, =, tableau, ., getBasicRow, (, i, ), ;, if, (, basicRow, !=, null, &&, basicRow]
[++, ), {, final, Integer, basicRow, =, tableau, ., getBasicRow, (, i, ), ;, if, (, basicRow, !=, null, &&]
[;, if, (, basicRow, !=, null, &&, basicRow, ., equals, (, row, ), &&, i, <, minIndex, ), {, minIndex]
[., getBasicRow, (, i, ), ;, if, (, basicRow, !=, null, &&, basicRow, ., equals, (, row, ), &&, i]
[), ;, if, (, basicRow, !=, null, &&, basicRow, ., equals, (, row, ), &&, i, <, minIndex, ), {]
[), {, minIndex, =, i, ;, minRow, =, row, ;, }, }, }, return, minRow, ;, }, }, return, minRatioPositions]
[&&, i, <, minIndex, ), {, minIndex, =, i, ;, minRow, =, row, ;, }, }, }, return, minRow, ;]
[&&, basicRow, ., equals, (, row, ), &&, i, <, minIndex, ), {, minIndex, =, i, ;, minRow, =, row]
[!=, null, &&, basicRow, ., equals, (, row, ), &&, i, <, minIndex, ), {, minIndex, =, i, ;, minRow]
[&&, basicRow, ., equals, (, row, ), &&, i, <, minIndex, ), {, minIndex, =, i, ;, minRow, =, row]
[&&, i, <, minIndex, ), {, minIndex, =, i, ;, minRow, =, row, ;, }, }, }, return, minRow, ;]
[., equals, (, row, ), &&, i, <, minIndex, ), {, minIndex, =, i, ;, minRow, =, row, ;, }]
[), &&, i, <, minIndex, ), {, minIndex, =, i, ;, minRow, =, row, ;, }, }, }, return, minRow]
[), {, minIndex, =, i, ;, minRow, =, row, ;, }, }, }, return, minRow, ;, }, }, return, minRatioPositions]
[<, minIndex, ), {, minIndex, =, i, ;, minRow, =, row, ;, }, }, }, return, minRow, ;, }, }]
[), {, minIndex, =, i, ;, minRow, =, row, ;, }, }, }, return, minRow, ;, }, }, return, minRatioPositions]
[=, i, ;, minRow, =, row, ;, }, }, }, return, minRow, ;, }, }, return, minRatioPositions, ., get, (]
[;, minRow, =, row, ;, }, }, }, return, minRow, ;, }, }, return, minRatioPositions, ., get, (, 0, )]
[=, row, ;, }, }, }, return, minRow, ;, }, }, return, minRatioPositions, ., get, (, 0, ), ;, }]
[;, }, }, }, return, minRow, ;, }, }, return, minRatioPositions, ., get, (, 0, ), ;, }, protected, void]
[;, }, }, return, minRatioPositions, ., get, (, 0, ), ;, }, protected, void, doIteration, (, final, SimplexTableau, tableau, )]
[;, }, protected, void, doIteration, (, final, SimplexTableau, tableau, ), throws, MaxCountExceededException, ,, UnboundedSolutionException, {, incrementIterationsCounter, (, ), ;, Integer]
[., get, (, 0, ), ;, }, protected, void, doIteration, (, final, SimplexTableau, tableau, ), throws, MaxCountExceededException, ,, UnboundedSolutionException, {]
[), ;, }, protected, void, doIteration, (, final, SimplexTableau, tableau, ), throws, MaxCountExceededException, ,, UnboundedSolutionException, {, incrementIterationsCounter, (, ), ;]
[;, Integer, pivotCol, =, getPivotColumn, (, tableau, ), ;, Integer, pivotRow, =, getPivotRow, (, tableau, ,, pivotCol, ), ;, if]
[;, Integer, pivotRow, =, getPivotRow, (, tableau, ,, pivotCol, ), ;, if, (, pivotRow, ==, null, ), {, throw, new]
[), ;, Integer, pivotRow, =, getPivotRow, (, tableau, ,, pivotCol, ), ;, if, (, pivotRow, ==, null, ), {, throw]
[;, if, (, pivotRow, ==, null, ), {, throw, new, UnboundedSolutionException, (, ), ;, }, double, pivotVal, =, tableau, .]
[,, pivotCol, ), ;, if, (, pivotRow, ==, null, ), {, throw, new, UnboundedSolutionException, (, ), ;, }, double, pivotVal]
[), ;, if, (, pivotRow, ==, null, ), {, throw, new, UnboundedSolutionException, (, ), ;, }, double, pivotVal, =, tableau]
[), {, throw, new, UnboundedSolutionException, (, ), ;, }, double, pivotVal, =, tableau, ., getEntry, (, pivotRow, ,, pivotCol, )]
[==, null, ), {, throw, new, UnboundedSolutionException, (, ), ;, }, double, pivotVal, =, tableau, ., getEntry, (, pivotRow, ,]
[), {, throw, new, UnboundedSolutionException, (, ), ;, }, double, pivotVal, =, tableau, ., getEntry, (, pivotRow, ,, pivotCol, )]
[;, }, double, pivotVal, =, tableau, ., getEntry, (, pivotRow, ,, pivotCol, ), ;, tableau, ., divideRow, (, pivotRow, ,]
[;, tableau, ., divideRow, (, pivotRow, ,, pivotVal, ), ;, for, (, int, i, =, 0, ;, i, <, tableau]
[., getEntry, (, pivotRow, ,, pivotCol, ), ;, tableau, ., divideRow, (, pivotRow, ,, pivotVal, ), ;, for, (, int]
[,, pivotCol, ), ;, tableau, ., divideRow, (, pivotRow, ,, pivotVal, ), ;, for, (, int, i, =, 0, ;]
[), ;, tableau, ., divideRow, (, pivotRow, ,, pivotVal, ), ;, for, (, int, i, =, 0, ;, i, <]
[;, for, (, int, i, =, 0, ;, i, <, tableau, ., getHeight, (, ), ;, i, ++, ), {]
[., divideRow, (, pivotRow, ,, pivotVal, ), ;, for, (, int, i, =, 0, ;, i, <, tableau, ., getHeight]
[,, pivotVal, ), ;, for, (, int, i, =, 0, ;, i, <, tableau, ., getHeight, (, ), ;, i]
[), ;, for, (, int, i, =, 0, ;, i, <, tableau, ., getHeight, (, ), ;, i, ++, )]
[;, i, <, tableau, ., getHeight, (, ), ;, i, ++, ), {, if, (, i, !=, pivotRow, ), {]
[;, i, ++, ), {, if, (, i, !=, pivotRow, ), {, final, double, multiplier, =, tableau, ., getEntry, (]
[<, tableau, ., getHeight, (, ), ;, i, ++, ), {, if, (, i, !=, pivotRow, ), {, final, double]
[;, i, ++, ), {, if, (, i, !=, pivotRow, ), {, final, double, multiplier, =, tableau, ., getEntry, (]
[., getHeight, (, ), ;, i, ++, ), {, if, (, i, !=, pivotRow, ), {, final, double, multiplier, =]
[), {, if, (, i, !=, pivotRow, ), {, final, double, multiplier, =, tableau, ., getEntry, (, i, ,, pivotCol]
[++, ), {, if, (, i, !=, pivotRow, ), {, final, double, multiplier, =, tableau, ., getEntry, (, i, ,]
[), {, final, double, multiplier, =, tableau, ., getEntry, (, i, ,, pivotCol, ), ;, tableau, ., subtractRow, (, i]
[!=, pivotRow, ), {, final, double, multiplier, =, tableau, ., getEntry, (, i, ,, pivotCol, ), ;, tableau, ., subtractRow]
[), {, final, double, multiplier, =, tableau, ., getEntry, (, i, ,, pivotCol, ), ;, tableau, ., subtractRow, (, i]
[;, tableau, ., subtractRow, (, i, ,, pivotRow, ,, multiplier, ), ;, }, }, }, protected, void, solvePhase1, (, final]
[., getEntry, (, i, ,, pivotCol, ), ;, tableau, ., subtractRow, (, i, ,, pivotRow, ,, multiplier, ), ;, }]
[,, pivotCol, ), ;, tableau, ., subtractRow, (, i, ,, pivotRow, ,, multiplier, ), ;, }, }, }, protected, void]
[), ;, tableau, ., subtractRow, (, i, ,, pivotRow, ,, multiplier, ), ;, }, }, }, protected, void, solvePhase1, (]
[;, }, }, }, protected, void, solvePhase1, (, final, SimplexTableau, tableau, ), throws, MaxCountExceededException, ,, UnboundedSolutionException, ,, NoFeasibleSolutionException, {, if]
[., subtractRow, (, i, ,, pivotRow, ,, multiplier, ), ;, }, }, }, protected, void, solvePhase1, (, final, SimplexTableau, tableau]
[,, pivotRow, ,, multiplier, ), ;, }, }, }, protected, void, solvePhase1, (, final, SimplexTableau, tableau, ), throws, MaxCountExceededException, ,]
[,, multiplier, ), ;, }, }, }, protected, void, solvePhase1, (, final, SimplexTableau, tableau, ), throws, MaxCountExceededException, ,, UnboundedSolutionException, ,]
[), ;, }, }, }, protected, void, solvePhase1, (, final, SimplexTableau, tableau, ), throws, MaxCountExceededException, ,, UnboundedSolutionException, ,, NoFeasibleSolutionException, {]
[), {, return, ;, }, while, (, !, tableau, ., isOptimal, (, ), ), {, doIteration, (, tableau, ), ;]
[==, 0, ), {, return, ;, }, while, (, !, tableau, ., isOptimal, (, ), ), {, doIteration, (, tableau]
[., getNumArtificialVariables, (, ), ==, 0, ), {, return, ;, }, while, (, !, tableau, ., isOptimal, (, ), )]
[), {, return, ;, }, while, (, !, tableau, ., isOptimal, (, ), ), {, doIteration, (, tableau, ), ;]
[), {, doIteration, (, tableau, ), ;, }, if, (, !, Precision, ., equals, (, tableau, ., getEntry, (, 0]
[), {, doIteration, (, tableau, ), ;, }, if, (, !, Precision, ., equals, (, tableau, ., getEntry, (, 0]
[., isOptimal, (, ), ), {, doIteration, (, tableau, ), ;, }, if, (, !, Precision, ., equals, (, tableau]
[;, }, if, (, !, Precision, ., equals, (, tableau, ., getEntry, (, 0, ,, tableau, ., getRhsOffset, (, )]
[), ;, }, if, (, !, Precision, ., equals, (, tableau, ., getEntry, (, 0, ,, tableau, ., getRhsOffset, (]
[), {, throw, new, NoFeasibleSolutionException, (, ), ;, }, }, @, Override, public, PointValuePair, doOptimize, (, ), throws, MaxCountExceededException, ,]
[), {, throw, new, NoFeasibleSolutionException, (, ), ;, }, }, @, Override, public, PointValuePair, doOptimize, (, ), throws, MaxCountExceededException, ,]
[., equals, (, tableau, ., getEntry, (, 0, ,, tableau, ., getRhsOffset, (, ), ), ,, 0d, ,, epsilon, )]
[,, 0d, ,, epsilon, ), ), {, throw, new, NoFeasibleSolutionException, (, ), ;, }, }, @, Override, public, PointValuePair, doOptimize]
[., getEntry, (, 0, ,, tableau, ., getRhsOffset, (, ), ), ,, 0d, ,, epsilon, ), ), {, throw, new]
[,, tableau, ., getRhsOffset, (, ), ), ,, 0d, ,, epsilon, ), ), {, throw, new, NoFeasibleSolutionException, (, ), ;]
[), ,, 0d, ,, epsilon, ), ), {, throw, new, NoFeasibleSolutionException, (, ), ;, }, }, @, Override, public, PointValuePair]
[., getRhsOffset, (, ), ), ,, 0d, ,, epsilon, ), ), {, throw, new, NoFeasibleSolutionException, (, ), ;, }, }]
[,, epsilon, ), ), {, throw, new, NoFeasibleSolutionException, (, ), ;, }, }, @, Override, public, PointValuePair, doOptimize, (, )]
[), ), {, throw, new, NoFeasibleSolutionException, (, ), ;, }, }, @, Override, public, PointValuePair, doOptimize, (, ), throws, MaxCountExceededException]
[;, }, }, @, Override, public, PointValuePair, doOptimize, (, ), throws, MaxCountExceededException, ,, UnboundedSolutionException, ,, NoFeasibleSolutionException, {, final, SimplexTableau, tableau]
[;, solvePhase1, (, tableau, ), ;, tableau, ., dropPhase1Objective, (, ), ;, while, (, !, tableau, ., isOptimal, (, )]
[,, getConstraints, (, ), ,, getGoalType, (, ), ,, restrictToNonNegative, (, ), ,, epsilon, ,, maxUlps, ), ;, solvePhase1, (]
[,, getGoalType, (, ), ,, restrictToNonNegative, (, ), ,, epsilon, ,, maxUlps, ), ;, solvePhase1, (, tableau, ), ;, tableau]
[,, restrictToNonNegative, (, ), ,, epsilon, ,, maxUlps, ), ;, solvePhase1, (, tableau, ), ;, tableau, ., dropPhase1Objective, (, )]
[,, epsilon, ,, maxUlps, ), ;, solvePhase1, (, tableau, ), ;, tableau, ., dropPhase1Objective, (, ), ;, while, (, !]
[,, maxUlps, ), ;, solvePhase1, (, tableau, ), ;, tableau, ., dropPhase1Objective, (, ), ;, while, (, !, tableau, .]
[), ;, solvePhase1, (, tableau, ), ;, tableau, ., dropPhase1Objective, (, ), ;, while, (, !, tableau, ., isOptimal, (]
[;, tableau, ., dropPhase1Objective, (, ), ;, while, (, !, tableau, ., isOptimal, (, ), ), {, doIteration, (, tableau]
[), ;, tableau, ., dropPhase1Objective, (, ), ;, while, (, !, tableau, ., isOptimal, (, ), ), {, doIteration, (]
[;, while, (, !, tableau, ., isOptimal, (, ), ), {, doIteration, (, tableau, ), ;, }, return, tableau, .]
[., dropPhase1Objective, (, ), ;, while, (, !, tableau, ., isOptimal, (, ), ), {, doIteration, (, tableau, ), ;]
[), {, doIteration, (, tableau, ), ;, }, return, tableau, ., getSolution, (, ), ;, }, }]
[), {, doIteration, (, tableau, ), ;, }, return, tableau, ., getSolution, (, ), ;, }, }]
[., isOptimal, (, ), ), {, doIteration, (, tableau, ), ;, }, return, tableau, ., getSolution, (, ), ;, }]
[;, }, return, tableau, ., getSolution, (, ), ;, }, }]
[), ;, }, return, tableau, ., getSolution, (, ), ;, }, }]
[;, }, }]
[., getSolution, (, ), ;, }, }]
