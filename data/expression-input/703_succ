[=, annotatable, ;, this, ., second, =, annotation, ;, }, }, private, static, class, GraphAnnotationState, extends, ArrayList, <, AnnotationState, >]
[., first, =, annotatable, ;, this, ., second, =, annotation, ;, }, }, private, static, class, GraphAnnotationState, extends, ArrayList, <]
[;, this, ., second, =, annotation, ;, }, }, private, static, class, GraphAnnotationState, extends, ArrayList, <, AnnotationState, >, {, private]
[=, annotation, ;, }, }, private, static, class, GraphAnnotationState, extends, ArrayList, <, AnnotationState, >, {, private, static, final, long, serialVersionUID]
[., second, =, annotation, ;, }, }, private, static, class, GraphAnnotationState, extends, ArrayList, <, AnnotationState, >, {, private, static, final]
[;, }, }, private, static, class, GraphAnnotationState, extends, ArrayList, <, AnnotationState, >, {, private, static, final, long, serialVersionUID, =, 1L]
[;, public, GraphAnnotationState, (, int, size, ), {, super, (, size, ), ;, }, }, private, Deque, <, GraphAnnotationState, >]
[), ;, }, }, private, Deque, <, GraphAnnotationState, >, nodeAnnotationStack, ;, private, Deque, <, GraphAnnotationState, >, edgeAnnotationStack, ;, public, abstract]
[), {, connect, (, n1, ,, edge, ,, n2, ), ;, }, }, public, abstract, GraphNode, <, N, ,, E]
[), {, connect, (, n1, ,, edge, ,, n2, ), ;, }, }, public, abstract, GraphNode, <, N, ,, E]
[,, edge, ,, n2, ), ), {, connect, (, n1, ,, edge, ,, n2, ), ;, }, }, public, abstract]
[,, n2, ), ), {, connect, (, n1, ,, edge, ,, n2, ), ;, }, }, public, abstract, GraphNode, <]
[), ), {, connect, (, n1, ,, edge, ,, n2, ), ;, }, }, public, abstract, GraphNode, <, N, ,]
[;, }, }, public, abstract, GraphNode, <, N, ,, E, >, createNode, (, N, value, ), ;, @, Override, public]
[,, edge, ,, n2, ), ;, }, }, public, abstract, GraphNode, <, N, ,, E, >, createNode, (, N, value]
[,, n2, ), ;, }, }, public, abstract, GraphNode, <, N, ,, E, >, createNode, (, N, value, ), ;]
[), ;, }, }, public, abstract, GraphNode, <, N, ,, E, >, createNode, (, N, value, ), ;, @, Override]
[;, }, public, abstract, List, <, GraphNode, <, N, ,, E, >, >, getNeighborNodes, (, N, value, ), ;, public]
[), ;, }, public, abstract, List, <, GraphNode, <, N, ,, E, >, >, getNeighborNodes, (, N, value, ), ;]
[;, }, public, abstract, boolean, isConnected, (, N, n1, ,, N, n2, ), ;, public, abstract, boolean, isConnected, (, N]
[!=, null, ;, }, public, abstract, boolean, isConnected, (, N, n1, ,, N, n2, ), ;, public, abstract, boolean, isConnected]
[), !=, null, ;, }, public, abstract, boolean, isConnected, (, N, n1, ,, N, n2, ), ;, public, abstract, boolean]
[;, }, public, abstract, boolean, isConnected, (, N, n1, ,, N, n2, ), ;, public, abstract, boolean, isConnected, (, N]
[<, T, extends, GraphNode, <, N, ,, E, >, >, T, getNodeOrFail, (, N, val, ), {, T, node, =]
[), <, T, extends, GraphNode, <, N, ,, E, >, >, T, getNodeOrFail, (, N, val, ), {, T, node]
[;, if, (, node, ==, null, ), {, throw, new, IllegalArgumentException, (, val, +, " does not exist in graph", ), ;, }, return, node]
[;, if, (, node, ==, null, ), {, throw, new, IllegalArgumentException, (, val, +, " does not exist in graph", ), ;, }, return, node]
[), ;, if, (, node, ==, null, ), {, throw, new, IllegalArgumentException, (, val, +, " does not exist in graph", ), ;, }, return]
[), {, throw, new, IllegalArgumentException, (, val, +, " does not exist in graph", ), ;, }, return, node, ;, }, @, Override, public, final]
[==, null, ), {, throw, new, IllegalArgumentException, (, val, +, " does not exist in graph", ), ;, }, return, node, ;, }, @, Override]
[), {, throw, new, IllegalArgumentException, (, val, +, " does not exist in graph", ), ;, }, return, node, ;, }, @, Override, public, final]
[;, }, return, node, ;, }, @, Override, public, final, void, clearNodeAnnotations, (, ), {, for, (, GraphNode, <, N]
[), ;, }, return, node, ;, }, @, Override, public, final, void, clearNodeAnnotations, (, ), {, for, (, GraphNode, <]
[+, " does not exist in graph", ), ;, }, return, node, ;, }, @, Override, public, final, void, clearNodeAnnotations, (, ), {, for, (]
[), ;, }, return, node, ;, }, @, Override, public, final, void, clearNodeAnnotations, (, ), {, for, (, GraphNode, <]
[;, }, @, Override, public, final, void, clearNodeAnnotations, (, ), {, for, (, GraphNode, <, N, ,, E, >, n]
[), {, n, ., setAnnotation, (, null, ), ;, }, }, public, final, void, clearEdgeAnnotations, (, ), {, for, (]
[;, }, }, public, final, void, clearEdgeAnnotations, (, ), {, for, (, GraphEdge, <, N, ,, E, >, e, :]
[., setAnnotation, (, null, ), ;, }, }, public, final, void, clearEdgeAnnotations, (, ), {, for, (, GraphEdge, <, N]
[), ;, }, }, public, final, void, clearEdgeAnnotations, (, ), {, for, (, GraphEdge, <, N, ,, E, >, e]
[), {, e, ., setAnnotation, (, null, ), ;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (]
[;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (, nodeAnnotationStack, ==, null, ), {, nodeAnnotationStack, =, Lists]
[., setAnnotation, (, null, ), ;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (, nodeAnnotationStack, ==, null]
[), ;, }, }, public, final, void, pushNodeAnnotations, (, ), {, if, (, nodeAnnotationStack, ==, null, ), {, nodeAnnotationStack, =]
[), {, nodeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, nodeAnnotationStack, ,, getNodes, (, ), ), ;]
[==, null, ), {, nodeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, nodeAnnotationStack, ,, getNodes, (, )]
[), {, nodeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, nodeAnnotationStack, ,, getNodes, (, ), ), ;]
[=, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, nodeAnnotationStack, ,, getNodes, (, ), ), ;, }, public, final]
[;, }, pushAnnotations, (, nodeAnnotationStack, ,, getNodes, (, ), ), ;, }, public, final, void, popNodeAnnotations, (, ), {, Preconditions]
[., newLinkedList, (, ), ;, }, pushAnnotations, (, nodeAnnotationStack, ,, getNodes, (, ), ), ;, }, public, final, void, popNodeAnnotations]
[;, }, public, final, void, popNodeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, nodeAnnotationStack, ,, "Popping node annotations without pushing.", ), ;, popAnnotations, (]
[,, getNodes, (, ), ), ;, }, public, final, void, popNodeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, nodeAnnotationStack, ,]
[), ;, }, public, final, void, popNodeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, nodeAnnotationStack, ,, "Popping node annotations without pushing.", ), ;, popAnnotations]
[;, popAnnotations, (, nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack, ==, null, )]
[., checkNotNull, (, nodeAnnotationStack, ,, "Popping node annotations without pushing.", ), ;, popAnnotations, (, nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, )]
[,, "Popping node annotations without pushing.", ), ;, popAnnotations, (, nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack]
[), ;, popAnnotations, (, nodeAnnotationStack, ), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack, ==, null]
[;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack, ==, null, ), {, edgeAnnotationStack, =, Lists, .]
[), ;, }, public, final, void, pushEdgeAnnotations, (, ), {, if, (, edgeAnnotationStack, ==, null, ), {, edgeAnnotationStack, =, Lists]
[), {, edgeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, edgeAnnotationStack, ,, getEdges, (, ), ), ;]
[==, null, ), {, edgeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, edgeAnnotationStack, ,, getEdges, (, )]
[), {, edgeAnnotationStack, =, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, edgeAnnotationStack, ,, getEdges, (, ), ), ;]
[=, Lists, ., newLinkedList, (, ), ;, }, pushAnnotations, (, edgeAnnotationStack, ,, getEdges, (, ), ), ;, }, public, final]
[;, }, pushAnnotations, (, edgeAnnotationStack, ,, getEdges, (, ), ), ;, }, public, final, void, popEdgeAnnotations, (, ), {, Preconditions]
[., newLinkedList, (, ), ;, }, pushAnnotations, (, edgeAnnotationStack, ,, getEdges, (, ), ), ;, }, public, final, void, popEdgeAnnotations]
[;, }, public, final, void, popEdgeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, edgeAnnotationStack, ,, "Popping edge annotations without pushing.", ), ;, popAnnotations, (]
[,, getEdges, (, ), ), ;, }, public, final, void, popEdgeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, edgeAnnotationStack, ,]
[), ;, }, public, final, void, popEdgeAnnotations, (, ), {, Preconditions, ., checkNotNull, (, edgeAnnotationStack, ,, "Popping edge annotations without pushing.", ), ;, popAnnotations]
[;, popAnnotations, (, edgeAnnotationStack, ), ;, }, public, interface, GraphEdge, <, N, ,, E, >, extends, Annotatable, {, E, getValue]
[., checkNotNull, (, edgeAnnotationStack, ,, "Popping edge annotations without pushing.", ), ;, popAnnotations, (, edgeAnnotationStack, ), ;, }, public, interface, GraphEdge, <, N, ,]
[,, "Popping edge annotations without pushing.", ), ;, popAnnotations, (, edgeAnnotationStack, ), ;, }, public, interface, GraphEdge, <, N, ,, E, >, extends, Annotatable]
[), ;, popAnnotations, (, edgeAnnotationStack, ), ;, }, public, interface, GraphEdge, <, N, ,, E, >, extends, Annotatable, {, E]
[;, }, public, interface, GraphEdge, <, N, ,, E, >, extends, Annotatable, {, E, getValue, (, ), ;, GraphNode, <]
[), ;, }, public, interface, GraphEdge, <, N, ,, E, >, extends, Annotatable, {, E, getValue, (, ), ;, GraphNode]
[;, SimpleSubGraph, (, Graph, <, N, ,, E, >, graph, ), {, this, ., graph, =, graph, ;, }, @]
[., newArrayList, (, ), ;, SimpleSubGraph, (, Graph, <, N, ,, E, >, graph, ), {, this, ., graph, =]
[=, graph, ;, }, @, Override, public, boolean, isIndependentOf, (, N, value, ), {, GraphNode, <, N, ,, E, >]
[., graph, =, graph, ;, }, @, Override, public, boolean, isIndependentOf, (, N, value, ), {, GraphNode, <, N, ,]
[;, }, @, Override, public, boolean, isIndependentOf, (, N, value, ), {, GraphNode, <, N, ,, E, >, node, =]
[;, for, (, GraphNode, <, N, ,, E, >, n, :, nodes, ), {, if, (, graph, ., getNeighborNodes, (]
[., getNode, (, value, ), ;, for, (, GraphNode, <, N, ,, E, >, n, :, nodes, ), {, if]
[), ;, for, (, GraphNode, <, N, ,, E, >, n, :, nodes, ), {, if, (, graph, ., getNeighborNodes]
[), {, if, (, graph, ., getNeighborNodes, (, n, ., getValue, (, ), ), ., contains, (, node, ), )]
[), {, return, false, ;, }, }, return, true, ;, }, @, Override, public, void, addNode, (, N, value, )]
[., contains, (, node, ), ), {, return, false, ;, }, }, return, true, ;, }, @, Override, public, void]
[., getNeighborNodes, (, n, ., getValue, (, ), ), ., contains, (, node, ), ), {, return, false, ;, }]
[), ., contains, (, node, ), ), {, return, false, ;, }, }, return, true, ;, }, @, Override, public]
[., getValue, (, ), ), ., contains, (, node, ), ), {, return, false, ;, }, }, return, true, ;]
[), ), {, return, false, ;, }, }, return, true, ;, }, @, Override, public, void, addNode, (, N, value]
[;, }, }, return, true, ;, }, @, Override, public, void, addNode, (, N, value, ), {, nodes, ., add]
[;, }, @, Override, public, void, addNode, (, N, value, ), {, nodes, ., add, (, graph, ., getNodeOrFail, (]
[;, }, }, private, static, void, pushAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ,, Collection, <, ?, extends, Annotatable, >]
[., add, (, graph, ., getNodeOrFail, (, value, ), ), ;, }, }, private, static, void, pushAnnotations, (, Deque, <]
[), ;, }, }, private, static, void, pushAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ,, Collection, <, ?, extends, Annotatable]
[., getNodeOrFail, (, value, ), ), ;, }, }, private, static, void, pushAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ,]
[), ), ;, }, }, private, static, void, pushAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ,, Collection, <, ?, extends]
[;, for, (, Annotatable, h, :, haveAnnotations, ), {, stack, ., peek, (, ), ., add, (, new, AnnotationState, (]
[., push, (, new, GraphAnnotationState, (, haveAnnotations, ., size, (, ), ), ), ;, for, (, Annotatable, h, :, haveAnnotations]
[), ;, for, (, Annotatable, h, :, haveAnnotations, ), {, stack, ., peek, (, ), ., add, (, new, AnnotationState]
[), ), ;, for, (, Annotatable, h, :, haveAnnotations, ), {, stack, ., peek, (, ), ., add, (, new]
[., size, (, ), ), ), ;, for, (, Annotatable, h, :, haveAnnotations, ), {, stack, ., peek, (, )]
[), {, stack, ., peek, (, ), ., add, (, new, AnnotationState, (, h, ,, h, ., getAnnotation, (, )]
[;, h, ., setAnnotation, (, null, ), ;, }, }, private, static, void, popAnnotations, (, Deque, <, GraphAnnotationState, >, stack]
[., add, (, new, AnnotationState, (, h, ,, h, ., getAnnotation, (, ), ), ), ;, h, ., setAnnotation, (]
[., peek, (, ), ., add, (, new, AnnotationState, (, h, ,, h, ., getAnnotation, (, ), ), ), ;]
[), ;, h, ., setAnnotation, (, null, ), ;, }, }, private, static, void, popAnnotations, (, Deque, <, GraphAnnotationState, >]
[,, h, ., getAnnotation, (, ), ), ), ;, h, ., setAnnotation, (, null, ), ;, }, }, private, static]
[), ), ;, h, ., setAnnotation, (, null, ), ;, }, }, private, static, void, popAnnotations, (, Deque, <, GraphAnnotationState]
[., getAnnotation, (, ), ), ), ;, h, ., setAnnotation, (, null, ), ;, }, }, private, static, void, popAnnotations]
[;, }, }, private, static, void, popAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ), {, for, (, AnnotationState, as, :]
[., setAnnotation, (, null, ), ;, }, }, private, static, void, popAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ), {]
[), ;, }, }, private, static, void, popAnnotations, (, Deque, <, GraphAnnotationState, >, stack, ), {, for, (, AnnotationState, as]
[), {, as, ., first, ., setAnnotation, (, as, ., second, ), ;, }, }, }]
[., pop, (, ), ), {, as, ., first, ., setAnnotation, (, as, ., second, ), ;, }, }, }]
[;, }, }, }]
[., setAnnotation, (, as, ., second, ), ;, }, }, }]
[., first, ., setAnnotation, (, as, ., second, ), ;, }, }, }]
[), ;, }, }, }]
[., second, ), ;, }, }, }]
