[private, final, List, <, Node, >, replacements, ;, GetReplacementSideEffectSubexpressions, (, AbstractCompiler, compiler, ,, List, <, Node, >, replacements, ), {]
[private, final, List, <, Node, >, replacements, ;, GetReplacementSideEffectSubexpressions, (, AbstractCompiler, compiler, ,, List, <, Node, >, replacements, ), {]
[Node, >, replacements, ;, GetReplacementSideEffectSubexpressions, (, AbstractCompiler, compiler, ,, List, <, Node, >, replacements, ), {, this, ., compiler, =]
[replacements, ;, GetReplacementSideEffectSubexpressions, (, AbstractCompiler, compiler, ,, List, <, Node, >, replacements, ), {, this, ., compiler, =, compiler, ;]
[replacements, ;, GetReplacementSideEffectSubexpressions, (, AbstractCompiler, compiler, ,, List, <, Node, >, replacements, ), {, this, ., compiler, =, compiler, ;]
[AbstractCompiler, compiler, ,, List, <, Node, >, replacements, ), {, this, ., compiler, =, compiler, ;, this, ., replacements, =]
[compiler, =, compiler, ;, this, ., replacements, =, replacements, ;, }, @, Override, public, boolean, classDefiningCallsHaveSideEffects, (, ), {, return]
[classDefiningCallsHaveSideEffects, (, ), {, return, true, ;, }, @, Override, public, void, keepSubTree, (, Node, original, ), {, if, (]
[classDefiningCallsHaveSideEffects, (, ), {, return, true, ;, }, @, Override, public, void, keepSubTree, (, Node, original, ), {, if, (]
[classDefiningCallsHaveSideEffects, (, ), {, return, true, ;, }, @, Override, public, void, keepSubTree, (, Node, original, ), {, if, (]
[;, }, @, Override, public, void, keepSubTree, (, Node, original, ), {, if, (, original, ., getParent, (, ), !=]
[Override, public, void, keepSubTree, (, Node, original, ), {, if, (, original, ., getParent, (, ), !=, null, ), {]
[Override, public, void, keepSubTree, (, Node, original, ), {, if, (, original, ., getParent, (, ), !=, null, ), {]
[), {, if, (, original, ., getParent, (, ), !=, null, ), {, original, ., detachFromParent, (, ), ;, }]
[), {, if, (, original, ., getParent, (, ), !=, null, ), {, original, ., detachFromParent, (, ), ;, }]
[original, ., getParent, (, ), !=, null, ), {, original, ., detachFromParent, (, ), ;, }, replacements, ., add, (]
[;, }, replacements, ., add, (, original, ), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {]
[;, }, replacements, ., add, (, original, ), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {]
[add, (, original, ), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument, (]
[add, (, original, ), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument, (]
[(, original, ), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument, (, (]
[(, original, ), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument, (, (]
[public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument, (, (, original, ., isAnd, (, ), ), ||]
[void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument, (, (, original, ., isAnd, (, ), ), ||, (]
[void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument, (, (, original, ., isAnd, (, ), ), ||, (]
[Preconditions, ., checkArgument, (, (, original, ., isAnd, (, ), ), ||, (, original, ., isOr, (, ), ), ,]
[checkArgument, (, (, original, ., isAnd, (, ), ), ||, (, original, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,]
[checkArgument, (, (, original, ., isAnd, (, ), ), ||, (, original, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,]
[., isAnd, (, ), ), ||, (, original, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (]
[., isAnd, (, ), ), ||, (, original, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (]
[), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, original, ., getType, (, ), ), ), ;, Node, left, =]
[), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, original, ., getType, (, ), ), ), ;, Node, left, =]
[original, ., getType, (, ), ), ), ;, Node, left, =, original, ., getFirstChild, (, ), ;, Node, right, =]
[original, ., getType, (, ), ), ), ;, Node, left, =, original, ., getFirstChild, (, ), ;, Node, right, =]
[left, =, original, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, Node, simplifiedRight, =]
[original, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (]
[(, ), ;, Node, right, =, left, ., getNext, (, ), ;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;]
[(, ), ;, Node, right, =, left, ., getNext, (, ), ;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;]
[left, ., getNext, (, ), ;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;, original, ., detachChildren, (, ), ;]
[left, ., getNext, (, ), ;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;, original, ., detachChildren, (, ), ;]
[), ;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;, original, ., detachChildren, (, ), ;, original, ., addChildToBack, (]
[simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;, original, ., detachChildren, (, ), ;, original, ., addChildToBack, (, left, ), ;]
[simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;, original, ., detachChildren, (, ), ;, original, ., addChildToBack, (, left, ), ;]
[right, ), ;, original, ., detachChildren, (, ), ;, original, ., addChildToBack, (, left, ), ;, original, ., addChildToBack, (]
[original, ., detachChildren, (, ), ;, original, ., addChildToBack, (, left, ), ;, original, ., addChildToBack, (, simplifiedRight, ), ;]
[detachChildren, (, ), ;, original, ., addChildToBack, (, left, ), ;, original, ., addChildToBack, (, simplifiedRight, ), ;, keepSubTree, (]
[original, ), ;, }, @, Override, public, void, keepSimplifiedHookExpression, (, Node, hook, ,, boolean, thenHasSideEffects, ,, boolean, elseHasSideEffects, ), {]
[original, ), ;, }, @, Override, public, void, keepSimplifiedHookExpression, (, Node, hook, ,, boolean, thenHasSideEffects, ,, boolean, elseHasSideEffects, ), {]
[@, Override, public, void, keepSimplifiedHookExpression, (, Node, hook, ,, boolean, thenHasSideEffects, ,, boolean, elseHasSideEffects, ), {, Preconditions, ., checkArgument, (]
[@, Override, public, void, keepSimplifiedHookExpression, (, Node, hook, ,, boolean, thenHasSideEffects, ,, boolean, elseHasSideEffects, ), {, Preconditions, ., checkArgument, (]
[Node, hook, ,, boolean, thenHasSideEffects, ,, boolean, elseHasSideEffects, ), {, Preconditions, ., checkArgument, (, hook, ., isHook, (, ), ,]
[,, boolean, thenHasSideEffects, ,, boolean, elseHasSideEffects, ), {, Preconditions, ., checkArgument, (, hook, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,]
[,, boolean, thenHasSideEffects, ,, boolean, elseHasSideEffects, ), {, Preconditions, ., checkArgument, (, hook, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,]
[boolean, elseHasSideEffects, ), {, Preconditions, ., checkArgument, (, hook, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (]
[boolean, elseHasSideEffects, ), {, Preconditions, ., checkArgument, (, hook, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (]
[(, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, hook, ., getType, (, ), ), ), ;, Node, condition, =]
[(, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, hook, ., getType, (, ), ), ), ;, Node, condition, =]
[hook, ., getType, (, ), ), ), ;, Node, condition, =, hook, ., getFirstChild, (, ), ;, Node, thenBranch, =]
[hook, ., getType, (, ), ), ), ;, Node, condition, =, hook, ., getFirstChild, (, ), ;, Node, thenBranch, =]
[condition, =, hook, ., getFirstChild, (, ), ;, Node, thenBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =]
[condition, =, hook, ., getFirstChild, (, ), ;, Node, thenBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =]
[Node, thenBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (]
[Node, thenBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (]
[=, condition, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, thenHasSideEffects, &&]
[getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {]
[getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {]
[=, thenBranch, ., getNext, (, ), ;, if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {, hook, ., detachChildren, (, ), ;]
[=, thenBranch, ., getNext, (, ), ;, if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {, hook, ., detachChildren, (, ), ;]
[(, ), ;, if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {, hook, ., detachChildren, (, ), ;, hook, ., addChildToBack, (]
[if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {, hook, ., detachChildren, (, ), ;, hook, ., addChildToBack, (, condition, ), ;]
[if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {, hook, ., detachChildren, (, ), ;, hook, ., addChildToBack, (, condition, ), ;]
[elseHasSideEffects, ), {, hook, ., detachChildren, (, ), ;, hook, ., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (]
[{, hook, ., detachChildren, (, ), ;, hook, ., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (]
[(, ), ;, hook, ., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;]
[(, ), ;, hook, ., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;]
[., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;, hook, ., addChildToBack, (]
[(, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (]
[hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;]
[addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;, keepSubTree, (]
[;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;, keepSubTree, (, hook, ), ;, }, else, if, (]
[;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;, keepSubTree, (, hook, ), ;, }, else, if, (]
[., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;, keepSubTree, (, hook, ), ;, }, else, if, (, thenHasSideEffects, ||]
[), ), ;, keepSubTree, (, hook, ), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =]
[), ), ;, keepSubTree, (, hook, ), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =]
[;, keepSubTree, (, hook, ), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?]
[;, keepSubTree, (, hook, ), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?]
[), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :]
[), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :]
[||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :, Token, ., OR, ;, Node, body, =]
[||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :, Token, ., OR, ;, Node, body, =]
[), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?]
[int, type, =, thenHasSideEffects, ?, Token, ., AND, :, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :]
[Token, ., AND, :, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =]
[Token, ., AND, :, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =]
[:, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (]
[., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (, type, ,]
[., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (, type, ,]
[thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (, type, ,, condition, ., detachFromParent, (, ), ,]
[thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (, type, ,, condition, ., detachFromParent, (, ), ,, simplifyShortCircuitBranch, (]
[=, new, Node, (, type, ,, condition, ., detachFromParent, (, ), ,, simplifyShortCircuitBranch, (, body, ), ), ., copyInformationFrom, (]
[(, type, ,, condition, ., detachFromParent, (, ), ,, simplifyShortCircuitBranch, (, body, ), ), ., copyInformationFrom, (, hook, ), ;]
[,, condition, ., detachFromParent, (, ), ,, simplifyShortCircuitBranch, (, body, ), ), ., copyInformationFrom, (, hook, ), ;, keepSubTree, (]
[simplifyShortCircuitBranch, (, body, ), ), ., copyInformationFrom, (, hook, ), ;, keepSubTree, (, simplified, ), ;, }, else, {, throw]
[), ), ., copyInformationFrom, (, hook, ), ;, keepSubTree, (, simplified, ), ;, }, else, {, throw, new, IllegalArgumentException, (]
[(, "keepSimplifiedHookExpression must keep at least 1 branch", ), ;, }, }, private, Node, simplifyShortCircuitBranch, (, Node, node, ), {, List, <, Node, >, parts, =]
[(, "keepSimplifiedHookExpression must keep at least 1 branch", ), ;, }, }, private, Node, simplifyShortCircuitBranch, (, Node, node, ), {, List, <, Node, >, parts, =]
[private, Node, simplifyShortCircuitBranch, (, Node, node, ), {, List, <, Node, >, parts, =, Lists, ., newArrayList, (, ), ;]
[private, Node, simplifyShortCircuitBranch, (, Node, node, ), {, List, <, Node, >, parts, =, Lists, ., newArrayList, (, ), ;]
[Node, node, ), {, List, <, Node, >, parts, =, Lists, ., newArrayList, (, ), ;, NodeTraversal, ., traverse, (]
[), {, List, <, Node, >, parts, =, Lists, ., newArrayList, (, ), ;, NodeTraversal, ., traverse, (, compiler, ,]
[List, <, Node, >, parts, =, Lists, ., newArrayList, (, ), ;, NodeTraversal, ., traverse, (, compiler, ,, node, ,]
[>, parts, =, Lists, ., newArrayList, (, ), ;, NodeTraversal, ., traverse, (, compiler, ,, node, ,, new, GatherSideEffectSubexpressionsCallback, (]
[=, Lists, ., newArrayList, (, ), ;, NodeTraversal, ., traverse, (, compiler, ,, node, ,, new, GatherSideEffectSubexpressionsCallback, (, compiler, ,]
[newArrayList, (, ), ;, NodeTraversal, ., traverse, (, compiler, ,, node, ,, new, GatherSideEffectSubexpressionsCallback, (, compiler, ,, new, GetReplacementSideEffectSubexpressions, (]
[), ;, NodeTraversal, ., traverse, (, compiler, ,, node, ,, new, GatherSideEffectSubexpressionsCallback, (, compiler, ,, new, GetReplacementSideEffectSubexpressions, (, compiler, ,]
[node, ,, new, GatherSideEffectSubexpressionsCallback, (, compiler, ,, new, GetReplacementSideEffectSubexpressions, (, compiler, ,, parts, ), ), ), ;, Node, ret, =]
[new, GetReplacementSideEffectSubexpressions, (, compiler, ,, parts, ), ), ), ;, Node, ret, =, null, ;, for, (, Node, part, :]
[parts, ), ), ), ;, Node, ret, =, null, ;, for, (, Node, part, :, parts, ), {, if, (]
[parts, ), ), ), ;, Node, ret, =, null, ;, for, (, Node, part, :, parts, ), {, if, (]
[), ), ;, Node, ret, =, null, ;, for, (, Node, part, :, parts, ), {, if, (, ret, !=]
[Node, ret, =, null, ;, for, (, Node, part, :, parts, ), {, if, (, ret, !=, null, ), {]
[=, null, ;, for, (, Node, part, :, parts, ), {, if, (, ret, !=, null, ), {, ret, =]
[=, null, ;, for, (, Node, part, :, parts, ), {, if, (, ret, !=, null, ), {, ret, =]
[=, null, ;, for, (, Node, part, :, parts, ), {, if, (, ret, !=, null, ), {, ret, =]
[(, Node, part, :, parts, ), {, if, (, ret, !=, null, ), {, ret, =, IR, ., comma, (]
[part, :, parts, ), {, if, (, ret, !=, null, ), {, ret, =, IR, ., comma, (, ret, ,]
[if, (, ret, !=, null, ), {, ret, =, IR, ., comma, (, ret, ,, part, ), ., srcref, (]
[{, ret, =, IR, ., comma, (, ret, ,, part, ), ., srcref, (, node, ), ;, }, else, {]
[=, IR, ., comma, (, ret, ,, part, ), ., srcref, (, node, ), ;, }, else, {, ret, =]
[,, part, ), ., srcref, (, node, ), ;, }, else, {, ret, =, part, ;, }, }, if, (]
[,, part, ), ., srcref, (, node, ), ;, }, else, {, ret, =, part, ;, }, }, if, (]
[), ., srcref, (, node, ), ;, }, else, {, ret, =, part, ;, }, }, if, (, ret, ==]
[node, ), ;, }, else, {, ret, =, part, ;, }, }, if, (, ret, ==, null, ), {, throw]
[}, else, {, ret, =, part, ;, }, }, if, (, ret, ==, null, ), {, throw, new, IllegalArgumentException, (]
[}, else, {, ret, =, part, ;, }, }, if, (, ret, ==, null, ), {, throw, new, IllegalArgumentException, (]
[{, ret, =, part, ;, }, }, if, (, ret, ==, null, ), {, throw, new, IllegalArgumentException, (, "expected at least one side effect subexpression in short ", +]
[}, }, if, (, ret, ==, null, ), {, throw, new, IllegalArgumentException, (, "expected at least one side effect subexpression in short ", +, "circuit branch.", ), ;, }, return]
["expected at least one side effect subexpression in short ", +, "circuit branch.", ), ;, }, return, ret, ;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =]
["expected at least one side effect subexpression in short ", +, "circuit branch.", ), ;, }, return, ret, ;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =]
[;, }, return, ret, ;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (]
[;, }, return, ret, ;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (]
[;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (, Token, ., BLOCK, ,]
[;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (, Token, ., BLOCK, ,]
[static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (, Token, ., BLOCK, ,, Token, ., SCRIPT, ,]
[static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (, Token, ., BLOCK, ,, Token, ., SCRIPT, ,]
[Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (, Token, ., BLOCK, ,, Token, ., SCRIPT, ,, Token, ., VAR, ,]
[Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (, Token, ., BLOCK, ,, Token, ., SCRIPT, ,, Token, ., VAR, ,]
[ImmutableSet, ., of, (, Token, ., BLOCK, ,, Token, ., SCRIPT, ,, Token, ., VAR, ,, Token, ., EXPR_RESULT, ,]
[ImmutableSet, ., of, (, Token, ., BLOCK, ,, Token, ., SCRIPT, ,, Token, ., VAR, ,, Token, ., EXPR_RESULT, ,]
[;, private, final, AbstractCompiler, compiler, ;, private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler, ,, SideEffectAccumulator, accumulator, ), {]
[;, private, final, AbstractCompiler, compiler, ;, private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler, ,, SideEffectAccumulator, accumulator, ), {]
[compiler, ;, private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler, ,, SideEffectAccumulator, accumulator, ), {, this, ., compiler, =]
[private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler, ,, SideEffectAccumulator, accumulator, ), {, this, ., compiler, =, compiler, ;]
[private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler, ,, SideEffectAccumulator, accumulator, ), {, this, ., compiler, =, compiler, ;]
[;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler, ,, SideEffectAccumulator, accumulator, ), {, this, ., compiler, =, compiler, ;, this, ., accumulator, =]
[compiler, ;, this, ., accumulator, =, accumulator, ;, }, private, boolean, isClassDefiningCall, (, Node, callNode, ), {, SubclassRelationship, classes, =]
[compiler, ;, this, ., accumulator, =, accumulator, ;, }, private, boolean, isClassDefiningCall, (, Node, callNode, ), {, SubclassRelationship, classes, =]
[compiler, ;, this, ., accumulator, =, accumulator, ;, }, private, boolean, isClassDefiningCall, (, Node, callNode, ), {, SubclassRelationship, classes, =]
[}, private, boolean, isClassDefiningCall, (, Node, callNode, ), {, SubclassRelationship, classes, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (]
[(, Node, callNode, ), {, SubclassRelationship, classes, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, callNode, ), ;, return]
[(, Node, callNode, ), {, SubclassRelationship, classes, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, callNode, ), ;, return]
[callNode, ), {, SubclassRelationship, classes, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, callNode, ), ;, return, classes, !=]
[;, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, ), {, if, (]
[;, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, ), {, if, (]
[;, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, ), {, if, (]
[public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, ), {, if, (, FORBIDDEN_TYPES, ., contains, (]
[public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, ), {, if, (, FORBIDDEN_TYPES, ., contains, (]
[Node, node, ,, Node, parent, ), {, if, (, FORBIDDEN_TYPES, ., contains, (, node, ., getType, (, ), ), ||]
[Node, node, ,, Node, parent, ), {, if, (, FORBIDDEN_TYPES, ., contains, (, node, ., getType, (, ), ), ||]
[parent, ), {, if, (, FORBIDDEN_TYPES, ., contains, (, node, ., getType, (, ), ), ||, NodeUtil, ., isControlStructure, (]
[FORBIDDEN_TYPES, ., contains, (, node, ., getType, (, ), ), ||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw]
[(, node, ., getType, (, ), ), ||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw, new, IllegalArgumentException, (]
[(, node, ., getType, (, ), ), ||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw, new, IllegalArgumentException, (]
[(, node, ., getType, (, ), ), ||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw, new, IllegalArgumentException, (]
[(, ), ), ||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw, new, IllegalArgumentException, (, Token, ., name, (]
[(, ), ), ||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw, new, IllegalArgumentException, (, Token, ., name, (]
[(, node, ), ), {, throw, new, IllegalArgumentException, (, Token, ., name, (, node, ., getType, (, ), ), +]
[new, IllegalArgumentException, (, Token, ., name, (, node, ., getType, (, ), ), +, " nodes are not supported.", ), ;, }, if, (]
[new, IllegalArgumentException, (, Token, ., name, (, node, ., getType, (, ), ), +, " nodes are not supported.", ), ;, }, if, (]
[., getType, (, ), ), +, " nodes are not supported.", ), ;, }, if, (, node, ., isFunction, (, ), ), {, return]
[+, " nodes are not supported.", ), ;, }, if, (, node, ., isFunction, (, ), ), {, return, false, ;, }, if, (]
[+, " nodes are not supported.", ), ;, }, if, (, node, ., isFunction, (, ), ), {, return, false, ;, }, if, (]
[., isFunction, (, ), ), {, return, false, ;, }, if, (, node, ., isHook, (, ), ), {, return]
[(, ), ), {, return, false, ;, }, if, (, node, ., isHook, (, ), ), {, return, processHook, (]
[;, }, if, (, node, ., isHook, (, ), ), {, return, processHook, (, node, ), ;, }, if, (]
[;, }, if, (, node, ., isHook, (, ), ), {, return, processHook, (, node, ), ;, }, if, (]
[}, if, (, node, ., isHook, (, ), ), {, return, processHook, (, node, ), ;, }, if, (, (]
[}, if, (, node, ., isHook, (, ), ), {, return, processHook, (, node, ), ;, }, if, (, (]
[), ), {, return, processHook, (, node, ), ;, }, if, (, (, node, ., isAnd, (, ), ), ||]
[), {, return, processHook, (, node, ), ;, }, if, (, (, node, ., isAnd, (, ), ), ||, (]
[), {, return, processHook, (, node, ), ;, }, if, (, (, node, ., isAnd, (, ), ), ||, (]
[if, (, (, node, ., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ), {, return]
[(, node, ., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ), {, return, processShortCircuitExpression, (]
[), ||, (, node, ., isOr, (, ), ), ), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (]
[||, (, node, ., isOr, (, ), ), ), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (, !]
[||, (, node, ., isOr, (, ), ), ), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (, !]
[isOr, (, ), ), ), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (]
[), ), ), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (, node, ,]
[processShortCircuitExpression, (, node, ), ;, }, if, (, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (, node, ,, compiler, ), ), {, return]
[(, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (, node, ,, compiler, ), ), {, return, true, ;, }, else, {, if, (]
[(, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (, node, ,, compiler, ), ), {, return, true, ;, }, else, {, if, (]
[compiler, ), ), {, return, true, ;, }, else, {, if, (, node, ., isCall, (, ), ), {, return]
[), {, return, true, ;, }, else, {, if, (, node, ., isCall, (, ), ), {, return, processFunctionCall, (]
[{, if, (, node, ., isCall, (, ), ), {, return, processFunctionCall, (, node, ), ;, }, else, if, (]
[{, if, (, node, ., isCall, (, ), ), {, return, processFunctionCall, (, node, ), ;, }, else, if, (]
[), {, return, processFunctionCall, (, node, ), ;, }, else, if, (, node, ., isNew, (, ), ), {, return]
[return, processFunctionCall, (, node, ), ;, }, else, if, (, node, ., isNew, (, ), ), {, return, processConstructorCall, (]
[}, else, if, (, node, ., isNew, (, ), ), {, return, processConstructorCall, (, node, ), ;, }, else, {]
[}, else, if, (, node, ., isNew, (, ), ), {, return, processConstructorCall, (, node, ), ;, }, else, {]
[node, ., isNew, (, ), ), {, return, processConstructorCall, (, node, ), ;, }, else, {, accumulator, ., keepSubTree, (]
[), ), {, return, processConstructorCall, (, node, ), ;, }, else, {, accumulator, ., keepSubTree, (, node, ), ;, return]
[accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {]
[accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {]
[node, ), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[node, ), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (, (]
[), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (, (]
[}, boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (, (, node, ., isAnd, (, ), ), ||]
[boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (, (, node, ., isAnd, (, ), ), ||, (]
[boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (, (, node, ., isAnd, (, ), ), ||, (]
[Preconditions, ., checkArgument, (, (, node, ., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ,]
[checkArgument, (, (, node, ., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,]
[checkArgument, (, (, node, ., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,]
[., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (]
[., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (]
[), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, left, =]
[), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, left, =]
[node, ., getType, (, ), ), ), ;, Node, left, =, node, ., getFirstChild, (, ), ;, Node, right, =]
[node, ., getType, (, ), ), ), ;, Node, left, =, node, ., getFirstChild, (, ), ;, Node, right, =]
[Node, left, =, node, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, if, (]
[Node, left, =, node, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, if, (]
[., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, if, (, NodeUtil, ., mayHaveSideEffects, (]
[(, ), ;, Node, right, =, left, ., getNext, (, ), ;, if, (, NodeUtil, ., mayHaveSideEffects, (, right, ,]
[right, =, left, ., getNext, (, ), ;, if, (, NodeUtil, ., mayHaveSideEffects, (, right, ,, compiler, ), ), {]
[right, =, left, ., getNext, (, ), ;, if, (, NodeUtil, ., mayHaveSideEffects, (, right, ,, compiler, ), ), {]
[getNext, (, ), ;, if, (, NodeUtil, ., mayHaveSideEffects, (, right, ,, compiler, ), ), {, accumulator, ., keepSimplifiedShortCircuitExpression, (]
[if, (, NodeUtil, ., mayHaveSideEffects, (, right, ,, compiler, ), ), {, accumulator, ., keepSimplifiedShortCircuitExpression, (, node, ), ;, return]
[right, ,, compiler, ), ), {, accumulator, ., keepSimplifiedShortCircuitExpression, (, node, ), ;, return, false, ;, }, else, {, return]
[), ;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processHook, (, Node, node, ), {]
[), ;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processHook, (, Node, node, ), {]
[;, }, else, {, return, true, ;, }, }, boolean, processHook, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[;, }, else, {, return, true, ;, }, }, boolean, processHook, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[;, }, }, boolean, processHook, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isHook, (, ), ,]
[}, boolean, processHook, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,]
[}, boolean, processHook, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,]
[Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (]
[Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (]
[(, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, condition, =]
[(, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, condition, =]
[node, ., getType, (, ), ), ), ;, Node, condition, =, node, ., getFirstChild, (, ), ;, Node, ifBranch, =]
[node, ., getType, (, ), ), ), ;, Node, condition, =, node, ., getFirstChild, (, ), ;, Node, ifBranch, =]
[condition, =, node, ., getFirstChild, (, ), ;, Node, ifBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =]
[condition, =, node, ., getFirstChild, (, ), ;, Node, ifBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =]
[ifBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =, ifBranch, ., getNext, (, ), ;, boolean, thenHasSideEffects, =]
[ifBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =, ifBranch, ., getNext, (, ), ;, boolean, thenHasSideEffects, =]
[getNext, (, ), ;, Node, elseBranch, =, ifBranch, ., getNext, (, ), ;, boolean, thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (]
[), ;, Node, elseBranch, =, ifBranch, ., getNext, (, ), ;, boolean, thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, ifBranch, ,]
[., getNext, (, ), ;, boolean, thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, ifBranch, ,, compiler, ), ;, boolean, elseHasSideEffects, =]
[., getNext, (, ), ;, boolean, thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, ifBranch, ,, compiler, ), ;, boolean, elseHasSideEffects, =]
[;, boolean, thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, ifBranch, ,, compiler, ), ;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (]
[thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, ifBranch, ,, compiler, ), ;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,]
[(, ifBranch, ,, compiler, ), ;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (]
[(, ifBranch, ,, compiler, ), ;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (]
[,, compiler, ), ;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||]
[;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {]
[;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {]
[NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, accumulator, ., keepSimplifiedHookExpression, (]
[mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,]
[elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,]
[;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,, elseHasSideEffects, ), ;, return]
[), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,, elseHasSideEffects, ), ;, return, false, ;, }, else, {, return]
[), ;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processFunctionCall, (, Node, node, ), {]
[), ;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processFunctionCall, (, Node, node, ), {]
[;, }, else, {, return, true, ;, }, }, boolean, processFunctionCall, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[;, }, else, {, return, true, ;, }, }, boolean, processFunctionCall, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[;, }, }, boolean, processFunctionCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isCall, (, ), ,]
[}, boolean, processFunctionCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isCall, (, ), ,, "Expected: CALL, Got: %s", ,]
[}, boolean, processFunctionCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isCall, (, ), ,, "Expected: CALL, Got: %s", ,]
[Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isCall, (, ), ,, "Expected: CALL, Got: %s", ,, Token, ., name, (]
[Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isCall, (, ), ,, "Expected: CALL, Got: %s", ,, Token, ., name, (]
[(, ), ,, "Expected: CALL, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, functionName, =]
[(, ), ,, "Expected: CALL, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, functionName, =]
[(, node, ., getType, (, ), ), ), ;, Node, functionName, =, node, ., getFirstChild, (, ), ;, if, (]
[(, node, ., getType, (, ), ), ), ;, Node, functionName, =, node, ., getFirstChild, (, ), ;, if, (]
[(, node, ., getType, (, ), ), ), ;, Node, functionName, =, node, ., getFirstChild, (, ), ;, if, (]
[), ), ;, Node, functionName, =, node, ., getFirstChild, (, ), ;, if, (, functionName, ., isName, (, ), ||]
[), ), ;, Node, functionName, =, node, ., getFirstChild, (, ), ;, if, (, functionName, ., isName, (, ), ||]
[(, ), ;, if, (, functionName, ., isName, (, ), ||, functionName, ., isGetProp, (, ), ), {, if, (]
[(, ), ;, if, (, functionName, ., isName, (, ), ||, functionName, ., isGetProp, (, ), ), {, if, (]
[), ;, if, (, functionName, ., isName, (, ), ||, functionName, ., isGetProp, (, ), ), {, if, (, !]
[), ;, if, (, functionName, ., isName, (, ), ||, functionName, ., isGetProp, (, ), ), {, if, (, !]
[isName, (, ), ||, functionName, ., isGetProp, (, ), ), {, if, (, !, accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&]
[), ||, functionName, ., isGetProp, (, ), ), {, if, (, !, accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (]
[(, ), ), {, if, (, !, accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (, node, ), ), {, return]
[!, accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (, node, ), ), {, return, true, ;, }, }, if, (]
[accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (, node, ), ), {, return, true, ;, }, }, if, (, !]
[accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (, node, ), ), {, return, true, ;, }, }, if, (, !]
[), &&, isClassDefiningCall, (, node, ), ), {, return, true, ;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (]
[), ), {, return, true, ;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node, ), ), {, return]
[return, true, ;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node, ), ), {, return, true, ;, }]
[return, true, ;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node, ), ), {, return, true, ;, }]
[}, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, ., keepSubTree, (]
[NodeUtil, ., functionCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return]
[;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, boolean, processConstructorCall, (, Node, node, ), {]
[;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, boolean, processConstructorCall, (, Node, node, ), {]
[keepSubTree, (, node, ), ;, return, false, ;, }, boolean, processConstructorCall, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[keepSubTree, (, node, ), ;, return, false, ;, }, boolean, processConstructorCall, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[false, ;, }, boolean, processConstructorCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isNew, (, ), ,]
[}, boolean, processConstructorCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isNew, (, ), ,, "Expected: NEW, Got: %s", ,]
[}, boolean, processConstructorCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isNew, (, ), ,, "Expected: NEW, Got: %s", ,]
[Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isNew, (, ), ,, "Expected: NEW, Got: %s", ,, Token, ., name, (]
[Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isNew, (, ), ,, "Expected: NEW, Got: %s", ,, Token, ., name, (]
[isNew, (, ), ,, "Expected: NEW, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, if, (]
[(, ), ,, "Expected: NEW, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, if, (, !]
[(, ), ,, "Expected: NEW, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, if, (, !]
[,, Token, ., name, (, node, ., getType, (, ), ), ), ;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (]
[node, ., getType, (, ), ), ), ;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (, node, ), ), {, return]
[(, ), ), ), ;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (, node, ), ), {, return, true, ;, }]
[(, ), ), ), ;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (, node, ), ), {, return, true, ;, }]
[;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, ., keepSubTree, (]
[NodeUtil, ., constructorCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return]
