[;, static, final, String, JSC_PROPERTY_NAME_FN, =, "JSCompiler_renameProperty", ;, static, final, char, LARGEST_BASIC_LATIN, =, 0x7f, ;, private, static, final, Set, <]
[;, static, final, String, JSC_PROPERTY_NAME_FN, =, "JSCompiler_renameProperty", ;, static, final, char, LARGEST_BASIC_LATIN, =, 0x7f, ;, private, static, final, Set, <]
[., pow, (, 2, ,, 53, ), ;, static, final, String, JSC_PROPERTY_NAME_FN, =, "JSCompiler_renameProperty", ;, static, final, char, LARGEST_BASIC_LATIN, =]
[,, 53, ), ;, static, final, String, JSC_PROPERTY_NAME_FN, =, "JSCompiler_renameProperty", ;, static, final, char, LARGEST_BASIC_LATIN, =, 0x7f, ;, private, static]
[), ;, static, final, String, JSC_PROPERTY_NAME_FN, =, "JSCompiler_renameProperty", ;, static, final, char, LARGEST_BASIC_LATIN, =, 0x7f, ;, private, static, final, Set]
[;, static, final, char, LARGEST_BASIC_LATIN, =, 0x7f, ;, private, static, final, Set, <, String, >, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =, new, HashSet, <]
[;, private, static, final, Set, <, String, >, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, =, new, HashSet, <, String, >, (, Arrays, ., asList, (]
[;, private, NodeUtil, (, ), {, }, static, TernaryValue, getImpureBooleanValue, (, Node, n, ), {, switch, (, n, ., getType]
[), ;, private, NodeUtil, (, ), {, }, static, TernaryValue, getImpureBooleanValue, (, Node, n, ), {, switch, (, n, .]
[., asList, (, "Array", ,, "Date", ,, "Error", ,, "Object", ,, "RegExp", ,, "XMLHttpRequest", ), ), ;, private, NodeUtil, (]
[,, "Date", ,, "Error", ,, "Object", ,, "RegExp", ,, "XMLHttpRequest", ), ), ;, private, NodeUtil, (, ), {, }, static]
[,, "Error", ,, "Object", ,, "RegExp", ,, "XMLHttpRequest", ), ), ;, private, NodeUtil, (, ), {, }, static, TernaryValue, getImpureBooleanValue]
[,, "Object", ,, "RegExp", ,, "XMLHttpRequest", ), ), ;, private, NodeUtil, (, ), {, }, static, TernaryValue, getImpureBooleanValue, (, Node]
[,, "RegExp", ,, "XMLHttpRequest", ), ), ;, private, NodeUtil, (, ), {, }, static, TernaryValue, getImpureBooleanValue, (, Node, n, )]
[,, "XMLHttpRequest", ), ), ;, private, NodeUtil, (, ), {, }, static, TernaryValue, getImpureBooleanValue, (, Node, n, ), {, switch]
[), ), ;, private, NodeUtil, (, ), {, }, static, TernaryValue, getImpureBooleanValue, (, Node, n, ), {, switch, (, n]
[), {, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, getImpureBooleanValue, (, n, ., getLastChild, (, )]
[., getType, (, ), ), {, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, getImpureBooleanValue, (, n]
[:, case, Token, ., COMMA, :, return, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, case, Token, ., NOT]
[., ASSIGN, :, case, Token, ., COMMA, :, return, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, case, Token]
[:, return, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, case, Token, ., NOT, :, TernaryValue, value, =, getImpureBooleanValue]
[., COMMA, :, return, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, case, Token, ., NOT, :, TernaryValue, value]
[;, case, Token, ., NOT, :, TernaryValue, value, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, value]
[), ;, case, Token, ., NOT, :, TernaryValue, value, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return]
[., getLastChild, (, ), ), ;, case, Token, ., NOT, :, TernaryValue, value, =, getImpureBooleanValue, (, n, ., getLastChild, (]
[:, TernaryValue, value, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, value, ., not, (, ), ;]
[., NOT, :, TernaryValue, value, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, value, ., not, (]
[;, return, value, ., not, (, ), ;, case, Token, ., AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n]
[), ;, return, value, ., not, (, ), ;, case, Token, ., AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (]
[., getLastChild, (, ), ), ;, return, value, ., not, (, ), ;, case, Token, ., AND, :, {, TernaryValue]
[;, case, Token, ., AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue]
[., not, (, ), ;, case, Token, ., AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (]
[:, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n]
[., AND, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue]
[;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., and, (, rhs, )]
[), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., and, (, rhs]
[., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs]
[;, return, lhs, ., and, (, rhs, ), ;, }, case, Token, ., OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue]
[), ;, return, lhs, ., and, (, rhs, ), ;, }, case, Token, ., OR, :, {, TernaryValue, lhs, =]
[., getLastChild, (, ), ), ;, return, lhs, ., and, (, rhs, ), ;, }, case, Token, ., OR, :]
[;, }, case, Token, ., OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;]
[., and, (, rhs, ), ;, }, case, Token, ., OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, .]
[), ;, }, case, Token, ., OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), )]
[:, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n]
[., OR, :, {, TernaryValue, lhs, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue]
[;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., or, (, rhs, )]
[), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs, ., or, (, rhs]
[., getFirstChild, (, ), ), ;, TernaryValue, rhs, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, return, lhs]
[;, return, lhs, ., or, (, rhs, ), ;, }, case, Token, ., HOOK, :, {, TernaryValue, trueValue, =, getImpureBooleanValue]
[), ;, return, lhs, ., or, (, rhs, ), ;, }, case, Token, ., HOOK, :, {, TernaryValue, trueValue, =]
[., getLastChild, (, ), ), ;, return, lhs, ., or, (, rhs, ), ;, }, case, Token, ., HOOK, :]
[;, }, case, Token, ., HOOK, :, {, TernaryValue, trueValue, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ., getNext]
[., or, (, rhs, ), ;, }, case, Token, ., HOOK, :, {, TernaryValue, trueValue, =, getImpureBooleanValue, (, n, .]
[), ;, }, case, Token, ., HOOK, :, {, TernaryValue, trueValue, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), .]
[:, {, TernaryValue, trueValue, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ., getNext, (, ), ), ;, TernaryValue, falseValue]
[., HOOK, :, {, TernaryValue, trueValue, =, getImpureBooleanValue, (, n, ., getFirstChild, (, ), ., getNext, (, ), ), ;]
[;, TernaryValue, falseValue, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, if, (, trueValue, ., equals, (, falseValue]
[), ;, TernaryValue, falseValue, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, if, (, trueValue, ., equals, (]
[., getNext, (, ), ), ;, TernaryValue, falseValue, =, getImpureBooleanValue, (, n, ., getLastChild, (, ), ), ;, if, (]
[., getFirstChild, (, ), ., getNext, (, ), ), ;, TernaryValue, falseValue, =, getImpureBooleanValue, (, n, ., getLastChild, (, )]
[;, if, (, trueValue, ., equals, (, falseValue, ), ), {, return, trueValue, ;, }, else, {, return, TernaryValue, .]
[), ;, if, (, trueValue, ., equals, (, falseValue, ), ), {, return, trueValue, ;, }, else, {, return, TernaryValue]
[., getLastChild, (, ), ), ;, if, (, trueValue, ., equals, (, falseValue, ), ), {, return, trueValue, ;, }]
[), {, return, trueValue, ;, }, else, {, return, TernaryValue, ., UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT, :]
[., equals, (, falseValue, ), ), {, return, trueValue, ;, }, else, {, return, TernaryValue, ., UNKNOWN, ;, }, }]
[), ), {, return, trueValue, ;, }, else, {, return, TernaryValue, ., UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT]
[;, }, else, {, return, TernaryValue, ., UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT]
[;, }, }, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, TernaryValue, ., TRUE, ;, case, Token]
[., UNKNOWN, ;, }, }, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, TernaryValue, ., TRUE, ;]
[:, case, Token, ., OBJECTLIT, :, return, TernaryValue, ., TRUE, ;, case, Token, ., VOID, :, return, TernaryValue, ., FALSE]
[., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, TernaryValue, ., TRUE, ;, case, Token, ., VOID, :, return, TernaryValue]
[:, return, TernaryValue, ., TRUE, ;, case, Token, ., VOID, :, return, TernaryValue, ., FALSE, ;, default, :, return, getPureBooleanValue]
[., OBJECTLIT, :, return, TernaryValue, ., TRUE, ;, case, Token, ., VOID, :, return, TernaryValue, ., FALSE, ;, default, :]
[;, case, Token, ., VOID, :, return, TernaryValue, ., FALSE, ;, default, :, return, getPureBooleanValue, (, n, ), ;, }]
[., TRUE, ;, case, Token, ., VOID, :, return, TernaryValue, ., FALSE, ;, default, :, return, getPureBooleanValue, (, n, )]
[:, return, TernaryValue, ., FALSE, ;, default, :, return, getPureBooleanValue, (, n, ), ;, }, }, static, TernaryValue, getPureBooleanValue, (]
[., VOID, :, return, TernaryValue, ., FALSE, ;, default, :, return, getPureBooleanValue, (, n, ), ;, }, }, static, TernaryValue]
[;, default, :, return, getPureBooleanValue, (, n, ), ;, }, }, static, TernaryValue, getPureBooleanValue, (, Node, n, ), {, switch]
[., FALSE, ;, default, :, return, getPureBooleanValue, (, n, ), ;, }, }, static, TernaryValue, getPureBooleanValue, (, Node, n, )]
[;, }, }, static, TernaryValue, getPureBooleanValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), ;, }, }, static, TernaryValue, getPureBooleanValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), )]
[), {, case, Token, ., STRING, :, return, TernaryValue, ., forBoolean, (, n, ., getString, (, ), ., length, (]
[., getType, (, ), ), {, case, Token, ., STRING, :, return, TernaryValue, ., forBoolean, (, n, ., getString, (]
[:, return, TernaryValue, ., forBoolean, (, n, ., getString, (, ), ., length, (, ), >, 0, ), ;, case]
[., STRING, :, return, TernaryValue, ., forBoolean, (, n, ., getString, (, ), ., length, (, ), >, 0, )]
[;, case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;]
[., forBoolean, (, n, ., getString, (, ), ., length, (, ), >, 0, ), ;, case, Token, ., NUMBER]
[), ;, case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=, 0, )]
[>, 0, ), ;, case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=]
[., length, (, ), >, 0, ), ;, case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (, n, .]
[., getString, (, ), ., length, (, ), >, 0, ), ;, case, Token, ., NUMBER, :, return, TernaryValue, .]
[), ;, case, Token, ., NUMBER, :, return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=, 0, )]
[:, return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;, case, Token, ., NOT, :]
[., NUMBER, :, return, TernaryValue, ., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;, case, Token, .]
[;, case, Token, ., NOT, :, return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not, (, ), ;]
[., forBoolean, (, n, ., getDouble, (, ), !=, 0, ), ;, case, Token, ., NOT, :, return, getPureBooleanValue, (]
[), ;, case, Token, ., NOT, :, return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not, (, )]
[!=, 0, ), ;, case, Token, ., NOT, :, return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not]
[., getDouble, (, ), !=, 0, ), ;, case, Token, ., NOT, :, return, getPureBooleanValue, (, n, ., getLastChild, (]
[), ;, case, Token, ., NOT, :, return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not, (, )]
[:, return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not, (, ), ;, case, Token, ., NULL, :]
[., NOT, :, return, getPureBooleanValue, (, n, ., getLastChild, (, ), ), ., not, (, ), ;, case, Token, .]
[;, case, Token, ., NULL, :, case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;, case, Token, ., VOID]
[., not, (, ), ;, case, Token, ., NULL, :, case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;]
[), ., not, (, ), ;, case, Token, ., NULL, :, case, Token, ., FALSE, :, return, TernaryValue, ., FALSE]
[., getLastChild, (, ), ), ., not, (, ), ;, case, Token, ., NULL, :, case, Token, ., FALSE, :]
[:, case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;, case, Token, ., VOID, :, if, (, !, mayHaveSideEffects]
[., NULL, :, case, Token, ., FALSE, :, return, TernaryValue, ., FALSE, ;, case, Token, ., VOID, :, if, (]
[:, return, TernaryValue, ., FALSE, ;, case, Token, ., VOID, :, if, (, !, mayHaveSideEffects, (, n, ., getFirstChild, (]
[., FALSE, :, return, TernaryValue, ., FALSE, ;, case, Token, ., VOID, :, if, (, !, mayHaveSideEffects, (, n, .]
[;, case, Token, ., VOID, :, if, (, !, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return]
[., FALSE, ;, case, Token, ., VOID, :, if, (, !, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), )]
[:, if, (, !, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return, TernaryValue, ., FALSE, ;, }]
[., VOID, :, if, (, !, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return, TernaryValue, ., FALSE]
[), {, return, TernaryValue, ., FALSE, ;, }, break, ;, case, Token, ., NAME, :, String, name, =, n, .]
[), {, return, TernaryValue, ., FALSE, ;, }, break, ;, case, Token, ., NAME, :, String, name, =, n, .]
[), ), {, return, TernaryValue, ., FALSE, ;, }, break, ;, case, Token, ., NAME, :, String, name, =, n]
[., getFirstChild, (, ), ), ), {, return, TernaryValue, ., FALSE, ;, }, break, ;, case, Token, ., NAME, :]
[;, }, break, ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[., FALSE, ;, }, break, ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;]
[:, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||, "NaN"]
[., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, )]
[;, if, (, "undefined", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return, TernaryValue]
[., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||, "NaN", ., equals, (, name, )]
[), {, return, TernaryValue, ., FALSE, ;, }, else, if, (, "Infinity", ., equals, (, name, ), ), {, return]
[||, "NaN", ., equals, (, name, ), ), {, return, TernaryValue, ., FALSE, ;, }, else, if, (, "Infinity", .]
[., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return, TernaryValue, ., FALSE, ;, }]
[), ||, "NaN", ., equals, (, name, ), ), {, return, TernaryValue, ., FALSE, ;, }, else, if, (, "Infinity"]
[), {, return, TernaryValue, ., FALSE, ;, }, else, if, (, "Infinity", ., equals, (, name, ), ), {, return]
[., equals, (, name, ), ), {, return, TernaryValue, ., FALSE, ;, }, else, if, (, "Infinity", ., equals, (]
[), ), {, return, TernaryValue, ., FALSE, ;, }, else, if, (, "Infinity", ., equals, (, name, ), ), {]
[;, }, else, if, (, "Infinity", ., equals, (, name, ), ), {, return, TernaryValue, ., TRUE, ;, }, break]
[., FALSE, ;, }, else, if, (, "Infinity", ., equals, (, name, ), ), {, return, TernaryValue, ., TRUE, ;]
[), {, return, TernaryValue, ., TRUE, ;, }, break, ;, case, Token, ., TRUE, :, case, Token, ., REGEXP, :]
[., equals, (, name, ), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, case, Token, ., TRUE, :]
[), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, case, Token, ., TRUE, :, case, Token, ., REGEXP]
[;, }, break, ;, case, Token, ., TRUE, :, case, Token, ., REGEXP, :, return, TernaryValue, ., TRUE, ;, case]
[., TRUE, ;, }, break, ;, case, Token, ., TRUE, :, case, Token, ., REGEXP, :, return, TernaryValue, ., TRUE]
[:, case, Token, ., REGEXP, :, return, TernaryValue, ., TRUE, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT]
[., TRUE, :, case, Token, ., REGEXP, :, return, TernaryValue, ., TRUE, ;, case, Token, ., ARRAYLIT, :, case, Token]
[:, return, TernaryValue, ., TRUE, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (, !, mayHaveSideEffects]
[., REGEXP, :, return, TernaryValue, ., TRUE, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (]
[;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (, !, mayHaveSideEffects, (, n, ), ), {]
[., TRUE, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (, !, mayHaveSideEffects, (, n, )]
[:, case, Token, ., OBJECTLIT, :, if, (, !, mayHaveSideEffects, (, n, ), ), {, return, TernaryValue, ., TRUE, ;]
[., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, if, (, !, mayHaveSideEffects, (, n, ), ), {, return, TernaryValue, .]
[:, if, (, !, mayHaveSideEffects, (, n, ), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, }, return]
[., OBJECTLIT, :, if, (, !, mayHaveSideEffects, (, n, ), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;]
[), {, return, TernaryValue, ., TRUE, ;, }, break, ;, }, return, TernaryValue, ., UNKNOWN, ;, }, static, String, getStringValue]
[), {, return, TernaryValue, ., TRUE, ;, }, break, ;, }, return, TernaryValue, ., UNKNOWN, ;, }, static, String, getStringValue]
[), ), {, return, TernaryValue, ., TRUE, ;, }, break, ;, }, return, TernaryValue, ., UNKNOWN, ;, }, static, String]
[;, }, break, ;, }, return, TernaryValue, ., UNKNOWN, ;, }, static, String, getStringValue, (, Node, n, ), {, switch]
[., TRUE, ;, }, break, ;, }, return, TernaryValue, ., UNKNOWN, ;, }, static, String, getStringValue, (, Node, n, )]
[;, }, static, String, getStringValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[., UNKNOWN, ;, }, static, String, getStringValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), )]
[), {, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, return, n, ., getString, (, ), ;, case]
[., getType, (, ), ), {, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, return, n, ., getString]
[:, case, Token, ., STRING_KEY, :, return, n, ., getString, (, ), ;, case, Token, ., NAME, :, String, name]
[., STRING, :, case, Token, ., STRING_KEY, :, return, n, ., getString, (, ), ;, case, Token, ., NAME, :]
[:, return, n, ., getString, (, ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (]
[., STRING_KEY, :, return, n, ., getString, (, ), ;, case, Token, ., NAME, :, String, name, =, n, .]
[;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals]
[., getString, (, ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if]
[:, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||, "Infinity"]
[., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, "undefined", ., equals, (, name, )]
[;, if, (, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals]
[., getString, (, ), ;, if, (, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, )]
[), {, return, name, ;, }, break, ;, case, Token, ., NUMBER, :, return, getStringValue, (, n, ., getDouble, (]
[||, "NaN", ., equals, (, name, ), ), {, return, name, ;, }, break, ;, case, Token, ., NUMBER, :]
[||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return, name, ;, }]
[., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), )]
[), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return, name, ;]
[||, "NaN", ., equals, (, name, ), ), {, return, name, ;, }, break, ;, case, Token, ., NUMBER, :]
[., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ), {, return, name, ;, }, break, ;]
[), ||, "NaN", ., equals, (, name, ), ), {, return, name, ;, }, break, ;, case, Token, ., NUMBER]
[), {, return, name, ;, }, break, ;, case, Token, ., NUMBER, :, return, getStringValue, (, n, ., getDouble, (]
[., equals, (, name, ), ), {, return, name, ;, }, break, ;, case, Token, ., NUMBER, :, return, getStringValue]
[), ), {, return, name, ;, }, break, ;, case, Token, ., NUMBER, :, return, getStringValue, (, n, ., getDouble]
[;, }, break, ;, case, Token, ., NUMBER, :, return, getStringValue, (, n, ., getDouble, (, ), ), ;, case]
[:, return, getStringValue, (, n, ., getDouble, (, ), ), ;, case, Token, ., FALSE, :, return, "false", ;, case]
[., NUMBER, :, return, getStringValue, (, n, ., getDouble, (, ), ), ;, case, Token, ., FALSE, :, return, "false"]
[;, case, Token, ., FALSE, :, return, "false", ;, case, Token, ., TRUE, :, return, "true", ;, case, Token, .]
[), ;, case, Token, ., FALSE, :, return, "false", ;, case, Token, ., TRUE, :, return, "true", ;, case, Token]
[., getDouble, (, ), ), ;, case, Token, ., FALSE, :, return, "false", ;, case, Token, ., TRUE, :, return]
[:, return, "false", ;, case, Token, ., TRUE, :, return, "true", ;, case, Token, ., NULL, :, return, "null", ;]
[., FALSE, :, return, "false", ;, case, Token, ., TRUE, :, return, "true", ;, case, Token, ., NULL, :, return]
[;, case, Token, ., TRUE, :, return, "true", ;, case, Token, ., NULL, :, return, "null", ;, case, Token, .]
[:, return, "true", ;, case, Token, ., NULL, :, return, "null", ;, case, Token, ., VOID, :, return, "undefined", ;]
[., TRUE, :, return, "true", ;, case, Token, ., NULL, :, return, "null", ;, case, Token, ., VOID, :, return]
[;, case, Token, ., NULL, :, return, "null", ;, case, Token, ., VOID, :, return, "undefined", ;, case, Token, .]
[:, return, "null", ;, case, Token, ., VOID, :, return, "undefined", ;, case, Token, ., NOT, :, TernaryValue, child, =]
[., NULL, :, return, "null", ;, case, Token, ., VOID, :, return, "undefined", ;, case, Token, ., NOT, :, TernaryValue]
[;, case, Token, ., VOID, :, return, "undefined", ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n]
[:, return, "undefined", ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), )]
[., VOID, :, return, "undefined", ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (]
[;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (]
[:, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN]
[., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue]
[;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, "false", :]
[), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, "false"]
[., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (]
[), {, return, child, ., toBoolean, (, true, ), ?, "false", :, "true", ;, }, break, ;, case, Token, .]
[!=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, "false", :, "true", ;, }, break]
[), {, return, child, ., toBoolean, (, true, ), ?, "false", :, "true", ;, }, break, ;, case, Token, .]
[., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, "false", :, "true", ;, }, break, ;, case]
[;, }, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString, (, n, ), ;, case, Token, ., OBJECTLIT, :]
[?, "false", :, "true", ;, }, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString, (, n, ), ;, case]
[., toBoolean, (, true, ), ?, "false", :, "true", ;, }, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString]
[), ?, "false", :, "true", ;, }, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString, (, n, ), ;]
[:, "true", ;, }, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString, (, n, ), ;, case, Token, .]
[;, }, break, ;, case, Token, ., ARRAYLIT, :, return, arrayToString, (, n, ), ;, case, Token, ., OBJECTLIT, :]
[:, return, arrayToString, (, n, ), ;, case, Token, ., OBJECTLIT, :, return, "[object Object]", ;, }, return, null, ;, }]
[., ARRAYLIT, :, return, arrayToString, (, n, ), ;, case, Token, ., OBJECTLIT, :, return, "[object Object]", ;, }, return, null]
[;, case, Token, ., OBJECTLIT, :, return, "[object Object]", ;, }, return, null, ;, }, static, String, getStringValue, (, double, value]
[), ;, case, Token, ., OBJECTLIT, :, return, "[object Object]", ;, }, return, null, ;, }, static, String, getStringValue, (, double]
[:, return, "[object Object]", ;, }, return, null, ;, }, static, String, getStringValue, (, double, value, ), {, long, longValue, =]
[., OBJECTLIT, :, return, "[object Object]", ;, }, return, null, ;, }, static, String, getStringValue, (, double, value, ), {, long]
[;, }, return, null, ;, }, static, String, getStringValue, (, double, value, ), {, long, longValue, =, (, long, )]
[;, }, static, String, getStringValue, (, double, value, ), {, long, longValue, =, (, long, ), value, ;, if, (]
[;, if, (, longValue, ==, value, ), {, return, Long, ., toString, (, longValue, ), ;, }, else, {, return]
[;, if, (, longValue, ==, value, ), {, return, Long, ., toString, (, longValue, ), ;, }, else, {, return]
[), {, return, Long, ., toString, (, longValue, ), ;, }, else, {, return, Double, ., toString, (, value, )]
[==, value, ), {, return, Long, ., toString, (, longValue, ), ;, }, else, {, return, Double, ., toString, (]
[), {, return, Long, ., toString, (, longValue, ), ;, }, else, {, return, Double, ., toString, (, value, )]
[;, }, else, {, return, Double, ., toString, (, value, ), ;, }, }, static, String, getArrayElementStringValue, (, Node, n]
[., toString, (, longValue, ), ;, }, else, {, return, Double, ., toString, (, value, ), ;, }, }, static]
[), ;, }, else, {, return, Double, ., toString, (, value, ), ;, }, }, static, String, getArrayElementStringValue, (, Node]
[;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return, (, NodeUtil, ., isNullOrUndefined, (, n, ), ||]
[., toString, (, value, ), ;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return, (, NodeUtil, .]
[), ;, }, }, static, String, getArrayElementStringValue, (, Node, n, ), {, return, (, NodeUtil, ., isNullOrUndefined, (, n, )]
[;, }, static, String, arrayToString, (, Node, literal, ), {, Node, first, =, literal, ., getFirstChild, (, ), ;, StringBuilder]
[?, "", :, getStringValue, (, n, ), ;, }, static, String, arrayToString, (, Node, literal, ), {, Node, first, =]
[), ?, "", :, getStringValue, (, n, ), ;, }, static, String, arrayToString, (, Node, literal, ), {, Node, first]
[||, n, ., isEmpty, (, ), ), ?, "", :, getStringValue, (, n, ), ;, }, static, String, arrayToString, (]
[., isNullOrUndefined, (, n, ), ||, n, ., isEmpty, (, ), ), ?, "", :, getStringValue, (, n, ), ;]
[), ||, n, ., isEmpty, (, ), ), ?, "", :, getStringValue, (, n, ), ;, }, static, String, arrayToString]
[), ?, "", :, getStringValue, (, n, ), ;, }, static, String, arrayToString, (, Node, literal, ), {, Node, first]
[., isEmpty, (, ), ), ?, "", :, getStringValue, (, n, ), ;, }, static, String, arrayToString, (, Node, literal]
[:, getStringValue, (, n, ), ;, }, static, String, arrayToString, (, Node, literal, ), {, Node, first, =, literal, .]
[;, }, static, String, arrayToString, (, Node, literal, ), {, Node, first, =, literal, ., getFirstChild, (, ), ;, StringBuilder]
[), ;, }, static, String, arrayToString, (, Node, literal, ), {, Node, first, =, literal, ., getFirstChild, (, ), ;]
[;, StringBuilder, result, =, new, StringBuilder, (, ), ;, int, nextSlot, =, 0, ;, int, nextSkipSlot, =, 0, ;, for]
[., getFirstChild, (, ), ;, StringBuilder, result, =, new, StringBuilder, (, ), ;, int, nextSlot, =, 0, ;, int, nextSkipSlot]
[;, int, nextSlot, =, 0, ;, int, nextSkipSlot, =, 0, ;, for, (, Node, n, =, first, ;, n, !=]
[;, int, nextSkipSlot, =, 0, ;, for, (, Node, n, =, first, ;, n, !=, null, ;, n, =, n]
[;, for, (, Node, n, =, first, ;, n, !=, null, ;, n, =, n, ., getNext, (, ), )]
[;, n, !=, null, ;, n, =, n, ., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (, n]
[;, n, =, n, ., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;, if, (]
[!=, null, ;, n, =, n, ., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;]
[;, n, =, n, ., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;, if, (]
[=, n, ., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;, if, (, childValue, ==]
[), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;, if, (, childValue, ==, null, ), {, return, null, ;]
[., getNext, (, ), ), {, String, childValue, =, getArrayElementStringValue, (, n, ), ;, if, (, childValue, ==, null, )]
[;, if, (, childValue, ==, null, ), {, return, null, ;, }, if, (, n, !=, first, ), {, result]
[), ;, if, (, childValue, ==, null, ), {, return, null, ;, }, if, (, n, !=, first, ), {]
[), {, return, null, ;, }, if, (, n, !=, first, ), {, result, ., append, (, ',', ), ;]
[==, null, ), {, return, null, ;, }, if, (, n, !=, first, ), {, result, ., append, (, ',']
[), {, return, null, ;, }, if, (, n, !=, first, ), {, result, ., append, (, ',', ), ;]
[;, }, if, (, n, !=, first, ), {, result, ., append, (, ',', ), ;, }, result, ., append]
[), {, result, ., append, (, ',', ), ;, }, result, ., append, (, childValue, ), ;, nextSlot, ++, ;]
[!=, first, ), {, result, ., append, (, ',', ), ;, }, result, ., append, (, childValue, ), ;, nextSlot]
[), {, result, ., append, (, ',', ), ;, }, result, ., append, (, childValue, ), ;, nextSlot, ++, ;]
[;, }, result, ., append, (, childValue, ), ;, nextSlot, ++, ;, }, return, result, ., toString, (, ), ;]
[., append, (, ',', ), ;, }, result, ., append, (, childValue, ), ;, nextSlot, ++, ;, }, return, result]
[), ;, }, result, ., append, (, childValue, ), ;, nextSlot, ++, ;, }, return, result, ., toString, (, )]
[;, nextSlot, ++, ;, }, return, result, ., toString, (, ), ;, }, static, Double, getNumberValue, (, Node, n, )]
[., append, (, childValue, ), ;, nextSlot, ++, ;, }, return, result, ., toString, (, ), ;, }, static, Double]
[), ;, nextSlot, ++, ;, }, return, result, ., toString, (, ), ;, }, static, Double, getNumberValue, (, Node, n]
[;, }, return, result, ., toString, (, ), ;, }, static, Double, getNumberValue, (, Node, n, ), {, switch, (]
[++, ;, }, return, result, ., toString, (, ), ;, }, static, Double, getNumberValue, (, Node, n, ), {, switch]
[;, }, static, Double, getNumberValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[., toString, (, ), ;, }, static, Double, getNumberValue, (, Node, n, ), {, switch, (, n, ., getType, (]
[), {, case, Token, ., TRUE, :, return, 1.0, ;, case, Token, ., FALSE, :, case, Token, ., NULL, :]
[., getType, (, ), ), {, case, Token, ., TRUE, :, return, 1.0, ;, case, Token, ., FALSE, :, case]
[:, return, 1.0, ;, case, Token, ., FALSE, :, case, Token, ., NULL, :, return, 0.0, ;, case, Token, .]
[., TRUE, :, return, 1.0, ;, case, Token, ., FALSE, :, case, Token, ., NULL, :, return, 0.0, ;, case]
[;, case, Token, ., FALSE, :, case, Token, ., NULL, :, return, 0.0, ;, case, Token, ., NUMBER, :, return]
[:, case, Token, ., NULL, :, return, 0.0, ;, case, Token, ., NUMBER, :, return, n, ., getDouble, (, )]
[., FALSE, :, case, Token, ., NULL, :, return, 0.0, ;, case, Token, ., NUMBER, :, return, n, ., getDouble]
[:, return, 0.0, ;, case, Token, ., NUMBER, :, return, n, ., getDouble, (, ), ;, case, Token, ., VOID]
[., NULL, :, return, 0.0, ;, case, Token, ., NUMBER, :, return, n, ., getDouble, (, ), ;, case, Token]
[;, case, Token, ., NUMBER, :, return, n, ., getDouble, (, ), ;, case, Token, ., VOID, :, if, (]
[:, return, n, ., getDouble, (, ), ;, case, Token, ., VOID, :, if, (, mayHaveSideEffects, (, n, ., getFirstChild]
[., NUMBER, :, return, n, ., getDouble, (, ), ;, case, Token, ., VOID, :, if, (, mayHaveSideEffects, (, n]
[;, case, Token, ., VOID, :, if, (, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return, null]
[., getDouble, (, ), ;, case, Token, ., VOID, :, if, (, mayHaveSideEffects, (, n, ., getFirstChild, (, ), )]
[:, if, (, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return, null, ;, }, else, {, return]
[., VOID, :, if, (, mayHaveSideEffects, (, n, ., getFirstChild, (, ), ), ), {, return, null, ;, }, else]
[), {, return, null, ;, }, else, {, return, Double, ., NaN, ;, }, case, Token, ., NAME, :, String]
[), ), {, return, null, ;, }, else, {, return, Double, ., NaN, ;, }, case, Token, ., NAME, :]
[., getFirstChild, (, ), ), ), {, return, null, ;, }, else, {, return, Double, ., NaN, ;, }, case]
[;, }, else, {, return, Double, ., NaN, ;, }, case, Token, ., NAME, :, String, name, =, n, .]
[;, }, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, name, .]
[., NaN, ;, }, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[:, String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals, (, "undefined", ), ), {]
[., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals, (, "undefined", )]
[;, if, (, name, ., equals, (, "undefined", ), ), {, return, Double, ., NaN, ;, }, if, (, name]
[., getString, (, ), ;, if, (, name, ., equals, (, "undefined", ), ), {, return, Double, ., NaN, ;]
[), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "NaN", ), ), {, return, Double]
[., equals, (, "undefined", ), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "NaN"]
[), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "NaN", ), ), {, return]
[;, }, if, (, name, ., equals, (, "NaN", ), ), {, return, Double, ., NaN, ;, }, if, (]
[., NaN, ;, }, if, (, name, ., equals, (, "NaN", ), ), {, return, Double, ., NaN, ;, }]
[), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return, Double]
[., equals, (, "NaN", ), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "Infinity"]
[), ), {, return, Double, ., NaN, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return]
[;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null]
[., NaN, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }]
[), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG, :, if, (, n, .]
[., equals, (, "Infinity", ), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG]
[), ), {, return, Double, ., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG, :, if, (, n]
[;, }, return, null, ;, case, Token, ., NEG, :, if, (, n, ., getChildCount, (, ), ==, 1, &&]
[., POSITIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NEG, :, if, (, n, ., getChildCount, (, ), ==]
[;, case, Token, ., NEG, :, if, (, n, ., getChildCount, (, ), ==, 1, &&, n, ., getFirstChild, (]
[:, if, (, n, ., getChildCount, (, ), ==, 1, &&, n, ., getFirstChild, (, ), ., isName, (, )]
[., NEG, :, if, (, n, ., getChildCount, (, ), ==, 1, &&, n, ., getFirstChild, (, ), ., isName]
[), {, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue]
[&&, n, ., getFirstChild, (, ), ., getString, (, ), ., equals, (, "Infinity", ), ), {, return, Double, .]
[&&, n, ., getFirstChild, (, ), ., isName, (, ), &&, n, ., getFirstChild, (, ), ., getString, (, )]
[==, 1, &&, n, ., getFirstChild, (, ), ., isName, (, ), &&, n, ., getFirstChild, (, ), ., getString]
[., getChildCount, (, ), ==, 1, &&, n, ., getFirstChild, (, ), ., isName, (, ), &&, n, ., getFirstChild]
[&&, n, ., getFirstChild, (, ), ., isName, (, ), &&, n, ., getFirstChild, (, ), ., getString, (, )]
[&&, n, ., getFirstChild, (, ), ., getString, (, ), ., equals, (, "Infinity", ), ), {, return, Double, .]
[., isName, (, ), &&, n, ., getFirstChild, (, ), ., getString, (, ), ., equals, (, "Infinity", ), )]
[., getFirstChild, (, ), ., isName, (, ), &&, n, ., getFirstChild, (, ), ., getString, (, ), ., equals]
[), {, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue]
[., equals, (, "Infinity", ), ), {, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NOT]
[., getString, (, ), ., equals, (, "Infinity", ), ), {, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;]
[., getFirstChild, (, ), ., getString, (, ), ., equals, (, "Infinity", ), ), {, return, Double, ., NEGATIVE_INFINITY, ;]
[), ), {, return, Double, ., NEGATIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NOT, :, TernaryValue, child, =]
[;, }, return, null, ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, )]
[., NEGATIVE_INFINITY, ;, }, return, null, ;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild]
[;, case, Token, ., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (]
[:, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN]
[., NOT, :, TernaryValue, child, =, getPureBooleanValue, (, n, ., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue]
[;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, 0.0, :]
[), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, 0.0]
[., getFirstChild, (, ), ), ;, if, (, child, !=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (]
[), {, return, child, ., toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break, ;, case, Token, .]
[!=, TernaryValue, ., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break]
[), {, return, child, ., toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break, ;, case, Token, .]
[., UNKNOWN, ), {, return, child, ., toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break, ;, case]
[;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue, (, n, ., getString, (, ), ), ;, case]
[?, 0.0, :, 1.0, ;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue, (, n, ., getString, (]
[., toBoolean, (, true, ), ?, 0.0, :, 1.0, ;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue]
[), ?, 0.0, :, 1.0, ;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue, (, n, ., getString]
[:, 1.0, ;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue, (, n, ., getString, (, ), )]
[;, }, break, ;, case, Token, ., STRING, :, return, getStringNumberValue, (, n, ., getString, (, ), ), ;, case]
[:, return, getStringNumberValue, (, n, ., getString, (, ), ), ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT]
[., STRING, :, return, getStringNumberValue, (, n, ., getString, (, ), ), ;, case, Token, ., ARRAYLIT, :, case, Token]
[;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return]
[), ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;]
[., getString, (, ), ), ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue]
[:, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return, value, !=, null, ?, getStringNumberValue]
[., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return, value, !=, null]
[:, String, value, =, getStringValue, (, n, ), ;, return, value, !=, null, ?, getStringNumberValue, (, value, ), :, null]
[., OBJECTLIT, :, String, value, =, getStringValue, (, n, ), ;, return, value, !=, null, ?, getStringNumberValue, (, value, )]
[;, return, value, !=, null, ?, getStringNumberValue, (, value, ), :, null, ;, }, return, null, ;, }, static, Double]
[), ;, return, value, !=, null, ?, getStringNumberValue, (, value, ), :, null, ;, }, return, null, ;, }, static]
[;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String, rawJsString, ), {, if, (, rawJsString, ., contains, (]
[?, getStringNumberValue, (, value, ), :, null, ;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String, rawJsString, )]
[!=, null, ?, getStringNumberValue, (, value, ), :, null, ;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String]
[?, getStringNumberValue, (, value, ), :, null, ;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String, rawJsString, )]
[:, null, ;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String, rawJsString, ), {, if, (, rawJsString, .]
[), :, null, ;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String, rawJsString, ), {, if, (, rawJsString]
[;, }, return, null, ;, }, static, Double, getStringNumberValue, (, String, rawJsString, ), {, if, (, rawJsString, ., contains, (]
[;, }, static, Double, getStringNumberValue, (, String, rawJsString, ), {, if, (, rawJsString, ., contains, (, "\u000b", ), ), {]
[), {, return, null, ;, }, String, s, =, trimJsWhiteSpace, (, rawJsString, ), ;, if, (, s, ., length, (]
[., contains, (, "\u000b", ), ), {, return, null, ;, }, String, s, =, trimJsWhiteSpace, (, rawJsString, ), ;, if]
[), ), {, return, null, ;, }, String, s, =, trimJsWhiteSpace, (, rawJsString, ), ;, if, (, s, ., length]
[;, }, String, s, =, trimJsWhiteSpace, (, rawJsString, ), ;, if, (, s, ., length, (, ), ==, 0, )]
[;, if, (, s, ., length, (, ), ==, 0, ), {, return, 0.0, ;, }, if, (, s, .]
[), ;, if, (, s, ., length, (, ), ==, 0, ), {, return, 0.0, ;, }, if, (, s]
[), {, return, 0.0, ;, }, if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (]
[==, 0, ), {, return, 0.0, ;, }, if, (, s, ., length, (, ), >, 2, &&, s, .]
[., length, (, ), ==, 0, ), {, return, 0.0, ;, }, if, (, s, ., length, (, ), >]
[), {, return, 0.0, ;, }, if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (]
[;, }, if, (, s, ., length, (, ), >, 2, &&, s, ., charAt, (, 0, ), ==, '0']
[), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (, s, ., substring, (, 2, ), ,]
[&&, (, s, ., charAt, (, 1, ), ==, 'x', ||, s, ., charAt, (, 1, ), ==, 'X', )]
[&&, s, ., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||]
[>, 2, &&, s, ., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt, (, 1, ), ==]
[., length, (, ), >, 2, &&, s, ., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt]
[&&, s, ., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||]
[&&, (, s, ., charAt, (, 1, ), ==, 'x', ||, s, ., charAt, (, 1, ), ==, 'X', )]
[==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||, s, ., charAt, (, 1, ), ==]
[., charAt, (, 0, ), ==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||, s, .]
[), ==, '0', &&, (, s, ., charAt, (, 1, ), ==, 'x', ||, s, ., charAt, (, 1, )]
[&&, (, s, ., charAt, (, 1, ), ==, 'x', ||, s, ., charAt, (, 1, ), ==, 'X', )]
[), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (, s, ., substring, (, 2, ), ,]
[), ), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (, s, ., substring, (, 2, )]
[||, s, ., charAt, (, 1, ), ==, 'X', ), ), {, try, {, return, Double, ., valueOf, (, Integer]
[==, 'x', ||, s, ., charAt, (, 1, ), ==, 'X', ), ), {, try, {, return, Double, ., valueOf]
[., charAt, (, 1, ), ==, 'x', ||, s, ., charAt, (, 1, ), ==, 'X', ), ), {, try]
[), ==, 'x', ||, s, ., charAt, (, 1, ), ==, 'X', ), ), {, try, {, return, Double, .]
[||, s, ., charAt, (, 1, ), ==, 'X', ), ), {, try, {, return, Double, ., valueOf, (, Integer]
[), ), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (, s, ., substring, (, 2, )]
[==, 'X', ), ), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (, s, ., substring, (]
[., charAt, (, 1, ), ==, 'X', ), ), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt]
[), ==, 'X', ), ), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (, s, ., substring]
[), ), {, try, {, return, Double, ., valueOf, (, Integer, ., parseInt, (, s, ., substring, (, 2, )]
[;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (, s, ., length]
[., valueOf, (, Integer, ., parseInt, (, s, ., substring, (, 2, ), ,, 16, ), ), ;, }, catch]
[), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (, s, .]
[., parseInt, (, s, ., substring, (, 2, ), ,, 16, ), ), ;, }, catch, (, NumberFormatException, e, )]
[,, 16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if]
[., substring, (, 2, ), ,, 16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, .]
[), ,, 16, ), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }]
[), ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, if, (, s]
[;, }, }, if, (, s, ., length, (, ), >, 3, &&, (, s, ., charAt, (, 0, )]
[., NaN, ;, }, }, if, (, s, ., length, (, ), >, 3, &&, (, s, ., charAt, (]
[), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (, "-infinity"]
[&&, (, s, ., charAt, (, 2, ), ==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', )]
[&&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||]
[&&, (, s, ., charAt, (, 0, ), ==, '-', ||, s, ., charAt, (, 0, ), ==, '+', )]
[>, 3, &&, (, s, ., charAt, (, 0, ), ==, '-', ||, s, ., charAt, (, 0, ), ==]
[., length, (, ), >, 3, &&, (, s, ., charAt, (, 0, ), ==, '-', ||, s, ., charAt]
[&&, (, s, ., charAt, (, 0, ), ==, '-', ||, s, ., charAt, (, 0, ), ==, '+', )]
[&&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||]
[), &&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x']
[||, s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&]
[==, '-', ||, s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==]
[., charAt, (, 0, ), ==, '-', ||, s, ., charAt, (, 0, ), ==, '+', ), &&, s, .]
[), ==, '-', ||, s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, )]
[||, s, ., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&]
[), &&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x']
[==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, )]
[., charAt, (, 0, ), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&, (, s]
[), ==, '+', ), &&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2]
[), &&, s, ., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x']
[&&, (, s, ., charAt, (, 2, ), ==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', )]
[==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||, s, ., charAt, (, 2, ), ==]
[., charAt, (, 1, ), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||, s, .]
[), ==, '0', &&, (, s, ., charAt, (, 2, ), ==, 'x', ||, s, ., charAt, (, 2, )]
[&&, (, s, ., charAt, (, 2, ), ==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', )]
[), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (, "-infinity"]
[), ), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (]
[||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if, (, s, .]
[==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if, (]
[., charAt, (, 2, ), ==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return]
[), ==, 'x', ||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if]
[||, s, ., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if, (, s, .]
[), ), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (]
[==, 'X', ), ), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s, .]
[., charAt, (, 2, ), ==, 'X', ), ), {, return, null, ;, }, if, (, s, ., equals, (]
[), ==, 'X', ), ), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s]
[), ), {, return, null, ;, }, if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (]
[;, }, if, (, s, ., equals, (, "infinity", ), ||, s, ., equals, (, "-infinity", ), ||, s, .]
[), {, return, null, ;, }, try, {, return, Double, ., parseDouble, (, s, ), ;, }, catch, (, NumberFormatException]
[||, s, ., equals, (, "+infinity", ), ), {, return, null, ;, }, try, {, return, Double, ., parseDouble, (]
[||, s, ., equals, (, "-infinity", ), ||, s, ., equals, (, "+infinity", ), ), {, return, null, ;, }]
[., equals, (, "infinity", ), ||, s, ., equals, (, "-infinity", ), ||, s, ., equals, (, "+infinity", ), )]
[), ||, s, ., equals, (, "-infinity", ), ||, s, ., equals, (, "+infinity", ), ), {, return, null, ;]
[||, s, ., equals, (, "+infinity", ), ), {, return, null, ;, }, try, {, return, Double, ., parseDouble, (]
[., equals, (, "-infinity", ), ||, s, ., equals, (, "+infinity", ), ), {, return, null, ;, }, try, {]
[), ||, s, ., equals, (, "+infinity", ), ), {, return, null, ;, }, try, {, return, Double, ., parseDouble]
[), {, return, null, ;, }, try, {, return, Double, ., parseDouble, (, s, ), ;, }, catch, (, NumberFormatException]
[., equals, (, "+infinity", ), ), {, return, null, ;, }, try, {, return, Double, ., parseDouble, (, s, )]
[), ), {, return, null, ;, }, try, {, return, Double, ., parseDouble, (, s, ), ;, }, catch, (]
[;, }, try, {, return, Double, ., parseDouble, (, s, ), ;, }, catch, (, NumberFormatException, e, ), {, return]
[;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, static, String, trimJsWhiteSpace, (, String]
[., parseDouble, (, s, ), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }]
[), ;, }, catch, (, NumberFormatException, e, ), {, return, Double, ., NaN, ;, }, }, static, String, trimJsWhiteSpace, (]
[;, }, }, static, String, trimJsWhiteSpace, (, String, s, ), {, int, start, =, 0, ;, int, end, =, s]
[., NaN, ;, }, }, static, String, trimJsWhiteSpace, (, String, s, ), {, int, start, =, 0, ;, int, end]
[;, int, end, =, s, ., length, (, ), ;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (, s, .]
[;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -, 1, ), ), ==, TernaryValue]
[., length, (, ), ;, while, (, end, >, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -, 1]
[), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, )]
[&&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --]
[>, 0, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {]
[&&, isStrWhiteSpaceChar, (, s, ., charAt, (, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --]
[), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, )]
[==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, .]
[), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s]
[., charAt, (, end, -, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (]
[), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (]
[-, 1, ), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&]
[), ), ==, TernaryValue, ., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (]
[), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, )]
[., TRUE, ), {, end, --, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (]
[;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==, TernaryValue, .]
[--, ;, }, while, (, start, <, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==, TernaryValue]
[), {, start, ++, ;, }, return, s, ., substring, (, start, ,, end, ), ;, }, public, static, TernaryValue]
[&&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==, TernaryValue, ., TRUE, ), {, start, ++, ;, }]
[<, end, &&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==, TernaryValue, ., TRUE, ), {, start, ++]
[&&, isStrWhiteSpaceChar, (, s, ., charAt, (, start, ), ), ==, TernaryValue, ., TRUE, ), {, start, ++, ;, }]
[), {, start, ++, ;, }, return, s, ., substring, (, start, ,, end, ), ;, }, public, static, TernaryValue]
[==, TernaryValue, ., TRUE, ), {, start, ++, ;, }, return, s, ., substring, (, start, ,, end, ), ;]
[), ==, TernaryValue, ., TRUE, ), {, start, ++, ;, }, return, s, ., substring, (, start, ,, end, )]
[., charAt, (, start, ), ), ==, TernaryValue, ., TRUE, ), {, start, ++, ;, }, return, s, ., substring]
[), ), ==, TernaryValue, ., TRUE, ), {, start, ++, ;, }, return, s, ., substring, (, start, ,, end]
[), {, start, ++, ;, }, return, s, ., substring, (, start, ,, end, ), ;, }, public, static, TernaryValue]
[., TRUE, ), {, start, ++, ;, }, return, s, ., substring, (, start, ,, end, ), ;, }, public]
[;, }, return, s, ., substring, (, start, ,, end, ), ;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int, c]
[++, ;, }, return, s, ., substring, (, start, ,, end, ), ;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int]
[;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int, c, ), {, switch, (, c, ), {, case, '\u000B', :, return]
[., substring, (, start, ,, end, ), ;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int, c, ), {, switch, (]
[,, end, ), ;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int, c, ), {, switch, (, c, ), {, case]
[), ;, }, public, static, TernaryValue, isStrWhiteSpaceChar, (, int, c, ), {, switch, (, c, ), {, case, '\u000B', :]
[), {, case, '\u000B', :, return, TernaryValue, ., UNKNOWN, ;, case, ' ', :, case, '\n', :, case, '\r', :, case]
[:, return, TernaryValue, ., UNKNOWN, ;, case, ' ', :, case, '\n', :, case, '\r', :, case, '\t', :, case, '\u00A0']
[;, case, ' ', :, case, '\n', :, case, '\r', :, case, '\t', :, case, '\u00A0', :, case, '\u000C', :, case]
[., UNKNOWN, ;, case, ' ', :, case, '\n', :, case, '\r', :, case, '\t', :, case, '\u00A0', :, case, '\u000C']
[:, case, '\n', :, case, '\r', :, case, '\t', :, case, '\u00A0', :, case, '\u000C', :, case, '\u2028', :, case]
[:, case, '\r', :, case, '\t', :, case, '\u00A0', :, case, '\u000C', :, case, '\u2028', :, case, '\u2029', :, case]
[:, case, '\t', :, case, '\u00A0', :, case, '\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return]
[:, case, '\u00A0', :, case, '\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE]
[:, case, '\u000C', :, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :]
[:, case, '\u2028', :, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return, (, Character]
[:, case, '\u2029', :, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return, (, Character, ., getType, (]
[:, case, '\uFEFF', :, return, TernaryValue, ., TRUE, ;, default, :, return, (, Character, ., getType, (, c, ), ==]
[:, return, TernaryValue, ., TRUE, ;, default, :, return, (, Character, ., getType, (, c, ), ==, Character, ., SPACE_SEPARATOR]
[;, default, :, return, (, Character, ., getType, (, c, ), ==, Character, ., SPACE_SEPARATOR, ), ?, TernaryValue, ., TRUE]
[., TRUE, ;, default, :, return, (, Character, ., getType, (, c, ), ==, Character, ., SPACE_SEPARATOR, ), ?, TernaryValue]
[;, }, }, static, String, getFunctionName, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isFunction, (, )]
[?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {, Preconditions]
[), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {]
[==, Character, ., SPACE_SEPARATOR, ), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (]
[., getType, (, c, ), ==, Character, ., SPACE_SEPARATOR, ), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }]
[), ==, Character, ., SPACE_SEPARATOR, ), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName]
[), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {]
[., SPACE_SEPARATOR, ), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n]
[:, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {, Preconditions, ., checkState, (, n]
[., TRUE, :, TernaryValue, ., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {, Preconditions, ., checkState]
[;, }, }, static, String, getFunctionName, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isFunction, (, )]
[., FALSE, ;, }, }, static, String, getFunctionName, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isFunction]
[;, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[., checkState, (, n, ., isFunction, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, switch]
[), ;, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {]
[., isFunction, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType]
[;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., NAME, :, return, parent, ., getQualifiedName, (]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., NAME, :, return]
[), {, case, Token, ., NAME, :, return, parent, ., getQualifiedName, (, ), ;, case, Token, ., ASSIGN, :, return]
[., getType, (, ), ), {, case, Token, ., NAME, :, return, parent, ., getQualifiedName, (, ), ;, case, Token]
[:, return, parent, ., getQualifiedName, (, ), ;, case, Token, ., ASSIGN, :, return, parent, ., getFirstChild, (, ), .]
[., NAME, :, return, parent, ., getQualifiedName, (, ), ;, case, Token, ., ASSIGN, :, return, parent, ., getFirstChild, (]
[;, case, Token, ., ASSIGN, :, return, parent, ., getFirstChild, (, ), ., getQualifiedName, (, ), ;, default, :, String]
[., getQualifiedName, (, ), ;, case, Token, ., ASSIGN, :, return, parent, ., getFirstChild, (, ), ., getQualifiedName, (, )]
[:, return, parent, ., getFirstChild, (, ), ., getQualifiedName, (, ), ;, default, :, String, name, =, n, ., getFirstChild]
[., ASSIGN, :, return, parent, ., getFirstChild, (, ), ., getQualifiedName, (, ), ;, default, :, String, name, =, n]
[;, default, :, String, name, =, n, ., getFirstChild, (, ), ., getQualifiedName, (, ), ;, return, name, ;, }]
[., getQualifiedName, (, ), ;, default, :, String, name, =, n, ., getFirstChild, (, ), ., getQualifiedName, (, ), ;]
[., getFirstChild, (, ), ., getQualifiedName, (, ), ;, default, :, String, name, =, n, ., getFirstChild, (, ), .]
[;, return, name, ;, }, }, public, static, String, getNearestFunctionName, (, Node, n, ), {, if, (, !, n, .]
[., getQualifiedName, (, ), ;, return, name, ;, }, }, public, static, String, getNearestFunctionName, (, Node, n, ), {, if]
[., getFirstChild, (, ), ., getQualifiedName, (, ), ;, return, name, ;, }, }, public, static, String, getNearestFunctionName, (, Node]
[;, }, }, public, static, String, getNearestFunctionName, (, Node, n, ), {, if, (, !, n, ., isFunction, (, )]
[), {, return, null, ;, }, String, name, =, getFunctionName, (, n, ), ;, if, (, name, !=, null, )]
[), {, return, null, ;, }, String, name, =, getFunctionName, (, n, ), ;, if, (, name, !=, null, )]
[., isFunction, (, ), ), {, return, null, ;, }, String, name, =, getFunctionName, (, n, ), ;, if, (]
[;, }, String, name, =, getFunctionName, (, n, ), ;, if, (, name, !=, null, ), {, return, name, ;]
[;, if, (, name, !=, null, ), {, return, name, ;, }, Node, parent, =, n, ., getParent, (, )]
[), ;, if, (, name, !=, null, ), {, return, name, ;, }, Node, parent, =, n, ., getParent, (]
[), {, return, name, ;, }, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType]
[!=, null, ), {, return, name, ;, }, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent]
[), {, return, name, ;, }, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType]
[;, }, Node, parent, =, n, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {]
[;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, case, Token, ., GETTER_DEF, :]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, case]
[), {, case, Token, ., SETTER_DEF, :, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, return, parent, .]
[., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY]
[:, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, return, parent, ., getString, (, ), ;, case, Token]
[., SETTER_DEF, :, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, return, parent, ., getString, (, ), ;]
[:, case, Token, ., STRING_KEY, :, return, parent, ., getString, (, ), ;, case, Token, ., NUMBER, :, return, getStringValue]
[., GETTER_DEF, :, case, Token, ., STRING_KEY, :, return, parent, ., getString, (, ), ;, case, Token, ., NUMBER, :]
[:, return, parent, ., getString, (, ), ;, case, Token, ., NUMBER, :, return, getStringValue, (, parent, ), ;, }]
[., STRING_KEY, :, return, parent, ., getString, (, ), ;, case, Token, ., NUMBER, :, return, getStringValue, (, parent, )]
[;, case, Token, ., NUMBER, :, return, getStringValue, (, parent, ), ;, }, return, null, ;, }, static, boolean, isImmutableValue]
[., getString, (, ), ;, case, Token, ., NUMBER, :, return, getStringValue, (, parent, ), ;, }, return, null, ;]
[:, return, getStringValue, (, parent, ), ;, }, return, null, ;, }, static, boolean, isImmutableValue, (, Node, n, ), {]
[., NUMBER, :, return, getStringValue, (, parent, ), ;, }, return, null, ;, }, static, boolean, isImmutableValue, (, Node, n]
[;, }, return, null, ;, }, static, boolean, isImmutableValue, (, Node, n, ), {, switch, (, n, ., getType, (]
[), ;, }, return, null, ;, }, static, boolean, isImmutableValue, (, Node, n, ), {, switch, (, n, ., getType]
[;, }, static, boolean, isImmutableValue, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., NULL, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., NULL]
[:, case, Token, ., NUMBER, :, case, Token, ., NULL, :, case, Token, ., TRUE, :, case, Token, ., FALSE]
[., STRING, :, case, Token, ., NUMBER, :, case, Token, ., NULL, :, case, Token, ., TRUE, :, case, Token]
[:, case, Token, ., NULL, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case]
[., NUMBER, :, case, Token, ., NULL, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true]
[:, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., CAST, :, case]
[., NULL, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., CAST]
[:, case, Token, ., FALSE, :, return, true, ;, case, Token, ., CAST, :, case, Token, ., NOT, :, return]
[., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., CAST, :, case, Token, ., NOT]
[:, return, true, ;, case, Token, ., CAST, :, case, Token, ., NOT, :, return, isImmutableValue, (, n, ., getFirstChild]
[., FALSE, :, return, true, ;, case, Token, ., CAST, :, case, Token, ., NOT, :, return, isImmutableValue, (, n]
[;, case, Token, ., CAST, :, case, Token, ., NOT, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), )]
[:, case, Token, ., NOT, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., VOID]
[., CAST, :, case, Token, ., NOT, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token]
[:, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., VOID, :, case, Token, ., NEG]
[., NOT, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., VOID, :, case, Token]
[;, case, Token, ., VOID, :, case, Token, ., NEG, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), )]
[), ;, case, Token, ., VOID, :, case, Token, ., NEG, :, return, isImmutableValue, (, n, ., getFirstChild, (, )]
[., getFirstChild, (, ), ), ;, case, Token, ., VOID, :, case, Token, ., NEG, :, return, isImmutableValue, (, n]
[:, case, Token, ., NEG, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., NAME]
[., VOID, :, case, Token, ., NEG, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token]
[:, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., NAME, :, String, name, =, n]
[., NEG, :, return, isImmutableValue, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., NAME, :, String, name]
[;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, return, "undefined", ., equals, (]
[), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, return, "undefined", ., equals]
[., getFirstChild, (, ), ), ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;]
[:, String, name, =, n, ., getString, (, ), ;, return, "undefined", ., equals, (, name, ), ||, "Infinity", .]
[., NAME, :, String, name, =, n, ., getString, (, ), ;, return, "undefined", ., equals, (, name, ), ||]
[;, return, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (]
[., getString, (, ), ;, return, "undefined", ., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||]
[;, }, return, false, ;, }, static, boolean, isSymmetricOperation, (, Node, n, ), {, switch, (, n, ., getType, (]
[||, "NaN", ., equals, (, name, ), ;, }, return, false, ;, }, static, boolean, isSymmetricOperation, (, Node, n, )]
[||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ;, }, return, false, ;, }]
[., equals, (, name, ), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ;]
[), ||, "Infinity", ., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ;, }, return, false, ;]
[||, "NaN", ., equals, (, name, ), ;, }, return, false, ;, }, static, boolean, isSymmetricOperation, (, Node, n, )]
[., equals, (, name, ), ||, "NaN", ., equals, (, name, ), ;, }, return, false, ;, }, static, boolean]
[), ||, "NaN", ., equals, (, name, ), ;, }, return, false, ;, }, static, boolean, isSymmetricOperation, (, Node, n]
[;, }, return, false, ;, }, static, boolean, isSymmetricOperation, (, Node, n, ), {, switch, (, n, ., getType, (]
[., equals, (, name, ), ;, }, return, false, ;, }, static, boolean, isSymmetricOperation, (, Node, n, ), {, switch]
[), ;, }, return, false, ;, }, static, boolean, isSymmetricOperation, (, Node, n, ), {, switch, (, n, ., getType]
[;, }, static, boolean, isSymmetricOperation, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[), {, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ]
[:, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., MUL]
[., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token]
[:, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., MUL, :, return, true, ;, }]
[., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., MUL, :, return, true]
[:, case, Token, ., SHNE, :, case, Token, ., MUL, :, return, true, ;, }, return, false, ;, }, static]
[., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., MUL, :, return, true, ;, }, return, false, ;]
[:, case, Token, ., MUL, :, return, true, ;, }, return, false, ;, }, static, boolean, isRelationalOperation, (, Node, n]
[., SHNE, :, case, Token, ., MUL, :, return, true, ;, }, return, false, ;, }, static, boolean, isRelationalOperation, (]
[:, return, true, ;, }, return, false, ;, }, static, boolean, isRelationalOperation, (, Node, n, ), {, switch, (, n]
[., MUL, :, return, true, ;, }, return, false, ;, }, static, boolean, isRelationalOperation, (, Node, n, ), {, switch]
[;, }, return, false, ;, }, static, boolean, isRelationalOperation, (, Node, n, ), {, switch, (, n, ., getType, (]
[;, }, static, boolean, isRelationalOperation, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[), {, case, Token, ., GT, :, case, Token, ., GE, :, case, Token, ., LT, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., GT, :, case, Token, ., GE, :, case, Token, ., LT]
[:, case, Token, ., GE, :, case, Token, ., LT, :, case, Token, ., LE, :, return, true, ;, }]
[., GT, :, case, Token, ., GE, :, case, Token, ., LT, :, case, Token, ., LE, :, return, true]
[:, case, Token, ., LT, :, case, Token, ., LE, :, return, true, ;, }, return, false, ;, }, static]
[., GE, :, case, Token, ., LT, :, case, Token, ., LE, :, return, true, ;, }, return, false, ;]
[:, case, Token, ., LE, :, return, true, ;, }, return, false, ;, }, static, int, getInverseOperator, (, int, type]
[., LT, :, case, Token, ., LE, :, return, true, ;, }, return, false, ;, }, static, int, getInverseOperator, (]
[:, return, true, ;, }, return, false, ;, }, static, int, getInverseOperator, (, int, type, ), {, switch, (, type]
[., LE, :, return, true, ;, }, return, false, ;, }, static, int, getInverseOperator, (, int, type, ), {, switch]
[;, }, return, false, ;, }, static, int, getInverseOperator, (, int, type, ), {, switch, (, type, ), {, case]
[;, }, static, int, getInverseOperator, (, int, type, ), {, switch, (, type, ), {, case, Token, ., GT, :]
[), {, case, Token, ., GT, :, return, Token, ., LT, ;, case, Token, ., LT, :, return, Token, .]
[:, return, Token, ., LT, ;, case, Token, ., LT, :, return, Token, ., GT, ;, case, Token, ., GE]
[., GT, :, return, Token, ., LT, ;, case, Token, ., LT, :, return, Token, ., GT, ;, case, Token]
[;, case, Token, ., LT, :, return, Token, ., GT, ;, case, Token, ., GE, :, return, Token, ., LE]
[., LT, ;, case, Token, ., LT, :, return, Token, ., GT, ;, case, Token, ., GE, :, return, Token]
[:, return, Token, ., GT, ;, case, Token, ., GE, :, return, Token, ., LE, ;, case, Token, ., LE]
[., LT, :, return, Token, ., GT, ;, case, Token, ., GE, :, return, Token, ., LE, ;, case, Token]
[;, case, Token, ., GE, :, return, Token, ., LE, ;, case, Token, ., LE, :, return, Token, ., GE]
[., GT, ;, case, Token, ., GE, :, return, Token, ., LE, ;, case, Token, ., LE, :, return, Token]
[:, return, Token, ., LE, ;, case, Token, ., LE, :, return, Token, ., GE, ;, }, return, Token, .]
[., GE, :, return, Token, ., LE, ;, case, Token, ., LE, :, return, Token, ., GE, ;, }, return]
[;, case, Token, ., LE, :, return, Token, ., GE, ;, }, return, Token, ., ERROR, ;, }, static, boolean]
[., LE, ;, case, Token, ., LE, :, return, Token, ., GE, ;, }, return, Token, ., ERROR, ;, }]
[:, return, Token, ., GE, ;, }, return, Token, ., ERROR, ;, }, static, boolean, isLiteralValue, (, Node, n, ,]
[., LE, :, return, Token, ., GE, ;, }, return, Token, ., ERROR, ;, }, static, boolean, isLiteralValue, (, Node]
[;, }, return, Token, ., ERROR, ;, }, static, boolean, isLiteralValue, (, Node, n, ,, boolean, includeFunctions, ), {, switch]
[., GE, ;, }, return, Token, ., ERROR, ;, }, static, boolean, isLiteralValue, (, Node, n, ,, boolean, includeFunctions, )]
[;, }, static, boolean, isLiteralValue, (, Node, n, ,, boolean, includeFunctions, ), {, switch, (, n, ., getType, (, )]
[., ERROR, ;, }, static, boolean, isLiteralValue, (, Node, n, ,, boolean, includeFunctions, ), {, switch, (, n, ., getType]
[), {, case, Token, ., CAST, :, return, isLiteralValue, (, n, ., getFirstChild, (, ), ,, includeFunctions, ), ;, case]
[., getType, (, ), ), {, case, Token, ., CAST, :, return, isLiteralValue, (, n, ., getFirstChild, (, ), ,]
[:, return, isLiteralValue, (, n, ., getFirstChild, (, ), ,, includeFunctions, ), ;, case, Token, ., ARRAYLIT, :, for, (]
[., CAST, :, return, isLiteralValue, (, n, ., getFirstChild, (, ), ,, includeFunctions, ), ;, case, Token, ., ARRAYLIT, :]
[;, case, Token, ., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null]
[,, includeFunctions, ), ;, case, Token, ., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[., getFirstChild, (, ), ,, includeFunctions, ), ;, case, Token, ., ARRAYLIT, :, for, (, Node, child, =, n, .]
[), ;, case, Token, ., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=]
[:, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, .]
[., ARRAYLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, (, !, child, .]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[;, child, =, child, ., getNext, (, ), ), {, if, (, (, !, child, ., isEmpty, (, ), )]
[!=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, (, !, child, ., isEmpty, (]
[;, child, =, child, ., getNext, (, ), ), {, if, (, (, !, child, ., isEmpty, (, ), )]
[=, child, ., getNext, (, ), ), {, if, (, (, !, child, ., isEmpty, (, ), ), &&, !]
[), {, if, (, (, !, child, ., isEmpty, (, ), ), &&, !, isLiteralValue, (, child, ,, includeFunctions, )]
[., getNext, (, ), ), {, if, (, (, !, child, ., isEmpty, (, ), ), &&, !, isLiteralValue, (]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., REGEXP, :, for, (, Node, child, =]
[&&, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case, Token]
[), &&, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case]
[), &&, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case]
[., isEmpty, (, ), ), &&, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., REGEXP, :, for, (, Node, child, =]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., REGEXP, :, for, (, Node, child, =]
[,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., REGEXP, :, for, (]
[), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., REGEXP, :, for, (, Node, child]
[;, }, }, return, true, ;, case, Token, ., REGEXP, :, for, (, Node, child, =, n, ., getFirstChild, (]
[;, case, Token, ., REGEXP, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null]
[:, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, .]
[., REGEXP, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ,, includeFunctions, ), )]
[!=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ,, includeFunctions]
[;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ,, includeFunctions, ), )]
[=, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return]
[), {, if, (, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true]
[., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ,, includeFunctions, ), ), {, return, false, ;]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., OBJECTLIT, :, for, (, Node, child, =]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., OBJECTLIT, :, for, (, Node, child, =]
[,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., OBJECTLIT, :, for, (]
[), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., OBJECTLIT, :, for, (, Node, child]
[;, }, }, return, true, ;, case, Token, ., OBJECTLIT, :, for, (, Node, child, =, n, ., getFirstChild, (]
[;, case, Token, ., OBJECTLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null]
[:, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, .]
[., OBJECTLIT, :, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ., getFirstChild, (, )]
[!=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ., getFirstChild]
[;, child, =, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ., getFirstChild, (, )]
[=, child, ., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ., getFirstChild, (, ), ,, includeFunctions]
[), {, if, (, !, isLiteralValue, (, child, ., getFirstChild, (, ), ,, includeFunctions, ), ), {, return, false, ;]
[., getNext, (, ), ), {, if, (, !, isLiteralValue, (, child, ., getFirstChild, (, ), ,, includeFunctions, ), )]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return, includeFunctions, &&, !, NodeUtil]
[), {, return, false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return, includeFunctions, &&, !, NodeUtil]
[,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return, includeFunctions]
[., getFirstChild, (, ), ,, includeFunctions, ), ), {, return, false, ;, }, }, return, true, ;, case, Token, .]
[), ), {, return, false, ;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return, includeFunctions, &&, !]
[;, }, }, return, true, ;, case, Token, ., FUNCTION, :, return, includeFunctions, &&, !, NodeUtil, ., isFunctionDeclaration, (, n]
[;, case, Token, ., FUNCTION, :, return, includeFunctions, &&, !, NodeUtil, ., isFunctionDeclaration, (, n, ), ;, default, :, return]
[:, return, includeFunctions, &&, !, NodeUtil, ., isFunctionDeclaration, (, n, ), ;, default, :, return, isImmutableValue, (, n, ), ;]
[., FUNCTION, :, return, includeFunctions, &&, !, NodeUtil, ., isFunctionDeclaration, (, n, ), ;, default, :, return, isImmutableValue, (, n]
[;, default, :, return, isImmutableValue, (, n, ), ;, }, }, static, boolean, isValidDefineValue, (, Node, val, ,, Set, <]
[&&, !, NodeUtil, ., isFunctionDeclaration, (, n, ), ;, default, :, return, isImmutableValue, (, n, ), ;, }, }, static]
[;, default, :, return, isImmutableValue, (, n, ), ;, }, }, static, boolean, isValidDefineValue, (, Node, val, ,, Set, <]
[;, default, :, return, isImmutableValue, (, n, ), ;, }, }, static, boolean, isValidDefineValue, (, Node, val, ,, Set, <]
[., isFunctionDeclaration, (, n, ), ;, default, :, return, isImmutableValue, (, n, ), ;, }, }, static, boolean, isValidDefineValue, (]
[), ;, default, :, return, isImmutableValue, (, n, ), ;, }, }, static, boolean, isValidDefineValue, (, Node, val, ,, Set]
[;, }, }, static, boolean, isValidDefineValue, (, Node, val, ,, Set, <, String, >, defines, ), {, switch, (, val]
[), ;, }, }, static, boolean, isValidDefineValue, (, Node, val, ,, Set, <, String, >, defines, ), {, switch, (]
[), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., TRUE, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., STRING, :, case, Token, ., NUMBER, :, case, Token, ., TRUE]
[:, case, Token, ., NUMBER, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case]
[., STRING, :, case, Token, ., NUMBER, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true]
[:, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., ADD, :, case]
[., NUMBER, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., ADD]
[:, case, Token, ., FALSE, :, return, true, ;, case, Token, ., ADD, :, case, Token, ., BITAND, :, case]
[., TRUE, :, case, Token, ., FALSE, :, return, true, ;, case, Token, ., ADD, :, case, Token, ., BITAND]
[:, return, true, ;, case, Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case]
[., FALSE, :, return, true, ;, case, Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT]
[;, case, Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR]
[:, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR]
[., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token]
[:, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., DIV]
[., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token]
[:, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., DIV, :, case, Token, ., EQ]
[., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., DIV, :, case, Token]
[:, case, Token, ., BITXOR, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE]
[., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token]
[:, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT]
[., BITXOR, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token]
[:, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE]
[., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case, Token]
[:, case, Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LSH]
[., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token]
[:, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT]
[., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token]
[:, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD]
[., GT, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token]
[:, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL]
[., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token]
[:, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE]
[., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token]
[:, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., RSH]
[., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token]
[:, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., RSH, :, case, Token, ., SHEQ]
[., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., RSH, :, case, Token]
[:, case, Token, ., NE, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE]
[., MUL, :, case, Token, ., NE, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token]
[:, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB]
[., NE, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token]
[:, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., URSH]
[., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token]
[:, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., URSH, :, return, isValidDefineValue, (, val]
[., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., URSH, :, return, isValidDefineValue]
[:, case, Token, ., SUB, :, case, Token, ., URSH, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,]
[., SHNE, :, case, Token, ., SUB, :, case, Token, ., URSH, :, return, isValidDefineValue, (, val, ., getFirstChild, (]
[:, case, Token, ., URSH, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), &&, isValidDefineValue, (]
[., SUB, :, case, Token, ., URSH, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), &&]
[:, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), &&, isValidDefineValue, (, val, ., getLastChild, (, )]
[., URSH, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), &&, isValidDefineValue, (, val, ., getLastChild]
[;, case, Token, ., NOT, :, case, Token, ., NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (, val]
[&&, isValidDefineValue, (, val, ., getLastChild, (, ), ,, defines, ), ;, case, Token, ., NOT, :, case, Token, .]
[,, defines, ), &&, isValidDefineValue, (, val, ., getLastChild, (, ), ,, defines, ), ;, case, Token, ., NOT, :]
[., getFirstChild, (, ), ,, defines, ), &&, isValidDefineValue, (, val, ., getLastChild, (, ), ,, defines, ), ;, case]
[), &&, isValidDefineValue, (, val, ., getLastChild, (, ), ,, defines, ), ;, case, Token, ., NOT, :, case, Token]
[;, case, Token, ., NOT, :, case, Token, ., NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (, val]
[,, defines, ), ;, case, Token, ., NOT, :, case, Token, ., NEG, :, case, Token, ., POS, :, return]
[., getLastChild, (, ), ,, defines, ), ;, case, Token, ., NOT, :, case, Token, ., NEG, :, case, Token]
[), ;, case, Token, ., NOT, :, case, Token, ., NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (]
[:, case, Token, ., NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,]
[., NOT, :, case, Token, ., NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (]
[:, case, Token, ., POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), ;, case, Token]
[., NEG, :, case, Token, ., POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), ;]
[:, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), ;, case, Token, ., NAME, :, case, Token]
[., POS, :, return, isValidDefineValue, (, val, ., getFirstChild, (, ), ,, defines, ), ;, case, Token, ., NAME, :]
[;, case, Token, ., NAME, :, case, Token, ., GETPROP, :, if, (, val, ., isQualifiedName, (, ), ), {]
[,, defines, ), ;, case, Token, ., NAME, :, case, Token, ., GETPROP, :, if, (, val, ., isQualifiedName, (]
[., getFirstChild, (, ), ,, defines, ), ;, case, Token, ., NAME, :, case, Token, ., GETPROP, :, if, (]
[), ;, case, Token, ., NAME, :, case, Token, ., GETPROP, :, if, (, val, ., isQualifiedName, (, ), )]
[:, case, Token, ., GETPROP, :, if, (, val, ., isQualifiedName, (, ), ), {, return, defines, ., contains, (]
[., NAME, :, case, Token, ., GETPROP, :, if, (, val, ., isQualifiedName, (, ), ), {, return, defines, .]
[:, if, (, val, ., isQualifiedName, (, ), ), {, return, defines, ., contains, (, val, ., getQualifiedName, (, )]
[., GETPROP, :, if, (, val, ., isQualifiedName, (, ), ), {, return, defines, ., contains, (, val, ., getQualifiedName]
[), {, return, defines, ., contains, (, val, ., getQualifiedName, (, ), ), ;, }, }, return, false, ;, }]
[., isQualifiedName, (, ), ), {, return, defines, ., contains, (, val, ., getQualifiedName, (, ), ), ;, }, }]
[;, }, }, return, false, ;, }, static, boolean, isEmptyBlock, (, Node, block, ), {, if, (, !, block, .]
[., contains, (, val, ., getQualifiedName, (, ), ), ;, }, }, return, false, ;, }, static, boolean, isEmptyBlock, (]
[), ;, }, }, return, false, ;, }, static, boolean, isEmptyBlock, (, Node, block, ), {, if, (, !, block]
[., getQualifiedName, (, ), ), ;, }, }, return, false, ;, }, static, boolean, isEmptyBlock, (, Node, block, ), {]
[;, }, static, boolean, isEmptyBlock, (, Node, block, ), {, if, (, !, block, ., isBlock, (, ), ), {]
[), {, return, false, ;, }, for, (, Node, n, =, block, ., getFirstChild, (, ), ;, n, !=, null]
[), {, return, false, ;, }, for, (, Node, n, =, block, ., getFirstChild, (, ), ;, n, !=, null]
[., isBlock, (, ), ), {, return, false, ;, }, for, (, Node, n, =, block, ., getFirstChild, (, )]
[;, }, for, (, Node, n, =, block, ., getFirstChild, (, ), ;, n, !=, null, ;, n, =, n]
[;, n, !=, null, ;, n, =, n, ., getNext, (, ), ), {, if, (, !, n, ., isEmpty]
[., getFirstChild, (, ), ;, n, !=, null, ;, n, =, n, ., getNext, (, ), ), {, if, (]
[;, n, =, n, ., getNext, (, ), ), {, if, (, !, n, ., isEmpty, (, ), ), {]
[!=, null, ;, n, =, n, ., getNext, (, ), ), {, if, (, !, n, ., isEmpty, (, )]
[;, n, =, n, ., getNext, (, ), ), {, if, (, !, n, ., isEmpty, (, ), ), {]
[=, n, ., getNext, (, ), ), {, if, (, !, n, ., isEmpty, (, ), ), {, return, false]
[), {, if, (, !, n, ., isEmpty, (, ), ), {, return, false, ;, }, }, return, true, ;]
[., getNext, (, ), ), {, if, (, !, n, ., isEmpty, (, ), ), {, return, false, ;, }]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isSimpleOperator, (, Node, n, ), {, return]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isSimpleOperator, (, Node, n, ), {, return]
[., isEmpty, (, ), ), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isSimpleOperator, (, Node]
[;, }, }, return, true, ;, }, static, boolean, isSimpleOperator, (, Node, n, ), {, return, isSimpleOperatorType, (, n, .]
[;, }, static, boolean, isSimpleOperator, (, Node, n, ), {, return, isSimpleOperatorType, (, n, ., getType, (, ), ), ;]
[;, }, static, boolean, isSimpleOperatorType, (, int, type, ), {, switch, (, type, ), {, case, Token, ., ADD, :]
[), ;, }, static, boolean, isSimpleOperatorType, (, int, type, ), {, switch, (, type, ), {, case, Token, ., ADD]
[., getType, (, ), ), ;, }, static, boolean, isSimpleOperatorType, (, int, type, ), {, switch, (, type, ), {]
[), {, case, Token, ., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, .]
[:, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR]
[., ADD, :, case, Token, ., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token]
[:, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., COMMA]
[., BITAND, :, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token]
[:, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., COMMA, :, case, Token, ., DIV]
[., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., COMMA, :, case, Token]
[:, case, Token, ., BITXOR, :, case, Token, ., COMMA, :, case, Token, ., DIV, :, case, Token, ., EQ]
[., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., COMMA, :, case, Token, ., DIV, :, case, Token]
[:, case, Token, ., COMMA, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE]
[., BITXOR, :, case, Token, ., COMMA, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token]
[:, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GETELEM]
[., COMMA, :, case, Token, ., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token]
[:, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP]
[., DIV, :, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GETELEM, :, case, Token]
[:, case, Token, ., GE, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., GT]
[., EQ, :, case, Token, ., GE, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token]
[:, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., GT, :, case, Token, ., INSTANCEOF]
[., GE, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., GT, :, case, Token]
[:, case, Token, ., GETPROP, :, case, Token, ., GT, :, case, Token, ., INSTANCEOF, :, case, Token, ., LE]
[., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., GT, :, case, Token, ., INSTANCEOF, :, case, Token]
[:, case, Token, ., GT, :, case, Token, ., INSTANCEOF, :, case, Token, ., LE, :, case, Token, ., LSH]
[., GETPROP, :, case, Token, ., GT, :, case, Token, ., INSTANCEOF, :, case, Token, ., LE, :, case, Token]
[:, case, Token, ., INSTANCEOF, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT]
[., GT, :, case, Token, ., INSTANCEOF, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token]
[:, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD]
[., INSTANCEOF, :, case, Token, ., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token]
[:, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL]
[., LE, :, case, Token, ., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token]
[:, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE]
[., LSH, :, case, Token, ., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token]
[:, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., NOT]
[., LT, :, case, Token, ., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token]
[:, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., NOT, :, case, Token, ., RSH]
[., MOD, :, case, Token, ., MUL, :, case, Token, ., NE, :, case, Token, ., NOT, :, case, Token]
[:, case, Token, ., NE, :, case, Token, ., NOT, :, case, Token, ., RSH, :, case, Token, ., SHEQ]
[., MUL, :, case, Token, ., NE, :, case, Token, ., NOT, :, case, Token, ., RSH, :, case, Token]
[:, case, Token, ., NOT, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE]
[., NE, :, case, Token, ., NOT, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token]
[:, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB]
[., NOT, :, case, Token, ., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token]
[:, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., TYPEOF]
[., RSH, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token]
[:, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., TYPEOF, :, case, Token, ., VOID]
[., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., SUB, :, case, Token, ., TYPEOF, :, case, Token]
[:, case, Token, ., SUB, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., POS]
[., SHNE, :, case, Token, ., SUB, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token]
[:, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., POS, :, case, Token, ., NEG]
[., SUB, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., POS, :, case, Token]
[:, case, Token, ., VOID, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., URSH]
[., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token]
[:, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., URSH, :, return, true, ;, default]
[., VOID, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., URSH, :, return, true]
[:, case, Token, ., NEG, :, case, Token, ., URSH, :, return, true, ;, default, :, return, false, ;, }]
[., POS, :, case, Token, ., NEG, :, case, Token, ., URSH, :, return, true, ;, default, :, return, false]
[:, case, Token, ., URSH, :, return, true, ;, default, :, return, false, ;, }, }, static, Node, newExpr, (]
[., NEG, :, case, Token, ., URSH, :, return, true, ;, default, :, return, false, ;, }, }, static, Node]
[:, return, true, ;, default, :, return, false, ;, }, }, static, Node, newExpr, (, Node, child, ), {, return]
[., URSH, :, return, true, ;, default, :, return, false, ;, }, }, static, Node, newExpr, (, Node, child, )]
[;, default, :, return, false, ;, }, }, static, Node, newExpr, (, Node, child, ), {, return, IR, ., exprResult]
[;, }, }, static, Node, newExpr, (, Node, child, ), {, return, IR, ., exprResult, (, child, ), ., srcref]
[;, }, static, boolean, mayEffectMutableState, (, Node, n, ), {, return, mayEffectMutableState, (, n, ,, null, ), ;, }, static]
[., srcref, (, child, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ), {, return, mayEffectMutableState, (, n, ,]
[., exprResult, (, child, ), ., srcref, (, child, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ), {]
[), ., srcref, (, child, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ), {, return, mayEffectMutableState, (, n]
[), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ), {, return, mayEffectMutableState, (, n, ,, null, ), ;, }]
[;, }, static, boolean, mayEffectMutableState, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n, ,, true, ,]
[,, null, ), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n]
[), ;, }, static, boolean, mayEffectMutableState, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n, ,, true]
[;, }, static, boolean, mayHaveSideEffects, (, Node, n, ), {, return, mayHaveSideEffects, (, n, ,, null, ), ;, }, static]
[,, true, ,, compiler, ), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ), {, return, mayHaveSideEffects, (, n, ,]
[,, compiler, ), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ), {, return, mayHaveSideEffects, (, n, ,, null, )]
[), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ), {, return, mayHaveSideEffects, (, n, ,, null, ), ;, }]
[;, }, static, boolean, mayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n, ,, false, ,]
[,, null, ), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n]
[), ;, }, static, boolean, mayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, return, checkForStateChangeHelper, (, n, ,, false]
[;, }, private, static, boolean, checkForStateChangeHelper, (, Node, n, ,, boolean, checkForNewObjects, ,, AbstractCompiler, compiler, ), {, switch, (, n]
[,, false, ,, compiler, ), ;, }, private, static, boolean, checkForStateChangeHelper, (, Node, n, ,, boolean, checkForNewObjects, ,, AbstractCompiler, compiler]
[,, compiler, ), ;, }, private, static, boolean, checkForStateChangeHelper, (, Node, n, ,, boolean, checkForNewObjects, ,, AbstractCompiler, compiler, ), {]
[), ;, }, private, static, boolean, checkForStateChangeHelper, (, Node, n, ,, boolean, checkForNewObjects, ,, AbstractCompiler, compiler, ), {, switch, (]
[), {, case, Token, ., CAST, :, case, Token, ., AND, :, case, Token, ., BLOCK, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., CAST, :, case, Token, ., AND, :, case, Token, ., BLOCK]
[:, case, Token, ., AND, :, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., HOOK]
[., CAST, :, case, Token, ., AND, :, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case, Token]
[:, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case, Token, ., IF]
[., AND, :, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case, Token]
[:, case, Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., IN]
[., BLOCK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token]
[:, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., IN, :, case, Token, ., PARAM_LIST]
[., EXPR_RESULT, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., IN, :, case, Token]
[:, case, Token, ., IF, :, case, Token, ., IN, :, case, Token, ., PARAM_LIST, :, case, Token, ., NUMBER]
[., HOOK, :, case, Token, ., IF, :, case, Token, ., IN, :, case, Token, ., PARAM_LIST, :, case, Token]
[:, case, Token, ., IN, :, case, Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case, Token, ., OR]
[., IF, :, case, Token, ., IN, :, case, Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case, Token]
[:, case, Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case, Token, ., OR, :, case, Token, ., THIS]
[., IN, :, case, Token, ., PARAM_LIST, :, case, Token, ., NUMBER, :, case, Token, ., OR, :, case, Token]
[:, case, Token, ., NUMBER, :, case, Token, ., OR, :, case, Token, ., THIS, :, case, Token, ., TRUE]
[., PARAM_LIST, :, case, Token, ., NUMBER, :, case, Token, ., OR, :, case, Token, ., THIS, :, case, Token]
[:, case, Token, ., OR, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, case, Token, ., FALSE]
[., NUMBER, :, case, Token, ., OR, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, case, Token]
[:, case, Token, ., THIS, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., NULL]
[., OR, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token]
[:, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., NULL, :, case, Token, ., STRING]
[., THIS, :, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., NULL, :, case, Token]
[:, case, Token, ., FALSE, :, case, Token, ., NULL, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY]
[., TRUE, :, case, Token, ., FALSE, :, case, Token, ., NULL, :, case, Token, ., STRING, :, case, Token]
[:, case, Token, ., NULL, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., SWITCH]
[., FALSE, :, case, Token, ., NULL, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token]
[:, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., SWITCH, :, case, Token, ., TRY]
[., NULL, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., SWITCH, :, case, Token]
[:, case, Token, ., STRING_KEY, :, case, Token, ., SWITCH, :, case, Token, ., TRY, :, case, Token, ., EMPTY]
[., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., SWITCH, :, case, Token, ., TRY, :, case, Token]
[:, case, Token, ., SWITCH, :, case, Token, ., TRY, :, case, Token, ., EMPTY, :, break, ;, case, Token]
[., STRING_KEY, :, case, Token, ., SWITCH, :, case, Token, ., TRY, :, case, Token, ., EMPTY, :, break, ;]
[:, case, Token, ., TRY, :, case, Token, ., EMPTY, :, break, ;, case, Token, ., THROW, :, return, true]
[., SWITCH, :, case, Token, ., TRY, :, case, Token, ., EMPTY, :, break, ;, case, Token, ., THROW, :]
[:, case, Token, ., EMPTY, :, break, ;, case, Token, ., THROW, :, return, true, ;, case, Token, ., OBJECTLIT]
[., TRY, :, case, Token, ., EMPTY, :, break, ;, case, Token, ., THROW, :, return, true, ;, case, Token]
[:, break, ;, case, Token, ., THROW, :, return, true, ;, case, Token, ., OBJECTLIT, :, if, (, checkForNewObjects, )]
[., EMPTY, :, break, ;, case, Token, ., THROW, :, return, true, ;, case, Token, ., OBJECTLIT, :, if, (]
[:, return, true, ;, case, Token, ., OBJECTLIT, :, if, (, checkForNewObjects, ), {, return, true, ;, }, for, (]
[., THROW, :, return, true, ;, case, Token, ., OBJECTLIT, :, if, (, checkForNewObjects, ), {, return, true, ;, }]
[;, case, Token, ., OBJECTLIT, :, if, (, checkForNewObjects, ), {, return, true, ;, }, for, (, Node, c, =]
[:, if, (, checkForNewObjects, ), {, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, )]
[., OBJECTLIT, :, if, (, checkForNewObjects, ), {, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild]
[), {, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null]
[;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, .]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ., getFirstChild, (, ), ,]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ., getFirstChild, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ., getFirstChild, (, ), ,]
[=, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ., getFirstChild, (, ), ,, checkForNewObjects, ,]
[), {, if, (, checkForStateChangeHelper, (, c, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true]
[., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, )]
[), {, return, true, ;, }, }, return, false, ;, case, Token, ., ARRAYLIT, :, case, Token, ., REGEXP, :]
[,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return, false, ;, case, Token, ., ARRAYLIT, :]
[., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return, false, ;, case]
[,, compiler, ), ), {, return, true, ;, }, }, return, false, ;, case, Token, ., ARRAYLIT, :, case, Token]
[), ), {, return, true, ;, }, }, return, false, ;, case, Token, ., ARRAYLIT, :, case, Token, ., REGEXP]
[;, }, }, return, false, ;, case, Token, ., ARRAYLIT, :, case, Token, ., REGEXP, :, if, (, checkForNewObjects, )]
[;, case, Token, ., ARRAYLIT, :, case, Token, ., REGEXP, :, if, (, checkForNewObjects, ), {, return, true, ;, }]
[:, case, Token, ., REGEXP, :, if, (, checkForNewObjects, ), {, return, true, ;, }, break, ;, case, Token, .]
[., ARRAYLIT, :, case, Token, ., REGEXP, :, if, (, checkForNewObjects, ), {, return, true, ;, }, break, ;, case]
[:, if, (, checkForNewObjects, ), {, return, true, ;, }, break, ;, case, Token, ., VAR, :, case, Token, .]
[., REGEXP, :, if, (, checkForNewObjects, ), {, return, true, ;, }, break, ;, case, Token, ., VAR, :, case]
[), {, return, true, ;, }, break, ;, case, Token, ., VAR, :, case, Token, ., NAME, :, if, (]
[;, }, break, ;, case, Token, ., VAR, :, case, Token, ., NAME, :, if, (, n, ., getFirstChild, (]
[:, case, Token, ., NAME, :, if, (, n, ., getFirstChild, (, ), !=, null, ), {, return, true, ;]
[., VAR, :, case, Token, ., NAME, :, if, (, n, ., getFirstChild, (, ), !=, null, ), {, return]
[:, if, (, n, ., getFirstChild, (, ), !=, null, ), {, return, true, ;, }, break, ;, case, Token]
[., NAME, :, if, (, n, ., getFirstChild, (, ), !=, null, ), {, return, true, ;, }, break, ;]
[), {, return, true, ;, }, break, ;, case, Token, ., FUNCTION, :, return, checkForNewObjects, ||, !, isFunctionExpression, (, n]
[!=, null, ), {, return, true, ;, }, break, ;, case, Token, ., FUNCTION, :, return, checkForNewObjects, ||, !, isFunctionExpression]
[., getFirstChild, (, ), !=, null, ), {, return, true, ;, }, break, ;, case, Token, ., FUNCTION, :, return]
[), {, return, true, ;, }, break, ;, case, Token, ., FUNCTION, :, return, checkForNewObjects, ||, !, isFunctionExpression, (, n]
[;, }, break, ;, case, Token, ., FUNCTION, :, return, checkForNewObjects, ||, !, isFunctionExpression, (, n, ), ;, case, Token]
[:, return, checkForNewObjects, ||, !, isFunctionExpression, (, n, ), ;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {]
[., FUNCTION, :, return, checkForNewObjects, ||, !, isFunctionExpression, (, n, ), ;, case, Token, ., NEW, :, if, (, checkForNewObjects]
[;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {, return, true, ;, }, if, (, !, constructorCallHasSideEffects, (]
[||, !, isFunctionExpression, (, n, ), ;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {, return, true, ;]
[;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {, return, true, ;, }, if, (, !, constructorCallHasSideEffects, (]
[;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {, return, true, ;, }, if, (, !, constructorCallHasSideEffects, (]
[), ;, case, Token, ., NEW, :, if, (, checkForNewObjects, ), {, return, true, ;, }, if, (, !, constructorCallHasSideEffects]
[:, if, (, checkForNewObjects, ), {, return, true, ;, }, if, (, !, constructorCallHasSideEffects, (, n, ), ), {, break]
[., NEW, :, if, (, checkForNewObjects, ), {, return, true, ;, }, if, (, !, constructorCallHasSideEffects, (, n, ), )]
[), {, return, true, ;, }, if, (, !, constructorCallHasSideEffects, (, n, ), ), {, break, ;, }, return, true]
[;, }, if, (, !, constructorCallHasSideEffects, (, n, ), ), {, break, ;, }, return, true, ;, case, Token, .]
[), {, break, ;, }, return, true, ;, case, Token, ., CALL, :, if, (, !, functionCallHasSideEffects, (, n, ,]
[), {, break, ;, }, return, true, ;, case, Token, ., CALL, :, if, (, !, functionCallHasSideEffects, (, n, ,]
[), ), {, break, ;, }, return, true, ;, case, Token, ., CALL, :, if, (, !, functionCallHasSideEffects, (, n]
[;, case, Token, ., CALL, :, if, (, !, functionCallHasSideEffects, (, n, ,, compiler, ), ), {, break, ;, }]
[:, if, (, !, functionCallHasSideEffects, (, n, ,, compiler, ), ), {, break, ;, }, return, true, ;, default, :]
[., CALL, :, if, (, !, functionCallHasSideEffects, (, n, ,, compiler, ), ), {, break, ;, }, return, true, ;]
[), {, break, ;, }, return, true, ;, default, :, if, (, isSimpleOperator, (, n, ), ), {, break, ;]
[), {, break, ;, }, return, true, ;, default, :, if, (, isSimpleOperator, (, n, ), ), {, break, ;]
[,, compiler, ), ), {, break, ;, }, return, true, ;, default, :, if, (, isSimpleOperator, (, n, ), )]
[), ), {, break, ;, }, return, true, ;, default, :, if, (, isSimpleOperator, (, n, ), ), {, break]
[;, default, :, if, (, isSimpleOperator, (, n, ), ), {, break, ;, }, if, (, isAssignmentOp, (, n, )]
[), {, break, ;, }, if, (, isAssignmentOp, (, n, ), ), {, Node, assignTarget, =, n, ., getFirstChild, (]
[), ), {, break, ;, }, if, (, isAssignmentOp, (, n, ), ), {, Node, assignTarget, =, n, ., getFirstChild]
[), {, Node, assignTarget, =, n, ., getFirstChild, (, ), ;, if, (, assignTarget, ., isName, (, ), ), {]
[), ), {, Node, assignTarget, =, n, ., getFirstChild, (, ), ;, if, (, assignTarget, ., isName, (, ), )]
[;, if, (, assignTarget, ., isName, (, ), ), {, return, true, ;, }, if, (, checkForStateChangeHelper, (, n, .]
[., getFirstChild, (, ), ;, if, (, assignTarget, ., isName, (, ), ), {, return, true, ;, }, if, (]
[), {, return, true, ;, }, if, (, checkForStateChangeHelper, (, n, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, )]
[., isName, (, ), ), {, return, true, ;, }, if, (, checkForStateChangeHelper, (, n, ., getFirstChild, (, ), ,]
[;, }, if, (, checkForStateChangeHelper, (, n, ., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ||, checkForStateChangeHelper, (, n]
[), {, return, true, ;, }, if, (, isGet, (, assignTarget, ), ), {, Node, current, =, assignTarget, ., getFirstChild]
[||, checkForStateChangeHelper, (, n, ., getLastChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, if]
[,, checkForNewObjects, ,, compiler, ), ||, checkForStateChangeHelper, (, n, ., getLastChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {]
[., getFirstChild, (, ), ,, checkForNewObjects, ,, compiler, ), ||, checkForStateChangeHelper, (, n, ., getLastChild, (, ), ,, checkForNewObjects, ,]
[,, compiler, ), ||, checkForStateChangeHelper, (, n, ., getLastChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true]
[), ||, checkForStateChangeHelper, (, n, ., getLastChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }]
[), {, return, true, ;, }, if, (, isGet, (, assignTarget, ), ), {, Node, current, =, assignTarget, ., getFirstChild]
[,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, if, (, isGet, (, assignTarget, ), ), {, Node]
[., getLastChild, (, ), ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, if, (, isGet, (, assignTarget]
[,, compiler, ), ), {, return, true, ;, }, if, (, isGet, (, assignTarget, ), ), {, Node, current, =]
[), ), {, return, true, ;, }, if, (, isGet, (, assignTarget, ), ), {, Node, current, =, assignTarget, .]
[;, }, if, (, isGet, (, assignTarget, ), ), {, Node, current, =, assignTarget, ., getFirstChild, (, ), ;, if]
[), {, Node, current, =, assignTarget, ., getFirstChild, (, ), ;, if, (, evaluatesToLocalValue, (, current, ), ), {, return]
[), ), {, Node, current, =, assignTarget, ., getFirstChild, (, ), ;, if, (, evaluatesToLocalValue, (, current, ), ), {]
[;, if, (, evaluatesToLocalValue, (, current, ), ), {, return, false, ;, }, while, (, isGet, (, current, ), )]
[., getFirstChild, (, ), ;, if, (, evaluatesToLocalValue, (, current, ), ), {, return, false, ;, }, while, (, isGet]
[), {, return, false, ;, }, while, (, isGet, (, current, ), ), {, current, =, current, ., getFirstChild, (]
[), ), {, return, false, ;, }, while, (, isGet, (, current, ), ), {, current, =, current, ., getFirstChild]
[;, }, while, (, isGet, (, current, ), ), {, current, =, current, ., getFirstChild, (, ), ;, }, return]
[), {, current, =, current, ., getFirstChild, (, ), ;, }, return, !, isLiteralValue, (, current, ,, true, ), ;]
[), ), {, current, =, current, ., getFirstChild, (, ), ;, }, return, !, isLiteralValue, (, current, ,, true, )]
[=, current, ., getFirstChild, (, ), ;, }, return, !, isLiteralValue, (, current, ,, true, ), ;, }, else, {]
[;, }, return, !, isLiteralValue, (, current, ,, true, ), ;, }, else, {, return, !, isLiteralValue, (, assignTarget, ,]
[., getFirstChild, (, ), ;, }, return, !, isLiteralValue, (, current, ,, true, ), ;, }, else, {, return, !]
[;, }, else, {, return, !, isLiteralValue, (, assignTarget, ,, true, ), ;, }, }, return, true, ;, }, for]
[;, }, else, {, return, !, isLiteralValue, (, assignTarget, ,, true, ), ;, }, }, return, true, ;, }, for]
[,, true, ), ;, }, else, {, return, !, isLiteralValue, (, assignTarget, ,, true, ), ;, }, }, return, true]
[), ;, }, else, {, return, !, isLiteralValue, (, assignTarget, ,, true, ), ;, }, }, return, true, ;, }]
[;, }, }, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[;, }, }, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[,, true, ), ;, }, }, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, )]
[), ;, }, }, return, true, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c]
[;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ,]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ,, checkForNewObjects, ,, compiler, )]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ,, checkForNewObjects, ,]
[;, c, =, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ,, checkForNewObjects, ,, compiler, )]
[=, c, ., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ,, checkForNewObjects, ,, compiler, ), ), {]
[), {, if, (, checkForStateChangeHelper, (, c, ,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return]
[., getNext, (, ), ), {, if, (, checkForStateChangeHelper, (, c, ,, checkForNewObjects, ,, compiler, ), ), {, return, true]
[), {, return, true, ;, }, }, return, false, ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ), {, return]
[,, checkForNewObjects, ,, compiler, ), ), {, return, true, ;, }, }, return, false, ;, }, static, boolean, constructorCallHasSideEffects, (]
[,, compiler, ), ), {, return, true, ;, }, }, return, false, ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode]
[), ), {, return, true, ;, }, }, return, false, ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ), {]
[;, }, }, return, false, ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ), {, return, constructorCallHasSideEffects, (, callNode, ,]
[;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ), {, return, constructorCallHasSideEffects, (, callNode, ,, null, ), ;, }, static]
[;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ,, AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isNew, (]
[,, null, ), ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ,, AbstractCompiler, compiler, ), {, if, (, !, callNode]
[), ;, }, static, boolean, constructorCallHasSideEffects, (, Node, callNode, ,, AbstractCompiler, compiler, ), {, if, (, !, callNode, ., isNew]
[), {, throw, new, IllegalStateException, (, "Expected NEW node, got ", +, Token, ., name, (, callNode, ., getType, (, ), ), ), ;]
[), {, throw, new, IllegalStateException, (, "Expected NEW node, got ", +, Token, ., name, (, callNode, ., getType, (, ), ), ), ;]
[., isNew, (, ), ), {, throw, new, IllegalStateException, (, "Expected NEW node, got ", +, Token, ., name, (, callNode, ., getType, (]
[;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode, .]
[), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode]
[+, Token, ., name, (, callNode, ., getType, (, ), ), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (]
[), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode]
[., name, (, callNode, ., getType, (, ), ), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), )]
[), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =]
[., getType, (, ), ), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;]
[), {, return, false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName]
[., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if]
[;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS]
[;, if, (, nameNode, ., isName, (, ), &&, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, ., contains, (, nameNode, ., getString, (, ), ), )]
[., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), &&, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, ., contains, (, nameNode, ., getString]
[), {, return, false, ;, }, return, true, ;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet]
[&&, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, ., contains, (, nameNode, ., getString, (, ), ), ), {, return, false, ;, }, return, true, ;]
[., isName, (, ), &&, CONSTRUCTORS_WITHOUT_SIDE_EFFECTS, ., contains, (, nameNode, ., getString, (, ), ), ), {, return, false, ;]
[), {, return, false, ;, }, return, true, ;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet]
[., contains, (, nameNode, ., getString, (, ), ), ), {, return, false, ;, }, return, true, ;, }, private]
[), ), {, return, false, ;, }, return, true, ;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =]
[., getString, (, ), ), ), {, return, false, ;, }, return, true, ;, }, private, static, final, Set, <]
[;, }, return, true, ;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "Object"]
[;, }, private, static, final, Set, <, String, >, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "Object", ,, "Array", ,, "String"]
[;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "toString", ,, "valueOf", ), ;, private]
[., of, (, "Object", ,, "Array", ,, "String", ,, "Number", ,, "Boolean", ,, "RegExp", ,, "Error", ), ;, private, static]
[,, "Array", ,, "String", ,, "Number", ,, "Boolean", ,, "RegExp", ,, "Error", ), ;, private, static, final, Set, <, String]
[,, "String", ,, "Number", ,, "Boolean", ,, "RegExp", ,, "Error", ), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS]
[,, "Number", ,, "Boolean", ,, "RegExp", ,, "Error", ), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet]
[,, "Boolean", ,, "RegExp", ,, "Error", ), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of]
[,, "RegExp", ,, "Error", ), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "toString"]
[,, "Error", ), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "toString", ,, "valueOf"]
[), ;, private, static, final, Set, <, String, >, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, =, ImmutableSet, ., of, (, "toString", ,, "valueOf", ), ;]
[;, private, static, final, Set, <, String, >, REGEXP_METHODS, =, ImmutableSet, ., of, (, "test", ,, "exec", ), ;, private]
[., of, (, "toString", ,, "valueOf", ), ;, private, static, final, Set, <, String, >, REGEXP_METHODS, =, ImmutableSet, ., of]
[,, "valueOf", ), ;, private, static, final, Set, <, String, >, REGEXP_METHODS, =, ImmutableSet, ., of, (, "test", ,, "exec"]
[), ;, private, static, final, Set, <, String, >, REGEXP_METHODS, =, ImmutableSet, ., of, (, "test", ,, "exec", ), ;]
[;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =, ImmutableSet, ., of, (, "match", ,, "replace", ,, "search", ,]
[., of, (, "test", ,, "exec", ), ;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =, ImmutableSet, ., of]
[,, "exec", ), ;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =, ImmutableSet, ., of, (, "match", ,, "replace"]
[), ;, private, static, final, Set, <, String, >, STRING_REGEXP_METHODS, =, ImmutableSet, ., of, (, "match", ,, "replace", ,, "search"]
[;, static, boolean, functionCallHasSideEffects, (, Node, callNode, ), {, return, functionCallHasSideEffects, (, callNode, ,, null, ), ;, }, static, boolean]
[., of, (, "match", ,, "replace", ,, "search", ,, "split", ), ;, static, boolean, functionCallHasSideEffects, (, Node, callNode, ), {]
[,, "replace", ,, "search", ,, "split", ), ;, static, boolean, functionCallHasSideEffects, (, Node, callNode, ), {, return, functionCallHasSideEffects, (, callNode]
[,, "search", ,, "split", ), ;, static, boolean, functionCallHasSideEffects, (, Node, callNode, ), {, return, functionCallHasSideEffects, (, callNode, ,, null]
[,, "split", ), ;, static, boolean, functionCallHasSideEffects, (, Node, callNode, ), {, return, functionCallHasSideEffects, (, callNode, ,, null, ), ;]
[), ;, static, boolean, functionCallHasSideEffects, (, Node, callNode, ), {, return, functionCallHasSideEffects, (, callNode, ,, null, ), ;, }, static]
[;, }, static, boolean, functionCallHasSideEffects, (, Node, callNode, ,, @, Nullable, AbstractCompiler, compiler, ), {, if, (, !, callNode, .]
[,, null, ), ;, }, static, boolean, functionCallHasSideEffects, (, Node, callNode, ,, @, Nullable, AbstractCompiler, compiler, ), {, if, (]
[), ;, }, static, boolean, functionCallHasSideEffects, (, Node, callNode, ,, @, Nullable, AbstractCompiler, compiler, ), {, if, (, !, callNode]
[), {, throw, new, IllegalStateException, (, "Expected CALL node, got ", +, Token, ., name, (, callNode, ., getType, (, ), ), ), ;]
[), {, throw, new, IllegalStateException, (, "Expected CALL node, got ", +, Token, ., name, (, callNode, ., getType, (, ), ), ), ;]
[., isCall, (, ), ), {, throw, new, IllegalStateException, (, "Expected CALL node, got ", +, Token, ., name, (, callNode, ., getType, (]
[;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode, .]
[), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode]
[+, Token, ., name, (, callNode, ., getType, (, ), ), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (]
[), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode]
[., name, (, callNode, ., getType, (, ), ), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), )]
[), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =]
[., getType, (, ), ), ), ;, }, if, (, callNode, ., isNoSideEffectsCall, (, ), ), {, return, false, ;]
[), {, return, false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName]
[., isNoSideEffectsCall, (, ), ), {, return, false, ;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if]
[;, }, Node, nameNode, =, callNode, ., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), ), {]
[;, if, (, nameNode, ., isName, (, ), ), {, String, name, =, nameNode, ., getString, (, ), ;, if]
[., getFirstChild, (, ), ;, if, (, nameNode, ., isName, (, ), ), {, String, name, =, nameNode, ., getString]
[), {, String, name, =, nameNode, ., getString, (, ), ;, if, (, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, ., contains, (, name, ), )]
[., isName, (, ), ), {, String, name, =, nameNode, ., getString, (, ), ;, if, (, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, ., contains]
[;, if, (, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, ., contains, (, name, ), ), {, return, false, ;, }, }, else, if, (, nameNode]
[., getString, (, ), ;, if, (, BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS, ., contains, (, name, ), ), {, return, false, ;, }, }]
[), {, return, false, ;, }, }, else, if, (, nameNode, ., isGetProp, (, ), ), {, if, (, callNode]
[., contains, (, name, ), ), {, return, false, ;, }, }, else, if, (, nameNode, ., isGetProp, (, )]
[), ), {, return, false, ;, }, }, else, if, (, nameNode, ., isGetProp, (, ), ), {, if, (]
[;, }, }, else, if, (, nameNode, ., isGetProp, (, ), ), {, if, (, callNode, ., hasOneChild, (, )]
[), {, if, (, callNode, ., hasOneChild, (, ), &&, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, ., contains, (, nameNode, ., getLastChild, (, ), .]
[., isGetProp, (, ), ), {, if, (, callNode, ., hasOneChild, (, ), &&, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, ., contains, (, nameNode, .]
[), {, return, false, ;, }, if, (, callNode, ., isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (, nameNode, ., getFirstChild, (]
[&&, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;]
[., hasOneChild, (, ), &&, OBJECT_METHODS_WITHOUT_SIDEEFFECTS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), )]
[), {, return, false, ;, }, if, (, callNode, ., isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (, nameNode, ., getFirstChild, (]
[., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, if]
[), ), {, return, false, ;, }, if, (, callNode, ., isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (, nameNode, ., getFirstChild]
[., getString, (, ), ), ), {, return, false, ;, }, if, (, callNode, ., isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue]
[., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, if, (, callNode, ., isOnlyModifiesThisCall]
[;, }, if, (, callNode, ., isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (, nameNode, ., getFirstChild, (, ), ), ), {]
[), {, return, false, ;, }, if, (, nameNode, ., getFirstChild, (, ), ., isName, (, ), ), {, if]
[&&, evaluatesToLocalValue, (, nameNode, ., getFirstChild, (, ), ), ), {, return, false, ;, }, if, (, nameNode, ., getFirstChild]
[., isOnlyModifiesThisCall, (, ), &&, evaluatesToLocalValue, (, nameNode, ., getFirstChild, (, ), ), ), {, return, false, ;, }, if]
[), {, return, false, ;, }, if, (, nameNode, ., getFirstChild, (, ), ., isName, (, ), ), {, if]
[), ), {, return, false, ;, }, if, (, nameNode, ., getFirstChild, (, ), ., isName, (, ), ), {]
[., getFirstChild, (, ), ), ), {, return, false, ;, }, if, (, nameNode, ., getFirstChild, (, ), ., isName]
[;, }, if, (, nameNode, ., getFirstChild, (, ), ., isName, (, ), ), {, if, (, "Math.floor", ., equals]
[), {, if, (, "Math.floor", ., equals, (, nameNode, ., getQualifiedName, (, ), ), ), {, return, false, ;, }]
[., isName, (, ), ), {, if, (, "Math.floor", ., equals, (, nameNode, ., getQualifiedName, (, ), ), ), {]
[., getFirstChild, (, ), ., isName, (, ), ), {, if, (, "Math.floor", ., equals, (, nameNode, ., getQualifiedName, (]
[), {, return, false, ;, }, }, if, (, compiler, !=, null, &&, !, compiler, ., hasRegExpGlobalReferences, (, ), )]
[., equals, (, nameNode, ., getQualifiedName, (, ), ), ), {, return, false, ;, }, }, if, (, compiler, !=]
[), ), {, return, false, ;, }, }, if, (, compiler, !=, null, &&, !, compiler, ., hasRegExpGlobalReferences, (, )]
[., getQualifiedName, (, ), ), ), {, return, false, ;, }, }, if, (, compiler, !=, null, &&, !, compiler]
[;, }, }, if, (, compiler, !=, null, &&, !, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (, nameNode]
[), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, ), &&, REGEXP_METHODS, ., contains, (, nameNode, .]
[&&, !, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, )]
[!=, null, &&, !, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp]
[&&, !, compiler, ., hasRegExpGlobalReferences, (, ), ), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, )]
[), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, ), &&, REGEXP_METHODS, ., contains, (, nameNode, .]
[), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, ), &&, REGEXP_METHODS, ., contains, (, nameNode, .]
[., hasRegExpGlobalReferences, (, ), ), {, if, (, nameNode, ., getFirstChild, (, ), ., isRegExp, (, ), &&, REGEXP_METHODS, .]
[), {, return, false, ;, }, else, if, (, nameNode, ., getFirstChild, (, ), ., isString, (, ), &&, STRING_REGEXP_METHODS]
[&&, REGEXP_METHODS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;]
[., isRegExp, (, ), &&, REGEXP_METHODS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), )]
[., getFirstChild, (, ), ., isRegExp, (, ), &&, REGEXP_METHODS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString]
[), {, return, false, ;, }, else, if, (, nameNode, ., getFirstChild, (, ), ., isString, (, ), &&, STRING_REGEXP_METHODS]
[., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, else]
[), ), {, return, false, ;, }, else, if, (, nameNode, ., getFirstChild, (, ), ., isString, (, ), &&]
[., getString, (, ), ), ), {, return, false, ;, }, else, if, (, nameNode, ., getFirstChild, (, ), .]
[., getLastChild, (, ), ., getString, (, ), ), ), {, return, false, ;, }, else, if, (, nameNode, .]
[;, }, else, if, (, nameNode, ., getFirstChild, (, ), ., isString, (, ), &&, STRING_REGEXP_METHODS, ., contains, (, nameNode]
[), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (, param, !=, null, &&, (, param, .]
[&&, STRING_REGEXP_METHODS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, Node, param, =]
[., isString, (, ), &&, STRING_REGEXP_METHODS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), )]
[., getFirstChild, (, ), ., isString, (, ), &&, STRING_REGEXP_METHODS, ., contains, (, nameNode, ., getLastChild, (, ), ., getString]
[), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (, param, !=, null, &&, (, param, .]
[., contains, (, nameNode, ., getLastChild, (, ), ., getString, (, ), ), ), {, Node, param, =, nameNode, .]
[), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (, param, !=, null, &&, (, param]
[., getString, (, ), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;, if, (, param, !=]
[., getLastChild, (, ), ., getString, (, ), ), ), {, Node, param, =, nameNode, ., getNext, (, ), ;]
[;, if, (, param, !=, null, &&, (, param, ., isString, (, ), ||, param, ., isRegExp, (, ), )]
[., getNext, (, ), ;, if, (, param, !=, null, &&, (, param, ., isString, (, ), ||, param, .]
[), {, return, false, ;, }, }, }, }, return, true, ;, }, static, boolean, callHasLocalResult, (, Node, n, )]
[&&, (, param, ., isString, (, ), ||, param, ., isRegExp, (, ), ), ), {, return, false, ;, }]
[!=, null, &&, (, param, ., isString, (, ), ||, param, ., isRegExp, (, ), ), ), {, return, false]
[&&, (, param, ., isString, (, ), ||, param, ., isRegExp, (, ), ), ), {, return, false, ;, }]
[), {, return, false, ;, }, }, }, }, return, true, ;, }, static, boolean, callHasLocalResult, (, Node, n, )]
[), ), {, return, false, ;, }, }, }, }, return, true, ;, }, static, boolean, callHasLocalResult, (, Node, n]
[||, param, ., isRegExp, (, ), ), ), {, return, false, ;, }, }, }, }, return, true, ;, }]
[., isString, (, ), ||, param, ., isRegExp, (, ), ), ), {, return, false, ;, }, }, }, }]
[), ), {, return, false, ;, }, }, }, }, return, true, ;, }, static, boolean, callHasLocalResult, (, Node, n]
[., isRegExp, (, ), ), ), {, return, false, ;, }, }, }, }, return, true, ;, }, static, boolean]
[;, }, }, }, }, return, true, ;, }, static, boolean, callHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState]
[;, }, static, boolean, callHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), )]
[;, return, (, n, ., getSideEffectFlags, (, ), &, Node, ., FLAG_LOCAL_RESULTS, ), >, 0, ;, }, static, boolean, newHasLocalResult]
[., checkState, (, n, ., isCall, (, ), ), ;, return, (, n, ., getSideEffectFlags, (, ), &, Node, .]
[), ;, return, (, n, ., getSideEffectFlags, (, ), &, Node, ., FLAG_LOCAL_RESULTS, ), >, 0, ;, }, static, boolean]
[., isCall, (, ), ), ;, return, (, n, ., getSideEffectFlags, (, ), &, Node, ., FLAG_LOCAL_RESULTS, ), >, 0]
[;, }, static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew, (, ), )]
[>, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew, (]
[), >, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew]
[&, Node, ., FLAG_LOCAL_RESULTS, ), >, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState]
[., getSideEffectFlags, (, ), &, Node, ., FLAG_LOCAL_RESULTS, ), >, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, )]
[), >, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew]
[., FLAG_LOCAL_RESULTS, ), >, 0, ;, }, static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n]
[;, }, static, boolean, newHasLocalResult, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew, (, ), )]
[;, return, n, ., isOnlyModifiesThisCall, (, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ), {, return, nodeTypeMayHaveSideEffects, (]
[., checkState, (, n, ., isNew, (, ), ), ;, return, n, ., isOnlyModifiesThisCall, (, ), ;, }, static, boolean]
[), ;, return, n, ., isOnlyModifiesThisCall, (, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ), {, return, nodeTypeMayHaveSideEffects]
[., isNew, (, ), ), ;, return, n, ., isOnlyModifiesThisCall, (, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n]
[;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ), {, return, nodeTypeMayHaveSideEffects, (, n, ,, null, ), ;, }, static]
[., isOnlyModifiesThisCall, (, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ), {, return, nodeTypeMayHaveSideEffects, (, n, ,, null]
[;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, if, (, isAssignmentOp, (, n, ), )]
[,, null, ), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, if, (, isAssignmentOp, (]
[), ;, }, static, boolean, nodeTypeMayHaveSideEffects, (, Node, n, ,, AbstractCompiler, compiler, ), {, if, (, isAssignmentOp, (, n, )]
[), {, return, true, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., DELPROP, :]
[), ), {, return, true, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., DELPROP]
[;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., DELPROP, :, case, Token, ., DEC]
[), {, case, Token, ., DELPROP, :, case, Token, ., DEC, :, case, Token, ., INC, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., DELPROP, :, case, Token, ., DEC, :, case, Token, ., INC]
[:, case, Token, ., DEC, :, case, Token, ., INC, :, case, Token, ., THROW, :, return, true, ;, case]
[., DELPROP, :, case, Token, ., DEC, :, case, Token, ., INC, :, case, Token, ., THROW, :, return, true]
[:, case, Token, ., INC, :, case, Token, ., THROW, :, return, true, ;, case, Token, ., CALL, :, return]
[., DEC, :, case, Token, ., INC, :, case, Token, ., THROW, :, return, true, ;, case, Token, ., CALL]
[:, case, Token, ., THROW, :, return, true, ;, case, Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n]
[., INC, :, case, Token, ., THROW, :, return, true, ;, case, Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects]
[:, return, true, ;, case, Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case]
[., THROW, :, return, true, ;, case, Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, )]
[;, case, Token, ., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NEW]
[:, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects]
[., CALL, :, return, NodeUtil, ., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NEW, :, return, NodeUtil]
[;, case, Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NAME]
[., functionCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,]
[,, compiler, ), ;, case, Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case]
[), ;, case, Token, ., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, .]
[:, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NAME, :, return, n, ., hasChildren]
[., NEW, :, return, NodeUtil, ., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NAME, :, return, n]
[;, case, Token, ., NAME, :, return, n, ., hasChildren, (, ), ;, default, :, return, false, ;, }, }]
[., constructorCallHasSideEffects, (, n, ,, compiler, ), ;, case, Token, ., NAME, :, return, n, ., hasChildren, (, ), ;]
[,, compiler, ), ;, case, Token, ., NAME, :, return, n, ., hasChildren, (, ), ;, default, :, return, false]
[), ;, case, Token, ., NAME, :, return, n, ., hasChildren, (, ), ;, default, :, return, false, ;, }]
[:, return, n, ., hasChildren, (, ), ;, default, :, return, false, ;, }, }, static, boolean, canBeSideEffected, (, Node]
[., NAME, :, return, n, ., hasChildren, (, ), ;, default, :, return, false, ;, }, }, static, boolean, canBeSideEffected]
[;, default, :, return, false, ;, }, }, static, boolean, canBeSideEffected, (, Node, n, ), {, Set, <, String, >]
[., hasChildren, (, ), ;, default, :, return, false, ;, }, }, static, boolean, canBeSideEffected, (, Node, n, ), {]
[;, }, }, static, boolean, canBeSideEffected, (, Node, n, ), {, Set, <, String, >, emptySet, =, Collections, ., emptySet]
[;, return, canBeSideEffected, (, n, ,, emptySet, ), ;, }, static, boolean, canBeSideEffected, (, Node, n, ,, Set, <, String]
[., emptySet, (, ), ;, return, canBeSideEffected, (, n, ,, emptySet, ), ;, }, static, boolean, canBeSideEffected, (, Node, n]
[;, }, static, boolean, canBeSideEffected, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, switch, (, n, .]
[,, emptySet, ), ;, }, static, boolean, canBeSideEffected, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, switch]
[), ;, }, static, boolean, canBeSideEffected, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, switch, (, n]
[), {, case, Token, ., CALL, :, case, Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :]
[., getType, (, ), ), {, case, Token, ., CALL, :, case, Token, ., NEW, :, return, true, ;, case]
[:, case, Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (, n, )]
[., CALL, :, case, Token, ., NEW, :, return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (]
[:, return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (, n, ), &&, !, knownConstants, ., contains]
[., NEW, :, return, true, ;, case, Token, ., NAME, :, return, !, isConstantName, (, n, ), &&, !, knownConstants]
[;, case, Token, ., NAME, :, return, !, isConstantName, (, n, ), &&, !, knownConstants, ., contains, (, n, .]
[:, return, !, isConstantName, (, n, ), &&, !, knownConstants, ., contains, (, n, ., getString, (, ), ), ;]
[., NAME, :, return, !, isConstantName, (, n, ), &&, !, knownConstants, ., contains, (, n, ., getString, (, )]
[;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :, Preconditions]
[&&, !, knownConstants, ., contains, (, n, ., getString, (, ), ), ;, case, Token, ., GETPROP, :, case, Token]
[&&, !, knownConstants, ., contains, (, n, ., getString, (, ), ), ;, case, Token, ., GETPROP, :, case, Token]
[), &&, !, knownConstants, ., contains, (, n, ., getString, (, ), ), ;, case, Token, ., GETPROP, :, case]
[;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :, Preconditions]
[;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :, Preconditions]
[., contains, (, n, ., getString, (, ), ), ;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :]
[), ;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :]
[., getString, (, ), ), ;, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case]
[:, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (, isFunctionExpression, (]
[., GETPROP, :, case, Token, ., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (]
[:, return, true, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (, isFunctionExpression, (, n, ), ), ;, return]
[., GETELEM, :, return, true, ;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (, isFunctionExpression, (, n, ), )]
[;, case, Token, ., FUNCTION, :, Preconditions, ., checkState, (, isFunctionExpression, (, n, ), ), ;, return, false, ;, }]
[:, Preconditions, ., checkState, (, isFunctionExpression, (, n, ), ), ;, return, false, ;, }, for, (, Node, c, =]
[., FUNCTION, :, Preconditions, ., checkState, (, isFunctionExpression, (, n, ), ), ;, return, false, ;, }, for, (, Node]
[;, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;]
[., checkState, (, isFunctionExpression, (, n, ), ), ;, return, false, ;, }, for, (, Node, c, =, n, .]
[), ;, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null]
[), ), ;, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, canBeSideEffected, (, c, ,]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, canBeSideEffected, (, c, ,, knownConstants, ), ), {]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, canBeSideEffected, (, c, ,, knownConstants, )]
[;, c, =, c, ., getNext, (, ), ), {, if, (, canBeSideEffected, (, c, ,, knownConstants, ), ), {]
[=, c, ., getNext, (, ), ), {, if, (, canBeSideEffected, (, c, ,, knownConstants, ), ), {, return, true]
[), {, if, (, canBeSideEffected, (, c, ,, knownConstants, ), ), {, return, true, ;, }, }, return, false, ;]
[., getNext, (, ), ), {, if, (, canBeSideEffected, (, c, ,, knownConstants, ), ), {, return, true, ;, }]
[), {, return, true, ;, }, }, return, false, ;, }, static, int, precedence, (, int, type, ), {, switch]
[,, knownConstants, ), ), {, return, true, ;, }, }, return, false, ;, }, static, int, precedence, (, int, type]
[), ), {, return, true, ;, }, }, return, false, ;, }, static, int, precedence, (, int, type, ), {]
[;, }, }, return, false, ;, }, static, int, precedence, (, int, type, ), {, switch, (, type, ), {]
[;, }, static, int, precedence, (, int, type, ), {, switch, (, type, ), {, case, Token, ., COMMA, :]
[), {, case, Token, ., COMMA, :, return, 0, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :]
[:, return, 0, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[., COMMA, :, return, 0, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND]
[;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH]
[:, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH]
[., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token]
[:, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH]
[., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token]
[:, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD]
[., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token]
[:, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB]
[., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token]
[:, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL]
[., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token]
[:, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV]
[., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token]
[:, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD]
[., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token]
[:, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN]
[., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case, Token]
[:, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1, ;, case]
[., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1]
[:, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1, ;, case, Token, ., HOOK, :, return]
[., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1, ;, case, Token, ., HOOK]
[:, case, Token, ., ASSIGN, :, return, 1, ;, case, Token, ., HOOK, :, return, 2, ;, case, Token, .]
[., ASSIGN_MOD, :, case, Token, ., ASSIGN, :, return, 1, ;, case, Token, ., HOOK, :, return, 2, ;, case]
[:, return, 1, ;, case, Token, ., HOOK, :, return, 2, ;, case, Token, ., OR, :, return, 3, ;]
[., ASSIGN, :, return, 1, ;, case, Token, ., HOOK, :, return, 2, ;, case, Token, ., OR, :, return]
[;, case, Token, ., HOOK, :, return, 2, ;, case, Token, ., OR, :, return, 3, ;, case, Token, .]
[:, return, 2, ;, case, Token, ., OR, :, return, 3, ;, case, Token, ., AND, :, return, 4, ;]
[., HOOK, :, return, 2, ;, case, Token, ., OR, :, return, 3, ;, case, Token, ., AND, :, return]
[;, case, Token, ., OR, :, return, 3, ;, case, Token, ., AND, :, return, 4, ;, case, Token, .]
[:, return, 3, ;, case, Token, ., AND, :, return, 4, ;, case, Token, ., BITOR, :, return, 5, ;]
[., OR, :, return, 3, ;, case, Token, ., AND, :, return, 4, ;, case, Token, ., BITOR, :, return]
[;, case, Token, ., AND, :, return, 4, ;, case, Token, ., BITOR, :, return, 5, ;, case, Token, .]
[:, return, 4, ;, case, Token, ., BITOR, :, return, 5, ;, case, Token, ., BITXOR, :, return, 6, ;]
[., AND, :, return, 4, ;, case, Token, ., BITOR, :, return, 5, ;, case, Token, ., BITXOR, :, return]
[;, case, Token, ., BITOR, :, return, 5, ;, case, Token, ., BITXOR, :, return, 6, ;, case, Token, .]
[:, return, 5, ;, case, Token, ., BITXOR, :, return, 6, ;, case, Token, ., BITAND, :, return, 7, ;]
[., BITOR, :, return, 5, ;, case, Token, ., BITXOR, :, return, 6, ;, case, Token, ., BITAND, :, return]
[;, case, Token, ., BITXOR, :, return, 6, ;, case, Token, ., BITAND, :, return, 7, ;, case, Token, .]
[:, return, 6, ;, case, Token, ., BITAND, :, return, 7, ;, case, Token, ., EQ, :, case, Token, .]
[., BITXOR, :, return, 6, ;, case, Token, ., BITAND, :, return, 7, ;, case, Token, ., EQ, :, case]
[;, case, Token, ., BITAND, :, return, 7, ;, case, Token, ., EQ, :, case, Token, ., NE, :, case]
[:, return, 7, ;, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[., BITAND, :, return, 7, ;, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ]
[;, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE]
[:, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, 8, ;, case]
[., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, 8]
[:, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, 8, ;, case, Token, ., LT, :, case]
[., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, 8, ;, case, Token, ., LT]
[:, case, Token, ., SHNE, :, return, 8, ;, case, Token, ., LT, :, case, Token, ., GT, :, case]
[., SHEQ, :, case, Token, ., SHNE, :, return, 8, ;, case, Token, ., LT, :, case, Token, ., GT]
[:, return, 8, ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[., SHNE, :, return, 8, ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE]
[;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE]
[:, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., INSTANCEOF]
[., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token]
[:, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., INSTANCEOF, :, case, Token, ., IN]
[., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., INSTANCEOF, :, case, Token]
[:, case, Token, ., GE, :, case, Token, ., INSTANCEOF, :, case, Token, ., IN, :, return, 9, ;, case]
[., LE, :, case, Token, ., GE, :, case, Token, ., INSTANCEOF, :, case, Token, ., IN, :, return, 9]
[:, case, Token, ., INSTANCEOF, :, case, Token, ., IN, :, return, 9, ;, case, Token, ., LSH, :, case]
[., GE, :, case, Token, ., INSTANCEOF, :, case, Token, ., IN, :, return, 9, ;, case, Token, ., LSH]
[:, case, Token, ., IN, :, return, 9, ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case]
[., INSTANCEOF, :, case, Token, ., IN, :, return, 9, ;, case, Token, ., LSH, :, case, Token, ., RSH]
[:, return, 9, ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return]
[., IN, :, return, 9, ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH]
[;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, 10, ;, case]
[:, case, Token, ., RSH, :, case, Token, ., URSH, :, return, 10, ;, case, Token, ., SUB, :, case]
[., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, 10, ;, case, Token, ., SUB]
[:, case, Token, ., URSH, :, return, 10, ;, case, Token, ., SUB, :, case, Token, ., ADD, :, return]
[., RSH, :, case, Token, ., URSH, :, return, 10, ;, case, Token, ., SUB, :, case, Token, ., ADD]
[:, return, 10, ;, case, Token, ., SUB, :, case, Token, ., ADD, :, return, 11, ;, case, Token, .]
[., URSH, :, return, 10, ;, case, Token, ., SUB, :, case, Token, ., ADD, :, return, 11, ;, case]
[;, case, Token, ., SUB, :, case, Token, ., ADD, :, return, 11, ;, case, Token, ., MUL, :, case]
[:, case, Token, ., ADD, :, return, 11, ;, case, Token, ., MUL, :, case, Token, ., MOD, :, case]
[., SUB, :, case, Token, ., ADD, :, return, 11, ;, case, Token, ., MUL, :, case, Token, ., MOD]
[:, return, 11, ;, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, return]
[., ADD, :, return, 11, ;, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV]
[;, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, return, 12, ;, case]
[:, case, Token, ., MOD, :, case, Token, ., DIV, :, return, 12, ;, case, Token, ., INC, :, case]
[., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, return, 12, ;, case, Token, ., INC]
[:, case, Token, ., DIV, :, return, 12, ;, case, Token, ., INC, :, case, Token, ., DEC, :, case]
[., MOD, :, case, Token, ., DIV, :, return, 12, ;, case, Token, ., INC, :, case, Token, ., DEC]
[:, return, 12, ;, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., NEW, :, case]
[., DIV, :, return, 12, ;, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., NEW]
[;, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., NEW, :, case, Token, ., DELPROP]
[:, case, Token, ., DEC, :, case, Token, ., NEW, :, case, Token, ., DELPROP, :, case, Token, ., TYPEOF]
[., INC, :, case, Token, ., DEC, :, case, Token, ., NEW, :, case, Token, ., DELPROP, :, case, Token]
[:, case, Token, ., NEW, :, case, Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case, Token, ., VOID]
[., DEC, :, case, Token, ., NEW, :, case, Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case, Token]
[:, case, Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., NOT]
[., NEW, :, case, Token, ., DELPROP, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token]
[:, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., NOT, :, case, Token, ., BITNOT]
[., DELPROP, :, case, Token, ., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., NOT, :, case, Token]
[:, case, Token, ., VOID, :, case, Token, ., NOT, :, case, Token, ., BITNOT, :, case, Token, ., POS]
[., TYPEOF, :, case, Token, ., VOID, :, case, Token, ., NOT, :, case, Token, ., BITNOT, :, case, Token]
[:, case, Token, ., NOT, :, case, Token, ., BITNOT, :, case, Token, ., POS, :, case, Token, ., NEG]
[., VOID, :, case, Token, ., NOT, :, case, Token, ., BITNOT, :, case, Token, ., POS, :, case, Token]
[:, case, Token, ., BITNOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, return, 13, ;, case]
[., NOT, :, case, Token, ., BITNOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, return, 13]
[:, case, Token, ., POS, :, case, Token, ., NEG, :, return, 13, ;, case, Token, ., CALL, :, case]
[., BITNOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, return, 13, ;, case, Token, ., CALL]
[:, case, Token, ., NEG, :, return, 13, ;, case, Token, ., CALL, :, case, Token, ., GETELEM, :, case]
[., POS, :, case, Token, ., NEG, :, return, 13, ;, case, Token, ., CALL, :, case, Token, ., GETELEM]
[:, return, 13, ;, case, Token, ., CALL, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case]
[., NEG, :, return, 13, ;, case, Token, ., CALL, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP]
[;, case, Token, ., CALL, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., ARRAYLIT]
[:, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case, Token, ., EMPTY]
[., CALL, :, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case, Token]
[:, case, Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case, Token, ., FALSE]
[., GETELEM, :, case, Token, ., GETPROP, :, case, Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case, Token]
[:, case, Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case, Token, ., FALSE, :, case, Token, ., FUNCTION]
[., GETPROP, :, case, Token, ., ARRAYLIT, :, case, Token, ., EMPTY, :, case, Token, ., FALSE, :, case, Token]
[:, case, Token, ., EMPTY, :, case, Token, ., FALSE, :, case, Token, ., FUNCTION, :, case, Token, ., NAME]
[., ARRAYLIT, :, case, Token, ., EMPTY, :, case, Token, ., FALSE, :, case, Token, ., FUNCTION, :, case, Token]
[:, case, Token, ., FALSE, :, case, Token, ., FUNCTION, :, case, Token, ., NAME, :, case, Token, ., NULL]
[., EMPTY, :, case, Token, ., FALSE, :, case, Token, ., FUNCTION, :, case, Token, ., NAME, :, case, Token]
[:, case, Token, ., FUNCTION, :, case, Token, ., NAME, :, case, Token, ., NULL, :, case, Token, ., NUMBER]
[., FALSE, :, case, Token, ., FUNCTION, :, case, Token, ., NAME, :, case, Token, ., NULL, :, case, Token]
[:, case, Token, ., NAME, :, case, Token, ., NULL, :, case, Token, ., NUMBER, :, case, Token, ., OBJECTLIT]
[., FUNCTION, :, case, Token, ., NAME, :, case, Token, ., NULL, :, case, Token, ., NUMBER, :, case, Token]
[:, case, Token, ., NULL, :, case, Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP]
[., NAME, :, case, Token, ., NULL, :, case, Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case, Token]
[:, case, Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., STRING]
[., NULL, :, case, Token, ., NUMBER, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token]
[:, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY]
[., NUMBER, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., STRING, :, case, Token]
[:, case, Token, ., REGEXP, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., THIS]
[., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token]
[:, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., THIS, :, case, Token, ., TRUE]
[., REGEXP, :, case, Token, ., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., THIS, :, case, Token]
[:, case, Token, ., STRING_KEY, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, return, 15, ;, case]
[., STRING, :, case, Token, ., STRING_KEY, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, return, 15]
[:, case, Token, ., THIS, :, case, Token, ., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return]
[., STRING_KEY, :, case, Token, ., THIS, :, case, Token, ., TRUE, :, return, 15, ;, case, Token, ., CAST]
[:, case, Token, ., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw]
[., THIS, :, case, Token, ., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default]
[:, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (, "Unknown precedence for ", +]
[., TRUE, :, return, 15, ;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (]
[;, case, Token, ., CAST, :, return, 16, ;, default, :, throw, new, Error, (, "Unknown precedence for ", +, Token, ., name]
[:, return, 16, ;, default, :, throw, new, Error, (, "Unknown precedence for ", +, Token, ., name, (, type, ), +, " (type "]
[., CAST, :, return, 16, ;, default, :, throw, new, Error, (, "Unknown precedence for ", +, Token, ., name, (, type, )]
[;, default, :, throw, new, Error, (, "Unknown precedence for ", +, Token, ., name, (, type, ), +, " (type ", +, type, +]
[;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (, n, ., getType, (, ), )]
[+, ")", ), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (, n, ., getType, (]
[+, type, +, ")", ), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (, n, .]
[+, " (type ", +, type, +, ")", ), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (]
[+, Token, ., name, (, type, ), +, " (type ", +, type, +, ")", ), ;, }, }, static, boolean, isUndefined]
[+, " (type ", +, type, +, ")", ), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (]
[., name, (, type, ), +, " (type ", +, type, +, ")", ), ;, }, }, static, boolean, isUndefined, (, Node]
[), +, " (type ", +, type, +, ")", ), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch]
[+, type, +, ")", ), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (, n, .]
[+, ")", ), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (, n, ., getType, (]
[), ;, }, }, static, boolean, isUndefined, (, Node, n, ), {, switch, (, n, ., getType, (, ), )]
[), {, case, Token, ., VOID, :, return, true, ;, case, Token, ., NAME, :, return, n, ., getString, (]
[., getType, (, ), ), {, case, Token, ., VOID, :, return, true, ;, case, Token, ., NAME, :, return]
[:, return, true, ;, case, Token, ., NAME, :, return, n, ., getString, (, ), ., equals, (, "undefined", )]
[., VOID, :, return, true, ;, case, Token, ., NAME, :, return, n, ., getString, (, ), ., equals, (]
[;, case, Token, ., NAME, :, return, n, ., getString, (, ), ., equals, (, "undefined", ), ;, }, return]
[:, return, n, ., getString, (, ), ., equals, (, "undefined", ), ;, }, return, false, ;, }, static, boolean]
[., NAME, :, return, n, ., getString, (, ), ., equals, (, "undefined", ), ;, }, return, false, ;, }]
[;, }, return, false, ;, }, static, boolean, isNullOrUndefined, (, Node, n, ), {, return, n, ., isNull, (, )]
[., equals, (, "undefined", ), ;, }, return, false, ;, }, static, boolean, isNullOrUndefined, (, Node, n, ), {, return]
[., getString, (, ), ., equals, (, "undefined", ), ;, }, return, false, ;, }, static, boolean, isNullOrUndefined, (, Node]
[), ;, }, return, false, ;, }, static, boolean, isNullOrUndefined, (, Node, n, ), {, return, n, ., isNull, (]
[;, }, static, boolean, isNullOrUndefined, (, Node, n, ), {, return, n, ., isNull, (, ), ||, isUndefined, (, n]
[;, }, static, final, Predicate, <, Node, >, IMMUTABLE_PREDICATE, =, new, Predicate, <, Node, >, (, ), {, @, Override]
[||, isUndefined, (, n, ), ;, }, static, final, Predicate, <, Node, >, IMMUTABLE_PREDICATE, =, new, Predicate, <, Node, >]
[., isNull, (, ), ||, isUndefined, (, n, ), ;, }, static, final, Predicate, <, Node, >, IMMUTABLE_PREDICATE, =, new]
[;, }, static, final, Predicate, <, Node, >, IMMUTABLE_PREDICATE, =, new, Predicate, <, Node, >, (, ), {, @, Override]
[), ;, }, static, final, Predicate, <, Node, >, IMMUTABLE_PREDICATE, =, new, Predicate, <, Node, >, (, ), {, @]
[;, static, boolean, isImmutableResult, (, Node, n, ), {, return, allResultsMatch, (, n, ,, IMMUTABLE_PREDICATE, ), ;, }, static, boolean]
[;, }, }, ;, static, boolean, isImmutableResult, (, Node, n, ), {, return, allResultsMatch, (, n, ,, IMMUTABLE_PREDICATE, ), ;]
[), ;, }, }, ;, static, boolean, isImmutableResult, (, Node, n, ), {, return, allResultsMatch, (, n, ,, IMMUTABLE_PREDICATE, )]
[;, }, static, boolean, allResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (, n, .]
[,, IMMUTABLE_PREDICATE, ), ;, }, static, boolean, allResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p, ), {, switch]
[), ;, }, static, boolean, allResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (, n]
[), {, case, Token, ., CAST, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case]
[., getType, (, ), ), {, case, Token, ., CAST, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,]
[:, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token]
[., CAST, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :]
[;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, ), ,]
[,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch, (, n, ., getLastChild]
[., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch]
[), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, )]
[:, case, Token, ., COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token]
[., ASSIGN, :, case, Token, ., COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;]
[:, return, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token]
[., COMMA, :, return, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :]
[;, case, Token, ., AND, :, case, Token, ., OR, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,]
[,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, allResultsMatch, (, n, ., getFirstChild]
[., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, allResultsMatch]
[), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, allResultsMatch, (, n, ., getFirstChild, (, )]
[:, case, Token, ., OR, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), &&, allResultsMatch, (]
[., AND, :, case, Token, ., OR, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), &&]
[:, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, )]
[., OR, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild]
[;, case, Token, ., HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p]
[&&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, allResultsMatch, (]
[,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :]
[., getFirstChild, (, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, allResultsMatch]
[;, case, Token, ., HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p]
[,, p, ), ;, case, Token, ., HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (]
[., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (]
[), ;, case, Token, ., HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,]
[:, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), &&, allResultsMatch, (, n]
[., HOOK, :, return, allResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), &&, allResultsMatch]
[;, default, :, return, p, ., apply, (, n, ), ;, }, }, static, boolean, anyResultsMatch, (, Node, n, ,]
[&&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return, p, ., apply, (, n]
[,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return, p, .]
[., getNext, (, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default]
[., getFirstChild, (, ), ., getNext, (, ), ,, p, ), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,]
[), &&, allResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return, p, ., apply, (]
[;, default, :, return, p, ., apply, (, n, ), ;, }, }, static, boolean, anyResultsMatch, (, Node, n, ,]
[,, p, ), ;, default, :, return, p, ., apply, (, n, ), ;, }, }, static, boolean, anyResultsMatch, (]
[., getLastChild, (, ), ,, p, ), ;, default, :, return, p, ., apply, (, n, ), ;, }, }]
[), ;, default, :, return, p, ., apply, (, n, ), ;, }, }, static, boolean, anyResultsMatch, (, Node, n]
[;, }, }, static, boolean, anyResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (, n]
[., apply, (, n, ), ;, }, }, static, boolean, anyResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p]
[), ;, }, }, static, boolean, anyResultsMatch, (, Node, n, ,, Predicate, <, Node, >, p, ), {, switch, (]
[), {, case, Token, ., CAST, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case]
[., getType, (, ), ), {, case, Token, ., CAST, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,]
[:, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token]
[., CAST, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :]
[;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,]
[,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch, (, n, ., getLastChild]
[., getFirstChild, (, ), ,, p, ), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch]
[), ;, case, Token, ., ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, )]
[:, case, Token, ., COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token]
[., ASSIGN, :, case, Token, ., COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;]
[:, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token]
[., COMMA, :, return, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :]
[;, case, Token, ., AND, :, case, Token, ., OR, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,]
[,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, anyResultsMatch, (, n, ., getFirstChild]
[., getLastChild, (, ), ,, p, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, anyResultsMatch]
[), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, anyResultsMatch, (, n, ., getFirstChild, (, )]
[:, case, Token, ., OR, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ||, anyResultsMatch, (]
[., AND, :, case, Token, ., OR, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ||]
[:, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, )]
[., OR, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild]
[;, case, Token, ., HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p]
[||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, anyResultsMatch, (]
[,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :]
[., getFirstChild, (, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case]
[), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, anyResultsMatch]
[;, case, Token, ., HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p]
[,, p, ), ;, case, Token, ., HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (]
[., getLastChild, (, ), ,, p, ), ;, case, Token, ., HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (]
[), ;, case, Token, ., HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,]
[:, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), ||, anyResultsMatch, (, n]
[., HOOK, :, return, anyResultsMatch, (, n, ., getFirstChild, (, ), ., getNext, (, ), ,, p, ), ||, anyResultsMatch]
[;, default, :, return, p, ., apply, (, n, ), ;, }, }, static, class, NumbericResultPredicate, implements, Predicate, <, Node]
[||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return, p, ., apply, (, n]
[,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return, p, .]
[., getNext, (, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default]
[., getFirstChild, (, ), ., getNext, (, ), ,, p, ), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,]
[), ||, anyResultsMatch, (, n, ., getLastChild, (, ), ,, p, ), ;, default, :, return, p, ., apply, (]
[;, default, :, return, p, ., apply, (, n, ), ;, }, }, static, class, NumbericResultPredicate, implements, Predicate, <, Node]
[,, p, ), ;, default, :, return, p, ., apply, (, n, ), ;, }, }, static, class, NumbericResultPredicate, implements]
[., getLastChild, (, ), ,, p, ), ;, default, :, return, p, ., apply, (, n, ), ;, }, }]
[), ;, default, :, return, p, ., apply, (, n, ), ;, }, }, static, class, NumbericResultPredicate, implements, Predicate, <]
[;, }, }, static, class, NumbericResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n]
[., apply, (, n, ), ;, }, }, static, class, NumbericResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public]
[), ;, }, }, static, class, NumbericResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node]
[;, }, }, static, final, NumbericResultPredicate, NUMBERIC_RESULT_PREDICATE, =, new, NumbericResultPredicate, (, ), ;, static, boolean, isNumericResult, (, Node, n, )]
[), ;, }, }, static, final, NumbericResultPredicate, NUMBERIC_RESULT_PREDICATE, =, new, NumbericResultPredicate, (, ), ;, static, boolean, isNumericResult, (, Node, n]
[;, static, boolean, isNumericResult, (, Node, n, ), {, return, allResultsMatch, (, n, ,, NUMBERIC_RESULT_PREDICATE, ), ;, }, static, boolean]
[;, }, static, boolean, isNumericResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[,, NUMBERIC_RESULT_PREDICATE, ), ;, }, static, boolean, isNumericResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, )]
[), ;, }, static, boolean, isNumericResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), {, case, Token, ., ADD, :, return, !, mayBeString, (, n, ., getFirstChild, (, ), ), &&, !, mayBeString]
[., getType, (, ), ), {, case, Token, ., ADD, :, return, !, mayBeString, (, n, ., getFirstChild, (, )]
[:, return, !, mayBeString, (, n, ., getFirstChild, (, ), ), &&, !, mayBeString, (, n, ., getLastChild, (, )]
[., ADD, :, return, !, mayBeString, (, n, ., getFirstChild, (, ), ), &&, !, mayBeString, (, n, ., getLastChild]
[;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND]
[&&, !, mayBeString, (, n, ., getLastChild, (, ), ), ;, case, Token, ., BITNOT, :, case, Token, ., BITOR]
[&&, !, mayBeString, (, n, ., getLastChild, (, ), ), ;, case, Token, ., BITNOT, :, case, Token, ., BITOR]
[), &&, !, mayBeString, (, n, ., getLastChild, (, ), ), ;, case, Token, ., BITNOT, :, case, Token, .]
[., getFirstChild, (, ), ), &&, !, mayBeString, (, n, ., getLastChild, (, ), ), ;, case, Token, ., BITNOT]
[;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND]
[;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND]
[), ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, .]
[., getLastChild, (, ), ), ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR]
[:, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH]
[., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token]
[:, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH]
[., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token]
[:, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH]
[., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token]
[:, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB]
[., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token]
[:, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL]
[., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token]
[:, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD]
[., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token]
[:, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV]
[., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token]
[:, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., INC]
[., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token]
[:, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., INC, :, case, Token, ., DEC]
[., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., INC, :, case, Token]
[:, case, Token, ., DIV, :, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., POS]
[., MOD, :, case, Token, ., DIV, :, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token]
[:, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., POS, :, case, Token, ., NEG]
[., DIV, :, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., POS, :, case, Token]
[:, case, Token, ., DEC, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., NUMBER]
[., INC, :, case, Token, ., DEC, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token]
[:, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., NUMBER, :, return, true, ;, case]
[., DEC, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., NUMBER, :, return, true]
[:, case, Token, ., NEG, :, case, Token, ., NUMBER, :, return, true, ;, case, Token, ., NAME, :, String]
[., POS, :, case, Token, ., NEG, :, case, Token, ., NUMBER, :, return, true, ;, case, Token, ., NAME]
[:, case, Token, ., NUMBER, :, return, true, ;, case, Token, ., NAME, :, String, name, =, n, ., getString]
[., NEG, :, case, Token, ., NUMBER, :, return, true, ;, case, Token, ., NAME, :, String, name, =, n]
[:, return, true, ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (]
[., NUMBER, :, return, true, ;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;]
[;, case, Token, ., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals]
[:, String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals, (, "NaN", ), ), {]
[., NAME, :, String, name, =, n, ., getString, (, ), ;, if, (, name, ., equals, (, "NaN", )]
[;, if, (, name, ., equals, (, "NaN", ), ), {, return, true, ;, }, if, (, name, ., equals]
[., getString, (, ), ;, if, (, name, ., equals, (, "NaN", ), ), {, return, true, ;, }, if]
[), {, return, true, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return, true, ;, }]
[., equals, (, "NaN", ), ), {, return, true, ;, }, if, (, name, ., equals, (, "Infinity", ), )]
[), ), {, return, true, ;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return, true, ;]
[;, }, if, (, name, ., equals, (, "Infinity", ), ), {, return, true, ;, }, return, false, ;, default]
[), {, return, true, ;, }, return, false, ;, default, :, return, false, ;, }, }, static, class, BooleanResultPredicate, implements]
[., equals, (, "Infinity", ), ), {, return, true, ;, }, return, false, ;, default, :, return, false, ;, }]
[), ), {, return, true, ;, }, return, false, ;, default, :, return, false, ;, }, }, static, class, BooleanResultPredicate]
[;, }, return, false, ;, default, :, return, false, ;, }, }, static, class, BooleanResultPredicate, implements, Predicate, <, Node, >]
[;, default, :, return, false, ;, }, }, static, class, BooleanResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public]
[;, }, }, static, class, BooleanResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n]
[;, }, }, static, final, BooleanResultPredicate, BOOLEAN_RESULT_PREDICATE, =, new, BooleanResultPredicate, (, ), ;, static, boolean, isBooleanResult, (, Node, n, )]
[), ;, }, }, static, final, BooleanResultPredicate, BOOLEAN_RESULT_PREDICATE, =, new, BooleanResultPredicate, (, ), ;, static, boolean, isBooleanResult, (, Node, n]
[;, static, boolean, isBooleanResult, (, Node, n, ), {, return, allResultsMatch, (, n, ,, BOOLEAN_RESULT_PREDICATE, ), ;, }, static, boolean]
[;, }, static, boolean, isBooleanResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[,, BOOLEAN_RESULT_PREDICATE, ), ;, }, static, boolean, isBooleanResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, )]
[), ;, }, static, boolean, isBooleanResultHelper, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), {, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., EQ, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., TRUE, :, case, Token, ., FALSE, :, case, Token, ., EQ]
[:, case, Token, ., FALSE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ]
[., TRUE, :, case, Token, ., FALSE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token]
[:, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE]
[., FALSE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token]
[:, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., LT]
[., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token]
[:, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., LT, :, case, Token, ., GT]
[., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., LT, :, case, Token]
[:, case, Token, ., SHNE, :, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE]
[., SHEQ, :, case, Token, ., SHNE, :, case, Token, ., LT, :, case, Token, ., GT, :, case, Token]
[:, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE]
[., SHNE, :, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token]
[:, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., IN]
[., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token]
[:, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., IN, :, case, Token, ., INSTANCEOF]
[., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., IN, :, case, Token]
[:, case, Token, ., GE, :, case, Token, ., IN, :, case, Token, ., INSTANCEOF, :, case, Token, ., NOT]
[., LE, :, case, Token, ., GE, :, case, Token, ., IN, :, case, Token, ., INSTANCEOF, :, case, Token]
[:, case, Token, ., IN, :, case, Token, ., INSTANCEOF, :, case, Token, ., NOT, :, case, Token, ., DELPROP]
[., GE, :, case, Token, ., IN, :, case, Token, ., INSTANCEOF, :, case, Token, ., NOT, :, case, Token]
[:, case, Token, ., INSTANCEOF, :, case, Token, ., NOT, :, case, Token, ., DELPROP, :, return, true, ;, default]
[., IN, :, case, Token, ., INSTANCEOF, :, case, Token, ., NOT, :, case, Token, ., DELPROP, :, return, true]
[:, case, Token, ., NOT, :, case, Token, ., DELPROP, :, return, true, ;, default, :, return, false, ;, }]
[., INSTANCEOF, :, case, Token, ., NOT, :, case, Token, ., DELPROP, :, return, true, ;, default, :, return, false]
[:, case, Token, ., DELPROP, :, return, true, ;, default, :, return, false, ;, }, }, static, class, MayBeStringResultPredicate, implements]
[., NOT, :, case, Token, ., DELPROP, :, return, true, ;, default, :, return, false, ;, }, }, static, class]
[:, return, true, ;, default, :, return, false, ;, }, }, static, class, MayBeStringResultPredicate, implements, Predicate, <, Node, >, {]
[., DELPROP, :, return, true, ;, default, :, return, false, ;, }, }, static, class, MayBeStringResultPredicate, implements, Predicate, <, Node]
[;, default, :, return, false, ;, }, }, static, class, MayBeStringResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public]
[;, }, }, static, class, MayBeStringResultPredicate, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n]
[;, }, }, static, final, MayBeStringResultPredicate, MAY_BE_STRING_PREDICATE, =, new, MayBeStringResultPredicate, (, ), ;, static, boolean, mayBeString, (, Node, n, )]
[), ;, }, }, static, final, MayBeStringResultPredicate, MAY_BE_STRING_PREDICATE, =, new, MayBeStringResultPredicate, (, ), ;, static, boolean, mayBeString, (, Node, n]
[;, static, boolean, mayBeString, (, Node, n, ), {, return, mayBeString, (, n, ,, true, ), ;, }, static, boolean]
[;, }, static, boolean, mayBeString, (, Node, n, ,, boolean, recurse, ), {, if, (, recurse, ), {, return, anyResultsMatch]
[,, true, ), ;, }, static, boolean, mayBeString, (, Node, n, ,, boolean, recurse, ), {, if, (, recurse, )]
[), ;, }, static, boolean, mayBeString, (, Node, n, ,, boolean, recurse, ), {, if, (, recurse, ), {, return]
[), {, return, anyResultsMatch, (, n, ,, MAY_BE_STRING_PREDICATE, ), ;, }, else, {, return, mayBeStringHelper, (, n, ), ;, }]
[;, }, else, {, return, mayBeStringHelper, (, n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {]
[,, MAY_BE_STRING_PREDICATE, ), ;, }, else, {, return, mayBeStringHelper, (, n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node]
[), ;, }, else, {, return, mayBeStringHelper, (, n, ), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, )]
[;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return, !, isNumericResult, (, n, ), &&, !, isBooleanResult]
[), ;, }, }, static, boolean, mayBeStringHelper, (, Node, n, ), {, return, !, isNumericResult, (, n, ), &&, !]
[;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :]
[&&, !, n, ., isNull, (, ), ;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (, type]
[&&, !, isUndefined, (, n, ), &&, !, n, ., isNull, (, ), ;, }, static, boolean, isAssociative, (, int]
[&&, !, isBooleanResult, (, n, ), &&, !, isUndefined, (, n, ), &&, !, n, ., isNull, (, ), ;]
[&&, !, isBooleanResult, (, n, ), &&, !, isUndefined, (, n, ), &&, !, n, ., isNull, (, ), ;]
[), &&, !, isBooleanResult, (, n, ), &&, !, isUndefined, (, n, ), &&, !, n, ., isNull, (, )]
[&&, !, isUndefined, (, n, ), &&, !, n, ., isNull, (, ), ;, }, static, boolean, isAssociative, (, int]
[&&, !, isUndefined, (, n, ), &&, !, n, ., isNull, (, ), ;, }, static, boolean, isAssociative, (, int]
[), &&, !, isUndefined, (, n, ), &&, !, n, ., isNull, (, ), ;, }, static, boolean, isAssociative, (]
[&&, !, n, ., isNull, (, ), ;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (, type]
[&&, !, n, ., isNull, (, ), ;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (, type]
[), &&, !, n, ., isNull, (, ), ;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (]
[;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :]
[;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (, type, ), {, case, Token, ., MUL, :]
[., isNull, (, ), ;, }, static, boolean, isAssociative, (, int, type, ), {, switch, (, type, ), {, case]
[), {, case, Token, ., MUL, :, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, .]
[:, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, ., BITOR, :, case, Token, ., BITXOR]
[., MUL, :, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, ., BITOR, :, case, Token]
[:, case, Token, ., OR, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND]
[., AND, :, case, Token, ., OR, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token]
[:, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default]
[., OR, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true]
[:, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default, :, return, false, ;, }]
[., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default, :, return, false]
[:, case, Token, ., BITAND, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isCommutative, (]
[., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean]
[:, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isCommutative, (, int, type, ), {, switch]
[., BITAND, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isCommutative, (, int, type, )]
[;, default, :, return, false, ;, }, }, static, boolean, isCommutative, (, int, type, ), {, switch, (, type, )]
[;, }, }, static, boolean, isCommutative, (, int, type, ), {, switch, (, type, ), {, case, Token, ., MUL]
[), {, case, Token, ., MUL, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, .]
[:, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default]
[., MUL, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true]
[:, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default, :, return, false, ;, }]
[., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default, :, return, false]
[:, case, Token, ., BITAND, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isAssignmentOp, (]
[., BITXOR, :, case, Token, ., BITAND, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean]
[:, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isAssignmentOp, (, Node, n, ), {, switch]
[., BITAND, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isAssignmentOp, (, Node, n, )]
[;, default, :, return, false, ;, }, }, static, boolean, isAssignmentOp, (, Node, n, ), {, switch, (, n, .]
[;, }, }, static, boolean, isAssignmentOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), {, case, Token, ., ASSIGN, :, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., ASSIGN, :, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR]
[:, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH]
[., ASSIGN, :, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token]
[:, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH]
[., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token]
[:, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH]
[., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token]
[:, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD]
[., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token]
[:, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB]
[., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token]
[:, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL]
[., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token]
[:, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV]
[., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token]
[:, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD]
[., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token]
[:, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, true, ;, }]
[., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, true]
[:, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, true, ;, }, return, false, ;, }, static]
[., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, true, ;, }, return, false, ;]
[:, case, Token, ., ASSIGN_MOD, :, return, true, ;, }, return, false, ;, }, static, int, getOpFromAssignmentOp, (, Node, n]
[., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, true, ;, }, return, false, ;, }, static, int, getOpFromAssignmentOp, (]
[:, return, true, ;, }, return, false, ;, }, static, int, getOpFromAssignmentOp, (, Node, n, ), {, switch, (, n]
[., ASSIGN_MOD, :, return, true, ;, }, return, false, ;, }, static, int, getOpFromAssignmentOp, (, Node, n, ), {, switch]
[;, }, return, false, ;, }, static, int, getOpFromAssignmentOp, (, Node, n, ), {, switch, (, n, ., getType, (]
[;, }, static, int, getOpFromAssignmentOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[), {, case, Token, ., ASSIGN_BITOR, :, return, Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return, Token, .]
[., getType, (, ), ), {, case, Token, ., ASSIGN_BITOR, :, return, Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR]
[:, return, Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND]
[., ASSIGN_BITOR, :, return, Token, ., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case, Token]
[;, case, Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND]
[., BITOR, ;, case, Token, ., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return, Token]
[:, return, Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH]
[., ASSIGN_BITXOR, :, return, Token, ., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case, Token]
[;, case, Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return, Token, ., LSH]
[., BITXOR, ;, case, Token, ., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return, Token]
[:, return, Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case, Token, ., ASSIGN_RSH]
[., ASSIGN_BITAND, :, return, Token, ., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case, Token]
[;, case, Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return, Token, ., RSH]
[., BITAND, ;, case, Token, ., ASSIGN_LSH, :, return, Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return, Token]
[:, return, Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case, Token, ., ASSIGN_URSH]
[., ASSIGN_LSH, :, return, Token, ., LSH, ;, case, Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case, Token]
[;, case, Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return, Token, ., URSH]
[., LSH, ;, case, Token, ., ASSIGN_RSH, :, return, Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return, Token]
[:, return, Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case, Token, ., ASSIGN_ADD]
[., ASSIGN_RSH, :, return, Token, ., RSH, ;, case, Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case, Token]
[;, case, Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return, Token, ., ADD]
[., RSH, ;, case, Token, ., ASSIGN_URSH, :, return, Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return, Token]
[:, return, Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case, Token, ., ASSIGN_SUB]
[., ASSIGN_URSH, :, return, Token, ., URSH, ;, case, Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case, Token]
[;, case, Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return, Token, ., SUB]
[., URSH, ;, case, Token, ., ASSIGN_ADD, :, return, Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return, Token]
[:, return, Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case, Token, ., ASSIGN_MUL]
[., ASSIGN_ADD, :, return, Token, ., ADD, ;, case, Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case, Token]
[;, case, Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return, Token, ., MUL]
[., ADD, ;, case, Token, ., ASSIGN_SUB, :, return, Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return, Token]
[:, return, Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case, Token, ., ASSIGN_DIV]
[., ASSIGN_SUB, :, return, Token, ., SUB, ;, case, Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case, Token]
[;, case, Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return, Token, ., DIV]
[., SUB, ;, case, Token, ., ASSIGN_MUL, :, return, Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return, Token]
[:, return, Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD]
[., ASSIGN_MUL, :, return, Token, ., MUL, ;, case, Token, ., ASSIGN_DIV, :, return, Token, ., DIV, ;, case, Token]
[;, case, Token, ., ASSIGN_DIV, :, return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD, :, return, Token, ., MOD]
[., MUL, ;, case, Token, ., ASSIGN_DIV, :, return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD, :, return, Token]
[:, return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD, :, return, Token, ., MOD, ;, }, throw, new, IllegalArgumentException]
[., ASSIGN_DIV, :, return, Token, ., DIV, ;, case, Token, ., ASSIGN_MOD, :, return, Token, ., MOD, ;, }, throw]
[;, case, Token, ., ASSIGN_MOD, :, return, Token, ., MOD, ;, }, throw, new, IllegalArgumentException, (, "Not an assignment op:", +, n, )]
[., DIV, ;, case, Token, ., ASSIGN_MOD, :, return, Token, ., MOD, ;, }, throw, new, IllegalArgumentException, (, "Not an assignment op:", +]
[:, return, Token, ., MOD, ;, }, throw, new, IllegalArgumentException, (, "Not an assignment op:", +, n, ), ;, }, static, boolean, containsFunction]
[., ASSIGN_MOD, :, return, Token, ., MOD, ;, }, throw, new, IllegalArgumentException, (, "Not an assignment op:", +, n, ), ;, }, static]
[;, }, throw, new, IllegalArgumentException, (, "Not an assignment op:", +, n, ), ;, }, static, boolean, containsFunction, (, Node, n, ), {]
[., MOD, ;, }, throw, new, IllegalArgumentException, (, "Not an assignment op:", +, n, ), ;, }, static, boolean, containsFunction, (, Node, n]
[;, }, static, boolean, containsFunction, (, Node, n, ), {, return, containsType, (, n, ,, Token, ., FUNCTION, ), ;]
[), ;, }, static, boolean, containsFunction, (, Node, n, ), {, return, containsType, (, n, ,, Token, ., FUNCTION, )]
[+, n, ), ;, }, static, boolean, containsFunction, (, Node, n, ), {, return, containsType, (, n, ,, Token, .]
[), ;, }, static, boolean, containsFunction, (, Node, n, ), {, return, containsType, (, n, ,, Token, ., FUNCTION, )]
[;, }, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =, (, n, ., isFunction, (, ), )]
[,, Token, ., FUNCTION, ), ;, }, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =, (, n]
[), ;, }, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =, (, n, ., isFunction, (, )]
[., FUNCTION, ), ;, }, static, boolean, referencesThis, (, Node, n, ), {, Node, start, =, (, n, ., isFunction]
[;, return, containsType, (, start, ,, Token, ., THIS, ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n]
[?, n, ., getLastChild, (, ), :, n, ;, return, containsType, (, start, ,, Token, ., THIS, ,, MATCH_NOT_FUNCTION, )]
[), ?, n, ., getLastChild, (, ), :, n, ;, return, containsType, (, start, ,, Token, ., THIS, ,, MATCH_NOT_FUNCTION]
[., isFunction, (, ), ), ?, n, ., getLastChild, (, ), :, n, ;, return, containsType, (, start, ,, Token]
[:, n, ;, return, containsType, (, start, ,, Token, ., THIS, ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (]
[., getLastChild, (, ), :, n, ;, return, containsType, (, start, ,, Token, ., THIS, ,, MATCH_NOT_FUNCTION, ), ;, }]
[;, return, containsType, (, start, ,, Token, ., THIS, ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n]
[;, }, static, boolean, isGet, (, Node, n, ), {, return, n, ., isGetProp, (, ), ||, n, ., isGetElem]
[,, Token, ., THIS, ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n, ), {, return, n, .]
[,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n, ), {, return, n, ., isGetProp, (, ), ||]
[., THIS, ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isGet, (, Node, n, ), {, return, n, ., isGetProp, (]
[), ;, }, static, boolean, isGet, (, Node, n, ), {, return, n, ., isGetProp, (, ), ||, n, .]
[;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return, n, ., isName, (, ), &&, n, ., getParent]
[||, n, ., isGetElem, (, ), ;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return, n, ., isName]
[., isGetProp, (, ), ||, n, ., isGetElem, (, ), ;, }, static, boolean, isVarDeclaration, (, Node, n, ), {]
[;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return, n, ., isName, (, ), &&, n, ., getParent]
[., isGetElem, (, ), ;, }, static, boolean, isVarDeclaration, (, Node, n, ), {, return, n, ., isName, (, )]
[;, }, static, Node, getAssignedValue, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isName, (, ), )]
[&&, n, ., getParent, (, ), ., isVar, (, ), ;, }, static, Node, getAssignedValue, (, Node, n, ), {]
[., isName, (, ), &&, n, ., getParent, (, ), ., isVar, (, ), ;, }, static, Node, getAssignedValue, (]
[;, }, static, Node, getAssignedValue, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isName, (, ), )]
[., isVar, (, ), ;, }, static, Node, getAssignedValue, (, Node, n, ), {, Preconditions, ., checkState, (, n, .]
[., getParent, (, ), ., isVar, (, ), ;, }, static, Node, getAssignedValue, (, Node, n, ), {, Preconditions, .]
[;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isVar, (, ), ), {, return]
[., checkState, (, n, ., isName, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if]
[), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isVar, (, ), ), {]
[., isName, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isVar]
[;, if, (, parent, ., isVar, (, ), ), {, return, n, ., getFirstChild, (, ), ;, }, else, if]
[., getParent, (, ), ;, if, (, parent, ., isVar, (, ), ), {, return, n, ., getFirstChild, (, )]
[), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (, parent, ., isAssign, (, ), &&, parent]
[., isVar, (, ), ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (, parent, ., isAssign]
[;, }, else, if, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), {]
[., getFirstChild, (, ), ;, }, else, if, (, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, )]
[), {, return, n, ., getNext, (, ), ;, }, else, {, return, null, ;, }, }, static, boolean, isExprAssign]
[&&, parent, ., getFirstChild, (, ), ==, n, ), {, return, n, ., getNext, (, ), ;, }, else, {]
[., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), {, return, n, ., getNext, (, )]
[), {, return, n, ., getNext, (, ), ;, }, else, {, return, null, ;, }, }, static, boolean, isExprAssign]
[==, n, ), {, return, n, ., getNext, (, ), ;, }, else, {, return, null, ;, }, }, static]
[., getFirstChild, (, ), ==, n, ), {, return, n, ., getNext, (, ), ;, }, else, {, return, null]
[), {, return, n, ., getNext, (, ), ;, }, else, {, return, null, ;, }, }, static, boolean, isExprAssign]
[;, }, else, {, return, null, ;, }, }, static, boolean, isExprAssign, (, Node, n, ), {, return, n, .]
[., getNext, (, ), ;, }, else, {, return, null, ;, }, }, static, boolean, isExprAssign, (, Node, n, )]
[;, }, }, static, boolean, isExprAssign, (, Node, n, ), {, return, n, ., isExprResult, (, ), &&, n, .]
[;, }, static, boolean, isExprCall, (, Node, n, ), {, return, n, ., isExprResult, (, ), &&, n, ., getFirstChild]
[&&, n, ., getFirstChild, (, ), ., isAssign, (, ), ;, }, static, boolean, isExprCall, (, Node, n, ), {]
[., isExprResult, (, ), &&, n, ., getFirstChild, (, ), ., isAssign, (, ), ;, }, static, boolean, isExprCall, (]
[;, }, static, boolean, isExprCall, (, Node, n, ), {, return, n, ., isExprResult, (, ), &&, n, ., getFirstChild]
[., isAssign, (, ), ;, }, static, boolean, isExprCall, (, Node, n, ), {, return, n, ., isExprResult, (, )]
[., getFirstChild, (, ), ., isAssign, (, ), ;, }, static, boolean, isExprCall, (, Node, n, ), {, return, n]
[;, }, static, boolean, isForIn, (, Node, n, ), {, return, n, ., isFor, (, ), &&, n, ., getChildCount]
[&&, n, ., getFirstChild, (, ), ., isCall, (, ), ;, }, static, boolean, isForIn, (, Node, n, ), {]
[., isExprResult, (, ), &&, n, ., getFirstChild, (, ), ., isCall, (, ), ;, }, static, boolean, isForIn, (]
[;, }, static, boolean, isForIn, (, Node, n, ), {, return, n, ., isFor, (, ), &&, n, ., getChildCount]
[., isCall, (, ), ;, }, static, boolean, isForIn, (, Node, n, ), {, return, n, ., isFor, (, )]
[., getFirstChild, (, ), ., isCall, (, ), ;, }, static, boolean, isForIn, (, Node, n, ), {, return, n]
[;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[&&, n, ., getChildCount, (, ), ==, 3, ;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (]
[., isFor, (, ), &&, n, ., getChildCount, (, ), ==, 3, ;, }, static, boolean, isLoopStructure, (, Node, n]
[;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[==, 3, ;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), )]
[., getChildCount, (, ), ==, 3, ;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (, n, .]
[;, }, static, boolean, isLoopStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, return, true, ;]
[., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE]
[:, case, Token, ., DO, :, case, Token, ., WHILE, :, return, true, ;, default, :, return, false, ;, }]
[., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, return, true, ;, default, :, return, false]
[:, case, Token, ., WHILE, :, return, true, ;, default, :, return, false, ;, }, }, static, Node, getLoopCodeBlock, (]
[., DO, :, case, Token, ., WHILE, :, return, true, ;, default, :, return, false, ;, }, }, static, Node]
[:, return, true, ;, default, :, return, false, ;, }, }, static, Node, getLoopCodeBlock, (, Node, n, ), {, switch]
[., WHILE, :, return, true, ;, default, :, return, false, ;, }, }, static, Node, getLoopCodeBlock, (, Node, n, )]
[;, default, :, return, false, ;, }, }, static, Node, getLoopCodeBlock, (, Node, n, ), {, switch, (, n, .]
[;, }, }, static, Node, getLoopCodeBlock, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, return, n, ., getLastChild, (, ), ;, case]
[., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, return, n, ., getLastChild]
[:, case, Token, ., WHILE, :, return, n, ., getLastChild, (, ), ;, case, Token, ., DO, :, return, n]
[., FOR, :, case, Token, ., WHILE, :, return, n, ., getLastChild, (, ), ;, case, Token, ., DO, :]
[:, return, n, ., getLastChild, (, ), ;, case, Token, ., DO, :, return, n, ., getFirstChild, (, ), ;]
[., WHILE, :, return, n, ., getLastChild, (, ), ;, case, Token, ., DO, :, return, n, ., getFirstChild, (]
[;, case, Token, ., DO, :, return, n, ., getFirstChild, (, ), ;, default, :, return, null, ;, }, }]
[., getLastChild, (, ), ;, case, Token, ., DO, :, return, n, ., getFirstChild, (, ), ;, default, :, return]
[:, return, n, ., getFirstChild, (, ), ;, default, :, return, null, ;, }, }, static, boolean, isWithinLoop, (, Node]
[., DO, :, return, n, ., getFirstChild, (, ), ;, default, :, return, null, ;, }, }, static, boolean, isWithinLoop]
[;, default, :, return, null, ;, }, }, static, boolean, isWithinLoop, (, Node, n, ), {, for, (, Node, parent]
[., getFirstChild, (, ), ;, default, :, return, null, ;, }, }, static, boolean, isWithinLoop, (, Node, n, ), {]
[;, }, }, static, boolean, isWithinLoop, (, Node, n, ), {, for, (, Node, parent, :, n, ., getAncestors, (]
[), {, if, (, NodeUtil, ., isLoopStructure, (, parent, ), ), {, return, true, ;, }, if, (, parent, .]
[., getAncestors, (, ), ), {, if, (, NodeUtil, ., isLoopStructure, (, parent, ), ), {, return, true, ;, }]
[), {, return, true, ;, }, if, (, parent, ., isFunction, (, ), ), {, break, ;, }, }, return]
[., isLoopStructure, (, parent, ), ), {, return, true, ;, }, if, (, parent, ., isFunction, (, ), ), {]
[), ), {, return, true, ;, }, if, (, parent, ., isFunction, (, ), ), {, break, ;, }, }]
[;, }, if, (, parent, ., isFunction, (, ), ), {, break, ;, }, }, return, false, ;, }, static]
[), {, break, ;, }, }, return, false, ;, }, static, boolean, isControlStructure, (, Node, n, ), {, switch, (]
[., isFunction, (, ), ), {, break, ;, }, }, return, false, ;, }, static, boolean, isControlStructure, (, Node, n]
[;, }, static, boolean, isControlStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE]
[:, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, case, Token, ., IF]
[., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, case, Token]
[:, case, Token, ., WHILE, :, case, Token, ., WITH, :, case, Token, ., IF, :, case, Token, ., LABEL]
[., DO, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, case, Token, ., IF, :, case, Token]
[:, case, Token, ., WITH, :, case, Token, ., IF, :, case, Token, ., LABEL, :, case, Token, ., TRY]
[., WHILE, :, case, Token, ., WITH, :, case, Token, ., IF, :, case, Token, ., LABEL, :, case, Token]
[:, case, Token, ., IF, :, case, Token, ., LABEL, :, case, Token, ., TRY, :, case, Token, ., CATCH]
[., WITH, :, case, Token, ., IF, :, case, Token, ., LABEL, :, case, Token, ., TRY, :, case, Token]
[:, case, Token, ., LABEL, :, case, Token, ., TRY, :, case, Token, ., CATCH, :, case, Token, ., SWITCH]
[., IF, :, case, Token, ., LABEL, :, case, Token, ., TRY, :, case, Token, ., CATCH, :, case, Token]
[:, case, Token, ., TRY, :, case, Token, ., CATCH, :, case, Token, ., SWITCH, :, case, Token, ., CASE]
[., LABEL, :, case, Token, ., TRY, :, case, Token, ., CATCH, :, case, Token, ., SWITCH, :, case, Token]
[:, case, Token, ., CATCH, :, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE]
[., TRY, :, case, Token, ., CATCH, :, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token]
[:, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, true, ;, default]
[., CATCH, :, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, true]
[:, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, return, false, ;, }]
[., SWITCH, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, return, false]
[:, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isControlStructureCodeBlock, (]
[., CASE, :, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean]
[:, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isControlStructureCodeBlock, (, Node, parent, ,, Node, n]
[., DEFAULT_CASE, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isControlStructureCodeBlock, (, Node, parent, ,]
[;, default, :, return, false, ;, }, }, static, boolean, isControlStructureCodeBlock, (, Node, parent, ,, Node, n, ), {, switch]
[;, }, }, static, boolean, isControlStructureCodeBlock, (, Node, parent, ,, Node, n, ), {, switch, (, parent, ., getType, (]
[), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, case, Token, ., LABEL, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., WHILE, :, case, Token, ., LABEL]
[:, case, Token, ., WHILE, :, case, Token, ., LABEL, :, case, Token, ., WITH, :, return, parent, ., getLastChild]
[., FOR, :, case, Token, ., WHILE, :, case, Token, ., LABEL, :, case, Token, ., WITH, :, return, parent]
[:, case, Token, ., LABEL, :, case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==, n, ;]
[., WHILE, :, case, Token, ., LABEL, :, case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==]
[:, case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., DO, :]
[., LABEL, :, case, Token, ., WITH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, .]
[:, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., DO, :, return, parent, ., getFirstChild, (]
[., WITH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., DO, :, return, parent, .]
[;, case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==, n, ;, case, Token, ., IF, :]
[==, n, ;, case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==, n, ;, case, Token, .]
[., getLastChild, (, ), ==, n, ;, case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==, n]
[;, case, Token, ., DO, :, return, parent, ., getFirstChild, (, ), ==, n, ;, case, Token, ., IF, :]
[:, return, parent, ., getFirstChild, (, ), ==, n, ;, case, Token, ., IF, :, return, parent, ., getFirstChild, (]
[., DO, :, return, parent, ., getFirstChild, (, ), ==, n, ;, case, Token, ., IF, :, return, parent, .]
[;, case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :]
[==, n, ;, case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, .]
[., getFirstChild, (, ), ==, n, ;, case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n]
[;, case, Token, ., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :]
[:, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return, parent, ., getFirstChild, (]
[., IF, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return, parent, .]
[;, case, Token, ., TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, )]
[!=, n, ;, case, Token, ., TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||, parent, ., getLastChild]
[., getFirstChild, (, ), !=, n, ;, case, Token, ., TRY, :, return, parent, ., getFirstChild, (, ), ==, n]
[;, case, Token, ., TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, )]
[:, return, parent, ., getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, ), ==, n, ;, case, Token]
[., TRY, :, return, parent, ., getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, ), ==, n, ;]
[;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :]
[||, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, )]
[==, n, ||, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., CATCH, :, return, parent, ., getLastChild]
[., getFirstChild, (, ), ==, n, ||, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., CATCH, :]
[||, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, )]
[;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :]
[==, n, ;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, .]
[., getLastChild, (, ), ==, n, ;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==, n]
[;, case, Token, ., CATCH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :]
[:, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :]
[., CATCH, :, return, parent, ., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :, case, Token, .]
[;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, return, parent, ., getFirstChild, (, ), !=, n, ;]
[==, n, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, return, parent, ., getFirstChild, (, ), !=]
[., getLastChild, (, ), ==, n, ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, return, parent, .]
[;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, return, parent, ., getFirstChild, (, ), !=, n, ;]
[:, case, Token, ., CASE, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., DEFAULT_CASE, :]
[., SWITCH, :, case, Token, ., CASE, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, .]
[:, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :]
[., CASE, :, return, parent, ., getFirstChild, (, ), !=, n, ;, case, Token, ., DEFAULT_CASE, :, return, true, ;]
[;, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, Preconditions, ., checkState, (, isControlStructure, (, parent, ), )]
[!=, n, ;, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, Preconditions, ., checkState, (, isControlStructure, (, parent]
[., getFirstChild, (, ), !=, n, ;, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, Preconditions, ., checkState]
[;, case, Token, ., DEFAULT_CASE, :, return, true, ;, default, :, Preconditions, ., checkState, (, isControlStructure, (, parent, ), )]
[:, return, true, ;, default, :, Preconditions, ., checkState, (, isControlStructure, (, parent, ), ), ;, return, false, ;, }]
[., DEFAULT_CASE, :, return, true, ;, default, :, Preconditions, ., checkState, (, isControlStructure, (, parent, ), ), ;, return, false]
[;, default, :, Preconditions, ., checkState, (, isControlStructure, (, parent, ), ), ;, return, false, ;, }, }, static, Node]
[;, return, false, ;, }, }, static, Node, getConditionExpression, (, Node, n, ), {, switch, (, n, ., getType, (]
[., checkState, (, isControlStructure, (, parent, ), ), ;, return, false, ;, }, }, static, Node, getConditionExpression, (, Node, n]
[), ;, return, false, ;, }, }, static, Node, getConditionExpression, (, Node, n, ), {, switch, (, n, ., getType]
[), ), ;, return, false, ;, }, }, static, Node, getConditionExpression, (, Node, n, ), {, switch, (, n, .]
[;, }, }, static, Node, getConditionExpression, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), {, case, Token, ., IF, :, case, Token, ., WHILE, :, return, n, ., getFirstChild, (, ), ;, case]
[., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., WHILE, :, return, n, ., getFirstChild]
[:, case, Token, ., WHILE, :, return, n, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n]
[., IF, :, case, Token, ., WHILE, :, return, n, ., getFirstChild, (, ), ;, case, Token, ., DO, :]
[:, return, n, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, ., getLastChild, (, ), ;]
[., WHILE, :, return, n, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, ., getLastChild, (]
[;, case, Token, ., DO, :, return, n, ., getLastChild, (, ), ;, case, Token, ., FOR, :, switch, (]
[., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, ., getLastChild, (, ), ;, case, Token, .]
[:, return, n, ., getLastChild, (, ), ;, case, Token, ., FOR, :, switch, (, n, ., getChildCount, (, )]
[., DO, :, return, n, ., getLastChild, (, ), ;, case, Token, ., FOR, :, switch, (, n, ., getChildCount]
[;, case, Token, ., FOR, :, switch, (, n, ., getChildCount, (, ), ), {, case, 3, :, return, null]
[., getLastChild, (, ), ;, case, Token, ., FOR, :, switch, (, n, ., getChildCount, (, ), ), {, case]
[:, switch, (, n, ., getChildCount, (, ), ), {, case, 3, :, return, null, ;, case, 4, :, return]
[., FOR, :, switch, (, n, ., getChildCount, (, ), ), {, case, 3, :, return, null, ;, case, 4]
[), {, case, 3, :, return, null, ;, case, 4, :, return, n, ., getFirstChild, (, ), ., getNext, (]
[., getChildCount, (, ), ), {, case, 3, :, return, null, ;, case, 4, :, return, n, ., getFirstChild, (]
[:, return, null, ;, case, 4, :, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, throw]
[;, case, 4, :, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, throw, new, IllegalArgumentException, (]
[:, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, throw, new, IllegalArgumentException, (, "malformed 'for' statement ", +, n]
[;, }, throw, new, IllegalArgumentException, (, "malformed 'for' statement ", +, n, ), ;, case, Token, ., CASE, :, return, null, ;, }]
[., getNext, (, ), ;, }, throw, new, IllegalArgumentException, (, "malformed 'for' statement ", +, n, ), ;, case, Token, ., CASE, :]
[., getFirstChild, (, ), ., getNext, (, ), ;, }, throw, new, IllegalArgumentException, (, "malformed 'for' statement ", +, n, ), ;, case]
[;, case, Token, ., CASE, :, return, null, ;, }, throw, new, IllegalArgumentException, (, n, +, " does not have a condition.", ), ;, }]
[), ;, case, Token, ., CASE, :, return, null, ;, }, throw, new, IllegalArgumentException, (, n, +, " does not have a condition.", ), ;]
[+, n, ), ;, case, Token, ., CASE, :, return, null, ;, }, throw, new, IllegalArgumentException, (, n, +, " does not have a condition."]
[), ;, case, Token, ., CASE, :, return, null, ;, }, throw, new, IllegalArgumentException, (, n, +, " does not have a condition.", ), ;]
[:, return, null, ;, }, throw, new, IllegalArgumentException, (, n, +, " does not have a condition.", ), ;, }, static, boolean, isStatementBlock, (, Node]
[., CASE, :, return, null, ;, }, throw, new, IllegalArgumentException, (, n, +, " does not have a condition.", ), ;, }, static, boolean, isStatementBlock]
[;, }, throw, new, IllegalArgumentException, (, n, +, " does not have a condition.", ), ;, }, static, boolean, isStatementBlock, (, Node, n, ), {]
[;, }, static, boolean, isStatementBlock, (, Node, n, ), {, return, n, ., isScript, (, ), ||, n, ., isBlock]
[), ;, }, static, boolean, isStatementBlock, (, Node, n, ), {, return, n, ., isScript, (, ), ||, n, .]
[+, " does not have a condition.", ), ;, }, static, boolean, isStatementBlock, (, Node, n, ), {, return, n, ., isScript, (, ), ||]
[), ;, }, static, boolean, isStatementBlock, (, Node, n, ), {, return, n, ., isScript, (, ), ||, n, .]
[;, }, static, boolean, isStatement, (, Node, n, ), {, return, isStatementParent, (, n, ., getParent, (, ), ), ;]
[||, n, ., isBlock, (, ), ;, }, static, boolean, isStatement, (, Node, n, ), {, return, isStatementParent, (, n]
[., isScript, (, ), ||, n, ., isBlock, (, ), ;, }, static, boolean, isStatement, (, Node, n, ), {]
[;, }, static, boolean, isStatement, (, Node, n, ), {, return, isStatementParent, (, n, ., getParent, (, ), ), ;]
[., isBlock, (, ), ;, }, static, boolean, isStatement, (, Node, n, ), {, return, isStatementParent, (, n, ., getParent]
[;, }, static, boolean, isStatementParent, (, Node, parent, ), {, Preconditions, ., checkState, (, parent, !=, null, ), ;, switch]
[), ;, }, static, boolean, isStatementParent, (, Node, parent, ), {, Preconditions, ., checkState, (, parent, !=, null, ), ;]
[., getParent, (, ), ), ;, }, static, boolean, isStatementParent, (, Node, parent, ), {, Preconditions, ., checkState, (, parent]
[;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :]
[., checkState, (, parent, !=, null, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, .]
[), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SCRIPT, :, case, Token, ., BLOCK]
[!=, null, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SCRIPT, :, case, Token]
[), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., SCRIPT, :, case, Token, ., BLOCK]
[), {, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, return, true, ;]
[., getType, (, ), ), {, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL]
[:, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, return, true, ;, default, :, return, false, ;, }]
[., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, return, true, ;, default, :, return, false]
[:, case, Token, ., LABEL, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isSwitchCase, (]
[., BLOCK, :, case, Token, ., LABEL, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean]
[:, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isSwitchCase, (, Node, n, ), {, return]
[., LABEL, :, return, true, ;, default, :, return, false, ;, }, }, static, boolean, isSwitchCase, (, Node, n, )]
[;, default, :, return, false, ;, }, }, static, boolean, isSwitchCase, (, Node, n, ), {, return, n, ., isCase]
[;, }, }, static, boolean, isSwitchCase, (, Node, n, ), {, return, n, ., isCase, (, ), ||, n, .]
[;, }, static, boolean, isReferenceName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !, n, .]
[||, n, ., isDefaultCase, (, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {, return, n, ., isName]
[., isCase, (, ), ||, n, ., isDefaultCase, (, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {]
[;, }, static, boolean, isReferenceName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !, n, .]
[., isDefaultCase, (, ), ;, }, static, boolean, isReferenceName, (, Node, n, ), {, return, n, ., isName, (, )]
[;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return, parent, ., isTry, (, ), &&]
[&&, !, n, ., getString, (, ), ., isEmpty, (, ), ;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,]
[., isName, (, ), &&, !, n, ., getString, (, ), ., isEmpty, (, ), ;, }, static, boolean, isTryFinallyNode]
[;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return, parent, ., isTry, (, ), &&]
[;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return, parent, ., isTry, (, ), &&]
[., isEmpty, (, ), ;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, ), {, return, parent, .]
[., getString, (, ), ., isEmpty, (, ), ;, }, static, boolean, isTryFinallyNode, (, Node, parent, ,, Node, child, )]
[;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return]
[&&, child, ==, parent, ., getLastChild, (, ), ;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent]
[&&, parent, ., getChildCount, (, ), ==, 3, &&, child, ==, parent, ., getLastChild, (, ), ;, }, static, boolean]
[., isTry, (, ), &&, parent, ., getChildCount, (, ), ==, 3, &&, child, ==, parent, ., getLastChild, (, )]
[&&, child, ==, parent, ., getLastChild, (, ), ;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent]
[==, 3, &&, child, ==, parent, ., getLastChild, (, ), ;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {]
[., getChildCount, (, ), ==, 3, &&, child, ==, parent, ., getLastChild, (, ), ;, }, static, boolean, isTryCatchNodeContainer, (]
[&&, child, ==, parent, ., getLastChild, (, ), ;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent]
[;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return]
[==, parent, ., getLastChild, (, ), ;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =, n]
[;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, return]
[., getLastChild, (, ), ;, }, static, boolean, isTryCatchNodeContainer, (, Node, n, ), {, Node, parent, =, n, ., getParent]
[;, return, parent, ., isTry, (, ), &&, parent, ., getFirstChild, (, ), ., getNext, (, ), ==, n, ;]
[., getParent, (, ), ;, return, parent, ., isTry, (, ), &&, parent, ., getFirstChild, (, ), ., getNext, (]
[;, }, static, void, removeChild, (, Node, parent, ,, Node, node, ), {, if, (, isTryFinallyNode, (, parent, ,, node]
[&&, parent, ., getFirstChild, (, ), ., getNext, (, ), ==, n, ;, }, static, void, removeChild, (, Node, parent]
[., isTry, (, ), &&, parent, ., getFirstChild, (, ), ., getNext, (, ), ==, n, ;, }, static, void]
[;, }, static, void, removeChild, (, Node, parent, ,, Node, node, ), {, if, (, isTryFinallyNode, (, parent, ,, node]
[==, n, ;, }, static, void, removeChild, (, Node, parent, ,, Node, node, ), {, if, (, isTryFinallyNode, (, parent]
[., getNext, (, ), ==, n, ;, }, static, void, removeChild, (, Node, parent, ,, Node, node, ), {, if]
[., getFirstChild, (, ), ., getNext, (, ), ==, n, ;, }, static, void, removeChild, (, Node, parent, ,, Node]
[;, }, static, void, removeChild, (, Node, parent, ,, Node, node, ), {, if, (, isTryFinallyNode, (, parent, ,, node]
[), {, if, (, NodeUtil, ., hasCatchHandler, (, getCatchBlock, (, parent, ), ), ), {, parent, ., removeChild, (, node]
[,, node, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, getCatchBlock, (, parent, ), ), ), {, parent, .]
[), ), {, if, (, NodeUtil, ., hasCatchHandler, (, getCatchBlock, (, parent, ), ), ), {, parent, ., removeChild, (]
[), {, parent, ., removeChild, (, node, ), ;, }, else, {, node, ., detachChildren, (, ), ;, }, }]
[., hasCatchHandler, (, getCatchBlock, (, parent, ), ), ), {, parent, ., removeChild, (, node, ), ;, }, else, {]
[), ), {, parent, ., removeChild, (, node, ), ;, }, else, {, node, ., detachChildren, (, ), ;, }]
[), ), ), {, parent, ., removeChild, (, node, ), ;, }, else, {, node, ., detachChildren, (, ), ;]
[;, }, else, {, node, ., detachChildren, (, ), ;, }, }, else, if, (, node, ., isCatch, (, )]
[., removeChild, (, node, ), ;, }, else, {, node, ., detachChildren, (, ), ;, }, }, else, if, (]
[), ;, }, else, {, node, ., detachChildren, (, ), ;, }, }, else, if, (, node, ., isCatch, (]
[;, }, }, else, if, (, node, ., isCatch, (, ), ), {, Node, tryNode, =, node, ., getParent, (]
[., detachChildren, (, ), ;, }, }, else, if, (, node, ., isCatch, (, ), ), {, Node, tryNode, =]
[), {, Node, tryNode, =, node, ., getParent, (, ), ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil]
[., isCatch, (, ), ), {, Node, tryNode, =, node, ., getParent, (, ), ., getParent, (, ), ;, Preconditions]
[;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachFromParent, (, ), ;, }]
[., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachFromParent]
[., getParent, (, ), ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), )]
[;, node, ., detachFromParent, (, ), ;, }, else, if, (, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode, =]
[., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachFromParent, (, ), ;, }, else, if]
[), ;, node, ., detachFromParent, (, ), ;, }, else, if, (, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode]
[., hasFinally, (, tryNode, ), ), ;, node, ., detachFromParent, (, ), ;, }, else, if, (, isTryCatchNodeContainer, (, node]
[), ), ;, node, ., detachFromParent, (, ), ;, }, else, if, (, isTryCatchNodeContainer, (, node, ), ), {, Node]
[;, }, else, if, (, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode, =, node, ., getParent, (, ), ;]
[., detachFromParent, (, ), ;, }, else, if, (, isTryCatchNodeContainer, (, node, ), ), {, Node, tryNode, =, node, .]
[), {, Node, tryNode, =, node, ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode]
[), ), {, Node, tryNode, =, node, ., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (]
[;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachChildren, (, ), ;, }]
[., getParent, (, ), ;, Preconditions, ., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachChildren]
[;, node, ., detachChildren, (, ), ;, }, else, if, (, node, ., isBlock, (, ), ), {, node, .]
[., checkState, (, NodeUtil, ., hasFinally, (, tryNode, ), ), ;, node, ., detachChildren, (, ), ;, }, else, if]
[), ;, node, ., detachChildren, (, ), ;, }, else, if, (, node, ., isBlock, (, ), ), {, node]
[., hasFinally, (, tryNode, ), ), ;, node, ., detachChildren, (, ), ;, }, else, if, (, node, ., isBlock]
[), ), ;, node, ., detachChildren, (, ), ;, }, else, if, (, node, ., isBlock, (, ), ), {]
[;, }, else, if, (, node, ., isBlock, (, ), ), {, node, ., detachChildren, (, ), ;, }, else]
[., detachChildren, (, ), ;, }, else, if, (, node, ., isBlock, (, ), ), {, node, ., detachChildren, (]
[), {, node, ., detachChildren, (, ), ;, }, else, if, (, isStatementBlock, (, parent, ), ||, isSwitchCase, (, node]
[., isBlock, (, ), ), {, node, ., detachChildren, (, ), ;, }, else, if, (, isStatementBlock, (, parent, )]
[;, }, else, if, (, isStatementBlock, (, parent, ), ||, isSwitchCase, (, node, ), ), {, parent, ., removeChild, (]
[., detachChildren, (, ), ;, }, else, if, (, isStatementBlock, (, parent, ), ||, isSwitchCase, (, node, ), ), {]
[), {, parent, ., removeChild, (, node, ), ;, }, else, if, (, parent, ., isVar, (, ), ), {]
[||, isSwitchCase, (, node, ), ), {, parent, ., removeChild, (, node, ), ;, }, else, if, (, parent, .]
[), ||, isSwitchCase, (, node, ), ), {, parent, ., removeChild, (, node, ), ;, }, else, if, (, parent]
[), {, parent, ., removeChild, (, node, ), ;, }, else, if, (, parent, ., isVar, (, ), ), {]
[), ), {, parent, ., removeChild, (, node, ), ;, }, else, if, (, parent, ., isVar, (, ), )]
[;, }, else, if, (, parent, ., isVar, (, ), ), {, if, (, parent, ., hasMoreThanOneChild, (, ), )]
[., removeChild, (, node, ), ;, }, else, if, (, parent, ., isVar, (, ), ), {, if, (, parent]
[), ;, }, else, if, (, parent, ., isVar, (, ), ), {, if, (, parent, ., hasMoreThanOneChild, (, )]
[), {, if, (, parent, ., hasMoreThanOneChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, }, else]
[., isVar, (, ), ), {, if, (, parent, ., hasMoreThanOneChild, (, ), ), {, parent, ., removeChild, (, node]
[), {, parent, ., removeChild, (, node, ), ;, }, else, {, parent, ., removeChild, (, node, ), ;, removeChild]
[., hasMoreThanOneChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, }, else, {, parent, ., removeChild, (]
[;, }, else, {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent]
[., removeChild, (, node, ), ;, }, else, {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, .]
[), ;, }, else, {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,]
[;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, }, else, if, (, parent, ., isLabel]
[., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, }, else]
[), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, }, else, if, (, parent, .]
[;, }, }, else, if, (, parent, ., isLabel, (, ), &&, node, ==, parent, ., getLastChild, (, ), )]
[,, parent, ), ;, }, }, else, if, (, parent, ., isLabel, (, ), &&, node, ==, parent, ., getLastChild]
[., getParent, (, ), ,, parent, ), ;, }, }, else, if, (, parent, ., isLabel, (, ), &&, node]
[), ;, }, }, else, if, (, parent, ., isLabel, (, ), &&, node, ==, parent, ., getLastChild, (, )]
[), {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;]
[&&, node, ==, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent]
[., isLabel, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, node, )]
[), {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;]
[==, parent, ., getLastChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent]
[), {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;]
[., getLastChild, (, ), ), {, parent, ., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, )]
[;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, else, if, (, parent, ., isFor, (]
[., removeChild, (, node, ), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, else, if]
[), ;, removeChild, (, parent, ., getParent, (, ), ,, parent, ), ;, }, else, if, (, parent, ., isFor]
[;, }, else, if, (, parent, ., isFor, (, ), &&, parent, ., getChildCount, (, ), ==, 4, ), {]
[,, parent, ), ;, }, else, if, (, parent, ., isFor, (, ), &&, parent, ., getChildCount, (, ), ==]
[., getParent, (, ), ,, parent, ), ;, }, else, if, (, parent, ., isFor, (, ), &&, parent, .]
[), ;, }, else, if, (, parent, ., isFor, (, ), &&, parent, ., getChildCount, (, ), ==, 4, )]
[), {, parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new]
[&&, parent, ., getChildCount, (, ), ==, 4, ), {, parent, ., replaceChild, (, node, ,, IR, ., empty, (]
[., isFor, (, ), &&, parent, ., getChildCount, (, ), ==, 4, ), {, parent, ., replaceChild, (, node, ,]
[), {, parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new]
[==, 4, ), {, parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {]
[., getChildCount, (, ), ==, 4, ), {, parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), )]
[), {, parent, ., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new]
[;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: ", +, node, ., toString, (, ), +, " of ", +, parent, .]
[., replaceChild, (, node, ,, IR, ., empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: "]
[,, IR, ., empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: ", +, node, ., toString]
[), ;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: ", +, node, ., toString, (, ), +, " of ", +, parent]
[., empty, (, ), ), ;, }, else, {, throw, new, IllegalStateException, (, "Invalid attempt to remove node: ", +, node, ., toString, (, )]
[;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {, Preconditions, ., checkState, (, tryNode, ., isTry, (, )]
[), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {, Preconditions, ., checkState, (, tryNode, ., isTry, (]
[+, parent, ., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {, Preconditions, .]
[+, " of ", +, parent, ., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {]
[+, node, ., toString, (, ), +, " of ", +, parent, ., toString, (, ), ), ;, }, }, static, void]
[+, " of ", +, parent, ., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {]
[., toString, (, ), +, " of ", +, parent, ., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (]
[+, parent, ., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {, Preconditions, .]
[), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {, Preconditions, ., checkState, (, tryNode, ., isTry, (]
[., toString, (, ), ), ;, }, }, static, void, maybeAddFinally, (, Node, tryNode, ), {, Preconditions, ., checkState, (]
[;, if, (, !, NodeUtil, ., hasFinally, (, tryNode, ), ), {, tryNode, ., addChildrenToBack, (, IR, ., block, (]
[., checkState, (, tryNode, ., isTry, (, ), ), ;, if, (, !, NodeUtil, ., hasFinally, (, tryNode, ), )]
[), ;, if, (, !, NodeUtil, ., hasFinally, (, tryNode, ), ), {, tryNode, ., addChildrenToBack, (, IR, ., block]
[., isTry, (, ), ), ;, if, (, !, NodeUtil, ., hasFinally, (, tryNode, ), ), {, tryNode, ., addChildrenToBack]
[), {, tryNode, ., addChildrenToBack, (, IR, ., block, (, ), ., srcref, (, tryNode, ), ), ;, }, }]
[), {, tryNode, ., addChildrenToBack, (, IR, ., block, (, ), ., srcref, (, tryNode, ), ), ;, }, }]
[., hasFinally, (, tryNode, ), ), {, tryNode, ., addChildrenToBack, (, IR, ., block, (, ), ., srcref, (, tryNode]
[), ), {, tryNode, ., addChildrenToBack, (, IR, ., block, (, ), ., srcref, (, tryNode, ), ), ;, }]
[;, }, }, static, boolean, tryMergeBlock, (, Node, block, ), {, Preconditions, ., checkState, (, block, ., isBlock, (, )]
[., addChildrenToBack, (, IR, ., block, (, ), ., srcref, (, tryNode, ), ), ;, }, }, static, boolean, tryMergeBlock]
[), ;, }, }, static, boolean, tryMergeBlock, (, Node, block, ), {, Preconditions, ., checkState, (, block, ., isBlock, (]
[., srcref, (, tryNode, ), ), ;, }, }, static, boolean, tryMergeBlock, (, Node, block, ), {, Preconditions, ., checkState]
[., block, (, ), ., srcref, (, tryNode, ), ), ;, }, }, static, boolean, tryMergeBlock, (, Node, block, )]
[), ), ;, }, }, static, boolean, tryMergeBlock, (, Node, block, ), {, Preconditions, ., checkState, (, block, ., isBlock]
[;, Node, parent, =, block, ., getParent, (, ), ;, if, (, isStatementBlock, (, parent, ), ), {, Node, previous]
[., checkState, (, block, ., isBlock, (, ), ), ;, Node, parent, =, block, ., getParent, (, ), ;, if]
[), ;, Node, parent, =, block, ., getParent, (, ), ;, if, (, isStatementBlock, (, parent, ), ), {, Node]
[., isBlock, (, ), ), ;, Node, parent, =, block, ., getParent, (, ), ;, if, (, isStatementBlock, (, parent]
[;, if, (, isStatementBlock, (, parent, ), ), {, Node, previous, =, block, ;, while, (, block, ., hasChildren, (]
[., getParent, (, ), ;, if, (, isStatementBlock, (, parent, ), ), {, Node, previous, =, block, ;, while, (]
[), {, Node, previous, =, block, ;, while, (, block, ., hasChildren, (, ), ), {, Node, child, =, block]
[), ), {, Node, previous, =, block, ;, while, (, block, ., hasChildren, (, ), ), {, Node, child, =]
[;, while, (, block, ., hasChildren, (, ), ), {, Node, child, =, block, ., removeFirstChild, (, ), ;, parent]
[), {, Node, child, =, block, ., removeFirstChild, (, ), ;, parent, ., addChildAfter, (, child, ,, previous, ), ;]
[., hasChildren, (, ), ), {, Node, child, =, block, ., removeFirstChild, (, ), ;, parent, ., addChildAfter, (, child]
[;, parent, ., addChildAfter, (, child, ,, previous, ), ;, previous, =, child, ;, }, parent, ., removeChild, (, block]
[., removeFirstChild, (, ), ;, parent, ., addChildAfter, (, child, ,, previous, ), ;, previous, =, child, ;, }, parent]
[;, previous, =, child, ;, }, parent, ., removeChild, (, block, ), ;, return, true, ;, }, else, {, return]
[., addChildAfter, (, child, ,, previous, ), ;, previous, =, child, ;, }, parent, ., removeChild, (, block, ), ;]
[,, previous, ), ;, previous, =, child, ;, }, parent, ., removeChild, (, block, ), ;, return, true, ;, }]
[), ;, previous, =, child, ;, }, parent, ., removeChild, (, block, ), ;, return, true, ;, }, else, {]
[=, child, ;, }, parent, ., removeChild, (, block, ), ;, return, true, ;, }, else, {, return, false, ;]
[;, }, parent, ., removeChild, (, block, ), ;, return, true, ;, }, else, {, return, false, ;, }, }]
[;, return, true, ;, }, else, {, return, false, ;, }, }, static, boolean, isCallOrNew, (, Node, node, ), {]
[., removeChild, (, block, ), ;, return, true, ;, }, else, {, return, false, ;, }, }, static, boolean, isCallOrNew]
[), ;, return, true, ;, }, else, {, return, false, ;, }, }, static, boolean, isCallOrNew, (, Node, node, )]
[;, }, else, {, return, false, ;, }, }, static, boolean, isCallOrNew, (, Node, node, ), {, return, node, .]
[;, }, }, static, boolean, isCallOrNew, (, Node, node, ), {, return, node, ., isCall, (, ), ||, node, .]
[;, }, static, Node, getFunctionBody, (, Node, fn, ), {, Preconditions, ., checkArgument, (, fn, ., isFunction, (, ), )]
[||, node, ., isNew, (, ), ;, }, static, Node, getFunctionBody, (, Node, fn, ), {, Preconditions, ., checkArgument, (]
[., isCall, (, ), ||, node, ., isNew, (, ), ;, }, static, Node, getFunctionBody, (, Node, fn, ), {]
[;, }, static, Node, getFunctionBody, (, Node, fn, ), {, Preconditions, ., checkArgument, (, fn, ., isFunction, (, ), )]
[., isNew, (, ), ;, }, static, Node, getFunctionBody, (, Node, fn, ), {, Preconditions, ., checkArgument, (, fn, .]
[;, return, fn, ., getLastChild, (, ), ;, }, static, boolean, isFunctionDeclaration, (, Node, n, ), {, return, n, .]
[., checkArgument, (, fn, ., isFunction, (, ), ), ;, return, fn, ., getLastChild, (, ), ;, }, static, boolean]
[), ;, return, fn, ., getLastChild, (, ), ;, }, static, boolean, isFunctionDeclaration, (, Node, n, ), {, return, n]
[., isFunction, (, ), ), ;, return, fn, ., getLastChild, (, ), ;, }, static, boolean, isFunctionDeclaration, (, Node, n]
[;, }, static, boolean, isFunctionDeclaration, (, Node, n, ), {, return, n, ., isFunction, (, ), &&, isStatement, (, n]
[., getLastChild, (, ), ;, }, static, boolean, isFunctionDeclaration, (, Node, n, ), {, return, n, ., isFunction, (, )]
[;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), &&, (, n, ., getParent]
[&&, isStatement, (, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (, n, )]
[., isFunction, (, ), &&, isStatement, (, n, ), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return]
[;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), &&, (, n, ., getParent]
[), ;, }, static, boolean, isHoistedFunctionDeclaration, (, Node, n, ), {, return, isFunctionDeclaration, (, n, ), &&, (, n, .]
[;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return, n, ., isFunction, (, ), &&, !, isStatement, (]
[&&, (, n, ., getParent, (, ), ., isScript, (, ), ||, n, ., getParent, (, ), ., getParent, (]
[), &&, (, n, ., getParent, (, ), ., isScript, (, ), ||, n, ., getParent, (, ), ., getParent]
[;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return, n, ., isFunction, (, ), &&, !, isStatement, (]
[), ;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return, n, ., isFunction, (, ), &&, !, isStatement]
[||, n, ., getParent, (, ), ., getParent, (, ), ., isFunction, (, ), ), ;, }, static, boolean, isFunctionExpression]
[., isScript, (, ), ||, n, ., getParent, (, ), ., getParent, (, ), ., isFunction, (, ), ), ;]
[., getParent, (, ), ., isScript, (, ), ||, n, ., getParent, (, ), ., getParent, (, ), ., isFunction]
[), ;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return, n, ., isFunction, (, ), &&, !, isStatement]
[., isFunction, (, ), ), ;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return, n, ., isFunction, (]
[., getParent, (, ), ., isFunction, (, ), ), ;, }, static, boolean, isFunctionExpression, (, Node, n, ), {, return]
[., getParent, (, ), ., getParent, (, ), ., isFunction, (, ), ), ;, }, static, boolean, isFunctionExpression, (, Node]
[;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !, n, .]
[&&, !, isStatement, (, n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return, n, ., isName]
[., isFunction, (, ), &&, !, isStatement, (, n, ), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {]
[;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !, n, .]
[;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !, n, .]
[), ;, }, static, boolean, isBleedingFunctionName, (, Node, n, ), {, return, n, ., isName, (, ), &&, !, n]
[;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return, isFunctionExpression, (, node, ), &&, isEmptyBlock, (, node, .]
[&&, isFunctionExpression, (, n, ., getParent, (, ), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return]
[&&, !, n, ., getString, (, ), ., isEmpty, (, ), &&, isFunctionExpression, (, n, ., getParent, (, ), )]
[., isName, (, ), &&, !, n, ., getString, (, ), ., isEmpty, (, ), &&, isFunctionExpression, (, n, .]
[&&, isFunctionExpression, (, n, ., getParent, (, ), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return]
[&&, isFunctionExpression, (, n, ., getParent, (, ), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return]
[., isEmpty, (, ), &&, isFunctionExpression, (, n, ., getParent, (, ), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node]
[., getString, (, ), ., isEmpty, (, ), &&, isFunctionExpression, (, n, ., getParent, (, ), ), ;, }, static]
[;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return, isFunctionExpression, (, node, ), &&, isEmptyBlock, (, node, .]
[), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return, isFunctionExpression, (, node, ), &&, isEmptyBlock, (, node]
[., getParent, (, ), ), ;, }, static, boolean, isEmptyFunctionExpression, (, Node, node, ), {, return, isFunctionExpression, (, node, )]
[;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {, Preconditions, ., checkArgument, (, function, ., isFunction, (, ), )]
[&&, isEmptyBlock, (, node, ., getLastChild, (, ), ), ;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {, Preconditions]
[), &&, isEmptyBlock, (, node, ., getLastChild, (, ), ), ;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {]
[;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {, Preconditions, ., checkArgument, (, function, ., isFunction, (, ), )]
[), ;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {, Preconditions, ., checkArgument, (, function, ., isFunction, (, )]
[., getLastChild, (, ), ), ;, }, static, boolean, isVarArgsFunction, (, Node, function, ), {, Preconditions, ., checkArgument, (, function]
[;, return, isNameReferenced, (, function, ., getLastChild, (, ), ,, "arguments", ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isObjectCallMethod, (]
[., checkArgument, (, function, ., isFunction, (, ), ), ;, return, isNameReferenced, (, function, ., getLastChild, (, ), ,, "arguments"]
[), ;, return, isNameReferenced, (, function, ., getLastChild, (, ), ,, "arguments", ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isObjectCallMethod]
[., isFunction, (, ), ), ;, return, isNameReferenced, (, function, ., getLastChild, (, ), ,, "arguments", ,, MATCH_NOT_FUNCTION, ), ;]
[;, }, static, boolean, isObjectCallMethod, (, Node, callNode, ,, String, methodName, ), {, if, (, callNode, ., isCall, (, )]
[,, "arguments", ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isObjectCallMethod, (, Node, callNode, ,, String, methodName, ), {, if, (]
[., getLastChild, (, ), ,, "arguments", ,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isObjectCallMethod, (, Node, callNode, ,, String, methodName]
[,, MATCH_NOT_FUNCTION, ), ;, }, static, boolean, isObjectCallMethod, (, Node, callNode, ,, String, methodName, ), {, if, (, callNode, .]
[), ;, }, static, boolean, isObjectCallMethod, (, Node, callNode, ,, String, methodName, ), {, if, (, callNode, ., isCall, (]
[), {, Node, functionIndentifyingExpression, =, callNode, ., getFirstChild, (, ), ;, if, (, isGet, (, functionIndentifyingExpression, ), ), {, Node]
[., isCall, (, ), ), {, Node, functionIndentifyingExpression, =, callNode, ., getFirstChild, (, ), ;, if, (, isGet, (, functionIndentifyingExpression]
[;, if, (, isGet, (, functionIndentifyingExpression, ), ), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (, ), ;, if, (]
[., getFirstChild, (, ), ;, if, (, isGet, (, functionIndentifyingExpression, ), ), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (]
[), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (, ), ;, if, (, last, !=, null, &&, last, ., isString]
[), ), {, Node, last, =, functionIndentifyingExpression, ., getLastChild, (, ), ;, if, (, last, !=, null, &&, last, .]
[;, if, (, last, !=, null, &&, last, ., isString, (, ), ), {, String, propName, =, last, ., getString]
[., getLastChild, (, ), ;, if, (, last, !=, null, &&, last, ., isString, (, ), ), {, String, propName]
[), {, String, propName, =, last, ., getString, (, ), ;, return, (, propName, ., equals, (, methodName, ), )]
[&&, last, ., isString, (, ), ), {, String, propName, =, last, ., getString, (, ), ;, return, (, propName]
[!=, null, &&, last, ., isString, (, ), ), {, String, propName, =, last, ., getString, (, ), ;, return]
[&&, last, ., isString, (, ), ), {, String, propName, =, last, ., getString, (, ), ;, return, (, propName]
[), {, String, propName, =, last, ., getString, (, ), ;, return, (, propName, ., equals, (, methodName, ), )]
[., isString, (, ), ), {, String, propName, =, last, ., getString, (, ), ;, return, (, propName, ., equals]
[;, return, (, propName, ., equals, (, methodName, ), ), ;, }, }, }, return, false, ;, }, static, boolean]
[., getString, (, ), ;, return, (, propName, ., equals, (, methodName, ), ), ;, }, }, }, return, false]
[;, }, }, }, return, false, ;, }, static, boolean, isFunctionObjectCall, (, Node, callNode, ), {, return, isObjectCallMethod, (, callNode]
[), ;, }, }, }, return, false, ;, }, static, boolean, isFunctionObjectCall, (, Node, callNode, ), {, return, isObjectCallMethod, (]
[., equals, (, methodName, ), ), ;, }, }, }, return, false, ;, }, static, boolean, isFunctionObjectCall, (, Node, callNode]
[), ), ;, }, }, }, return, false, ;, }, static, boolean, isFunctionObjectCall, (, Node, callNode, ), {, return, isObjectCallMethod]
[;, }, static, boolean, isFunctionObjectCall, (, Node, callNode, ), {, return, isObjectCallMethod, (, callNode, ,, "call", ), ;, }, static]
[;, }, static, boolean, isFunctionObjectApply, (, Node, callNode, ), {, return, isObjectCallMethod, (, callNode, ,, "apply", ), ;, }, static]
[,, "call", ), ;, }, static, boolean, isFunctionObjectApply, (, Node, callNode, ), {, return, isObjectCallMethod, (, callNode, ,, "apply", )]
[), ;, }, static, boolean, isFunctionObjectApply, (, Node, callNode, ), {, return, isObjectCallMethod, (, callNode, ,, "apply", ), ;, }]
[;, }, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return, (, parent, ., isAssign, (, )]
[,, "apply", ), ;, }, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return, (, parent, .]
[), ;, }, static, boolean, isVarOrSimpleAssignLhs, (, Node, n, ,, Node, parent, ), {, return, (, parent, ., isAssign, (]
[;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isName, (, )]
[||, parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument]
[), ||, parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, .]
[&&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ;, }, public, static, boolean]
[., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ;]
[), ||, parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, .]
[==, n, ), ||, parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {]
[., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (]
[), ||, parent, ., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, .]
[;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isName, (, )]
[., isVar, (, ), ;, }, public, static, boolean, isLValue, (, Node, n, ), {, Preconditions, ., checkArgument, (, n]
[;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;]
[., checkArgument, (, n, ., isName, (, ), ||, n, ., isGetProp, (, ), ||, n, ., isGetElem, (, )]
[), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false]
[||, n, ., isGetElem, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent]
[||, n, ., isGetProp, (, ), ||, n, ., isGetElem, (, ), ), ;, Node, parent, =, n, ., getParent]
[., isName, (, ), ||, n, ., isGetProp, (, ), ||, n, ., isGetElem, (, ), ), ;, Node, parent]
[||, n, ., isGetElem, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent]
[., isGetProp, (, ), ||, n, ., isGetElem, (, ), ), ;, Node, parent, =, n, ., getParent, (, )]
[), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false]
[., isGetElem, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null]
[;, if, (, parent, ==, null, ), {, return, false, ;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, )]
[., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, false, ;, }, return, (, NodeUtil, .]
[), {, return, false, ;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, )]
[==, null, ), {, return, false, ;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild]
[), {, return, false, ;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, )]
[;, }, return, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[;, }, static, boolean, isObjectLitKey, (, Node, node, ,, Node, parent, ), {, switch, (, node, ., getType, (, )]
[||, parent, ., isCatch, (, ), ;, }, static, boolean, isObjectLitKey, (, Node, node, ,, Node, parent, ), {, switch]
[||, parent, ., isParamList, (, ), ||, parent, ., isCatch, (, ), ;, }, static, boolean, isObjectLitKey, (, Node, node]
[||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||, parent, ., isCatch, (, ), ;, }]
[||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||, parent]
[||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isDec]
[||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==]
[||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, .]
[), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent]
[&&, parent, ., getFirstChild, (, ), ==, n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, .]
[., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, (, NodeUtil, ., isForIn, (]
[), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent]
[), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent]
[==, n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, )]
[., getFirstChild, (, ), ==, n, ), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, ., getFirstChild, (]
[), ||, (, NodeUtil, ., isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent]
[||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==]
[), ||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, )]
[&&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||, (, parent, ., isFunction]
[., isForIn, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, )]
[), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||, (, parent, .]
[), ||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, )]
[==, n, ), ||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild]
[., getFirstChild, (, ), ==, n, ), ||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, )]
[), ||, parent, ., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, )]
[||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isDec]
[., isVar, (, ), ||, (, parent, ., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==, n, )]
[||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||, parent]
[), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||]
[&&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (]
[., isFunction, (, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isDec, (, ), ||]
[), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||]
[==, n, ), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||, parent, ., isParamList, (]
[., getFirstChild, (, ), ==, n, ), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||]
[), ||, parent, ., isDec, (, ), ||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||]
[||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||, parent, ., isCatch, (, ), ;, }]
[., isDec, (, ), ||, parent, ., isInc, (, ), ||, parent, ., isParamList, (, ), ||, parent, ., isCatch]
[||, parent, ., isParamList, (, ), ||, parent, ., isCatch, (, ), ;, }, static, boolean, isObjectLitKey, (, Node, node]
[., isInc, (, ), ||, parent, ., isParamList, (, ), ||, parent, ., isCatch, (, ), ;, }, static, boolean]
[||, parent, ., isCatch, (, ), ;, }, static, boolean, isObjectLitKey, (, Node, node, ,, Node, parent, ), {, switch]
[., isParamList, (, ), ||, parent, ., isCatch, (, ), ;, }, static, boolean, isObjectLitKey, (, Node, node, ,, Node]
[;, }, static, boolean, isObjectLitKey, (, Node, node, ,, Node, parent, ), {, switch, (, node, ., getType, (, )]
[., isCatch, (, ), ;, }, static, boolean, isObjectLitKey, (, Node, node, ,, Node, parent, ), {, switch, (, node]
[), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, true, ;]
[., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF]
[:, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static]
[., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, true, ;, }, return, false, ;]
[:, case, Token, ., SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static, String, getObjectLitKeyName, (, Node, key]
[., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static, String, getObjectLitKeyName, (]
[:, return, true, ;, }, return, false, ;, }, static, String, getObjectLitKeyName, (, Node, key, ), {, switch, (, key]
[., SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static, String, getObjectLitKeyName, (, Node, key, ), {, switch]
[;, }, return, false, ;, }, static, String, getObjectLitKeyName, (, Node, key, ), {, switch, (, key, ., getType, (]
[;, }, static, String, getObjectLitKeyName, (, Node, key, ), {, switch, (, key, ., getType, (, ), ), {, case]
[), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, key, .]
[., getType, (, ), ), {, case, Token, ., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF]
[:, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, key, ., getString, (, ), ;, }, throw]
[., STRING_KEY, :, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, key, ., getString, (, ), ;]
[:, case, Token, ., SETTER_DEF, :, return, key, ., getString, (, ), ;, }, throw, new, IllegalStateException, (, "Unexpected node type: ", +]
[., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, key, ., getString, (, ), ;, }, throw, new, IllegalStateException, (]
[:, return, key, ., getString, (, ), ;, }, throw, new, IllegalStateException, (, "Unexpected node type: ", +, key, ), ;, }, static]
[., SETTER_DEF, :, return, key, ., getString, (, ), ;, }, throw, new, IllegalStateException, (, "Unexpected node type: ", +, key, ), ;]
[;, }, throw, new, IllegalStateException, (, "Unexpected node type: ", +, key, ), ;, }, static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType]
[., getString, (, ), ;, }, throw, new, IllegalStateException, (, "Unexpected node type: ", +, key, ), ;, }, static, JSType, getObjectLitKeyTypeFromValueType, (]
[;, }, static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType, valueType, ), {, if, (, valueType, !=, null, ), {]
[), ;, }, static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType, valueType, ), {, if, (, valueType, !=, null, )]
[+, key, ), ;, }, static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType, valueType, ), {, if, (, valueType, !=]
[), ;, }, static, JSType, getObjectLitKeyTypeFromValueType, (, Node, key, ,, JSType, valueType, ), {, if, (, valueType, !=, null, )]
[), {, switch, (, key, ., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, if, (, valueType, .]
[!=, null, ), {, switch, (, key, ., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, if, (]
[), {, switch, (, key, ., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, if, (, valueType, .]
[), {, case, Token, ., GETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType]
[., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {]
[:, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, valueType]
[., GETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, )]
[), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, valueType, =, fntype, ., getReturnType, (, ), ;, }]
[., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, valueType, =, fntype, ., getReturnType]
[;, valueType, =, fntype, ., getReturnType, (, ), ;, }, else, {, return, null, ;, }, break, ;, case, Token]
[., toMaybeFunctionType, (, ), ;, valueType, =, fntype, ., getReturnType, (, ), ;, }, else, {, return, null, ;, }]
[=, fntype, ., getReturnType, (, ), ;, }, else, {, return, null, ;, }, break, ;, case, Token, ., SETTER_DEF]
[;, }, else, {, return, null, ;, }, break, ;, case, Token, ., SETTER_DEF, :, if, (, valueType, ., isFunctionType]
[., getReturnType, (, ), ;, }, else, {, return, null, ;, }, break, ;, case, Token, ., SETTER_DEF, :, if]
[;, }, break, ;, case, Token, ., SETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype]
[:, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, Node]
[., SETTER_DEF, :, if, (, valueType, ., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, )]
[), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, Node, param, =, fntype, ., getParametersNode, (, ), .]
[., isFunctionType, (, ), ), {, FunctionType, fntype, =, valueType, ., toMaybeFunctionType, (, ), ;, Node, param, =, fntype, .]
[;, Node, param, =, fntype, ., getParametersNode, (, ), ., getFirstChild, (, ), ;, valueType, =, param, ., getJSType, (]
[., toMaybeFunctionType, (, ), ;, Node, param, =, fntype, ., getParametersNode, (, ), ., getFirstChild, (, ), ;, valueType, =]
[;, valueType, =, param, ., getJSType, (, ), ;, }, else, {, return, null, ;, }, break, ;, }, }]
[., getFirstChild, (, ), ;, valueType, =, param, ., getJSType, (, ), ;, }, else, {, return, null, ;, }]
[., getParametersNode, (, ), ., getFirstChild, (, ), ;, valueType, =, param, ., getJSType, (, ), ;, }, else, {]
[=, param, ., getJSType, (, ), ;, }, else, {, return, null, ;, }, break, ;, }, }, return, valueType]
[;, }, else, {, return, null, ;, }, break, ;, }, }, return, valueType, ;, }, static, boolean, isGetOrSetKey, (]
[., getJSType, (, ), ;, }, else, {, return, null, ;, }, break, ;, }, }, return, valueType, ;, }]
[;, }, break, ;, }, }, return, valueType, ;, }, static, boolean, isGetOrSetKey, (, Node, node, ), {, switch, (]
[;, }, static, boolean, isGetOrSetKey, (, Node, node, ), {, switch, (, node, ., getType, (, ), ), {, case]
[), {, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, true, ;, }, return, false, ;, }]
[., getType, (, ), ), {, case, Token, ., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, true, ;, }]
[:, case, Token, ., SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static, String, opToStr, (, int, operator]
[., GETTER_DEF, :, case, Token, ., SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static, String, opToStr, (]
[:, return, true, ;, }, return, false, ;, }, static, String, opToStr, (, int, operator, ), {, switch, (, operator]
[., SETTER_DEF, :, return, true, ;, }, return, false, ;, }, static, String, opToStr, (, int, operator, ), {, switch]
[;, }, return, false, ;, }, static, String, opToStr, (, int, operator, ), {, switch, (, operator, ), {, case]
[;, }, static, String, opToStr, (, int, operator, ), {, switch, (, operator, ), {, case, Token, ., BITOR, :]
[), {, case, Token, ., BITOR, :, return, "|", ;, case, Token, ., OR, :, return, "||", ;, case, Token]
[:, return, "|", ;, case, Token, ., OR, :, return, "||", ;, case, Token, ., BITXOR, :, return, "^", ;]
[., BITOR, :, return, "|", ;, case, Token, ., OR, :, return, "||", ;, case, Token, ., BITXOR, :, return]
[;, case, Token, ., OR, :, return, "||", ;, case, Token, ., BITXOR, :, return, "^", ;, case, Token, .]
[:, return, "||", ;, case, Token, ., BITXOR, :, return, "^", ;, case, Token, ., AND, :, return, "&&", ;]
[., OR, :, return, "||", ;, case, Token, ., BITXOR, :, return, "^", ;, case, Token, ., AND, :, return]
[;, case, Token, ., BITXOR, :, return, "^", ;, case, Token, ., AND, :, return, "&&", ;, case, Token, .]
[:, return, "^", ;, case, Token, ., AND, :, return, "&&", ;, case, Token, ., BITAND, :, return, "&", ;]
[., BITXOR, :, return, "^", ;, case, Token, ., AND, :, return, "&&", ;, case, Token, ., BITAND, :, return]
[;, case, Token, ., AND, :, return, "&&", ;, case, Token, ., BITAND, :, return, "&", ;, case, Token, .]
[:, return, "&&", ;, case, Token, ., BITAND, :, return, "&", ;, case, Token, ., SHEQ, :, return, "===", ;]
[., AND, :, return, "&&", ;, case, Token, ., BITAND, :, return, "&", ;, case, Token, ., SHEQ, :, return]
[;, case, Token, ., BITAND, :, return, "&", ;, case, Token, ., SHEQ, :, return, "===", ;, case, Token, .]
[:, return, "&", ;, case, Token, ., SHEQ, :, return, "===", ;, case, Token, ., EQ, :, return, "==", ;]
[., BITAND, :, return, "&", ;, case, Token, ., SHEQ, :, return, "===", ;, case, Token, ., EQ, :, return]
[;, case, Token, ., SHEQ, :, return, "===", ;, case, Token, ., EQ, :, return, "==", ;, case, Token, .]
[:, return, "===", ;, case, Token, ., EQ, :, return, "==", ;, case, Token, ., NOT, :, return, "!", ;]
[., SHEQ, :, return, "===", ;, case, Token, ., EQ, :, return, "==", ;, case, Token, ., NOT, :, return]
[;, case, Token, ., EQ, :, return, "==", ;, case, Token, ., NOT, :, return, "!", ;, case, Token, .]
[:, return, "==", ;, case, Token, ., NOT, :, return, "!", ;, case, Token, ., NE, :, return, "!=", ;]
[., EQ, :, return, "==", ;, case, Token, ., NOT, :, return, "!", ;, case, Token, ., NE, :, return]
[;, case, Token, ., NOT, :, return, "!", ;, case, Token, ., NE, :, return, "!=", ;, case, Token, .]
[:, return, "!", ;, case, Token, ., NE, :, return, "!=", ;, case, Token, ., SHNE, :, return, "!==", ;]
[., NOT, :, return, "!", ;, case, Token, ., NE, :, return, "!=", ;, case, Token, ., SHNE, :, return]
[;, case, Token, ., NE, :, return, "!=", ;, case, Token, ., SHNE, :, return, "!==", ;, case, Token, .]
[:, return, "!=", ;, case, Token, ., SHNE, :, return, "!==", ;, case, Token, ., LSH, :, return, "<<", ;]
[., NE, :, return, "!=", ;, case, Token, ., SHNE, :, return, "!==", ;, case, Token, ., LSH, :, return]
[;, case, Token, ., SHNE, :, return, "!==", ;, case, Token, ., LSH, :, return, "<<", ;, case, Token, .]
[:, return, "!==", ;, case, Token, ., LSH, :, return, "<<", ;, case, Token, ., IN, :, return, "in", ;]
[., SHNE, :, return, "!==", ;, case, Token, ., LSH, :, return, "<<", ;, case, Token, ., IN, :, return]
[;, case, Token, ., LSH, :, return, "<<", ;, case, Token, ., IN, :, return, "in", ;, case, Token, .]
[:, return, "<<", ;, case, Token, ., IN, :, return, "in", ;, case, Token, ., LE, :, return, "<=", ;]
[., LSH, :, return, "<<", ;, case, Token, ., IN, :, return, "in", ;, case, Token, ., LE, :, return]
[;, case, Token, ., IN, :, return, "in", ;, case, Token, ., LE, :, return, "<=", ;, case, Token, .]
[:, return, "in", ;, case, Token, ., LE, :, return, "<=", ;, case, Token, ., LT, :, return, "<", ;]
[., IN, :, return, "in", ;, case, Token, ., LE, :, return, "<=", ;, case, Token, ., LT, :, return]
[;, case, Token, ., LE, :, return, "<=", ;, case, Token, ., LT, :, return, "<", ;, case, Token, .]
[:, return, "<=", ;, case, Token, ., LT, :, return, "<", ;, case, Token, ., URSH, :, return, ">>>", ;]
[., LE, :, return, "<=", ;, case, Token, ., LT, :, return, "<", ;, case, Token, ., URSH, :, return]
[;, case, Token, ., LT, :, return, "<", ;, case, Token, ., URSH, :, return, ">>>", ;, case, Token, .]
[:, return, "<", ;, case, Token, ., URSH, :, return, ">>>", ;, case, Token, ., RSH, :, return, ">>", ;]
[., LT, :, return, "<", ;, case, Token, ., URSH, :, return, ">>>", ;, case, Token, ., RSH, :, return]
[;, case, Token, ., URSH, :, return, ">>>", ;, case, Token, ., RSH, :, return, ">>", ;, case, Token, .]
[:, return, ">>>", ;, case, Token, ., RSH, :, return, ">>", ;, case, Token, ., GE, :, return, ">=", ;]
[., URSH, :, return, ">>>", ;, case, Token, ., RSH, :, return, ">>", ;, case, Token, ., GE, :, return]
[;, case, Token, ., RSH, :, return, ">>", ;, case, Token, ., GE, :, return, ">=", ;, case, Token, .]
[:, return, ">>", ;, case, Token, ., GE, :, return, ">=", ;, case, Token, ., GT, :, return, ">", ;]
[., RSH, :, return, ">>", ;, case, Token, ., GE, :, return, ">=", ;, case, Token, ., GT, :, return]
[;, case, Token, ., GE, :, return, ">=", ;, case, Token, ., GT, :, return, ">", ;, case, Token, .]
[:, return, ">=", ;, case, Token, ., GT, :, return, ">", ;, case, Token, ., MUL, :, return, "*", ;]
[., GE, :, return, ">=", ;, case, Token, ., GT, :, return, ">", ;, case, Token, ., MUL, :, return]
[;, case, Token, ., GT, :, return, ">", ;, case, Token, ., MUL, :, return, "*", ;, case, Token, .]
[:, return, ">", ;, case, Token, ., MUL, :, return, "*", ;, case, Token, ., DIV, :, return, "/", ;]
[., GT, :, return, ">", ;, case, Token, ., MUL, :, return, "*", ;, case, Token, ., DIV, :, return]
[;, case, Token, ., MUL, :, return, "*", ;, case, Token, ., DIV, :, return, "/", ;, case, Token, .]
[:, return, "*", ;, case, Token, ., DIV, :, return, "/", ;, case, Token, ., MOD, :, return, "%", ;]
[., MUL, :, return, "*", ;, case, Token, ., DIV, :, return, "/", ;, case, Token, ., MOD, :, return]
[;, case, Token, ., DIV, :, return, "/", ;, case, Token, ., MOD, :, return, "%", ;, case, Token, .]
[:, return, "/", ;, case, Token, ., MOD, :, return, "%", ;, case, Token, ., BITNOT, :, return, "~", ;]
[., DIV, :, return, "/", ;, case, Token, ., MOD, :, return, "%", ;, case, Token, ., BITNOT, :, return]
[;, case, Token, ., MOD, :, return, "%", ;, case, Token, ., BITNOT, :, return, "~", ;, case, Token, .]
[:, return, "%", ;, case, Token, ., BITNOT, :, return, "~", ;, case, Token, ., ADD, :, return, "+", ;]
[., MOD, :, return, "%", ;, case, Token, ., BITNOT, :, return, "~", ;, case, Token, ., ADD, :, return]
[;, case, Token, ., BITNOT, :, return, "~", ;, case, Token, ., ADD, :, return, "+", ;, case, Token, .]
[:, return, "~", ;, case, Token, ., ADD, :, return, "+", ;, case, Token, ., SUB, :, return, "-", ;]
[., BITNOT, :, return, "~", ;, case, Token, ., ADD, :, return, "+", ;, case, Token, ., SUB, :, return]
[;, case, Token, ., ADD, :, return, "+", ;, case, Token, ., SUB, :, return, "-", ;, case, Token, .]
[:, return, "+", ;, case, Token, ., SUB, :, return, "-", ;, case, Token, ., POS, :, return, "+", ;]
[., ADD, :, return, "+", ;, case, Token, ., SUB, :, return, "-", ;, case, Token, ., POS, :, return]
[;, case, Token, ., SUB, :, return, "-", ;, case, Token, ., POS, :, return, "+", ;, case, Token, .]
[:, return, "-", ;, case, Token, ., POS, :, return, "+", ;, case, Token, ., NEG, :, return, "-", ;]
[., SUB, :, return, "-", ;, case, Token, ., POS, :, return, "+", ;, case, Token, ., NEG, :, return]
[;, case, Token, ., POS, :, return, "+", ;, case, Token, ., NEG, :, return, "-", ;, case, Token, .]
[:, return, "+", ;, case, Token, ., NEG, :, return, "-", ;, case, Token, ., ASSIGN, :, return, "=", ;]
[., POS, :, return, "+", ;, case, Token, ., NEG, :, return, "-", ;, case, Token, ., ASSIGN, :, return]
[;, case, Token, ., NEG, :, return, "-", ;, case, Token, ., ASSIGN, :, return, "=", ;, case, Token, .]
[:, return, "-", ;, case, Token, ., ASSIGN, :, return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;]
[., NEG, :, return, "-", ;, case, Token, ., ASSIGN, :, return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return]
[;, case, Token, ., ASSIGN, :, return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;, case, Token, .]
[:, return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;]
[., ASSIGN, :, return, "=", ;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return]
[;, case, Token, ., ASSIGN_BITOR, :, return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;, case, Token, .]
[:, return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;]
[., ASSIGN_BITOR, :, return, "|=", ;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return]
[;, case, Token, ., ASSIGN_BITXOR, :, return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;, case, Token, .]
[:, return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;]
[., ASSIGN_BITXOR, :, return, "^=", ;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return]
[;, case, Token, ., ASSIGN_BITAND, :, return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;, case, Token, .]
[:, return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;]
[., ASSIGN_BITAND, :, return, "&=", ;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return]
[;, case, Token, ., ASSIGN_LSH, :, return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;, case, Token, .]
[:, return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;]
[., ASSIGN_LSH, :, return, "<<=", ;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return]
[;, case, Token, ., ASSIGN_RSH, :, return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;, case, Token, .]
[:, return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;]
[., ASSIGN_RSH, :, return, ">>=", ;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return]
[;, case, Token, ., ASSIGN_URSH, :, return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;, case, Token, .]
[:, return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;]
[., ASSIGN_URSH, :, return, ">>>=", ;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return]
[;, case, Token, ., ASSIGN_ADD, :, return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;, case, Token, .]
[:, return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;]
[., ASSIGN_ADD, :, return, "+=", ;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return]
[;, case, Token, ., ASSIGN_SUB, :, return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;, case, Token, .]
[:, return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;]
[., ASSIGN_SUB, :, return, "-=", ;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return]
[;, case, Token, ., ASSIGN_MUL, :, return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;, case, Token, .]
[:, return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;]
[., ASSIGN_MUL, :, return, "*=", ;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return]
[;, case, Token, ., ASSIGN_DIV, :, return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;, case, Token, .]
[:, return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;, case, Token, ., VOID, :, return, "void", ;]
[., ASSIGN_DIV, :, return, "/=", ;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;, case, Token, ., VOID, :, return]
[;, case, Token, ., ASSIGN_MOD, :, return, "%=", ;, case, Token, ., VOID, :, return, "void", ;, case, Token, .]
[:, return, "%=", ;, case, Token, ., VOID, :, return, "void", ;, case, Token, ., TYPEOF, :, return, "typeof", ;]
[., ASSIGN_MOD, :, return, "%=", ;, case, Token, ., VOID, :, return, "void", ;, case, Token, ., TYPEOF, :, return]
[;, case, Token, ., VOID, :, return, "void", ;, case, Token, ., TYPEOF, :, return, "typeof", ;, case, Token, .]
[:, return, "void", ;, case, Token, ., TYPEOF, :, return, "typeof", ;, case, Token, ., INSTANCEOF, :, return, "instanceof", ;]
[., VOID, :, return, "void", ;, case, Token, ., TYPEOF, :, return, "typeof", ;, case, Token, ., INSTANCEOF, :, return]
[;, case, Token, ., TYPEOF, :, return, "typeof", ;, case, Token, ., INSTANCEOF, :, return, "instanceof", ;, default, :, return]
[:, return, "typeof", ;, case, Token, ., INSTANCEOF, :, return, "instanceof", ;, default, :, return, null, ;, }, }, static]
[., TYPEOF, :, return, "typeof", ;, case, Token, ., INSTANCEOF, :, return, "instanceof", ;, default, :, return, null, ;, }]
[;, case, Token, ., INSTANCEOF, :, return, "instanceof", ;, default, :, return, null, ;, }, }, static, String, opToStrNoFail, (]
[:, return, "instanceof", ;, default, :, return, null, ;, }, }, static, String, opToStrNoFail, (, int, operator, ), {, String]
[., INSTANCEOF, :, return, "instanceof", ;, default, :, return, null, ;, }, }, static, String, opToStrNoFail, (, int, operator, )]
[;, default, :, return, null, ;, }, }, static, String, opToStrNoFail, (, int, operator, ), {, String, res, =, opToStr]
[;, }, }, static, String, opToStrNoFail, (, int, operator, ), {, String, res, =, opToStr, (, operator, ), ;, if]
[;, if, (, res, ==, null, ), {, throw, new, Error, (, "Unknown op ", +, operator, +, ": ", +, Token, .]
[), ;, if, (, res, ==, null, ), {, throw, new, Error, (, "Unknown op ", +, operator, +, ": ", +, Token]
[), {, throw, new, Error, (, "Unknown op ", +, operator, +, ": ", +, Token, ., name, (, operator, ), ), ;]
[==, null, ), {, throw, new, Error, (, "Unknown op ", +, operator, +, ": ", +, Token, ., name, (, operator, )]
[), {, throw, new, Error, (, "Unknown op ", +, operator, +, ": ", +, Token, ., name, (, operator, ), ), ;]
[;, }, return, res, ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ,, Predicate, <, Node, >]
[), ;, }, return, res, ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ,, Predicate, <, Node]
[+, Token, ., name, (, operator, ), ), ;, }, return, res, ;, }, static, boolean, containsType, (, Node, node]
[+, ": ", +, Token, ., name, (, operator, ), ), ;, }, return, res, ;, }, static, boolean, containsType, (]
[+, operator, +, ": ", +, Token, ., name, (, operator, ), ), ;, }, return, res, ;, }, static, boolean]
[+, ": ", +, Token, ., name, (, operator, ), ), ;, }, return, res, ;, }, static, boolean, containsType, (]
[+, Token, ., name, (, operator, ), ), ;, }, return, res, ;, }, static, boolean, containsType, (, Node, node]
[), ;, }, return, res, ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ,, Predicate, <, Node]
[., name, (, operator, ), ), ;, }, return, res, ;, }, static, boolean, containsType, (, Node, node, ,, int]
[), ), ;, }, return, res, ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ,, Predicate, <]
[;, }, static, boolean, containsType, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return]
[;, }, static, boolean, containsType, (, Node, node, ,, int, type, ), {, return, containsType, (, node, ,, type, ,]
[,, new, MatchNodeType, (, type, ), ,, traverseChildrenPred, ), ;, }, static, boolean, containsType, (, Node, node, ,, int, type]
[,, traverseChildrenPred, ), ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ), {, return, containsType, (, node]
[), ,, traverseChildrenPred, ), ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ), {, return, containsType, (]
[), ;, }, static, boolean, containsType, (, Node, node, ,, int, type, ), {, return, containsType, (, node, ,, type]
[;, }, static, void, redeclareVarsInsideBranch, (, Node, branch, ), {, Collection, <, Node, >, vars, =, getVarsDeclaredInBranch, (, branch, )]
[,, type, ,, Predicates, ., <, Node, >, alwaysTrue, (, ), ), ;, }, static, void, redeclareVarsInsideBranch, (, Node, branch]
[,, Predicates, ., <, Node, >, alwaysTrue, (, ), ), ;, }, static, void, redeclareVarsInsideBranch, (, Node, branch, ), {]
[), ;, }, static, void, redeclareVarsInsideBranch, (, Node, branch, ), {, Collection, <, Node, >, vars, =, getVarsDeclaredInBranch, (, branch]
[., <, Node, >, alwaysTrue, (, ), ), ;, }, static, void, redeclareVarsInsideBranch, (, Node, branch, ), {, Collection, <]
[;, if, (, vars, ., isEmpty, (, ), ), {, return, ;, }, Node, parent, =, getAddingRoot, (, branch, )]
[), ;, if, (, vars, ., isEmpty, (, ), ), {, return, ;, }, Node, parent, =, getAddingRoot, (, branch]
[), {, return, ;, }, Node, parent, =, getAddingRoot, (, branch, ), ;, for, (, Node, nameNode, :, vars, )]
[., isEmpty, (, ), ), {, return, ;, }, Node, parent, =, getAddingRoot, (, branch, ), ;, for, (, Node]
[;, for, (, Node, nameNode, :, vars, ), {, Node, var, =, IR, ., var, (, IR, ., name, (]
[), ;, for, (, Node, nameNode, :, vars, ), {, Node, var, =, IR, ., var, (, IR, ., name]
[), {, Node, var, =, IR, ., var, (, IR, ., name, (, nameNode, ., getString, (, ), ), .]
[;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild, (, ), ), ;, parent, ., addChildToFront, (, var, ), ;, }]
[., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild, (, ), ), ;, parent, ., addChildToFront]
[., var, (, IR, ., name, (, nameNode, ., getString, (, ), ), ., srcref, (, nameNode, ), ), .]
[), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild, (, ), ), ;, parent, .]
[., srcref, (, nameNode, ), ), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild, (]
[., name, (, nameNode, ., getString, (, ), ), ., srcref, (, nameNode, ), ), ., srcref, (, nameNode, )]
[), ., srcref, (, nameNode, ), ), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild]
[., getString, (, ), ), ., srcref, (, nameNode, ), ), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode]
[), ), ., srcref, (, nameNode, ), ;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild, (, ), ), ;, parent]
[), ;, copyNameAnnotations, (, nameNode, ,, var, ., getFirstChild, (, ), ), ;, parent, ., addChildToFront, (, var, ), ;]
[;, parent, ., addChildToFront, (, var, ), ;, }, }, static, void, copyNameAnnotations, (, Node, source, ,, Node, destination, )]
[,, var, ., getFirstChild, (, ), ), ;, parent, ., addChildToFront, (, var, ), ;, }, }, static, void, copyNameAnnotations]
[), ;, parent, ., addChildToFront, (, var, ), ;, }, }, static, void, copyNameAnnotations, (, Node, source, ,, Node, destination]
[., getFirstChild, (, ), ), ;, parent, ., addChildToFront, (, var, ), ;, }, }, static, void, copyNameAnnotations, (, Node]
[;, }, }, static, void, copyNameAnnotations, (, Node, source, ,, Node, destination, ), {, if, (, source, ., getBooleanProp, (]
[., addChildToFront, (, var, ), ;, }, }, static, void, copyNameAnnotations, (, Node, source, ,, Node, destination, ), {, if]
[), ;, }, }, static, void, copyNameAnnotations, (, Node, source, ,, Node, destination, ), {, if, (, source, ., getBooleanProp]
[), {, destination, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, }, private, static, Node, getAddingRoot, (]
[., getBooleanProp, (, Node, ., IS_CONSTANT_NAME, ), ), {, destination, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;]
[), ), {, destination, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, }, private, static, Node, getAddingRoot]
[., IS_CONSTANT_NAME, ), ), {, destination, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, }, private, static]
[;, }, }, private, static, Node, getAddingRoot, (, Node, n, ), {, Node, addingRoot, =, null, ;, Node, ancestor, =]
[., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, }, private, static, Node, getAddingRoot, (, Node, n, )]
[,, true, ), ;, }, }, private, static, Node, getAddingRoot, (, Node, n, ), {, Node, addingRoot, =, null, ;]
[., IS_CONSTANT_NAME, ,, true, ), ;, }, }, private, static, Node, getAddingRoot, (, Node, n, ), {, Node, addingRoot, =]
[), ;, }, }, private, static, Node, getAddingRoot, (, Node, n, ), {, Node, addingRoot, =, null, ;, Node, ancestor]
[;, Node, ancestor, =, n, ;, while, (, null, !=, (, ancestor, =, ancestor, ., getParent, (, ), ), )]
[;, while, (, null, !=, (, ancestor, =, ancestor, ., getParent, (, ), ), ), {, int, type, =, ancestor]
[), {, int, type, =, ancestor, ., getType, (, ), ;, if, (, type, ==, Token, ., SCRIPT, ), {]
[!=, (, ancestor, =, ancestor, ., getParent, (, ), ), ), {, int, type, =, ancestor, ., getType, (, )]
[), {, int, type, =, ancestor, ., getType, (, ), ;, if, (, type, ==, Token, ., SCRIPT, ), {]
[=, ancestor, ., getParent, (, ), ), ), {, int, type, =, ancestor, ., getType, (, ), ;, if, (]
[), ), {, int, type, =, ancestor, ., getType, (, ), ;, if, (, type, ==, Token, ., SCRIPT, )]
[., getParent, (, ), ), ), {, int, type, =, ancestor, ., getType, (, ), ;, if, (, type, ==]
[;, if, (, type, ==, Token, ., SCRIPT, ), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (]
[., getType, (, ), ;, if, (, type, ==, Token, ., SCRIPT, ), {, addingRoot, =, ancestor, ;, break, ;]
[), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (, type, ==, Token, ., FUNCTION, ), {, addingRoot]
[==, Token, ., SCRIPT, ), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (, type, ==, Token, .]
[), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (, type, ==, Token, ., FUNCTION, ), {, addingRoot]
[., SCRIPT, ), {, addingRoot, =, ancestor, ;, break, ;, }, else, if, (, type, ==, Token, ., FUNCTION, )]
[=, ancestor, ;, break, ;, }, else, if, (, type, ==, Token, ., FUNCTION, ), {, addingRoot, =, ancestor, .]
[;, break, ;, }, else, if, (, type, ==, Token, ., FUNCTION, ), {, addingRoot, =, ancestor, ., getLastChild, (]
[), {, addingRoot, =, ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (, addingRoot, .]
[==, Token, ., FUNCTION, ), {, addingRoot, =, ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, .]
[), {, addingRoot, =, ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (, addingRoot, .]
[., FUNCTION, ), {, addingRoot, =, ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (]
[=, ancestor, ., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (, addingRoot, ., isBlock, (, )]
[;, break, ;, }, }, Preconditions, ., checkState, (, addingRoot, ., isBlock, (, ), ||, addingRoot, ., isScript, (, )]
[., getLastChild, (, ), ;, break, ;, }, }, Preconditions, ., checkState, (, addingRoot, ., isBlock, (, ), ||, addingRoot]
[;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||, !, addingRoot, ., getFirstChild, (, ), .]
[., checkState, (, addingRoot, ., isBlock, (, ), ||, addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (]
[), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||, !, addingRoot, ., getFirstChild, (, )]
[||, addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||]
[., isBlock, (, ), ||, addingRoot, ., isScript, (, ), ), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (]
[), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||, !, addingRoot, ., getFirstChild, (, )]
[., isScript, (, ), ), ;, Preconditions, ., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||, !, addingRoot]
[;, return, addingRoot, ;, }, public, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ), {, int, endPos, =]
[., checkState, (, addingRoot, ., getFirstChild, (, ), ==, null, ||, !, addingRoot, ., getFirstChild, (, ), ., isScript, (]
[), ;, return, addingRoot, ;, }, public, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ), {, int, endPos]
[||, !, addingRoot, ., getFirstChild, (, ), ., isScript, (, ), ), ;, return, addingRoot, ;, }, public, static, Node]
[==, null, ||, !, addingRoot, ., getFirstChild, (, ), ., isScript, (, ), ), ;, return, addingRoot, ;, }, public]
[., getFirstChild, (, ), ==, null, ||, !, addingRoot, ., getFirstChild, (, ), ., isScript, (, ), ), ;, return]
[||, !, addingRoot, ., getFirstChild, (, ), ., isScript, (, ), ), ;, return, addingRoot, ;, }, public, static, Node]
[), ;, return, addingRoot, ;, }, public, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ), {, int, endPos]
[), ;, return, addingRoot, ;, }, public, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ), {, int, endPos]
[., isScript, (, ), ), ;, return, addingRoot, ;, }, public, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name]
[., getFirstChild, (, ), ., isScript, (, ), ), ;, return, addingRoot, ;, }, public, static, Node, newQualifiedNameNode, (, CodingConvention]
[;, }, public, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ), {, int, endPos, =, name, ., indexOf]
[;, if, (, endPos, ==, -, 1, ), {, return, newName, (, convention, ,, name, ), ;, }, Node, node]
[., indexOf, (, '.', ), ;, if, (, endPos, ==, -, 1, ), {, return, newName, (, convention, ,, name]
[), ;, if, (, endPos, ==, -, 1, ), {, return, newName, (, convention, ,, name, ), ;, }, Node]
[), {, return, newName, (, convention, ,, name, ), ;, }, Node, node, =, newName, (, convention, ,, name, .]
[==, -, 1, ), {, return, newName, (, convention, ,, name, ), ;, }, Node, node, =, newName, (, convention]
[), {, return, newName, (, convention, ,, name, ), ;, }, Node, node, =, newName, (, convention, ,, name, .]
[), {, return, newName, (, convention, ,, name, ), ;, }, Node, node, =, newName, (, convention, ,, name, .]
[;, }, Node, node, =, newName, (, convention, ,, name, ., substring, (, 0, ,, endPos, ), ), ;, int]
[,, name, ), ;, }, Node, node, =, newName, (, convention, ,, name, ., substring, (, 0, ,, endPos, )]
[), ;, }, Node, node, =, newName, (, convention, ,, name, ., substring, (, 0, ,, endPos, ), ), ;]
[;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;, endPos, =, name, ., indexOf, (, '.', ,]
[,, name, ., substring, (, 0, ,, endPos, ), ), ;, int, startPos, ;, do, {, startPos, =, endPos, +]
[), ;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;, endPos, =, name, ., indexOf, (, '.']
[., substring, (, 0, ,, endPos, ), ), ;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;]
[,, endPos, ), ), ;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;, endPos, =, name, .]
[), ), ;, int, startPos, ;, do, {, startPos, =, endPos, +, 1, ;, endPos, =, name, ., indexOf, (]
[=, endPos, +, 1, ;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (]
[;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1]
[+, 1, ;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==]
[;, endPos, =, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1]
[=, name, ., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1, ?, name]
[;, String, part, =, (, endPos, ==, -, 1, ?, name, ., substring, (, startPos, ), :, name, ., substring]
[., indexOf, (, '.', ,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1, ?, name, ., substring]
[,, startPos, ), ;, String, part, =, (, endPos, ==, -, 1, ?, name, ., substring, (, startPos, ), :]
[), ;, String, part, =, (, endPos, ==, -, 1, ?, name, ., substring, (, startPos, ), :, name, .]
[;, Node, propNode, =, IR, ., string, (, part, ), ;, if, (, convention, ., isConstantKey, (, part, ), )]
[), ;, Node, propNode, =, IR, ., string, (, part, ), ;, if, (, convention, ., isConstantKey, (, part, )]
[?, name, ., substring, (, startPos, ), :, name, ., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode]
[==, -, 1, ?, name, ., substring, (, startPos, ), :, name, ., substring, (, startPos, ,, endPos, ), )]
[?, name, ., substring, (, startPos, ), :, name, ., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode]
[?, name, ., substring, (, startPos, ), :, name, ., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode]
[:, name, ., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode, =, IR, ., string, (, part, )]
[., substring, (, startPos, ), :, name, ., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode, =, IR]
[), :, name, ., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode, =, IR, ., string, (, part]
[), ;, Node, propNode, =, IR, ., string, (, part, ), ;, if, (, convention, ., isConstantKey, (, part, )]
[., substring, (, startPos, ,, endPos, ), ), ;, Node, propNode, =, IR, ., string, (, part, ), ;, if]
[,, endPos, ), ), ;, Node, propNode, =, IR, ., string, (, part, ), ;, if, (, convention, ., isConstantKey]
[), ), ;, Node, propNode, =, IR, ., string, (, part, ), ;, if, (, convention, ., isConstantKey, (, part]
[;, if, (, convention, ., isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true]
[., string, (, part, ), ;, if, (, convention, ., isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (]
[), ;, if, (, convention, ., isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,]
[), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, node, =, IR, ., getprop, (]
[., isConstantKey, (, part, ), ), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, node]
[), ), {, propNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, node, =, IR, ., getprop]
[;, }, node, =, IR, ., getprop, (, node, ,, propNode, ), ;, }, while, (, endPos, !=, -, 1]
[., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, node, =, IR, ., getprop, (, node, ,, propNode]
[,, true, ), ;, }, node, =, IR, ., getprop, (, node, ,, propNode, ), ;, }, while, (, endPos]
[., IS_CONSTANT_NAME, ,, true, ), ;, }, node, =, IR, ., getprop, (, node, ,, propNode, ), ;, }, while]
[), ;, }, node, =, IR, ., getprop, (, node, ,, propNode, ), ;, }, while, (, endPos, !=, -]
[=, IR, ., getprop, (, node, ,, propNode, ), ;, }, while, (, endPos, !=, -, 1, ), ;, return]
[;, }, while, (, endPos, !=, -, 1, ), ;, return, node, ;, }, static, Node, newQualifiedNameNode, (, CodingConvention, convention]
[., getprop, (, node, ,, propNode, ), ;, }, while, (, endPos, !=, -, 1, ), ;, return, node, ;]
[,, propNode, ), ;, }, while, (, endPos, !=, -, 1, ), ;, return, node, ;, }, static, Node, newQualifiedNameNode]
[), ;, }, while, (, endPos, !=, -, 1, ), ;, return, node, ;, }, static, Node, newQualifiedNameNode, (, CodingConvention]
[), ;, return, node, ;, }, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String]
[!=, -, 1, ), ;, return, node, ;, }, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ,, Node]
[), ;, return, node, ;, }, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String]
[), ;, return, node, ;, }, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String]
[;, }, static, Node, newQualifiedNameNode, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node]
[;, setDebugInformation, (, node, ,, basisNode, ,, originalName, ), ;, return, node, ;, }, static, Node, getRootOfQualifiedName, (, Node, qName]
[,, name, ), ;, setDebugInformation, (, node, ,, basisNode, ,, originalName, ), ;, return, node, ;, }, static, Node, getRootOfQualifiedName]
[), ;, setDebugInformation, (, node, ,, basisNode, ,, originalName, ), ;, return, node, ;, }, static, Node, getRootOfQualifiedName, (, Node]
[;, return, node, ;, }, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (, Node, current, =, qName, ;]
[,, basisNode, ,, originalName, ), ;, return, node, ;, }, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (]
[,, originalName, ), ;, return, node, ;, }, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (, Node, current]
[), ;, return, node, ;, }, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (, Node, current, =, qName]
[;, }, static, Node, getRootOfQualifiedName, (, Node, qName, ), {, for, (, Node, current, =, qName, ;, true, ;, current]
[;, true, ;, current, =, current, ., getFirstChild, (, ), ), {, if, (, current, ., isName, (, ), ||]
[;, current, =, current, ., getFirstChild, (, ), ), {, if, (, current, ., isName, (, ), ||, current, .]
[=, current, ., getFirstChild, (, ), ), {, if, (, current, ., isName, (, ), ||, current, ., isThis, (]
[), {, if, (, current, ., isName, (, ), ||, current, ., isThis, (, ), ), {, return, current, ;]
[., getFirstChild, (, ), ), {, if, (, current, ., isName, (, ), ||, current, ., isThis, (, ), )]
[), {, return, current, ;, }, Preconditions, ., checkState, (, current, ., isGetProp, (, ), ), ;, }, }, static]
[||, current, ., isThis, (, ), ), {, return, current, ;, }, Preconditions, ., checkState, (, current, ., isGetProp, (]
[., isName, (, ), ||, current, ., isThis, (, ), ), {, return, current, ;, }, Preconditions, ., checkState, (]
[), {, return, current, ;, }, Preconditions, ., checkState, (, current, ., isGetProp, (, ), ), ;, }, }, static]
[., isThis, (, ), ), {, return, current, ;, }, Preconditions, ., checkState, (, current, ., isGetProp, (, ), )]
[;, }, Preconditions, ., checkState, (, current, ., isGetProp, (, ), ), ;, }, }, static, void, setDebugInformation, (, Node]
[;, }, }, static, void, setDebugInformation, (, Node, node, ,, Node, basisNode, ,, String, originalName, ), {, node, ., copyInformationFromForTree]
[., checkState, (, current, ., isGetProp, (, ), ), ;, }, }, static, void, setDebugInformation, (, Node, node, ,, Node]
[), ;, }, }, static, void, setDebugInformation, (, Node, node, ,, Node, basisNode, ,, String, originalName, ), {, node, .]
[., isGetProp, (, ), ), ;, }, }, static, void, setDebugInformation, (, Node, node, ,, Node, basisNode, ,, String, originalName]
[;, node, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, }, private, static, Node, newName, (, CodingConvention, convention]
[., copyInformationFromForTree, (, basisNode, ), ;, node, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, }, private, static]
[), ;, node, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, }, private, static, Node, newName, (, CodingConvention]
[;, }, private, static, Node, newName, (, CodingConvention, convention, ,, String, name, ), {, Node, nameNode, =, IR, ., name]
[., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, }, private, static, Node, newName, (, CodingConvention, convention, ,, String]
[,, originalName, ), ;, }, private, static, Node, newName, (, CodingConvention, convention, ,, String, name, ), {, Node, nameNode, =]
[., ORIGINALNAME_PROP, ,, originalName, ), ;, }, private, static, Node, newName, (, CodingConvention, convention, ,, String, name, ), {, Node]
[), ;, }, private, static, Node, newName, (, CodingConvention, convention, ,, String, name, ), {, Node, nameNode, =, IR, .]
[;, if, (, convention, ., isConstant, (, name, ), ), {, nameNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true]
[., name, (, name, ), ;, if, (, convention, ., isConstant, (, name, ), ), {, nameNode, ., putBooleanProp, (]
[), ;, if, (, convention, ., isConstant, (, name, ), ), {, nameNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,]
[), {, nameNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, return, nameNode, ;, }, static, Node]
[., isConstant, (, name, ), ), {, nameNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, return]
[), ), {, nameNode, ., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, return, nameNode, ;, }, static]
[;, }, return, nameNode, ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, srcref, ), {]
[., putBooleanProp, (, Node, ., IS_CONSTANT_NAME, ,, true, ), ;, }, return, nameNode, ;, }, static, Node, newName, (, CodingConvention]
[,, true, ), ;, }, return, nameNode, ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node]
[., IS_CONSTANT_NAME, ,, true, ), ;, }, return, nameNode, ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name]
[), ;, }, return, nameNode, ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, srcref, )]
[;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, srcref, ), {, return, newName, (, convention]
[;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String, originalName, ), {, Node]
[., srcref, (, srcref, ), ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,]
[,, name, ), ., srcref, (, srcref, ), ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,]
[), ., srcref, (, srcref, ), ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode]
[), ;, }, static, Node, newName, (, CodingConvention, convention, ,, String, name, ,, Node, basisNode, ,, String, originalName, ), {]
[;, nameNode, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, return, nameNode, ;, }, static, boolean, isLatin, (]
[,, name, ,, basisNode, ), ;, nameNode, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, return, nameNode, ;]
[,, basisNode, ), ;, nameNode, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, return, nameNode, ;, }, static]
[), ;, nameNode, ., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, return, nameNode, ;, }, static, boolean, isLatin]
[;, return, nameNode, ;, }, static, boolean, isLatin, (, String, s, ), {, int, len, =, s, ., length, (]
[., putProp, (, Node, ., ORIGINALNAME_PROP, ,, originalName, ), ;, return, nameNode, ;, }, static, boolean, isLatin, (, String, s]
[,, originalName, ), ;, return, nameNode, ;, }, static, boolean, isLatin, (, String, s, ), {, int, len, =, s]
[., ORIGINALNAME_PROP, ,, originalName, ), ;, return, nameNode, ;, }, static, boolean, isLatin, (, String, s, ), {, int, len]
[), ;, return, nameNode, ;, }, static, boolean, isLatin, (, String, s, ), {, int, len, =, s, ., length]
[;, }, static, boolean, isLatin, (, String, s, ), {, int, len, =, s, ., length, (, ), ;, for]
[;, for, (, int, index, =, 0, ;, index, <, len, ;, index, ++, ), {, char, c, =, s]
[., length, (, ), ;, for, (, int, index, =, 0, ;, index, <, len, ;, index, ++, ), {]
[;, index, <, len, ;, index, ++, ), {, char, c, =, s, ., charAt, (, index, ), ;, if]
[;, index, ++, ), {, char, c, =, s, ., charAt, (, index, ), ;, if, (, c, >, LARGEST_BASIC_LATIN]
[<, len, ;, index, ++, ), {, char, c, =, s, ., charAt, (, index, ), ;, if, (, c]
[;, index, ++, ), {, char, c, =, s, ., charAt, (, index, ), ;, if, (, c, >, LARGEST_BASIC_LATIN]
[), {, char, c, =, s, ., charAt, (, index, ), ;, if, (, c, >, LARGEST_BASIC_LATIN, ), {, return]
[++, ), {, char, c, =, s, ., charAt, (, index, ), ;, if, (, c, >, LARGEST_BASIC_LATIN, ), {]
[;, if, (, c, >, LARGEST_BASIC_LATIN, ), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidSimpleName]
[., charAt, (, index, ), ;, if, (, c, >, LARGEST_BASIC_LATIN, ), {, return, false, ;, }, }, return, true]
[), ;, if, (, c, >, LARGEST_BASIC_LATIN, ), {, return, false, ;, }, }, return, true, ;, }, static, boolean]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return]
[>, LARGEST_BASIC_LATIN, ), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, )]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return]
[;, }, }, return, true, ;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return, TokenStream, ., isJSIdentifier, (]
[;, }, static, boolean, isValidSimpleName, (, String, name, ), {, return, TokenStream, ., isJSIdentifier, (, name, ), &&, !, TokenStream]
[;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, ., endsWith, (, ".", ), ||]
[&&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, .]
[&&, !, TokenStream, ., isKeyword, (, name, ), &&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName, (]
[., isJSIdentifier, (, name, ), &&, !, TokenStream, ., isKeyword, (, name, ), &&, isLatin, (, name, ), ;, }]
[), &&, !, TokenStream, ., isKeyword, (, name, ), &&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName]
[&&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, .]
[&&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, .]
[., isKeyword, (, name, ), &&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, )]
[), &&, isLatin, (, name, ), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name]
[;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, ., endsWith, (, ".", ), ||]
[), ;, }, public, static, boolean, isValidQualifiedName, (, String, name, ), {, if, (, name, ., endsWith, (, ".", )]
[), {, return, false, ;, }, String, [, ], parts, =, name, ., split, (, "\\.", ), ;, for, (]
[||, name, ., startsWith, (, ".", ), ), {, return, false, ;, }, String, [, ], parts, =, name, .]
[., endsWith, (, ".", ), ||, name, ., startsWith, (, ".", ), ), {, return, false, ;, }, String, []
[), ||, name, ., startsWith, (, ".", ), ), {, return, false, ;, }, String, [, ], parts, =, name]
[), {, return, false, ;, }, String, [, ], parts, =, name, ., split, (, "\\.", ), ;, for, (]
[., startsWith, (, ".", ), ), {, return, false, ;, }, String, [, ], parts, =, name, ., split, (]
[), ), {, return, false, ;, }, String, [, ], parts, =, name, ., split, (, "\\.", ), ;, for]
[;, }, String, [, ], parts, =, name, ., split, (, "\\.", ), ;, for, (, String, part, :, parts]
[;, for, (, String, part, :, parts, ), {, if, (, !, isValidSimpleName, (, part, ), ), {, return, false]
[., split, (, "\\.", ), ;, for, (, String, part, :, parts, ), {, if, (, !, isValidSimpleName, (, part]
[), ;, for, (, String, part, :, parts, ), {, if, (, !, isValidSimpleName, (, part, ), ), {, return]
[), {, if, (, !, isValidSimpleName, (, part, ), ), {, return, false, ;, }, }, return, true, ;, }]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidPropertyName, (, String, name, ), {, return]
[), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidPropertyName, (, String, name, ), {, return]
[), ), {, return, false, ;, }, }, return, true, ;, }, static, boolean, isValidPropertyName, (, String, name, ), {]
[;, }, }, return, true, ;, }, static, boolean, isValidPropertyName, (, String, name, ), {, return, isValidSimpleName, (, name, )]
[;, }, static, boolean, isValidPropertyName, (, String, name, ), {, return, isValidSimpleName, (, name, ), ;, }, private, static, class]
[;, }, private, static, class, VarCollector, implements, Visitor, {, final, Map, <, String, ,, Node, >, vars, =, Maps, .]
[), ;, }, private, static, class, VarCollector, implements, Visitor, {, final, Map, <, String, ,, Node, >, vars, =, Maps]
[;, @, Override, public, void, visit, (, Node, n, ), {, if, (, n, ., isName, (, ), ), {]
[., newLinkedHashMap, (, ), ;, @, Override, public, void, visit, (, Node, n, ), {, if, (, n, ., isName]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, !=, null, &&, parent, ., isVar]
[., isName, (, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, !=, null]
[;, if, (, parent, !=, null, &&, parent, ., isVar, (, ), ), {, String, name, =, n, ., getString]
[., getParent, (, ), ;, if, (, parent, !=, null, &&, parent, ., isVar, (, ), ), {, String, name]
[), {, String, name, =, n, ., getString, (, ), ;, if, (, !, vars, ., containsKey, (, name, )]
[&&, parent, ., isVar, (, ), ), {, String, name, =, n, ., getString, (, ), ;, if, (, !]
[!=, null, &&, parent, ., isVar, (, ), ), {, String, name, =, n, ., getString, (, ), ;, if]
[&&, parent, ., isVar, (, ), ), {, String, name, =, n, ., getString, (, ), ;, if, (, !]
[), {, String, name, =, n, ., getString, (, ), ;, if, (, !, vars, ., containsKey, (, name, )]
[., isVar, (, ), ), {, String, name, =, n, ., getString, (, ), ;, if, (, !, vars, .]
[;, if, (, !, vars, ., containsKey, (, name, ), ), {, vars, ., put, (, name, ,, n, )]
[., getString, (, ), ;, if, (, !, vars, ., containsKey, (, name, ), ), {, vars, ., put, (]
[), {, vars, ., put, (, name, ,, n, ), ;, }, }, }, }, }, static, Collection, <, Node]
[), {, vars, ., put, (, name, ,, n, ), ;, }, }, }, }, }, static, Collection, <, Node]
[., containsKey, (, name, ), ), {, vars, ., put, (, name, ,, n, ), ;, }, }, }, }]
[), ), {, vars, ., put, (, name, ,, n, ), ;, }, }, }, }, }, static, Collection, <]
[;, }, }, }, }, }, static, Collection, <, Node, >, getVarsDeclaredInBranch, (, Node, root, ), {, VarCollector, collector, =]
[., put, (, name, ,, n, ), ;, }, }, }, }, }, static, Collection, <, Node, >, getVarsDeclaredInBranch, (]
[,, n, ), ;, }, }, }, }, }, static, Collection, <, Node, >, getVarsDeclaredInBranch, (, Node, root, ), {]
[), ;, }, }, }, }, }, static, Collection, <, Node, >, getVarsDeclaredInBranch, (, Node, root, ), {, VarCollector, collector]
[;, visitPreOrder, (, root, ,, collector, ,, MATCH_NOT_FUNCTION, ), ;, return, collector, ., vars, ., values, (, ), ;, }]
[;, return, collector, ., vars, ., values, (, ), ;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n, ), {, if]
[,, collector, ,, MATCH_NOT_FUNCTION, ), ;, return, collector, ., vars, ., values, (, ), ;, }, static, boolean, isPrototypePropertyDeclaration, (]
[,, MATCH_NOT_FUNCTION, ), ;, return, collector, ., vars, ., values, (, ), ;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n]
[), ;, return, collector, ., vars, ., values, (, ), ;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n, ), {]
[;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n, ), {, if, (, !, isExprAssign, (, n, ), ), {, return]
[., values, (, ), ;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n, ), {, if, (, !, isExprAssign, (, n]
[., vars, ., values, (, ), ;, }, static, boolean, isPrototypePropertyDeclaration, (, Node, n, ), {, if, (, !, isExprAssign]
[), {, return, false, ;, }, return, isPrototypeProperty, (, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ), ;]
[), {, return, false, ;, }, return, isPrototypeProperty, (, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ), ;]
[), ), {, return, false, ;, }, return, isPrototypeProperty, (, n, ., getFirstChild, (, ), ., getFirstChild, (, ), )]
[;, }, return, isPrototypeProperty, (, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ), ;, }, static, boolean, isPrototypeProperty]
[;, }, static, boolean, isPrototypeProperty, (, Node, n, ), {, String, lhsString, =, n, ., getQualifiedName, (, ), ;, if]
[), ;, }, static, boolean, isPrototypeProperty, (, Node, n, ), {, String, lhsString, =, n, ., getQualifiedName, (, ), ;]
[., getFirstChild, (, ), ), ;, }, static, boolean, isPrototypeProperty, (, Node, n, ), {, String, lhsString, =, n, .]
[., getFirstChild, (, ), ., getFirstChild, (, ), ), ;, }, static, boolean, isPrototypeProperty, (, Node, n, ), {, String]
[;, if, (, lhsString, ==, null, ), {, return, false, ;, }, int, prototypeIdx, =, lhsString, ., indexOf, (, ".prototype."]
[., getQualifiedName, (, ), ;, if, (, lhsString, ==, null, ), {, return, false, ;, }, int, prototypeIdx, =, lhsString]
[), {, return, false, ;, }, int, prototypeIdx, =, lhsString, ., indexOf, (, ".prototype.", ), ;, return, prototypeIdx, !=, -]
[==, null, ), {, return, false, ;, }, int, prototypeIdx, =, lhsString, ., indexOf, (, ".prototype.", ), ;, return, prototypeIdx]
[), {, return, false, ;, }, int, prototypeIdx, =, lhsString, ., indexOf, (, ".prototype.", ), ;, return, prototypeIdx, !=, -]
[;, }, int, prototypeIdx, =, lhsString, ., indexOf, (, ".prototype.", ), ;, return, prototypeIdx, !=, -, 1, ;, }, static]
[;, return, prototypeIdx, !=, -, 1, ;, }, static, Node, getPrototypeClassName, (, Node, qName, ), {, Node, cur, =, qName]
[., indexOf, (, ".prototype.", ), ;, return, prototypeIdx, !=, -, 1, ;, }, static, Node, getPrototypeClassName, (, Node, qName, )]
[), ;, return, prototypeIdx, !=, -, 1, ;, }, static, Node, getPrototypeClassName, (, Node, qName, ), {, Node, cur, =]
[;, }, static, Node, getPrototypeClassName, (, Node, qName, ), {, Node, cur, =, qName, ;, while, (, cur, ., isGetProp]
[!=, -, 1, ;, }, static, Node, getPrototypeClassName, (, Node, qName, ), {, Node, cur, =, qName, ;, while, (]
[;, }, static, Node, getPrototypeClassName, (, Node, qName, ), {, Node, cur, =, qName, ;, while, (, cur, ., isGetProp]
[;, }, static, Node, getPrototypeClassName, (, Node, qName, ), {, Node, cur, =, qName, ;, while, (, cur, ., isGetProp]
[;, while, (, cur, ., isGetProp, (, ), ), {, if, (, cur, ., getLastChild, (, ), ., getString, (]
[), {, if, (, cur, ., getLastChild, (, ), ., getString, (, ), ., equals, (, "prototype", ), ), {]
[., isGetProp, (, ), ), {, if, (, cur, ., getLastChild, (, ), ., getString, (, ), ., equals, (]
[), {, return, cur, ., getFirstChild, (, ), ;, }, else, {, cur, =, cur, ., getFirstChild, (, ), ;]
[., equals, (, "prototype", ), ), {, return, cur, ., getFirstChild, (, ), ;, }, else, {, cur, =, cur]
[., getString, (, ), ., equals, (, "prototype", ), ), {, return, cur, ., getFirstChild, (, ), ;, }, else]
[., getLastChild, (, ), ., getString, (, ), ., equals, (, "prototype", ), ), {, return, cur, ., getFirstChild, (]
[), ), {, return, cur, ., getFirstChild, (, ), ;, }, else, {, cur, =, cur, ., getFirstChild, (, )]
[;, }, else, {, cur, =, cur, ., getFirstChild, (, ), ;, }, }, return, null, ;, }, static, String]
[., getFirstChild, (, ), ;, }, else, {, cur, =, cur, ., getFirstChild, (, ), ;, }, }, return, null]
[=, cur, ., getFirstChild, (, ), ;, }, }, return, null, ;, }, static, String, getPrototypePropertyName, (, Node, qName, )]
[;, }, }, return, null, ;, }, static, String, getPrototypePropertyName, (, Node, qName, ), {, String, qNameStr, =, qName, .]
[., getFirstChild, (, ), ;, }, }, return, null, ;, }, static, String, getPrototypePropertyName, (, Node, qName, ), {, String]
[;, }, static, String, getPrototypePropertyName, (, Node, qName, ), {, String, qNameStr, =, qName, ., getQualifiedName, (, ), ;, int]
[;, int, prototypeIdx, =, qNameStr, ., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =, prototypeIdx, +, ".prototype", ., length, (]
[., getQualifiedName, (, ), ;, int, prototypeIdx, =, qNameStr, ., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =, prototypeIdx, +]
[;, int, memberIndex, =, prototypeIdx, +, ".prototype", ., length, (, ), +, 1, ;, return, qNameStr, ., substring, (, memberIndex]
[., lastIndexOf, (, ".prototype.", ), ;, int, memberIndex, =, prototypeIdx, +, ".prototype", ., length, (, ), +, 1, ;, return]
[), ;, int, memberIndex, =, prototypeIdx, +, ".prototype", ., length, (, ), +, 1, ;, return, qNameStr, ., substring, (]
[;, return, qNameStr, ., substring, (, memberIndex, ), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node]
[+, 1, ;, return, qNameStr, ., substring, (, memberIndex, ), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {]
[+, ".prototype", ., length, (, ), +, 1, ;, return, qNameStr, ., substring, (, memberIndex, ), ;, }, static, Node]
[+, 1, ;, return, qNameStr, ., substring, (, memberIndex, ), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {]
[., length, (, ), +, 1, ;, return, qNameStr, ., substring, (, memberIndex, ), ;, }, static, Node, newUndefinedNode, (]
[;, return, qNameStr, ., substring, (, memberIndex, ), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node]
[;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node, =, IR, ., voidNode, (, IR, ., number]
[., substring, (, memberIndex, ), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node, =, IR, .]
[), ;, }, static, Node, newUndefinedNode, (, Node, srcReferenceNode, ), {, Node, node, =, IR, ., voidNode, (, IR, .]
[;, if, (, srcReferenceNode, !=, null, ), {, node, ., copyInformationFromForTree, (, srcReferenceNode, ), ;, }, return, node, ;, }]
[., voidNode, (, IR, ., number, (, 0, ), ), ;, if, (, srcReferenceNode, !=, null, ), {, node, .]
[), ;, if, (, srcReferenceNode, !=, null, ), {, node, ., copyInformationFromForTree, (, srcReferenceNode, ), ;, }, return, node, ;]
[., number, (, 0, ), ), ;, if, (, srcReferenceNode, !=, null, ), {, node, ., copyInformationFromForTree, (, srcReferenceNode, )]
[), ), ;, if, (, srcReferenceNode, !=, null, ), {, node, ., copyInformationFromForTree, (, srcReferenceNode, ), ;, }, return, node]
[), {, node, ., copyInformationFromForTree, (, srcReferenceNode, ), ;, }, return, node, ;, }, static, Node, newVarNode, (, String, name]
[!=, null, ), {, node, ., copyInformationFromForTree, (, srcReferenceNode, ), ;, }, return, node, ;, }, static, Node, newVarNode, (]
[), {, node, ., copyInformationFromForTree, (, srcReferenceNode, ), ;, }, return, node, ;, }, static, Node, newVarNode, (, String, name]
[;, }, return, node, ;, }, static, Node, newVarNode, (, String, name, ,, Node, value, ), {, Node, nodeName, =]
[., copyInformationFromForTree, (, srcReferenceNode, ), ;, }, return, node, ;, }, static, Node, newVarNode, (, String, name, ,, Node, value]
[), ;, }, return, node, ;, }, static, Node, newVarNode, (, String, name, ,, Node, value, ), {, Node, nodeName]
[;, }, static, Node, newVarNode, (, String, name, ,, Node, value, ), {, Node, nodeName, =, IR, ., name, (]
[;, if, (, value, !=, null, ), {, Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null, )]
[., name, (, name, ), ;, if, (, value, !=, null, ), {, Preconditions, ., checkState, (, value, ., getNext]
[), ;, if, (, value, !=, null, ), {, Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null]
[), {, Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null, ), ;, nodeName, ., addChildToBack, (, value]
[!=, null, ), {, Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null, ), ;, nodeName, ., addChildToBack]
[), {, Preconditions, ., checkState, (, value, ., getNext, (, ), ==, null, ), ;, nodeName, ., addChildToBack, (, value]
[;, nodeName, ., addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =, IR]
[., checkState, (, value, ., getNext, (, ), ==, null, ), ;, nodeName, ., addChildToBack, (, value, ), ;, nodeName]
[), ;, nodeName, ., addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =]
[==, null, ), ;, nodeName, ., addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value, ), ;, }, Node]
[., getNext, (, ), ==, null, ), ;, nodeName, ., addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value]
[), ;, nodeName, ., addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =]
[;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =, IR, ., var, (, nodeName, ), ., srcref]
[., addChildToBack, (, value, ), ;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =, IR, ., var]
[), ;, nodeName, ., srcref, (, value, ), ;, }, Node, var, =, IR, ., var, (, nodeName, ), .]
[;, }, Node, var, =, IR, ., var, (, nodeName, ), ., srcref, (, nodeName, ), ;, return, var, ;]
[., srcref, (, value, ), ;, }, Node, var, =, IR, ., var, (, nodeName, ), ., srcref, (, nodeName]
[), ;, }, Node, var, =, IR, ., var, (, nodeName, ), ., srcref, (, nodeName, ), ;, return, var]
[;, return, var, ;, }, private, static, class, MatchNameNode, implements, Predicate, <, Node, >, {, final, String, name, ;, MatchNameNode]
[., srcref, (, nodeName, ), ;, return, var, ;, }, private, static, class, MatchNameNode, implements, Predicate, <, Node, >, {]
[., var, (, nodeName, ), ., srcref, (, nodeName, ), ;, return, var, ;, }, private, static, class, MatchNameNode, implements]
[), ., srcref, (, nodeName, ), ;, return, var, ;, }, private, static, class, MatchNameNode, implements, Predicate, <, Node, >]
[), ;, return, var, ;, }, private, static, class, MatchNameNode, implements, Predicate, <, Node, >, {, final, String, name, ;]
[;, }, private, static, class, MatchNameNode, implements, Predicate, <, Node, >, {, final, String, name, ;, MatchNameNode, (, String, name]
[=, name, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., isName, (, )]
[., name, =, name, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., isName]
[;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., isName, (, ), &&, n]
[;, }, }, static, class, MatchNodeType, implements, Predicate, <, Node, >, {, final, int, type, ;, MatchNodeType, (, int, type]
[&&, n, ., getString, (, ), ., equals, (, name, ), ;, }, }, static, class, MatchNodeType, implements, Predicate, <]
[., isName, (, ), &&, n, ., getString, (, ), ., equals, (, name, ), ;, }, }, static, class]
[;, }, }, static, class, MatchNodeType, implements, Predicate, <, Node, >, {, final, int, type, ;, MatchNodeType, (, int, type]
[., equals, (, name, ), ;, }, }, static, class, MatchNodeType, implements, Predicate, <, Node, >, {, final, int, type]
[., getString, (, ), ., equals, (, name, ), ;, }, }, static, class, MatchNodeType, implements, Predicate, <, Node, >]
[), ;, }, }, static, class, MatchNodeType, implements, Predicate, <, Node, >, {, final, int, type, ;, MatchNodeType, (, int]
[=, type, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., getType, (, )]
[., type, =, type, ;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., getType]
[;, }, @, Override, public, boolean, apply, (, Node, n, ), {, return, n, ., getType, (, ), ==, type]
[;, }, }, static, class, MatchDeclaration, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n]
[==, type, ;, }, }, static, class, MatchDeclaration, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (]
[., getType, (, ), ==, type, ;, }, }, static, class, MatchDeclaration, implements, Predicate, <, Node, >, {, @, Override]
[;, }, }, static, class, MatchDeclaration, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n]
[;, }, }, private, static, class, MatchNotFunction, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node]
[||, n, ., isVar, (, ), ;, }, }, private, static, class, MatchNotFunction, implements, Predicate, <, Node, >, {, @]
[), ||, n, ., isVar, (, ), ;, }, }, private, static, class, MatchNotFunction, implements, Predicate, <, Node, >, {]
[;, }, }, private, static, class, MatchNotFunction, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node]
[., isVar, (, ), ;, }, }, private, static, class, MatchNotFunction, implements, Predicate, <, Node, >, {, @, Override, public]
[;, }, }, static, final, Predicate, <, Node, >, MATCH_NOT_FUNCTION, =, new, MatchNotFunction, (, ), ;, static, class, MatchShallowStatement, implements]
[;, }, }, static, final, Predicate, <, Node, >, MATCH_NOT_FUNCTION, =, new, MatchNotFunction, (, ), ;, static, class, MatchShallowStatement, implements]
[., isFunction, (, ), ;, }, }, static, final, Predicate, <, Node, >, MATCH_NOT_FUNCTION, =, new, MatchNotFunction, (, ), ;]
[;, static, class, MatchShallowStatement, implements, Predicate, <, Node, >, {, @, Override, public, boolean, apply, (, Node, n, ), {]
[;, return, n, ., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&, (, parent, ==, null]
[., getParent, (, ), ;, return, n, ., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&]
[;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {]
[||, (, !, n, ., isFunction, (, ), &&, (, parent, ==, null, ||, isControlStructure, (, parent, ), ||, isStatementBlock]
[., isBlock, (, ), ||, (, !, n, ., isFunction, (, ), &&, (, parent, ==, null, ||, isControlStructure, (]
[;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, ), {]
[), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, )]
[&&, (, parent, ==, null, ||, isControlStructure, (, parent, ), ||, isStatementBlock, (, parent, ), ), ), ;, }, }]
[&&, (, parent, ==, null, ||, isControlStructure, (, parent, ), ||, isStatementBlock, (, parent, ), ), ), ;, }, }]
[., isFunction, (, ), &&, (, parent, ==, null, ||, isControlStructure, (, parent, ), ||, isStatementBlock, (, parent, ), )]
[), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred, )]
[), ), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred]
[||, isStatementBlock, (, parent, ), ), ), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,]
[||, isControlStructure, (, parent, ), ||, isStatementBlock, (, parent, ), ), ), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node]
[==, null, ||, isControlStructure, (, parent, ), ||, isStatementBlock, (, parent, ), ), ), ;, }, }, static, int, getNodeTypeReferenceCount]
[||, isControlStructure, (, parent, ), ||, isStatementBlock, (, parent, ), ), ), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node]
[||, isStatementBlock, (, parent, ), ), ), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,]
[), ||, isStatementBlock, (, parent, ), ), ), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type]
[), ), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >, traverseChildrenPred]
[), ), ), ;, }, }, static, int, getNodeTypeReferenceCount, (, Node, node, ,, int, type, ,, Predicate, <, Node, >]
[;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ,, Predicate, <, Node, >, traverseChildrenPred, ), {, return]
[,, new, MatchNodeType, (, type, ), ,, traverseChildrenPred, ), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name]
[,, traverseChildrenPred, ), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ,, Predicate, <, Node, >, traverseChildrenPred]
[), ,, traverseChildrenPred, ), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ,, Predicate, <, Node, >]
[), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ,, Predicate, <, Node, >, traverseChildrenPred, ), {]
[;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ), {, return, isNameReferenced, (, node, ,, name, ,]
[,, new, MatchNameNode, (, name, ), ,, traverseChildrenPred, ), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name]
[,, traverseChildrenPred, ), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ), {, return, isNameReferenced, (, node]
[), ,, traverseChildrenPred, ), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ), {, return, isNameReferenced, (]
[), ;, }, static, boolean, isNameReferenced, (, Node, node, ,, String, name, ), {, return, isNameReferenced, (, node, ,, name]
[;, }, static, int, getNameReferenceCount, (, Node, node, ,, String, name, ), {, return, getCount, (, node, ,, new, MatchNameNode]
[,, name, ,, Predicates, ., <, Node, >, alwaysTrue, (, ), ), ;, }, static, int, getNameReferenceCount, (, Node, node]
[,, Predicates, ., <, Node, >, alwaysTrue, (, ), ), ;, }, static, int, getNameReferenceCount, (, Node, node, ,, String]
[), ;, }, static, int, getNameReferenceCount, (, Node, node, ,, String, name, ), {, return, getCount, (, node, ,, new]
[., <, Node, >, alwaysTrue, (, ), ), ;, }, static, int, getNameReferenceCount, (, Node, node, ,, String, name, )]
[;, }, static, boolean, has, (, Node, node, ,, Predicate, <, Node, >, pred, ,, Predicate, <, Node, >, traverseChildrenPred]
[,, new, MatchNameNode, (, name, ), ,, Predicates, ., <, Node, >, alwaysTrue, (, ), ), ;, }, static, boolean]
[,, Predicates, ., <, Node, >, alwaysTrue, (, ), ), ;, }, static, boolean, has, (, Node, node, ,, Predicate]
[), ,, Predicates, ., <, Node, >, alwaysTrue, (, ), ), ;, }, static, boolean, has, (, Node, node, ,]
[), ;, }, static, boolean, has, (, Node, node, ,, Predicate, <, Node, >, pred, ,, Predicate, <, Node, >]
[., <, Node, >, alwaysTrue, (, ), ), ;, }, static, boolean, has, (, Node, node, ,, Predicate, <, Node]
[), {, return, true, ;, }, if, (, !, traverseChildrenPred, ., apply, (, node, ), ), {, return, false, ;]
[., apply, (, node, ), ), {, return, true, ;, }, if, (, !, traverseChildrenPred, ., apply, (, node, )]
[), ), {, return, true, ;, }, if, (, !, traverseChildrenPred, ., apply, (, node, ), ), {, return, false]
[;, }, if, (, !, traverseChildrenPred, ., apply, (, node, ), ), {, return, false, ;, }, for, (, Node]
[), {, return, false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null]
[), {, return, false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null]
[., apply, (, node, ), ), {, return, false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (]
[), ), {, return, false, ;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=]
[;, }, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, has, (, c, ,]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, has, (, c, ,, pred, ,, traverseChildrenPred, )]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, has, (, c, ,, pred, ,]
[;, c, =, c, ., getNext, (, ), ), {, if, (, has, (, c, ,, pred, ,, traverseChildrenPred, )]
[=, c, ., getNext, (, ), ), {, if, (, has, (, c, ,, pred, ,, traverseChildrenPred, ), ), {]
[), {, if, (, has, (, c, ,, pred, ,, traverseChildrenPred, ), ), {, return, true, ;, }, }, return]
[., getNext, (, ), ), {, if, (, has, (, c, ,, pred, ,, traverseChildrenPred, ), ), {, return, true]
[), {, return, true, ;, }, }, return, false, ;, }, static, int, getCount, (, Node, n, ,, Predicate, <]
[,, pred, ,, traverseChildrenPred, ), ), {, return, true, ;, }, }, return, false, ;, }, static, int, getCount, (]
[,, traverseChildrenPred, ), ), {, return, true, ;, }, }, return, false, ;, }, static, int, getCount, (, Node, n]
[), ), {, return, true, ;, }, }, return, false, ;, }, static, int, getCount, (, Node, n, ,, Predicate]
[;, }, }, return, false, ;, }, static, int, getCount, (, Node, n, ,, Predicate, <, Node, >, pred, ,]
[;, }, static, int, getCount, (, Node, n, ,, Predicate, <, Node, >, pred, ,, Predicate, <, Node, >, traverseChildrenPred]
[;, if, (, pred, ., apply, (, n, ), ), {, total, ++, ;, }, if, (, traverseChildrenPred, ., apply]
[), {, total, ++, ;, }, if, (, traverseChildrenPred, ., apply, (, n, ), ), {, for, (, Node, c]
[., apply, (, n, ), ), {, total, ++, ;, }, if, (, traverseChildrenPred, ., apply, (, n, ), )]
[), ), {, total, ++, ;, }, if, (, traverseChildrenPred, ., apply, (, n, ), ), {, for, (, Node]
[;, }, if, (, traverseChildrenPred, ., apply, (, n, ), ), {, for, (, Node, c, =, n, ., getFirstChild]
[++, ;, }, if, (, traverseChildrenPred, ., apply, (, n, ), ), {, for, (, Node, c, =, n, .]
[), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c]
[., apply, (, n, ), ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[), ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, total, +=, getCount, (, c, ,]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, total, +=]
[;, c, =, c, ., getNext, (, ), ), {, total, +=, getCount, (, c, ,, pred, ,, traverseChildrenPred, )]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, total, +=, getCount, (, c, ,, pred, ,]
[;, c, =, c, ., getNext, (, ), ), {, total, +=, getCount, (, c, ,, pred, ,, traverseChildrenPred, )]
[=, c, ., getNext, (, ), ), {, total, +=, getCount, (, c, ,, pred, ,, traverseChildrenPred, ), ;, }]
[), {, total, +=, getCount, (, c, ,, pred, ,, traverseChildrenPred, ), ;, }, }, return, total, ;, }, static]
[., getNext, (, ), ), {, total, +=, getCount, (, c, ,, pred, ,, traverseChildrenPred, ), ;, }, }, return]
[+=, getCount, (, c, ,, pred, ,, traverseChildrenPred, ), ;, }, }, return, total, ;, }, static, interface, Visitor, {]
[;, }, }, return, total, ;, }, static, interface, Visitor, {, void, visit, (, Node, node, ), ;, }, static]
[,, pred, ,, traverseChildrenPred, ), ;, }, }, return, total, ;, }, static, interface, Visitor, {, void, visit, (, Node]
[,, traverseChildrenPred, ), ;, }, }, return, total, ;, }, static, interface, Visitor, {, void, visit, (, Node, node, )]
[), ;, }, }, return, total, ;, }, static, interface, Visitor, {, void, visit, (, Node, node, ), ;, }]
[;, }, static, interface, Visitor, {, void, visit, (, Node, node, ), ;, }, static, void, visitPreOrder, (, Node, node]
[;, if, (, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (]
[., visit, (, node, ), ;, if, (, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c]
[), ;, if, (, traverseChildrenPred, ., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild]
[), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c]
[., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=]
[), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPreOrder, (, c, ,, visitor, ,]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPreOrder, (]
[;, c, =, c, ., getNext, (, ), ), {, visitPreOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPreOrder, (, c, ,, visitor, ,, traverseChildrenPred, )]
[;, c, =, c, ., getNext, (, ), ), {, visitPreOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }]
[=, c, ., getNext, (, ), ), {, visitPreOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }, }, }]
[), {, visitPreOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }, }, }, static, void, visitPostOrder, (, Node, node]
[., getNext, (, ), ), {, visitPreOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }, }, }, static, void]
[;, }, }, }, static, void, visitPostOrder, (, Node, node, ,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred, )]
[,, visitor, ,, traverseChildrenPred, ), ;, }, }, }, static, void, visitPostOrder, (, Node, node, ,, Visitor, visitor, ,, Predicate]
[,, traverseChildrenPred, ), ;, }, }, }, static, void, visitPostOrder, (, Node, node, ,, Visitor, visitor, ,, Predicate, <, Node]
[), ;, }, }, }, static, void, visitPostOrder, (, Node, node, ,, Visitor, visitor, ,, Predicate, <, Node, >, traverseChildrenPred]
[), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c]
[., apply, (, node, ), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=]
[), ), {, for, (, Node, c, =, node, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPostOrder, (]
[;, c, =, c, ., getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,, traverseChildrenPred, )]
[;, c, =, c, ., getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }]
[=, c, ., getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }, }, visitor]
[), {, visitPostOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }, }, visitor, ., visit, (, node, ), ;]
[., getNext, (, ), ), {, visitPostOrder, (, c, ,, visitor, ,, traverseChildrenPred, ), ;, }, }, visitor, ., visit]
[;, }, }, visitor, ., visit, (, node, ), ;, }, static, boolean, hasFinally, (, Node, n, ), {, Preconditions]
[,, visitor, ,, traverseChildrenPred, ), ;, }, }, visitor, ., visit, (, node, ), ;, }, static, boolean, hasFinally, (]
[,, traverseChildrenPred, ), ;, }, }, visitor, ., visit, (, node, ), ;, }, static, boolean, hasFinally, (, Node, n]
[), ;, }, }, visitor, ., visit, (, node, ), ;, }, static, boolean, hasFinally, (, Node, n, ), {]
[;, }, static, boolean, hasFinally, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), )]
[., visit, (, node, ), ;, }, static, boolean, hasFinally, (, Node, n, ), {, Preconditions, ., checkArgument, (, n]
[), ;, }, static, boolean, hasFinally, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, )]
[;, return, n, ., getChildCount, (, ), ==, 3, ;, }, static, Node, getCatchBlock, (, Node, n, ), {, Preconditions]
[., checkArgument, (, n, ., isTry, (, ), ), ;, return, n, ., getChildCount, (, ), ==, 3, ;, }]
[), ;, return, n, ., getChildCount, (, ), ==, 3, ;, }, static, Node, getCatchBlock, (, Node, n, ), {]
[., isTry, (, ), ), ;, return, n, ., getChildCount, (, ), ==, 3, ;, }, static, Node, getCatchBlock, (]
[;, }, static, Node, getCatchBlock, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), )]
[==, 3, ;, }, static, Node, getCatchBlock, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (]
[., getChildCount, (, ), ==, 3, ;, }, static, Node, getCatchBlock, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[;, }, static, Node, getCatchBlock, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isTry, (, ), )]
[;, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, hasCatchHandler, (, Node, n, )]
[., checkArgument, (, n, ., isTry, (, ), ), ;, return, n, ., getFirstChild, (, ), ., getNext, (, )]
[), ;, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, hasCatchHandler, (, Node, n]
[., isTry, (, ), ), ;, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean]
[;, }, static, boolean, hasCatchHandler, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isBlock, (, ), )]
[., getNext, (, ), ;, }, static, boolean, hasCatchHandler, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, .]
[., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, hasCatchHandler, (, Node, n, ), {, Preconditions, .]
[;, return, n, ., hasChildren, (, ), &&, n, ., getFirstChild, (, ), ., isCatch, (, ), ;, }, public]
[., checkArgument, (, n, ., isBlock, (, ), ), ;, return, n, ., hasChildren, (, ), &&, n, ., getFirstChild]
[), ;, return, n, ., hasChildren, (, ), &&, n, ., getFirstChild, (, ), ., isCatch, (, ), ;, }]
[., isBlock, (, ), ), ;, return, n, ., hasChildren, (, ), &&, n, ., getFirstChild, (, ), ., isCatch]
[;, }, public, static, Node, getFunctionParameters, (, Node, fnNode, ), {, Preconditions, ., checkArgument, (, fnNode, ., isFunction, (, )]
[&&, n, ., getFirstChild, (, ), ., isCatch, (, ), ;, }, public, static, Node, getFunctionParameters, (, Node, fnNode, )]
[., hasChildren, (, ), &&, n, ., getFirstChild, (, ), ., isCatch, (, ), ;, }, public, static, Node, getFunctionParameters]
[;, }, public, static, Node, getFunctionParameters, (, Node, fnNode, ), {, Preconditions, ., checkArgument, (, fnNode, ., isFunction, (, )]
[., isCatch, (, ), ;, }, public, static, Node, getFunctionParameters, (, Node, fnNode, ), {, Preconditions, ., checkArgument, (, fnNode]
[., getFirstChild, (, ), ., isCatch, (, ), ;, }, public, static, Node, getFunctionParameters, (, Node, fnNode, ), {, Preconditions]
[;, return, fnNode, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, isConstantName, (, Node, node, )]
[., checkArgument, (, fnNode, ., isFunction, (, ), ), ;, return, fnNode, ., getFirstChild, (, ), ., getNext, (, )]
[), ;, return, fnNode, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, isConstantName, (, Node, node]
[., isFunction, (, ), ), ;, return, fnNode, ., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean]
[;, }, static, boolean, isConstantName, (, Node, node, ), {, return, node, ., getBooleanProp, (, Node, ., IS_CONSTANT_NAME, ), ;]
[., getNext, (, ), ;, }, static, boolean, isConstantName, (, Node, node, ), {, return, node, ., getBooleanProp, (, Node]
[., getFirstChild, (, ), ., getNext, (, ), ;, }, static, boolean, isConstantName, (, Node, node, ), {, return, node]
[;, }, static, boolean, isConstantByConvention, (, CodingConvention, convention, ,, Node, node, ,, Node, parent, ), {, String, name, =, node]
[., getBooleanProp, (, Node, ., IS_CONSTANT_NAME, ), ;, }, static, boolean, isConstantByConvention, (, CodingConvention, convention, ,, Node, node, ,, Node]
[), ;, }, static, boolean, isConstantByConvention, (, CodingConvention, convention, ,, Node, node, ,, Node, parent, ), {, String, name, =]
[., IS_CONSTANT_NAME, ), ;, }, static, boolean, isConstantByConvention, (, CodingConvention, convention, ,, Node, node, ,, Node, parent, ), {, String]
[;, if, (, parent, ., isGetProp, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {, return, convention]
[., getString, (, ), ;, if, (, parent, ., isGetProp, (, ), &&, node, ==, parent, ., getLastChild, (, )]
[), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, if, (, isObjectLitKey, (, node, ,, parent, )]
[&&, node, ==, parent, ., getLastChild, (, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else]
[., isGetProp, (, ), &&, node, ==, parent, ., getLastChild, (, ), ), {, return, convention, ., isConstantKey, (, name]
[), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, if, (, isObjectLitKey, (, node, ,, parent, )]
[==, parent, ., getLastChild, (, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, if, (]
[), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, if, (, isObjectLitKey, (, node, ,, parent, )]
[., getLastChild, (, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, if, (, isObjectLitKey, (]
[;, }, else, if, (, isObjectLitKey, (, node, ,, parent, ), ), {, return, convention, ., isConstantKey, (, name, )]
[., isConstantKey, (, name, ), ;, }, else, if, (, isObjectLitKey, (, node, ,, parent, ), ), {, return, convention]
[), ;, }, else, if, (, isObjectLitKey, (, node, ,, parent, ), ), {, return, convention, ., isConstantKey, (, name]
[), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, {, return, convention, ., isConstant, (, name, )]
[,, parent, ), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, {, return, convention, ., isConstant]
[), ), {, return, convention, ., isConstantKey, (, name, ), ;, }, else, {, return, convention, ., isConstant, (, name]
[;, }, else, {, return, convention, ., isConstant, (, name, ), ;, }, }, public, static, JSDocInfo, getFunctionJSDocInfo, (, Node]
[., isConstantKey, (, name, ), ;, }, else, {, return, convention, ., isConstant, (, name, ), ;, }, }, public]
[), ;, }, else, {, return, convention, ., isConstant, (, name, ), ;, }, }, public, static, JSDocInfo, getFunctionJSDocInfo, (]
[;, }, }, public, static, JSDocInfo, getFunctionJSDocInfo, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isFunction, (]
[., isConstant, (, name, ), ;, }, }, public, static, JSDocInfo, getFunctionJSDocInfo, (, Node, n, ), {, Preconditions, ., checkState]
[), ;, }, }, public, static, JSDocInfo, getFunctionJSDocInfo, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isFunction]
[;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (, fnInfo, ==, null, &&, NodeUtil, ., isFunctionExpression, (]
[., checkState, (, n, ., isFunction, (, ), ), ;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if]
[), ;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (, fnInfo, ==, null, &&, NodeUtil, ., isFunctionExpression]
[., isFunction, (, ), ), ;, JSDocInfo, fnInfo, =, n, ., getJSDocInfo, (, ), ;, if, (, fnInfo, ==, null]
[;, if, (, fnInfo, ==, null, &&, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Node, parent, =, n, .]
[., getJSDocInfo, (, ), ;, if, (, fnInfo, ==, null, &&, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Node]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isAssign, (, ), ), {]
[&&, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[==, null, &&, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Node, parent, =, n, ., getParent, (, ), ;]
[&&, NodeUtil, ., isFunctionExpression, (, n, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isAssign, (, ), ), {]
[., isFunctionExpression, (, n, ), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, .]
[), ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ., isAssign, (, ), )]
[;, if, (, parent, ., isAssign, (, ), ), {, fnInfo, =, parent, ., getJSDocInfo, (, ), ;, }, else]
[., getParent, (, ), ;, if, (, parent, ., isAssign, (, ), ), {, fnInfo, =, parent, ., getJSDocInfo, (]
[), {, fnInfo, =, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isName, (, ), )]
[., isAssign, (, ), ), {, fnInfo, =, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, .]
[=, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isName, (, ), ), {, fnInfo, =]
[;, }, else, if, (, parent, ., isName, (, ), ), {, fnInfo, =, parent, ., getParent, (, ), .]
[., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isName, (, ), ), {, fnInfo, =, parent, .]
[), {, fnInfo, =, parent, ., getParent, (, ), ., getJSDocInfo, (, ), ;, }, }, return, fnInfo, ;, }]
[., isName, (, ), ), {, fnInfo, =, parent, ., getParent, (, ), ., getJSDocInfo, (, ), ;, }, }]
[=, parent, ., getParent, (, ), ., getJSDocInfo, (, ), ;, }, }, return, fnInfo, ;, }, public, static, String]
[;, }, }, return, fnInfo, ;, }, public, static, String, getSourceName, (, Node, n, ), {, String, sourceName, =, null]
[., getJSDocInfo, (, ), ;, }, }, return, fnInfo, ;, }, public, static, String, getSourceName, (, Node, n, ), {]
[., getParent, (, ), ., getJSDocInfo, (, ), ;, }, }, return, fnInfo, ;, }, public, static, String, getSourceName, (]
[;, }, public, static, String, getSourceName, (, Node, n, ), {, String, sourceName, =, null, ;, while, (, sourceName, ==]
[;, while, (, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getSourceFileName, (, ), ;]
[), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return]
[&&, n, !=, null, ), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =, n, ., getParent, (]
[==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =, n, .]
[&&, n, !=, null, ), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =, n, ., getParent, (]
[), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return]
[!=, null, ), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =, n, ., getParent, (, ), ;]
[), {, sourceName, =, n, ., getSourceFileName, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return]
[=, n, ., getSourceFileName, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return, sourceName, ;, }]
[;, n, =, n, ., getParent, (, ), ;, }, return, sourceName, ;, }, public, static, StaticSourceFile, getSourceFile, (, Node]
[., getSourceFileName, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return, sourceName, ;, }, public, static]
[=, n, ., getParent, (, ), ;, }, return, sourceName, ;, }, public, static, StaticSourceFile, getSourceFile, (, Node, n, )]
[;, }, return, sourceName, ;, }, public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =, null, ;]
[., getParent, (, ), ;, }, return, sourceName, ;, }, public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile]
[;, }, public, static, StaticSourceFile, getSourceFile, (, Node, n, ), {, StaticSourceFile, sourceName, =, null, ;, while, (, sourceName, ==]
[;, while, (, sourceName, ==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;]
[), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return]
[&&, n, !=, null, ), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =, n, ., getParent, (]
[==, null, &&, n, !=, null, ), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =, n, .]
[&&, n, !=, null, ), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =, n, ., getParent, (]
[), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return]
[!=, null, ), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =, n, ., getParent, (, ), ;]
[), {, sourceName, =, n, ., getStaticSourceFile, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return]
[=, n, ., getStaticSourceFile, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return, sourceName, ;, }]
[;, n, =, n, ., getParent, (, ), ;, }, return, sourceName, ;, }, public, static, InputId, getInputId, (, Node]
[., getStaticSourceFile, (, ), ;, n, =, n, ., getParent, (, ), ;, }, return, sourceName, ;, }, public, static]
[=, n, ., getParent, (, ), ;, }, return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, )]
[;, }, return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, ), {, while, (, n, !=, null]
[., getParent, (, ), ;, }, return, sourceName, ;, }, public, static, InputId, getInputId, (, Node, n, ), {, while]
[;, }, public, static, InputId, getInputId, (, Node, n, ), {, while, (, n, !=, null, &&, !, n, .]
[), {, n, =, n, ., getParent, (, ), ;, }, return, (, n, !=, null, &&, n, ., isScript]
[&&, !, n, ., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return, (]
[!=, null, &&, !, n, ., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }]
[&&, !, n, ., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return, (]
[), {, n, =, n, ., getParent, (, ), ;, }, return, (, n, !=, null, &&, n, ., isScript]
[), {, n, =, n, ., getParent, (, ), ;, }, return, (, n, !=, null, &&, n, ., isScript]
[., isScript, (, ), ), {, n, =, n, ., getParent, (, ), ;, }, return, (, n, !=, null]
[=, n, ., getParent, (, ), ;, }, return, (, n, !=, null, &&, n, ., isScript, (, ), )]
[;, }, return, (, n, !=, null, &&, n, ., isScript, (, ), ), ?, n, ., getInputId, (, )]
[., getParent, (, ), ;, }, return, (, n, !=, null, &&, n, ., isScript, (, ), ), ?, n]
[;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ..., parameters, ), {, boolean, isFreeCall, =, !, isGet, (]
[?, n, ., getInputId, (, ), :, null, ;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ..., parameters]
[), ?, n, ., getInputId, (, ), :, null, ;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ...]
[&&, n, ., isScript, (, ), ), ?, n, ., getInputId, (, ), :, null, ;, }, static, Node, newCallNode]
[!=, null, &&, n, ., isScript, (, ), ), ?, n, ., getInputId, (, ), :, null, ;, }, static]
[&&, n, ., isScript, (, ), ), ?, n, ., getInputId, (, ), :, null, ;, }, static, Node, newCallNode]
[), ?, n, ., getInputId, (, ), :, null, ;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ...]
[., isScript, (, ), ), ?, n, ., getInputId, (, ), :, null, ;, }, static, Node, newCallNode, (, Node]
[:, null, ;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ..., parameters, ), {, boolean, isFreeCall, =, !]
[., getInputId, (, ), :, null, ;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ..., parameters, ), {]
[;, }, static, Node, newCallNode, (, Node, callTarget, ,, Node, ..., parameters, ), {, boolean, isFreeCall, =, !, isGet, (]
[;, Node, call, =, IR, ., call, (, callTarget, ), ;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,, isFreeCall]
[;, Node, call, =, IR, ., call, (, callTarget, ), ;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,, isFreeCall]
[), ;, Node, call, =, IR, ., call, (, callTarget, ), ;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,]
[;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,, isFreeCall, ), ;, for, (, Node, parameter, :, parameters, ), {]
[., call, (, callTarget, ), ;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,, isFreeCall, ), ;, for, (, Node]
[), ;, call, ., putBooleanProp, (, Node, ., FREE_CALL, ,, isFreeCall, ), ;, for, (, Node, parameter, :, parameters, )]
[;, for, (, Node, parameter, :, parameters, ), {, call, ., addChildToBack, (, parameter, ), ;, }, return, call, ;]
[., putBooleanProp, (, Node, ., FREE_CALL, ,, isFreeCall, ), ;, for, (, Node, parameter, :, parameters, ), {, call, .]
[,, isFreeCall, ), ;, for, (, Node, parameter, :, parameters, ), {, call, ., addChildToBack, (, parameter, ), ;, }]
[., FREE_CALL, ,, isFreeCall, ), ;, for, (, Node, parameter, :, parameters, ), {, call, ., addChildToBack, (, parameter, )]
[), ;, for, (, Node, parameter, :, parameters, ), {, call, ., addChildToBack, (, parameter, ), ;, }, return, call]
[), {, call, ., addChildToBack, (, parameter, ), ;, }, return, call, ;, }, static, boolean, evaluatesToLocalValue, (, Node, value]
[;, }, return, call, ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ), {, return, evaluatesToLocalValue, (, value, ,, Predicates]
[., addChildToBack, (, parameter, ), ;, }, return, call, ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ), {, return]
[), ;, }, return, call, ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ), {, return, evaluatesToLocalValue, (, value, ,]
[;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ), {, return, evaluatesToLocalValue, (, value, ,, Predicates, ., <, Node, >]
[;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ,, Predicate, <, Node, >, locals, ), {, switch, (, value, .]
[,, Predicates, ., <, Node, >, alwaysFalse, (, ), ), ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ,, Predicate]
[), ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ,, Predicate, <, Node, >, locals, ), {, switch, (, value]
[., <, Node, >, alwaysFalse, (, ), ), ;, }, static, boolean, evaluatesToLocalValue, (, Node, value, ,, Predicate, <, Node]
[), {, case, Token, ., CAST, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, case]
[., getType, (, ), ), {, case, Token, ., CAST, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,]
[:, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, case, Token, ., ASSIGN, :, return, NodeUtil]
[., CAST, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, case, Token, ., ASSIGN, :]
[;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (, locals]
[,, locals, ), ;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), )]
[., getFirstChild, (, ), ,, locals, ), ;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, .]
[), ;, case, Token, ., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (]
[:, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (, locals, ., apply, (, value, )]
[., ASSIGN, :, return, NodeUtil, ., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (, locals, ., apply, (]
[;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token]
[||, (, locals, ., apply, (, value, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), )]
[., isImmutableValue, (, value, ., getLastChild, (, ), ), ||, (, locals, ., apply, (, value, ), &&, evaluatesToLocalValue, (]
[), ||, (, locals, ., apply, (, value, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, )]
[., getLastChild, (, ), ), ||, (, locals, ., apply, (, value, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (]
[;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token]
[), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[&&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue]
[., apply, (, value, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ), ;, case, Token]
[), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ), ;, case, Token, ., COMMA, :, return]
[), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[,, locals, ), ), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals]
[., getLastChild, (, ), ,, locals, ), ), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild]
[), ), ;, case, Token, ., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;]
[:, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., AND, :, case, Token]
[., COMMA, :, return, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., AND, :]
[;, case, Token, ., AND, :, case, Token, ., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,]
[,, locals, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild]
[., getLastChild, (, ), ,, locals, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, evaluatesToLocalValue]
[), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, )]
[:, case, Token, ., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), &&, evaluatesToLocalValue, (]
[., AND, :, case, Token, ., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), &&]
[:, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, )]
[., OR, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild]
[;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (, ), ,, locals]
[&&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (]
[,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., HOOK, :]
[., getFirstChild, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., HOOK, :, return, evaluatesToLocalValue]
[;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (, ), ,, locals]
[,, locals, ), ;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (]
[., getLastChild, (, ), ,, locals, ), ;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (]
[), ;, case, Token, ., HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (, ), ,]
[:, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value]
[., HOOK, :, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ., getNext, (, ), ,, locals, ), &&, evaluatesToLocalValue]
[;, case, Token, ., INC, :, case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP]
[&&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., INC, :, case, Token, .]
[,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., INC, :]
[., getNext, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case]
[., getFirstChild, (, ), ., getNext, (, ), ,, locals, ), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,]
[), &&, evaluatesToLocalValue, (, value, ., getLastChild, (, ), ,, locals, ), ;, case, Token, ., INC, :, case, Token]
[;, case, Token, ., INC, :, case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP]
[,, locals, ), ;, case, Token, ., INC, :, case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (]
[., getLastChild, (, ), ,, locals, ), ;, case, Token, ., INC, :, case, Token, ., DEC, :, if, (]
[), ;, case, Token, ., INC, :, case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (, Node, .]
[:, case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP, ), ), {, return, evaluatesToLocalValue]
[., INC, :, case, Token, ., DEC, :, if, (, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP, ), ), {]
[:, if, (, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP, ), ), {, return, evaluatesToLocalValue, (, value, ., getFirstChild, (]
[., DEC, :, if, (, value, ., getBooleanProp, (, Node, ., INCRDECR_PROP, ), ), {, return, evaluatesToLocalValue, (, value, .]
[), {, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, }, else, {, return, true, ;]
[., getBooleanProp, (, Node, ., INCRDECR_PROP, ), ), {, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, )]
[), ), {, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, }, else, {, return, true]
[., INCRDECR_PROP, ), ), {, return, evaluatesToLocalValue, (, value, ., getFirstChild, (, ), ,, locals, ), ;, }, else, {]
[;, }, else, {, return, true, ;, }, case, Token, ., THIS, :, return, locals, ., apply, (, value, )]
[,, locals, ), ;, }, else, {, return, true, ;, }, case, Token, ., THIS, :, return, locals, ., apply]
[., getFirstChild, (, ), ,, locals, ), ;, }, else, {, return, true, ;, }, case, Token, ., THIS, :]
[), ;, }, else, {, return, true, ;, }, case, Token, ., THIS, :, return, locals, ., apply, (, value]
[;, }, case, Token, ., THIS, :, return, locals, ., apply, (, value, ), ;, case, Token, ., NAME, :]
[:, return, locals, ., apply, (, value, ), ;, case, Token, ., NAME, :, return, isImmutableValue, (, value, ), ||]
[., THIS, :, return, locals, ., apply, (, value, ), ;, case, Token, ., NAME, :, return, isImmutableValue, (, value]
[;, case, Token, ., NAME, :, return, isImmutableValue, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[., apply, (, value, ), ;, case, Token, ., NAME, :, return, isImmutableValue, (, value, ), ||, locals, ., apply]
[), ;, case, Token, ., NAME, :, return, isImmutableValue, (, value, ), ||, locals, ., apply, (, value, ), ;]
[:, return, isImmutableValue, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., GETELEM, :, case]
[., NAME, :, return, isImmutableValue, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., GETELEM]
[;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case]
[||, locals, ., apply, (, value, ), ;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return, locals]
[), ||, locals, ., apply, (, value, ), ;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return]
[;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case]
[., apply, (, value, ), ;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return, locals, ., apply]
[), ;, case, Token, ., GETELEM, :, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;]
[:, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case, Token, ., CALL, :, return]
[., GETELEM, :, case, Token, ., GETPROP, :, return, locals, ., apply, (, value, ), ;, case, Token, ., CALL]
[:, return, locals, ., apply, (, value, ), ;, case, Token, ., CALL, :, return, callHasLocalResult, (, value, ), ||]
[., GETPROP, :, return, locals, ., apply, (, value, ), ;, case, Token, ., CALL, :, return, callHasLocalResult, (, value]
[;, case, Token, ., CALL, :, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value, ), ||, locals, ., apply]
[., apply, (, value, ), ;, case, Token, ., CALL, :, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value]
[), ;, case, Token, ., CALL, :, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value, ), ||, locals, .]
[:, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[., CALL, :, return, callHasLocalResult, (, value, ), ||, isToStringMethodCall, (, value, ), ||, locals, ., apply, (, value, )]
[;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||, locals]
[||, isToStringMethodCall, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return, newHasLocalResult]
[), ||, isToStringMethodCall, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return]
[||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||, locals]
[), ||, locals, ., apply, (, value, ), ;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||]
[;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (, value, ), ;, case]
[., apply, (, value, ), ;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||, locals, ., apply]
[), ;, case, Token, ., NEW, :, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (, value, ), ;]
[:, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., FUNCTION, :, case]
[., NEW, :, return, newHasLocalResult, (, value, ), ||, locals, ., apply, (, value, ), ;, case, Token, ., FUNCTION]
[;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT]
[||, locals, ., apply, (, value, ), ;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case, Token]
[), ||, locals, ., apply, (, value, ), ;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case]
[;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT]
[., apply, (, value, ), ;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT]
[), ;, case, Token, ., FUNCTION, :, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case, Token, .]
[:, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, true, ;, case]
[., FUNCTION, :, case, Token, ., REGEXP, :, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, true]
[:, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, true, ;, case, Token, ., DELPROP, :, case]
[., REGEXP, :, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, true, ;, case, Token, ., DELPROP]
[:, case, Token, ., OBJECTLIT, :, return, true, ;, case, Token, ., DELPROP, :, case, Token, ., IN, :, return]
[., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, return, true, ;, case, Token, ., DELPROP, :, case, Token, ., IN]
[:, return, true, ;, case, Token, ., DELPROP, :, case, Token, ., IN, :, return, true, ;, default, :, if]
[., OBJECTLIT, :, return, true, ;, case, Token, ., DELPROP, :, case, Token, ., IN, :, return, true, ;, default]
[;, case, Token, ., DELPROP, :, case, Token, ., IN, :, return, true, ;, default, :, if, (, isAssignmentOp, (]
[:, case, Token, ., IN, :, return, true, ;, default, :, if, (, isAssignmentOp, (, value, ), ||, isSimpleOperator, (]
[., DELPROP, :, case, Token, ., IN, :, return, true, ;, default, :, if, (, isAssignmentOp, (, value, ), ||]
[:, return, true, ;, default, :, if, (, isAssignmentOp, (, value, ), ||, isSimpleOperator, (, value, ), ||, isImmutableValue, (]
[., IN, :, return, true, ;, default, :, if, (, isAssignmentOp, (, value, ), ||, isSimpleOperator, (, value, ), ||]
[;, default, :, if, (, isAssignmentOp, (, value, ), ||, isSimpleOperator, (, value, ), ||, isImmutableValue, (, value, ), )]
[), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +, "\n parent:", +, value, ., getParent, (]
[||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +, "\n parent:"]
[||, isSimpleOperator, (, value, ), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (]
[), ||, isSimpleOperator, (, value, ), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException]
[||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +, "\n parent:"]
[), ||, isImmutableValue, (, value, ), ), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +]
[), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +, "\n parent:", +, value, ., getParent, (]
[), ), {, return, true, ;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +, "\n parent:", +, value, ., getParent]
[;, }, throw, new, IllegalStateException, (, "Unexpected expression node", +, value, +, "\n parent:", +, value, ., getParent, (, ), ), ;, }]
[;, }, }, private, static, Node, getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =, first, ;]
[), ;, }, }, private, static, Node, getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =, first]
[+, value, ., getParent, (, ), ), ;, }, }, private, static, Node, getNthSibling, (, Node, first, ,, int, index]
[+, "\n parent:", +, value, ., getParent, (, ), ), ;, }, }, private, static, Node, getNthSibling, (, Node, first, ,]
[+, value, +, "\n parent:", +, value, ., getParent, (, ), ), ;, }, }, private, static, Node, getNthSibling, (, Node]
[+, "\n parent:", +, value, ., getParent, (, ), ), ;, }, }, private, static, Node, getNthSibling, (, Node, first, ,]
[+, value, ., getParent, (, ), ), ;, }, }, private, static, Node, getNthSibling, (, Node, first, ,, int, index]
[), ;, }, }, private, static, Node, getNthSibling, (, Node, first, ,, int, index, ), {, Node, sibling, =, first]
[., getParent, (, ), ), ;, }, }, private, static, Node, getNthSibling, (, Node, first, ,, int, index, ), {]
[;, while, (, index, !=, 0, &&, sibling, !=, null, ), {, sibling, =, sibling, ., getNext, (, ), ;]
[), {, sibling, =, sibling, ., getNext, (, ), ;, index, --, ;, }, return, sibling, ;, }, static, Node]
[&&, sibling, !=, null, ), {, sibling, =, sibling, ., getNext, (, ), ;, index, --, ;, }, return, sibling]
[!=, 0, &&, sibling, !=, null, ), {, sibling, =, sibling, ., getNext, (, ), ;, index, --, ;, }]
[&&, sibling, !=, null, ), {, sibling, =, sibling, ., getNext, (, ), ;, index, --, ;, }, return, sibling]
[), {, sibling, =, sibling, ., getNext, (, ), ;, index, --, ;, }, return, sibling, ;, }, static, Node]
[!=, null, ), {, sibling, =, sibling, ., getNext, (, ), ;, index, --, ;, }, return, sibling, ;, }]
[), {, sibling, =, sibling, ., getNext, (, ), ;, index, --, ;, }, return, sibling, ;, }, static, Node]
[=, sibling, ., getNext, (, ), ;, index, --, ;, }, return, sibling, ;, }, static, Node, getArgumentForFunction, (, Node]
[;, index, --, ;, }, return, sibling, ;, }, static, Node, getArgumentForFunction, (, Node, function, ,, int, index, ), {]
[., getNext, (, ), ;, index, --, ;, }, return, sibling, ;, }, static, Node, getArgumentForFunction, (, Node, function, ,]
[;, }, return, sibling, ;, }, static, Node, getArgumentForFunction, (, Node, function, ,, int, index, ), {, Preconditions, ., checkState]
[--, ;, }, return, sibling, ;, }, static, Node, getArgumentForFunction, (, Node, function, ,, int, index, ), {, Preconditions, .]
[;, }, static, Node, getArgumentForFunction, (, Node, function, ,, int, index, ), {, Preconditions, ., checkState, (, function, ., isFunction]
[;, return, getNthSibling, (, function, ., getFirstChild, (, ), ., getNext, (, ), ., getFirstChild, (, ), ,, index, )]
[., checkState, (, function, ., isFunction, (, ), ), ;, return, getNthSibling, (, function, ., getFirstChild, (, ), ., getNext]
[), ;, return, getNthSibling, (, function, ., getFirstChild, (, ), ., getNext, (, ), ., getFirstChild, (, ), ,, index]
[., isFunction, (, ), ), ;, return, getNthSibling, (, function, ., getFirstChild, (, ), ., getNext, (, ), ., getFirstChild]
[;, }, static, Node, getArgumentForCallOrNew, (, Node, call, ,, int, index, ), {, Preconditions, ., checkState, (, isCallOrNew, (, call]
[,, index, ), ;, }, static, Node, getArgumentForCallOrNew, (, Node, call, ,, int, index, ), {, Preconditions, ., checkState, (]
[., getFirstChild, (, ), ,, index, ), ;, }, static, Node, getArgumentForCallOrNew, (, Node, call, ,, int, index, ), {]
[., getNext, (, ), ., getFirstChild, (, ), ,, index, ), ;, }, static, Node, getArgumentForCallOrNew, (, Node, call, ,]
[., getFirstChild, (, ), ., getNext, (, ), ., getFirstChild, (, ), ,, index, ), ;, }, static, Node, getArgumentForCallOrNew]
[), ;, }, static, Node, getArgumentForCallOrNew, (, Node, call, ,, int, index, ), {, Preconditions, ., checkState, (, isCallOrNew, (]
[;, return, getNthSibling, (, call, ., getFirstChild, (, ), ., getNext, (, ), ,, index, ), ;, }, static, boolean]
[., checkState, (, isCallOrNew, (, call, ), ), ;, return, getNthSibling, (, call, ., getFirstChild, (, ), ., getNext, (]
[), ;, return, getNthSibling, (, call, ., getFirstChild, (, ), ., getNext, (, ), ,, index, ), ;, }, static]
[), ), ;, return, getNthSibling, (, call, ., getFirstChild, (, ), ., getNext, (, ), ,, index, ), ;, }]
[;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (, ), ;, return]
[,, index, ), ;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (]
[., getNext, (, ), ,, index, ), ;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =]
[., getFirstChild, (, ), ., getNext, (, ), ,, index, ), ;, }, static, boolean, isCallOrNewTarget, (, Node, target, )]
[), ;, }, static, boolean, isCallOrNewTarget, (, Node, target, ), {, Node, parent, =, target, ., getParent, (, ), ;]
[;, return, parent, !=, null, &&, NodeUtil, ., isCallOrNew, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, target]
[., getParent, (, ), ;, return, parent, !=, null, &&, NodeUtil, ., isCallOrNew, (, parent, ), &&, parent, ., getFirstChild]
[;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node, getNode, =, call, ., getFirstChild, (, ), ;]
[&&, parent, ., getFirstChild, (, ), ==, target, ;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node]
[&&, NodeUtil, ., isCallOrNew, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, target, ;, }, private, static, boolean]
[!=, null, &&, NodeUtil, ., isCallOrNew, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, target, ;, }, private]
[&&, NodeUtil, ., isCallOrNew, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, target, ;, }, private, static, boolean]
[&&, parent, ., getFirstChild, (, ), ==, target, ;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node]
[., isCallOrNew, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, target, ;, }, private, static, boolean, isToStringMethodCall, (]
[), &&, parent, ., getFirstChild, (, ), ==, target, ;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {]
[;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node, getNode, =, call, ., getFirstChild, (, ), ;]
[==, target, ;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node, getNode, =, call, ., getFirstChild, (]
[., getFirstChild, (, ), ==, target, ;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node, getNode, =]
[;, }, private, static, boolean, isToStringMethodCall, (, Node, call, ), {, Node, getNode, =, call, ., getFirstChild, (, ), ;]
[;, if, (, isGet, (, getNode, ), ), {, Node, propNode, =, getNode, ., getLastChild, (, ), ;, return, propNode]
[., getFirstChild, (, ), ;, if, (, isGet, (, getNode, ), ), {, Node, propNode, =, getNode, ., getLastChild, (]
[), {, Node, propNode, =, getNode, ., getLastChild, (, ), ;, return, propNode, ., isString, (, ), &&, "toString", .]
[), ), {, Node, propNode, =, getNode, ., getLastChild, (, ), ;, return, propNode, ., isString, (, ), &&, "toString"]
[;, return, propNode, ., isString, (, ), &&, "toString", ., equals, (, propNode, ., getString, (, ), ), ;, }]
[., getLastChild, (, ), ;, return, propNode, ., isString, (, ), &&, "toString", ., equals, (, propNode, ., getString, (]
[;, }, return, false, ;, }, static, JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo, info, =, n, ., getJSDocInfo]
[&&, "toString", ., equals, (, propNode, ., getString, (, ), ), ;, }, return, false, ;, }, static, JSDocInfo, getBestJSDocInfo]
[., isString, (, ), &&, "toString", ., equals, (, propNode, ., getString, (, ), ), ;, }, return, false, ;]
[;, }, return, false, ;, }, static, JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo, info, =, n, ., getJSDocInfo]
[., equals, (, propNode, ., getString, (, ), ), ;, }, return, false, ;, }, static, JSDocInfo, getBestJSDocInfo, (, Node]
[), ;, }, return, false, ;, }, static, JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo, info, =, n, .]
[., getString, (, ), ), ;, }, return, false, ;, }, static, JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo]
[;, }, static, JSDocInfo, getBestJSDocInfo, (, Node, n, ), {, JSDocInfo, info, =, n, ., getJSDocInfo, (, ), ;, if]
[;, if, (, info, ==, null, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent]
[., getJSDocInfo, (, ), ;, if, (, info, ==, null, ), {, Node, parent, =, n, ., getParent, (, )]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, null]
[==, null, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, null]
[;, if, (, parent, ==, null, ), {, return, null, ;, }, if, (, parent, ., isName, (, ), )]
[., getParent, (, ), ;, if, (, parent, ==, null, ), {, return, null, ;, }, if, (, parent, .]
[), {, return, null, ;, }, if, (, parent, ., isName, (, ), ), {, return, getBestJSDocInfo, (, parent, )]
[==, null, ), {, return, null, ;, }, if, (, parent, ., isName, (, ), ), {, return, getBestJSDocInfo, (]
[), {, return, null, ;, }, if, (, parent, ., isName, (, ), ), {, return, getBestJSDocInfo, (, parent, )]
[;, }, if, (, parent, ., isName, (, ), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if]
[), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isAssign, (, ), ), {, return]
[., isName, (, ), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isAssign, (]
[;, }, else, if, (, parent, ., isAssign, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }]
[), ;, }, else, if, (, parent, ., isAssign, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;]
[), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,, parent, ., getParent]
[., isAssign, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, isObjectLitKey, (, parent]
[;, }, else, if, (, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return, parent, .]
[., getJSDocInfo, (, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), )]
[), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isFunction, (, ), ), {]
[,, parent, ., getParent, (, ), ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (]
[), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isFunction, (, ), )]
[., getParent, (, ), ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, .]
[;, }, else, if, (, parent, ., isFunction, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }]
[., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isFunction, (, ), ), {, return, parent, ., getJSDocInfo]
[), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isVar, (, ), &&, parent]
[., isFunction, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isVar]
[;, }, else, if, (, parent, ., isVar, (, ), &&, parent, ., hasOneChild, (, ), ), {, return, parent]
[., getJSDocInfo, (, ), ;, }, else, if, (, parent, ., isVar, (, ), &&, parent, ., hasOneChild, (, )]
[), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (, parent, ., isHook, (, ), &&]
[&&, parent, ., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (]
[., isVar, (, ), &&, parent, ., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }]
[), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (, parent, ., isHook, (, ), &&]
[., hasOneChild, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, else, if, (, (, parent, .]
[;, }, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, )]
[., getJSDocInfo, (, ), ;, }, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (]
[), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return]
[||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestJSDocInfo]
[||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=]
[||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&]
[), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, )]
[&&, parent, ., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (]
[., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||]
[), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, )]
[!=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma]
[., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||]
[), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, )]
[||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=]
[., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, .]
[||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestJSDocInfo]
[., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, )]
[), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return]
[), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {]
[&&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if]
[., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestJSDocInfo, (, parent, )]
[), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {]
[!=, n, ), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, )]
[., getFirstChild, (, ), !=, n, ), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent]
[), ), {, return, getBestJSDocInfo, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {]
[;, }, else, if, (, parent, ., isCast, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }]
[), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;]
[), {, return, parent, ., getJSDocInfo, (, ), ;, }, }, return, info, ;, }, static, Node, getBestLValue, (, Node]
[., isCast, (, ), ), {, return, parent, ., getJSDocInfo, (, ), ;, }, }, return, info, ;, }, static]
[;, }, }, return, info, ;, }, static, Node, getBestLValue, (, Node, n, ), {, Node, parent, =, n, .]
[., getJSDocInfo, (, ), ;, }, }, return, info, ;, }, static, Node, getBestLValue, (, Node, n, ), {, Node]
[;, }, static, Node, getBestLValue, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, boolean]
[;, boolean, isFunctionDeclaration, =, isFunctionDeclaration, (, n, ), ;, if, (, isFunctionDeclaration, ), {, return, n, ., getFirstChild, (, )]
[., getParent, (, ), ;, boolean, isFunctionDeclaration, =, isFunctionDeclaration, (, n, ), ;, if, (, isFunctionDeclaration, ), {, return, n]
[;, if, (, isFunctionDeclaration, ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (, parent, ., isName]
[), ;, if, (, isFunctionDeclaration, ), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (, parent, .]
[), {, return, n, ., getFirstChild, (, ), ;, }, else, if, (, parent, ., isName, (, ), ), {]
[;, }, else, if, (, parent, ., isName, (, ), ), {, return, parent, ;, }, else, if, (, parent]
[., getFirstChild, (, ), ;, }, else, if, (, parent, ., isName, (, ), ), {, return, parent, ;, }]
[), {, return, parent, ;, }, else, if, (, parent, ., isAssign, (, ), ), {, return, parent, ., getFirstChild]
[., isName, (, ), ), {, return, parent, ;, }, else, if, (, parent, ., isAssign, (, ), ), {]
[;, }, else, if, (, parent, ., isAssign, (, ), ), {, return, parent, ., getFirstChild, (, ), ;, }]
[), {, return, parent, ., getFirstChild, (, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,, parent, ., getParent]
[., isAssign, (, ), ), {, return, parent, ., getFirstChild, (, ), ;, }, else, if, (, isObjectLitKey, (, parent]
[;, }, else, if, (, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), ), {, return, parent, ;]
[., getFirstChild, (, ), ;, }, else, if, (, isObjectLitKey, (, parent, ,, parent, ., getParent, (, ), ), )]
[), {, return, parent, ;, }, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (]
[,, parent, ., getParent, (, ), ), ), {, return, parent, ;, }, else, if, (, (, parent, ., isHook]
[), ), {, return, parent, ;, }, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild]
[., getParent, (, ), ), ), {, return, parent, ;, }, else, if, (, (, parent, ., isHook, (, )]
[;, }, else, if, (, (, parent, ., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, )]
[), {, return, getBestLValue, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return]
[||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestLValue]
[||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=]
[||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&]
[), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, )]
[&&, parent, ., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (]
[., isHook, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||]
[), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, )]
[!=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma]
[., getFirstChild, (, ), !=, n, ), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||]
[), ||, parent, ., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, )]
[||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=]
[., isOr, (, ), ||, parent, ., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, .]
[||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestLValue]
[., isAnd, (, ), ||, (, parent, ., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, )]
[), {, return, getBestLValue, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return]
[), ), {, return, getBestLValue, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {]
[&&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestLValue, (, parent, ), ;, }, else, if]
[., isComma, (, ), &&, parent, ., getFirstChild, (, ), !=, n, ), ), {, return, getBestLValue, (, parent, )]
[), ), {, return, getBestLValue, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {]
[!=, n, ), ), {, return, getBestLValue, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, )]
[., getFirstChild, (, ), !=, n, ), ), {, return, getBestLValue, (, parent, ), ;, }, else, if, (, parent]
[), ), {, return, getBestLValue, (, parent, ), ;, }, else, if, (, parent, ., isCast, (, ), ), {]
[;, }, else, if, (, parent, ., isCast, (, ), ), {, return, getBestLValue, (, parent, ), ;, }, return]
[), ;, }, else, if, (, parent, ., isCast, (, ), ), {, return, getBestLValue, (, parent, ), ;, }]
[), {, return, getBestLValue, (, parent, ), ;, }, return, null, ;, }, static, Node, getRValueOfLValue, (, Node, n, )]
[., isCast, (, ), ), {, return, getBestLValue, (, parent, ), ;, }, return, null, ;, }, static, Node, getRValueOfLValue]
[;, }, return, null, ;, }, static, Node, getRValueOfLValue, (, Node, n, ), {, Node, parent, =, n, ., getParent]
[), ;, }, return, null, ;, }, static, Node, getRValueOfLValue, (, Node, n, ), {, Node, parent, =, n, .]
[;, }, static, Node, getRValueOfLValue, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, switch]
[;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return, n, ., getNext, (]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return]
[), {, case, Token, ., ASSIGN, :, return, n, ., getNext, (, ), ;, case, Token, ., VAR, :, return]
[., getType, (, ), ), {, case, Token, ., ASSIGN, :, return, n, ., getNext, (, ), ;, case, Token]
[:, return, n, ., getNext, (, ), ;, case, Token, ., VAR, :, return, n, ., getFirstChild, (, ), ;]
[., ASSIGN, :, return, n, ., getNext, (, ), ;, case, Token, ., VAR, :, return, n, ., getFirstChild, (]
[;, case, Token, ., VAR, :, return, n, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, parent]
[., getNext, (, ), ;, case, Token, ., VAR, :, return, n, ., getFirstChild, (, ), ;, case, Token, .]
[:, return, n, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, parent, ;, }, return, null, ;]
[., VAR, :, return, n, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, parent, ;, }, return]
[;, case, Token, ., FUNCTION, :, return, parent, ;, }, return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable]
[., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, parent, ;, }, return, null, ;, }, static, Node]
[:, return, parent, ;, }, return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if]
[., FUNCTION, :, return, parent, ;, }, return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, )]
[;, }, return, null, ;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==]
[;, }, static, Node, getBestLValueOwner, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||, lValue, .]
[), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {]
[||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,]
[==, null, ||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (]
[||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,]
[), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {]
[==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), )]
[., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, .]
[), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {]
[;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {, return, getBestLValue, (, lValue]
[), {, return, getBestLValue, (, lValue, ., getParent, (, ), ), ;, }, else, if, (, isGet, (, lValue, )]
[,, lValue, ., getParent, (, ), ), ), {, return, getBestLValue, (, lValue, ., getParent, (, ), ), ;, }]
[), ), {, return, getBestLValue, (, lValue, ., getParent, (, ), ), ;, }, else, if, (, isGet, (, lValue]
[., getParent, (, ), ), ), {, return, getBestLValue, (, lValue, ., getParent, (, ), ), ;, }, else, if]
[;, }, else, if, (, isGet, (, lValue, ), ), {, return, lValue, ., getFirstChild, (, ), ;, }, return]
[), ;, }, else, if, (, isGet, (, lValue, ), ), {, return, lValue, ., getFirstChild, (, ), ;, }]
[., getParent, (, ), ), ;, }, else, if, (, isGet, (, lValue, ), ), {, return, lValue, ., getFirstChild]
[), {, return, lValue, ., getFirstChild, (, ), ;, }, return, null, ;, }, static, String, getBestLValueName, (, @, Nullable]
[), ), {, return, lValue, ., getFirstChild, (, ), ;, }, return, null, ;, }, static, String, getBestLValueName, (, @]
[;, }, return, null, ;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==]
[., getFirstChild, (, ), ;, }, return, null, ;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {]
[;, }, static, String, getBestLValueName, (, @, Nullable, Node, lValue, ), {, if, (, lValue, ==, null, ||, lValue, .]
[), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {]
[||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,]
[==, null, ||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (]
[||, lValue, ., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,]
[), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {]
[==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), )]
[., getParent, (, ), ==, null, ), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, .]
[), {, return, null, ;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {]
[;, }, if, (, isObjectLitKey, (, lValue, ,, lValue, ., getParent, (, ), ), ), {, Node, owner, =, getBestLValue]
[), {, Node, owner, =, getBestLValue, (, lValue, ., getParent, (, ), ), ;, if, (, owner, !=, null, )]
[,, lValue, ., getParent, (, ), ), ), {, Node, owner, =, getBestLValue, (, lValue, ., getParent, (, ), )]
[), ), {, Node, owner, =, getBestLValue, (, lValue, ., getParent, (, ), ), ;, if, (, owner, !=, null]
[., getParent, (, ), ), ), {, Node, owner, =, getBestLValue, (, lValue, ., getParent, (, ), ), ;, if]
[;, if, (, owner, !=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=]
[), ;, if, (, owner, !=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName]
[., getParent, (, ), ), ;, if, (, owner, !=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, )]
[), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=, null, ), {, return, ownerName, +]
[!=, null, ), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=, null, ), {, return]
[), {, String, ownerName, =, getBestLValueName, (, owner, ), ;, if, (, ownerName, !=, null, ), {, return, ownerName, +]
[;, if, (, ownerName, !=, null, ), {, return, ownerName, +, ".", +, getObjectLitKeyName, (, lValue, ), ;, }, }]
[), ;, if, (, ownerName, !=, null, ), {, return, ownerName, +, ".", +, getObjectLitKeyName, (, lValue, ), ;, }]
[), {, return, ownerName, +, ".", +, getObjectLitKeyName, (, lValue, ), ;, }, }, return, null, ;, }, return, lValue]
[!=, null, ), {, return, ownerName, +, ".", +, getObjectLitKeyName, (, lValue, ), ;, }, }, return, null, ;, }]
[), {, return, ownerName, +, ".", +, getObjectLitKeyName, (, lValue, ), ;, }, }, return, null, ;, }, return, lValue]
[;, }, }, return, null, ;, }, return, lValue, ., getQualifiedName, (, ), ;, }, static, boolean, isExpressionResultUsed, (, Node]
[+, getObjectLitKeyName, (, lValue, ), ;, }, }, return, null, ;, }, return, lValue, ., getQualifiedName, (, ), ;, }]
[+, ".", +, getObjectLitKeyName, (, lValue, ), ;, }, }, return, null, ;, }, return, lValue, ., getQualifiedName, (, )]
[+, getObjectLitKeyName, (, lValue, ), ;, }, }, return, null, ;, }, return, lValue, ., getQualifiedName, (, ), ;, }]
[;, }, }, return, null, ;, }, return, lValue, ., getQualifiedName, (, ), ;, }, static, boolean, isExpressionResultUsed, (, Node]
[), ;, }, }, return, null, ;, }, return, lValue, ., getQualifiedName, (, ), ;, }, static, boolean, isExpressionResultUsed, (]
[;, }, return, lValue, ., getQualifiedName, (, ), ;, }, static, boolean, isExpressionResultUsed, (, Node, expr, ), {, Node, parent]
[;, }, static, boolean, isExpressionResultUsed, (, Node, expr, ), {, Node, parent, =, expr, ., getParent, (, ), ;, switch]
[., getQualifiedName, (, ), ;, }, static, boolean, isExpressionResultUsed, (, Node, expr, ), {, Node, parent, =, expr, ., getParent]
[;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., BLOCK, :, case]
[), {, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, return, false, ;, case, Token, ., CAST, :]
[., getType, (, ), ), {, case, Token, ., BLOCK, :, case, Token, ., EXPR_RESULT, :, return, false, ;, case]
[:, case, Token, ., EXPR_RESULT, :, return, false, ;, case, Token, ., CAST, :, return, isExpressionResultUsed, (, parent, ), ;]
[., BLOCK, :, case, Token, ., EXPR_RESULT, :, return, false, ;, case, Token, ., CAST, :, return, isExpressionResultUsed, (, parent]
[:, return, false, ;, case, Token, ., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case, Token, ., HOOK, :]
[., EXPR_RESULT, :, return, false, ;, case, Token, ., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case, Token, .]
[;, case, Token, ., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case, Token, ., HOOK, :, case, Token, .]
[:, return, isExpressionResultUsed, (, parent, ), ;, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, .]
[., CAST, :, return, isExpressionResultUsed, (, parent, ), ;, case, Token, ., HOOK, :, case, Token, ., AND, :, case]
[;, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, (, expr, ==]
[), ;, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, (, expr]
[:, case, Token, ., AND, :, case, Token, ., OR, :, return, (, expr, ==, parent, ., getFirstChild, (, )]
[., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, (, expr, ==, parent, ., getFirstChild]
[:, case, Token, ., OR, :, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed]
[., AND, :, case, Token, ., OR, :, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, true]
[:, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed, (, parent, ), ;, case]
[., OR, :, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed, (, parent, )]
[;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;, if, (, gramps, ., isCall]
[?, true, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent, (]
[), ?, true, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent]
[==, parent, ., getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., COMMA, :]
[), ?, true, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent]
[., getFirstChild, (, ), ), ?, true, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., COMMA, :, Node, gramps]
[:, isExpressionResultUsed, (, parent, ), ;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;]
[;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;, if, (, gramps, ., isCall]
[), ;, case, Token, ., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;, if, (, gramps, .]
[:, Node, gramps, =, parent, ., getParent, (, ), ;, if, (, gramps, ., isCall, (, ), &&, parent, ==]
[., COMMA, :, Node, gramps, =, parent, ., getParent, (, ), ;, if, (, gramps, ., isCall, (, ), &&]
[;, if, (, gramps, ., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (]
[., getParent, (, ), ;, if, (, gramps, ., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, )]
[), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&, parent, ., getChildCount, (, ), ==, 2, &&]
[&&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&]
[., isCall, (, ), &&, parent, ==, gramps, ., getFirstChild, (, ), ), {, if, (, expr, ==, parent, .]
[), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&, parent, ., getChildCount, (, ), ==, 2, &&]
[==, gramps, ., getFirstChild, (, ), ), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&, parent, .]
[), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&, parent, ., getChildCount, (, ), ==, 2, &&]
[., getFirstChild, (, ), ), {, if, (, expr, ==, parent, ., getFirstChild, (, ), &&, parent, ., getChildCount, (]
[), {, return, true, ;, }, }, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, false, :]
[&&, "eval", ., equals, (, expr, ., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;]
[&&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval", ., equals, (, expr, ., getNext, (, )]
[&&, parent, ., getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval"]
[==, parent, ., getFirstChild, (, ), &&, parent, ., getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, )]
[&&, parent, ., getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval"]
[., getFirstChild, (, ), &&, parent, ., getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, ), ., isName]
[&&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval", ., equals, (, expr, ., getNext, (, )]
[==, 2, &&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval", ., equals, (, expr, ., getNext]
[., getChildCount, (, ), ==, 2, &&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval", ., equals]
[&&, expr, ., getNext, (, ), ., isName, (, ), &&, "eval", ., equals, (, expr, ., getNext, (, )]
[&&, "eval", ., equals, (, expr, ., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;]
[., isName, (, ), &&, "eval", ., equals, (, expr, ., getNext, (, ), ., getString, (, ), ), )]
[., getNext, (, ), ., isName, (, ), &&, "eval", ., equals, (, expr, ., getNext, (, ), ., getString]
[), {, return, true, ;, }, }, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, false, :]
[., equals, (, expr, ., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;, }, }]
[), ), {, return, true, ;, }, }, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, false]
[., getString, (, ), ), ), {, return, true, ;, }, }, return, (, expr, ==, parent, ., getFirstChild, (]
[., getNext, (, ), ., getString, (, ), ), ), {, return, true, ;, }, }, return, (, expr, ==]
[;, }, }, return, (, expr, ==, parent, ., getFirstChild, (, ), ), ?, false, :, isExpressionResultUsed, (, parent, )]
[;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (, parent]
[?, false, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (]
[), ?, false, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn]
[==, parent, ., getFirstChild, (, ), ), ?, false, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :]
[), ?, false, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn]
[., getFirstChild, (, ), ), ?, false, :, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :, if, (]
[:, isExpressionResultUsed, (, parent, ), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, )]
[;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (, parent]
[), ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (]
[:, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (, parent, ., getChildAtIndex, (, 1, )]
[., FOR, :, if, (, !, NodeUtil, ., isForIn, (, parent, ), ), {, return, (, parent, ., getChildAtIndex, (]
[), {, return, (, parent, ., getChildAtIndex, (, 1, ), ==, expr, ), ;, }, break, ;, }, return, true]
[), {, return, (, parent, ., getChildAtIndex, (, 1, ), ==, expr, ), ;, }, break, ;, }, return, true]
[., isForIn, (, parent, ), ), {, return, (, parent, ., getChildAtIndex, (, 1, ), ==, expr, ), ;, }]
[), ), {, return, (, parent, ., getChildAtIndex, (, 1, ), ==, expr, ), ;, }, break, ;, }, return]
[;, }, break, ;, }, return, true, ;, }, static, boolean, isExecutedExactlyOnce, (, Node, n, ), {, inspect, :, do]
[), ;, }, break, ;, }, return, true, ;, }, static, boolean, isExecutedExactlyOnce, (, Node, n, ), {, inspect, :]
[==, expr, ), ;, }, break, ;, }, return, true, ;, }, static, boolean, isExecutedExactlyOnce, (, Node, n, ), {]
[., getChildAtIndex, (, 1, ), ==, expr, ), ;, }, break, ;, }, return, true, ;, }, static, boolean, isExecutedExactlyOnce]
[), ==, expr, ), ;, }, break, ;, }, return, true, ;, }, static, boolean, isExecutedExactlyOnce, (, Node, n, )]
[), ;, }, break, ;, }, return, true, ;, }, static, boolean, isExecutedExactlyOnce, (, Node, n, ), {, inspect, :]
[;, }, static, boolean, isExecutedExactlyOnce, (, Node, n, ), {, inspect, :, do, {, Node, parent, =, n, ., getParent]
[;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., HOOK, :]
[., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[), {, case, Token, ., IF, :, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., HOOK, :, case, Token, ., AND]
[:, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, if, (, parent, .]
[., IF, :, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, if, (]
[:, case, Token, ., AND, :, case, Token, ., OR, :, if, (, parent, ., getFirstChild, (, ), !=, n]
[., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, if, (, parent, ., getFirstChild, (, )]
[:, case, Token, ., OR, :, if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return, false, ;]
[., AND, :, case, Token, ., OR, :, if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return]
[:, if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case]
[., OR, :, if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect]
[), {, return, false, ;, }, continue, inspect, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (]
[!=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, ., FOR, :, if, (, NodeUtil, .]
[., getFirstChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, ., FOR, :]
[), {, return, false, ;, }, continue, inspect, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (]
[;, }, continue, inspect, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {]
[:, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, if, (, parent, ., getChildAtIndex, (, 1, ), !=]
[., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, if, (, parent, ., getChildAtIndex, (, 1]
[), {, if, (, parent, ., getChildAtIndex, (, 1, ), !=, n, ), {, return, false, ;, }, }, else]
[., isForIn, (, parent, ), ), {, if, (, parent, ., getChildAtIndex, (, 1, ), !=, n, ), {, return]
[), ), {, if, (, parent, ., getChildAtIndex, (, 1, ), !=, n, ), {, return, false, ;, }, }]
[), {, return, false, ;, }, }, else, {, if, (, parent, ., getFirstChild, (, ), !=, n, ), {]
[!=, n, ), {, return, false, ;, }, }, else, {, if, (, parent, ., getFirstChild, (, ), !=, n]
[., getChildAtIndex, (, 1, ), !=, n, ), {, return, false, ;, }, }, else, {, if, (, parent, .]
[), !=, n, ), {, return, false, ;, }, }, else, {, if, (, parent, ., getFirstChild, (, ), !=]
[), {, return, false, ;, }, }, else, {, if, (, parent, ., getFirstChild, (, ), !=, n, ), {]
[;, }, }, else, {, if, (, parent, ., getFirstChild, (, ), !=, n, ), {, return, false, ;, }]
[), {, return, false, ;, }, }, continue, inspect, ;, case, Token, ., WHILE, :, case, Token, ., DO, :]
[!=, n, ), {, return, false, ;, }, }, continue, inspect, ;, case, Token, ., WHILE, :, case, Token, .]
[., getFirstChild, (, ), !=, n, ), {, return, false, ;, }, }, continue, inspect, ;, case, Token, ., WHILE]
[), {, return, false, ;, }, }, continue, inspect, ;, case, Token, ., WHILE, :, case, Token, ., DO, :]
[;, }, }, continue, inspect, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, return, false, ;, case]
[:, case, Token, ., DO, :, return, false, ;, case, Token, ., TRY, :, if, (, !, hasFinally, (, parent]
[., WHILE, :, case, Token, ., DO, :, return, false, ;, case, Token, ., TRY, :, if, (, !, hasFinally]
[:, return, false, ;, case, Token, ., TRY, :, if, (, !, hasFinally, (, parent, ), ||, parent, ., getLastChild]
[., DO, :, return, false, ;, case, Token, ., TRY, :, if, (, !, hasFinally, (, parent, ), ||, parent]
[;, case, Token, ., TRY, :, if, (, !, hasFinally, (, parent, ), ||, parent, ., getLastChild, (, ), !=]
[:, if, (, !, hasFinally, (, parent, ), ||, parent, ., getLastChild, (, ), !=, n, ), {, return, false]
[., TRY, :, if, (, !, hasFinally, (, parent, ), ||, parent, ., getLastChild, (, ), !=, n, ), {]
[), {, return, false, ;, }, continue, inspect, ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return]
[||, parent, ., getLastChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, .]
[||, parent, ., getLastChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, .]
[), ||, parent, ., getLastChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token]
[), {, return, false, ;, }, continue, inspect, ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return]
[!=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE]
[., getLastChild, (, ), !=, n, ), {, return, false, ;, }, continue, inspect, ;, case, Token, ., CASE, :]
[), {, return, false, ;, }, continue, inspect, ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return]
[;, }, continue, inspect, ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, false, ;, case, Token]
[:, case, Token, ., DEFAULT_CASE, :, return, false, ;, case, Token, ., SCRIPT, :, case, Token, ., FUNCTION, :, break]
[., CASE, :, case, Token, ., DEFAULT_CASE, :, return, false, ;, case, Token, ., SCRIPT, :, case, Token, ., FUNCTION]
[:, return, false, ;, case, Token, ., SCRIPT, :, case, Token, ., FUNCTION, :, break, inspect, ;, }, }, while]
[., DEFAULT_CASE, :, return, false, ;, case, Token, ., SCRIPT, :, case, Token, ., FUNCTION, :, break, inspect, ;, }]
[;, case, Token, ., SCRIPT, :, case, Token, ., FUNCTION, :, break, inspect, ;, }, }, while, (, (, n]
[:, case, Token, ., FUNCTION, :, break, inspect, ;, }, }, while, (, (, n, =, n, ., getParent, (]
[., SCRIPT, :, case, Token, ., FUNCTION, :, break, inspect, ;, }, }, while, (, (, n, =, n, .]
[:, break, inspect, ;, }, }, while, (, (, n, =, n, ., getParent, (, ), ), !=, null, )]
[., FUNCTION, :, break, inspect, ;, }, }, while, (, (, n, =, n, ., getParent, (, ), ), !=]
[), ;, return, true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return, value, ?, IR, ., trueNode]
[!=, null, ), ;, return, true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return, value, ?, IR]
[=, n, ., getParent, (, ), ), !=, null, ), ;, return, true, ;, }, static, Node, booleanNode, (, boolean]
[), !=, null, ), ;, return, true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return, value, ?]
[., getParent, (, ), ), !=, null, ), ;, return, true, ;, }, static, Node, booleanNode, (, boolean, value, )]
[), ;, return, true, ;, }, static, Node, booleanNode, (, boolean, value, ), {, return, value, ?, IR, ., trueNode]
[;, }, static, Node, booleanNode, (, boolean, value, ), {, return, value, ?, IR, ., trueNode, (, ), :, IR]
[;, }, static, Node, numberNode, (, double, value, ,, Node, srcref, ), {, Node, result, ;, if, (, Double, .]
[?, IR, ., trueNode, (, ), :, IR, ., falseNode, (, ), ;, }, static, Node, numberNode, (, double, value]
[:, IR, ., falseNode, (, ), ;, }, static, Node, numberNode, (, double, value, ,, Node, srcref, ), {, Node]
[., trueNode, (, ), :, IR, ., falseNode, (, ), ;, }, static, Node, numberNode, (, double, value, ,, Node]
[;, }, static, Node, numberNode, (, double, value, ,, Node, srcref, ), {, Node, result, ;, if, (, Double, .]
[., falseNode, (, ), ;, }, static, Node, numberNode, (, double, value, ,, Node, srcref, ), {, Node, result, ;]
[), {, result, =, IR, ., name, (, "NaN", ), ;, }, else, if, (, value, ==, Double, ., POSITIVE_INFINITY]
[., isNaN, (, value, ), ), {, result, =, IR, ., name, (, "NaN", ), ;, }, else, if, (]
[), ), {, result, =, IR, ., name, (, "NaN", ), ;, }, else, if, (, value, ==, Double, .]
[=, IR, ., name, (, "NaN", ), ;, }, else, if, (, value, ==, Double, ., POSITIVE_INFINITY, ), {, result]
[;, }, else, if, (, value, ==, Double, ., POSITIVE_INFINITY, ), {, result, =, IR, ., name, (, "Infinity", )]
[., name, (, "NaN", ), ;, }, else, if, (, value, ==, Double, ., POSITIVE_INFINITY, ), {, result, =, IR]
[), ;, }, else, if, (, value, ==, Double, ., POSITIVE_INFINITY, ), {, result, =, IR, ., name, (, "Infinity"]
[), {, result, =, IR, ., name, (, "Infinity", ), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY]
[==, Double, ., POSITIVE_INFINITY, ), {, result, =, IR, ., name, (, "Infinity", ), ;, }, else, if, (, value]
[), {, result, =, IR, ., name, (, "Infinity", ), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY]
[., POSITIVE_INFINITY, ), {, result, =, IR, ., name, (, "Infinity", ), ;, }, else, if, (, value, ==, Double]
[=, IR, ., name, (, "Infinity", ), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {, result]
[;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {, result, =, IR, ., neg, (, IR, .]
[., name, (, "Infinity", ), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {, result, =, IR]
[), ;, }, else, if, (, value, ==, Double, ., NEGATIVE_INFINITY, ), {, result, =, IR, ., neg, (, IR]
[), {, result, =, IR, ., neg, (, IR, ., name, (, "Infinity", ), ), ;, }, else, {, result]
[==, Double, ., NEGATIVE_INFINITY, ), {, result, =, IR, ., neg, (, IR, ., name, (, "Infinity", ), ), ;]
[), {, result, =, IR, ., neg, (, IR, ., name, (, "Infinity", ), ), ;, }, else, {, result]
[., NEGATIVE_INFINITY, ), {, result, =, IR, ., neg, (, IR, ., name, (, "Infinity", ), ), ;, }, else]
[=, IR, ., neg, (, IR, ., name, (, "Infinity", ), ), ;, }, else, {, result, =, IR, .]
[;, }, else, {, result, =, IR, ., number, (, value, ), ;, }, if, (, srcref, !=, null, )]
[., neg, (, IR, ., name, (, "Infinity", ), ), ;, }, else, {, result, =, IR, ., number, (]
[), ;, }, else, {, result, =, IR, ., number, (, value, ), ;, }, if, (, srcref, !=, null]
[., name, (, "Infinity", ), ), ;, }, else, {, result, =, IR, ., number, (, value, ), ;, }]
[), ), ;, }, else, {, result, =, IR, ., number, (, value, ), ;, }, if, (, srcref, !=]
[=, IR, ., number, (, value, ), ;, }, if, (, srcref, !=, null, ), {, result, ., srcrefTree, (]
[;, }, if, (, srcref, !=, null, ), {, result, ., srcrefTree, (, srcref, ), ;, }, return, result, ;]
[., number, (, value, ), ;, }, if, (, srcref, !=, null, ), {, result, ., srcrefTree, (, srcref, )]
[), ;, }, if, (, srcref, !=, null, ), {, result, ., srcrefTree, (, srcref, ), ;, }, return, result]
[), {, result, ., srcrefTree, (, srcref, ), ;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n]
[!=, null, ), {, result, ., srcrefTree, (, srcref, ), ;, }, return, result, ;, }, static, boolean, isNaN, (]
[), {, result, ., srcrefTree, (, srcref, ), ;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n]
[;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (, (, n, ., isName]
[., srcrefTree, (, srcref, ), ;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if]
[), ;, }, return, result, ;, }, static, boolean, isNaN, (, Node, n, ), {, if, (, (, n, .]
[;, }, static, boolean, isNaN, (, Node, n, ), {, if, (, (, n, ., isName, (, ), &&, n]
[), {, return, true, ;, }, return, false, ;, }, }]
[||, (, n, ., getType, (, ), ==, Token, ., DIV, &&, n, ., getFirstChild, (, ), ., isNumber, (]
[), ||, (, n, ., getType, (, ), ==, Token, ., DIV, &&, n, ., getFirstChild, (, ), ., isNumber]
[&&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (, n, ., getType, (, ), ==]
[., isName, (, ), &&, n, ., getString, (, ), ., equals, (, "NaN", ), ), ||, (, n, .]
[), ||, (, n, ., getType, (, ), ==, Token, ., DIV, &&, n, ., getFirstChild, (, ), ., isNumber]
[., equals, (, "NaN", ), ), ||, (, n, ., getType, (, ), ==, Token, ., DIV, &&, n, .]
[., getString, (, ), ., equals, (, "NaN", ), ), ||, (, n, ., getType, (, ), ==, Token, .]
[), ), ||, (, n, ., getType, (, ), ==, Token, ., DIV, &&, n, ., getFirstChild, (, ), .]
[), {, return, true, ;, }, return, false, ;, }, }]
[), ), {, return, true, ;, }, return, false, ;, }, }]
[&&, n, ., getLastChild, (, ), ., getDouble, (, ), ==, 0, ), ), {, return, true, ;, }, return]
[&&, n, ., getLastChild, (, ), ., isNumber, (, ), &&, n, ., getLastChild, (, ), ., getDouble, (, )]
[&&, n, ., getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&, n, ., getLastChild, (, ), ., isNumber]
[&&, n, ., getFirstChild, (, ), ., isNumber, (, ), &&, n, ., getFirstChild, (, ), ., getDouble, (, )]
[==, Token, ., DIV, &&, n, ., getFirstChild, (, ), ., isNumber, (, ), &&, n, ., getFirstChild, (, )]
[., getType, (, ), ==, Token, ., DIV, &&, n, ., getFirstChild, (, ), ., isNumber, (, ), &&, n]
[&&, n, ., getFirstChild, (, ), ., isNumber, (, ), &&, n, ., getFirstChild, (, ), ., getDouble, (, )]
[., DIV, &&, n, ., getFirstChild, (, ), ., isNumber, (, ), &&, n, ., getFirstChild, (, ), ., getDouble]
[&&, n, ., getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&, n, ., getLastChild, (, ), ., isNumber]
[., isNumber, (, ), &&, n, ., getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&, n, ., getLastChild]
[., getFirstChild, (, ), ., isNumber, (, ), &&, n, ., getFirstChild, (, ), ., getDouble, (, ), ==, 0]
[&&, n, ., getLastChild, (, ), ., isNumber, (, ), &&, n, ., getLastChild, (, ), ., getDouble, (, )]
[==, 0, &&, n, ., getLastChild, (, ), ., isNumber, (, ), &&, n, ., getLastChild, (, ), ., getDouble]
[., getDouble, (, ), ==, 0, &&, n, ., getLastChild, (, ), ., isNumber, (, ), &&, n, ., getLastChild]
[., getFirstChild, (, ), ., getDouble, (, ), ==, 0, &&, n, ., getLastChild, (, ), ., isNumber, (, )]
[&&, n, ., getLastChild, (, ), ., isNumber, (, ), &&, n, ., getLastChild, (, ), ., getDouble, (, )]
[&&, n, ., getLastChild, (, ), ., getDouble, (, ), ==, 0, ), ), {, return, true, ;, }, return]
[., isNumber, (, ), &&, n, ., getLastChild, (, ), ., getDouble, (, ), ==, 0, ), ), {, return]
[., getLastChild, (, ), ., isNumber, (, ), &&, n, ., getLastChild, (, ), ., getDouble, (, ), ==, 0]
[), ), {, return, true, ;, }, return, false, ;, }, }]
[==, 0, ), ), {, return, true, ;, }, return, false, ;, }, }]
[., getDouble, (, ), ==, 0, ), ), {, return, true, ;, }, return, false, ;, }, }]
[., getLastChild, (, ), ., getDouble, (, ), ==, 0, ), ), {, return, true, ;, }, return, false, ;]
[), ), {, return, true, ;, }, return, false, ;, }, }]
[;, }, return, false, ;, }, }]
[;, }, }]
