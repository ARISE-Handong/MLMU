[{, super, (, ), ;, }, public, IntervalsSet, (, final, double, lower, ,, final, double, upper, ), {, super, (]
[(, ), ;, }, public, IntervalsSet, (, final, double, lower, ,, final, double, upper, ), {, super, (, buildTree, (]
[;, }, public, IntervalsSet, (, final, double, lower, ,, final, double, upper, ), {, super, (, buildTree, (, lower, ,]
[lower, ,, upper, ), ), ;, }, public, IntervalsSet, (, final, BSPTree, <, Euclidean1D, >, tree, ), {, super, (]
[tree, ), ;, }, public, IntervalsSet, (, final, Collection, <, SubHyperplane, <, Euclidean1D, >, >, boundary, ), {, super, (]
[}, private, static, BSPTree, <, Euclidean1D, >, buildTree, (, final, double, lower, ,, final, double, upper, ), {, if, (]
[}, private, static, BSPTree, <, Euclidean1D, >, buildTree, (, final, double, lower, ,, final, double, upper, ), {, if, (]
[}, private, static, BSPTree, <, Euclidean1D, >, buildTree, (, final, double, lower, ,, final, double, upper, ), {, if, (]
[<, Euclidean1D, >, buildTree, (, final, double, lower, ,, final, double, upper, ), {, if, (, Double, ., isInfinite, (]
[buildTree, (, final, double, lower, ,, final, double, upper, ), {, if, (, Double, ., isInfinite, (, lower, ), &&]
[(, final, double, lower, ,, final, double, upper, ), {, if, (, Double, ., isInfinite, (, lower, ), &&, (]
[(, final, double, lower, ,, final, double, upper, ), {, if, (, Double, ., isInfinite, (, lower, ), &&, (]
[double, lower, ,, final, double, upper, ), {, if, (, Double, ., isInfinite, (, lower, ), &&, (, lower, <]
[), {, if, (, Double, ., isInfinite, (, lower, ), &&, (, lower, <, 0, ), ), {, if, (]
[), {, if, (, Double, ., isInfinite, (, lower, ), &&, (, lower, <, 0, ), ), {, if, (]
[), {, if, (, Double, ., isInfinite, (, lower, ), &&, (, lower, <, 0, ), ), {, if, (]
[Double, ., isInfinite, (, lower, ), &&, (, lower, <, 0, ), ), {, if, (, Double, ., isInfinite, (]
[(, lower, ), &&, (, lower, <, 0, ), ), {, if, (, Double, ., isInfinite, (, upper, ), &&]
[lower, ), &&, (, lower, <, 0, ), ), {, if, (, Double, ., isInfinite, (, upper, ), &&, (]
[lower, ), &&, (, lower, <, 0, ), ), {, if, (, Double, ., isInfinite, (, upper, ), &&, (]
[&&, (, lower, <, 0, ), ), {, if, (, Double, ., isInfinite, (, upper, ), &&, (, upper, >]
[), ), {, if, (, Double, ., isInfinite, (, upper, ), &&, (, upper, >, 0, ), ), {, return]
[., isInfinite, (, upper, ), &&, (, upper, >, 0, ), ), {, return, new, BSPTree, <, Euclidean1D, >, (]
[., isInfinite, (, upper, ), &&, (, upper, >, 0, ), ), {, return, new, BSPTree, <, Euclidean1D, >, (]
[return, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., TRUE, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =]
[return, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., TRUE, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =]
[<, Euclidean1D, >, (, Boolean, ., TRUE, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =, new, OrientedPoint, (]
[(, Boolean, ., TRUE, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =, new, OrientedPoint, (, new, Vector1D, (]
[TRUE, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =, new, OrientedPoint, (, new, Vector1D, (, upper, ), ,]
[>, upperCut, =, new, OrientedPoint, (, new, Vector1D, (, upper, ), ,, true, ), ., wholeHyperplane, (, ), ;, return]
[new, Vector1D, (, upper, ), ,, true, ), ., wholeHyperplane, (, ), ;, return, new, BSPTree, <, Euclidean1D, >, (]
[(, upper, ), ,, true, ), ., wholeHyperplane, (, ), ;, return, new, BSPTree, <, Euclidean1D, >, (, upperCut, ,]
[., wholeHyperplane, (, ), ;, return, new, BSPTree, <, Euclidean1D, >, (, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (]
[., wholeHyperplane, (, ), ;, return, new, BSPTree, <, Euclidean1D, >, (, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (]
[return, new, BSPTree, <, Euclidean1D, >, (, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,]
[(, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (]
[(, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (]
[<, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., TRUE, ), ,]
[<, Euclidean1D, >, (, Boolean, ., TRUE, ), ,, null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, lowerCut, =]
[<, Euclidean1D, >, (, Boolean, ., TRUE, ), ,, null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, lowerCut, =]
[(, Boolean, ., TRUE, ), ,, null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, lowerCut, =, new, OrientedPoint, (]
[TRUE, ), ,, null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, lowerCut, =, new, OrientedPoint, (, new, Vector1D, (]
[null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, lowerCut, =, new, OrientedPoint, (, new, Vector1D, (, lower, ), ,]
[lowerCut, =, new, OrientedPoint, (, new, Vector1D, (, lower, ), ,, false, ), ., wholeHyperplane, (, ), ;, if, (]
[lowerCut, =, new, OrientedPoint, (, new, Vector1D, (, lower, ), ,, false, ), ., wholeHyperplane, (, ), ;, if, (]
[lowerCut, =, new, OrientedPoint, (, new, Vector1D, (, lower, ), ,, false, ), ., wholeHyperplane, (, ), ;, if, (]
[(, new, Vector1D, (, lower, ), ,, false, ), ., wholeHyperplane, (, ), ;, if, (, Double, ., isInfinite, (]
[(, lower, ), ,, false, ), ., wholeHyperplane, (, ), ;, if, (, Double, ., isInfinite, (, upper, ), &&]
[lower, ), ,, false, ), ., wholeHyperplane, (, ), ;, if, (, Double, ., isInfinite, (, upper, ), &&, (]
[lower, ), ,, false, ), ., wholeHyperplane, (, ), ;, if, (, Double, ., isInfinite, (, upper, ), &&, (]
[,, false, ), ., wholeHyperplane, (, ), ;, if, (, Double, ., isInfinite, (, upper, ), &&, (, upper, >]
[(, ), ;, if, (, Double, ., isInfinite, (, upper, ), &&, (, upper, >, 0, ), ), {, return]
[., isInfinite, (, upper, ), &&, (, upper, >, 0, ), ), {, return, new, BSPTree, <, Euclidean1D, >, (]
[(, upper, ), &&, (, upper, >, 0, ), ), {, return, new, BSPTree, <, Euclidean1D, >, (, lowerCut, ,]
[>, 0, ), ), {, return, new, BSPTree, <, Euclidean1D, >, (, lowerCut, ,, new, BSPTree, <, Euclidean1D, >, (]
[>, 0, ), ), {, return, new, BSPTree, <, Euclidean1D, >, (, lowerCut, ,, new, BSPTree, <, Euclidean1D, >, (]
[return, new, BSPTree, <, Euclidean1D, >, (, lowerCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,]
[(, lowerCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (]
[(, lowerCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (]
[<, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., TRUE, ), ,]
[<, Euclidean1D, >, (, Boolean, ., TRUE, ), ,, null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =]
[<, Euclidean1D, >, (, Boolean, ., TRUE, ), ,, null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =]
[(, Boolean, ., TRUE, ), ,, null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =, new, OrientedPoint, (]
[TRUE, ), ,, null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =, new, OrientedPoint, (, new, Vector1D, (]
[null, ), ;, }, final, SubHyperplane, <, Euclidean1D, >, upperCut, =, new, OrientedPoint, (, new, Vector1D, (, upper, ), ,]
[>, upperCut, =, new, OrientedPoint, (, new, Vector1D, (, upper, ), ,, true, ), ., wholeHyperplane, (, ), ;, return]
[new, Vector1D, (, upper, ), ,, true, ), ., wholeHyperplane, (, ), ;, return, new, BSPTree, <, Euclidean1D, >, (]
[(, upper, ), ,, true, ), ., wholeHyperplane, (, ), ;, return, new, BSPTree, <, Euclidean1D, >, (, lowerCut, ,]
[., wholeHyperplane, (, ), ;, return, new, BSPTree, <, Euclidean1D, >, (, lowerCut, ,, new, BSPTree, <, Euclidean1D, >, (]
[., wholeHyperplane, (, ), ;, return, new, BSPTree, <, Euclidean1D, >, (, lowerCut, ,, new, BSPTree, <, Euclidean1D, >, (]
[return, new, BSPTree, <, Euclidean1D, >, (, lowerCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,]
[(, lowerCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (]
[,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (, upperCut, ,]
[(, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (]
[(, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (]
[,, new, BSPTree, <, Euclidean1D, >, (, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,]
[(, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (]
[(, upperCut, ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (]
[<, Euclidean1D, >, (, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., TRUE, ), ,]
[(, Boolean, ., FALSE, ), ,, new, BSPTree, <, Euclidean1D, >, (, Boolean, ., TRUE, ), ,, null, ), ,]
[,, null, ), ;, }, @, Override, public, IntervalsSet, buildNew, (, final, BSPTree, <, Euclidean1D, >, tree, ), {, return]
[;, }, @, Override, public, IntervalsSet, buildNew, (, final, BSPTree, <, Euclidean1D, >, tree, ), {, return, new, IntervalsSet, (]
[), {, return, new, IntervalsSet, (, tree, ), ;, }, @, Override, protected, void, computeGeometricalProperties, (, ), {, if, (]
[), {, return, new, IntervalsSet, (, tree, ), ;, }, @, Override, protected, void, computeGeometricalProperties, (, ), {, if, (]
[), {, return, new, IntervalsSet, (, tree, ), ;, }, @, Override, protected, void, computeGeometricalProperties, (, ), {, if, (]
[return, new, IntervalsSet, (, tree, ), ;, }, @, Override, protected, void, computeGeometricalProperties, (, ), {, if, (, getTree, (]
[}, @, Override, protected, void, computeGeometricalProperties, (, ), {, if, (, getTree, (, false, ), ., getCut, (, ), ==]
[protected, void, computeGeometricalProperties, (, ), {, if, (, getTree, (, false, ), ., getCut, (, ), ==, null, ), {]
[computeGeometricalProperties, (, ), {, if, (, getTree, (, false, ), ., getCut, (, ), ==, null, ), {, setBarycenter, (]
[computeGeometricalProperties, (, ), {, if, (, getTree, (, false, ), ., getCut, (, ), ==, null, ), {, setBarycenter, (]
[(, getTree, (, false, ), ., getCut, (, ), ==, null, ), {, setBarycenter, (, Vector1D, ., NaN, ), ;]
[(, false, ), ., getCut, (, ), ==, null, ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, setSize, (]
[(, false, ), ., getCut, (, ), ==, null, ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, setSize, (]
[false, ), ., getCut, (, ), ==, null, ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, setSize, (, (]
[getCut, (, ), ==, null, ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, setSize, (, (, (, Boolean, )]
[getCut, (, ), ==, null, ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, setSize, (, (, (, Boolean, )]
[), ==, null, ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, setSize, (, (, (, Boolean, ), getTree, (]
[., NaN, ), ;, setSize, (, (, (, Boolean, ), getTree, (, false, ), ., getAttribute, (, ), ), ?]
[., NaN, ), ;, setSize, (, (, (, Boolean, ), getTree, (, false, ), ., getAttribute, (, ), ), ?]
[setSize, (, (, (, Boolean, ), getTree, (, false, ), ., getAttribute, (, ), ), ?, Double, ., POSITIVE_INFINITY, :]
[), ., getAttribute, (, ), ), ?, Double, ., POSITIVE_INFINITY, :, 0, ), ;, }, else, {, double, size, =]
[), ?, Double, ., POSITIVE_INFINITY, :, 0, ), ;, }, else, {, double, size, =, 0.0, ;, double, sum, =]
[;, }, else, {, double, size, =, 0.0, ;, double, sum, =, 0.0, ;, for, (, final, Interval, interval, :]
[size, =, 0.0, ;, double, sum, =, 0.0, ;, for, (, final, Interval, interval, :, asList, (, ), ), {]
[0.0, ;, double, sum, =, 0.0, ;, for, (, final, Interval, interval, :, asList, (, ), ), {, size, +=]
[0.0, ;, double, sum, =, 0.0, ;, for, (, final, Interval, interval, :, asList, (, ), ), {, size, +=]
[;, for, (, final, Interval, interval, :, asList, (, ), ), {, size, +=, interval, ., getSize, (, ), ;]
[(, final, Interval, interval, :, asList, (, ), ), {, size, +=, interval, ., getSize, (, ), ;, sum, +=]
[(, final, Interval, interval, :, asList, (, ), ), {, size, +=, interval, ., getSize, (, ), ;, sum, +=]
[(, final, Interval, interval, :, asList, (, ), ), {, size, +=, interval, ., getSize, (, ), ;, sum, +=]
[(, ), ), {, size, +=, interval, ., getSize, (, ), ;, sum, +=, interval, ., getSize, (, ), *]
[(, ), ), {, size, +=, interval, ., getSize, (, ), ;, sum, +=, interval, ., getSize, (, ), *]
[., getSize, (, ), ;, sum, +=, interval, ., getSize, (, ), *, interval, ., getBarycenter, (, ), ;, }]
[(, ), ;, sum, +=, interval, ., getSize, (, ), *, interval, ., getBarycenter, (, ), ;, }, setSize, (]
[interval, ., getSize, (, ), *, interval, ., getBarycenter, (, ), ;, }, setSize, (, size, ), ;, if, (]
[interval, ., getSize, (, ), *, interval, ., getBarycenter, (, ), ;, }, setSize, (, size, ), ;, if, (]
[), *, interval, ., getBarycenter, (, ), ;, }, setSize, (, size, ), ;, if, (, Double, ., isInfinite, (]
[getBarycenter, (, ), ;, }, setSize, (, size, ), ;, if, (, Double, ., isInfinite, (, size, ), ), {]
[), ;, }, setSize, (, size, ), ;, if, (, Double, ., isInfinite, (, size, ), ), {, setBarycenter, (]
[), ;, }, setSize, (, size, ), ;, if, (, Double, ., isInfinite, (, size, ), ), {, setBarycenter, (]
[(, Double, ., isInfinite, (, size, ), ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, }, else, if, (]
[(, Double, ., isInfinite, (, size, ), ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, }, else, if, (]
[., isInfinite, (, size, ), ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, }, else, if, (, size, >=]
[., isInfinite, (, size, ), ), {, setBarycenter, (, Vector1D, ., NaN, ), ;, }, else, if, (, size, >=]
[), {, setBarycenter, (, Vector1D, ., NaN, ), ;, }, else, if, (, size, >=, Precision, ., SAFE_MIN, ), {]
[setBarycenter, (, Vector1D, ., NaN, ), ;, }, else, if, (, size, >=, Precision, ., SAFE_MIN, ), {, setBarycenter, (]
[., NaN, ), ;, }, else, if, (, size, >=, Precision, ., SAFE_MIN, ), {, setBarycenter, (, new, Vector1D, (]
[., NaN, ), ;, }, else, if, (, size, >=, Precision, ., SAFE_MIN, ), {, setBarycenter, (, new, Vector1D, (]
[), ;, }, else, if, (, size, >=, Precision, ., SAFE_MIN, ), {, setBarycenter, (, new, Vector1D, (, sum, /]
[>=, Precision, ., SAFE_MIN, ), {, setBarycenter, (, new, Vector1D, (, sum, /, size, ), ), ;, }, else, {]
[., SAFE_MIN, ), {, setBarycenter, (, new, Vector1D, (, sum, /, size, ), ), ;, }, else, {, setBarycenter, (]
[., SAFE_MIN, ), {, setBarycenter, (, new, Vector1D, (, sum, /, size, ), ), ;, }, else, {, setBarycenter, (]
[SAFE_MIN, ), {, setBarycenter, (, new, Vector1D, (, sum, /, size, ), ), ;, }, else, {, setBarycenter, (, (]
[setBarycenter, (, new, Vector1D, (, sum, /, size, ), ), ;, }, else, {, setBarycenter, (, (, (, OrientedPoint, )]
[setBarycenter, (, new, Vector1D, (, sum, /, size, ), ), ;, }, else, {, setBarycenter, (, (, (, OrientedPoint, )]
[setBarycenter, (, new, Vector1D, (, sum, /, size, ), ), ;, }, else, {, setBarycenter, (, (, (, OrientedPoint, )]
[new, Vector1D, (, sum, /, size, ), ), ;, }, else, {, setBarycenter, (, (, (, OrientedPoint, ), getTree, (]
[getLocation, (, ), ), ;, }, }, }, public, double, getInf, (, ), {, BSPTree, <, Euclidean1D, >, node, =]
[), ), ;, }, }, }, public, double, getInf, (, ), {, BSPTree, <, Euclidean1D, >, node, =, getTree, (]
[public, double, getInf, (, ), {, BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, inf, =]
[public, double, getInf, (, ), {, BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, inf, =]
[BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, inf, =, Double, ., POSITIVE_INFINITY, ;, while, (]
[BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, inf, =, Double, ., POSITIVE_INFINITY, ;, while, (]
[BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, inf, =, Double, ., POSITIVE_INFINITY, ;, while, (]
[getTree, (, false, ), ;, double, inf, =, Double, ., POSITIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=]
[=, Double, ., POSITIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=, null, ), {, final, OrientedPoint, op, =]
[POSITIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=, null, ), {, final, OrientedPoint, op, =, (, OrientedPoint, )]
[POSITIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=, null, ), {, final, OrientedPoint, op, =, (, OrientedPoint, )]
[POSITIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=, null, ), {, final, OrientedPoint, op, =, (, OrientedPoint, )]
[null, ), {, final, OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;]
[{, final, OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;, inf, =]
[{, final, OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;, inf, =]
[{, final, OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;, inf, =]
[getCut, (, ), ., getHyperplane, (, ), ;, inf, =, op, ., getLocation, (, ), ., getX, (, ), ;]
[), ., getHyperplane, (, ), ;, inf, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =]
[), ., getHyperplane, (, ), ;, inf, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =]
[), ., getHyperplane, (, ), ;, inf, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =]
[inf, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =, op, ., isDirect, (, ), ?]
[inf, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =, op, ., isDirect, (, ), ?]
[), ., getX, (, ), ;, node, =, op, ., isDirect, (, ), ?, node, ., getMinus, (, ), :]
[), ., getX, (, ), ;, node, =, op, ., isDirect, (, ), ?, node, ., getMinus, (, ), :]
[op, ., isDirect, (, ), ?, node, ., getMinus, (, ), :, node, ., getPlus, (, ), ;, }, return]
[op, ., isDirect, (, ), ?, node, ., getMinus, (, ), :, node, ., getPlus, (, ), ;, }, return]
[., isDirect, (, ), ?, node, ., getMinus, (, ), :, node, ., getPlus, (, ), ;, }, return, (]
[), ?, node, ., getMinus, (, ), :, node, ., getPlus, (, ), ;, }, return, (, (, Boolean, )]
[), ?, node, ., getMinus, (, ), :, node, ., getPlus, (, ), ;, }, return, (, (, Boolean, )]
[:, node, ., getPlus, (, ), ;, }, return, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?]
[:, node, ., getPlus, (, ), ;, }, return, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?]
[(, ), ;, }, return, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?, Double, ., NEGATIVE_INFINITY, :]
[?, Double, ., NEGATIVE_INFINITY, :, inf, ;, }, public, double, getSup, (, ), {, BSPTree, <, Euclidean1D, >, node, =]
[., NEGATIVE_INFINITY, :, inf, ;, }, public, double, getSup, (, ), {, BSPTree, <, Euclidean1D, >, node, =, getTree, (]
[public, double, getSup, (, ), {, BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, sup, =]
[public, double, getSup, (, ), {, BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, sup, =]
[BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, sup, =, Double, ., NEGATIVE_INFINITY, ;, while, (]
[BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, sup, =, Double, ., NEGATIVE_INFINITY, ;, while, (]
[BSPTree, <, Euclidean1D, >, node, =, getTree, (, false, ), ;, double, sup, =, Double, ., NEGATIVE_INFINITY, ;, while, (]
[getTree, (, false, ), ;, double, sup, =, Double, ., NEGATIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=]
[=, Double, ., NEGATIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=, null, ), {, final, OrientedPoint, op, =]
[NEGATIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=, null, ), {, final, OrientedPoint, op, =, (, OrientedPoint, )]
[NEGATIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=, null, ), {, final, OrientedPoint, op, =, (, OrientedPoint, )]
[NEGATIVE_INFINITY, ;, while, (, node, ., getCut, (, ), !=, null, ), {, final, OrientedPoint, op, =, (, OrientedPoint, )]
[null, ), {, final, OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;]
[{, final, OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;, sup, =]
[{, final, OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;, sup, =]
[{, final, OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;, sup, =]
[getCut, (, ), ., getHyperplane, (, ), ;, sup, =, op, ., getLocation, (, ), ., getX, (, ), ;]
[), ., getHyperplane, (, ), ;, sup, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =]
[), ., getHyperplane, (, ), ;, sup, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =]
[), ., getHyperplane, (, ), ;, sup, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =]
[sup, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =, op, ., isDirect, (, ), ?]
[sup, =, op, ., getLocation, (, ), ., getX, (, ), ;, node, =, op, ., isDirect, (, ), ?]
[), ., getX, (, ), ;, node, =, op, ., isDirect, (, ), ?, node, ., getPlus, (, ), :]
[), ., getX, (, ), ;, node, =, op, ., isDirect, (, ), ?, node, ., getPlus, (, ), :]
[op, ., isDirect, (, ), ?, node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;, }, return]
[op, ., isDirect, (, ), ?, node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;, }, return]
[., isDirect, (, ), ?, node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;, }, return, (]
[), ?, node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;, }, return, (, (, Boolean, )]
[), ?, node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;, }, return, (, (, Boolean, )]
[:, node, ., getMinus, (, ), ;, }, return, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?]
[:, node, ., getMinus, (, ), ;, }, return, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?]
[(, ), ;, }, return, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?, Double, ., POSITIVE_INFINITY, :]
[:, sup, ;, }, public, List, <, Interval, >, asList, (, ), {, final, List, <, Interval, >, list, =]
[>, asList, (, ), {, final, List, <, Interval, >, list, =, new, ArrayList, <, Interval, >, (, ), ;]
[(, ), {, final, List, <, Interval, >, list, =, new, ArrayList, <, Interval, >, (, ), ;, recurseList, (]
[{, final, List, <, Interval, >, list, =, new, ArrayList, <, Interval, >, (, ), ;, recurseList, (, getTree, (]
[<, Interval, >, list, =, new, ArrayList, <, Interval, >, (, ), ;, recurseList, (, getTree, (, false, ), ,]
[>, list, =, new, ArrayList, <, Interval, >, (, ), ;, recurseList, (, getTree, (, false, ), ,, list, ,]
[>, list, =, new, ArrayList, <, Interval, >, (, ), ;, recurseList, (, getTree, (, false, ), ,, list, ,]
[ArrayList, <, Interval, >, (, ), ;, recurseList, (, getTree, (, false, ), ,, list, ,, Double, ., NEGATIVE_INFINITY, ,]
[ArrayList, <, Interval, >, (, ), ;, recurseList, (, getTree, (, false, ), ,, list, ,, Double, ., NEGATIVE_INFINITY, ,]
[;, recurseList, (, getTree, (, false, ), ,, list, ,, Double, ., NEGATIVE_INFINITY, ,, Double, ., POSITIVE_INFINITY, ), ;, return]
[node, ,, final, List, <, Interval, >, list, ,, final, double, lower, ,, final, double, upper, ), {, if, (]
[node, ,, final, List, <, Interval, >, list, ,, final, double, lower, ,, final, double, upper, ), {, if, (]
[node, ,, final, List, <, Interval, >, list, ,, final, double, lower, ,, final, double, upper, ), {, if, (]
[>, list, ,, final, double, lower, ,, final, double, upper, ), {, if, (, node, ., getCut, (, ), ==]
[lower, ,, final, double, upper, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, if, (]
[double, upper, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, if, (, (, Boolean, )]
[double, upper, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, if, (, (, Boolean, )]
[., getCut, (, ), ==, null, ), {, if, (, (, Boolean, ), node, ., getAttribute, (, ), ), {]
[., getCut, (, ), ==, null, ), {, if, (, (, Boolean, ), node, ., getAttribute, (, ), ), {]
[==, null, ), {, if, (, (, Boolean, ), node, ., getAttribute, (, ), ), {, list, ., add, (]
[{, if, (, (, Boolean, ), node, ., getAttribute, (, ), ), {, list, ., add, (, new, Interval, (]
[(, (, Boolean, ), node, ., getAttribute, (, ), ), {, list, ., add, (, new, Interval, (, lower, ,]
[., add, (, new, Interval, (, lower, ,, upper, ), ), ;, }, }, else, {, final, OrientedPoint, op, =]
[new, Interval, (, lower, ,, upper, ), ), ;, }, }, else, {, final, OrientedPoint, op, =, (, OrientedPoint, )]
[new, Interval, (, lower, ,, upper, ), ), ;, }, }, else, {, final, OrientedPoint, op, =, (, OrientedPoint, )]
[new, Interval, (, lower, ,, upper, ), ), ;, }, }, else, {, final, OrientedPoint, op, =, (, OrientedPoint, )]
[OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;, final, Vector1D, loc, =]
[OrientedPoint, op, =, (, OrientedPoint, ), node, ., getCut, (, ), ., getHyperplane, (, ), ;, final, Vector1D, loc, =]
[(, ), ., getHyperplane, (, ), ;, final, Vector1D, loc, =, op, ., getLocation, (, ), ;, double, x, =]
[(, ), ., getHyperplane, (, ), ;, final, Vector1D, loc, =, op, ., getLocation, (, ), ;, double, x, =]
[getLocation, (, ), ;, double, x, =, loc, ., getX, (, ), ;, final, BSPTree, <, Euclidean1D, >, low, =]
[getLocation, (, ), ;, double, x, =, loc, ., getX, (, ), ;, final, BSPTree, <, Euclidean1D, >, low, =]
[getLocation, (, ), ;, double, x, =, loc, ., getX, (, ), ;, final, BSPTree, <, Euclidean1D, >, low, =]
[=, loc, ., getX, (, ), ;, final, BSPTree, <, Euclidean1D, >, low, =, op, ., isDirect, (, ), ?]
[=, loc, ., getX, (, ), ;, final, BSPTree, <, Euclidean1D, >, low, =, op, ., isDirect, (, ), ?]
[;, final, BSPTree, <, Euclidean1D, >, low, =, op, ., isDirect, (, ), ?, node, ., getMinus, (, ), :]
[;, final, BSPTree, <, Euclidean1D, >, low, =, op, ., isDirect, (, ), ?, node, ., getMinus, (, ), :]
[?, node, ., getMinus, (, ), :, node, ., getPlus, (, ), ;, final, BSPTree, <, Euclidean1D, >, high, =]
[?, node, ., getMinus, (, ), :, node, ., getPlus, (, ), ;, final, BSPTree, <, Euclidean1D, >, high, =]
[?, node, ., getMinus, (, ), :, node, ., getPlus, (, ), ;, final, BSPTree, <, Euclidean1D, >, high, =]
[:, node, ., getPlus, (, ), ;, final, BSPTree, <, Euclidean1D, >, high, =, op, ., isDirect, (, ), ?]
[:, node, ., getPlus, (, ), ;, final, BSPTree, <, Euclidean1D, >, high, =, op, ., isDirect, (, ), ?]
[;, final, BSPTree, <, Euclidean1D, >, high, =, op, ., isDirect, (, ), ?, node, ., getPlus, (, ), :]
[;, final, BSPTree, <, Euclidean1D, >, high, =, op, ., isDirect, (, ), ?, node, ., getPlus, (, ), :]
[high, =, op, ., isDirect, (, ), ?, node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;]
[op, ., isDirect, (, ), ?, node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;, recurseList, (]
[isDirect, (, ), ?, node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;, recurseList, (, low, ,]
[), ?, node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;, recurseList, (, low, ,, list, ,]
[node, ., getPlus, (, ), :, node, ., getMinus, (, ), ;, recurseList, (, low, ,, list, ,, lower, ,]
[:, node, ., getMinus, (, ), ;, recurseList, (, low, ,, list, ,, lower, ,, x, ), ;, if, (]
[:, node, ., getMinus, (, ), ;, recurseList, (, low, ,, list, ,, lower, ,, x, ), ;, if, (]
[node, ., getMinus, (, ), ;, recurseList, (, low, ,, list, ,, lower, ,, x, ), ;, if, (, (]
[node, ., getMinus, (, ), ;, recurseList, (, low, ,, list, ,, lower, ,, x, ), ;, if, (, (]
[getMinus, (, ), ;, recurseList, (, low, ,, list, ,, lower, ,, x, ), ;, if, (, (, checkPoint, (]
[), ;, recurseList, (, low, ,, list, ,, lower, ,, x, ), ;, if, (, (, checkPoint, (, low, ,]
[(, low, ,, list, ,, lower, ,, x, ), ;, if, (, (, checkPoint, (, low, ,, loc, ), ==]
[(, low, ,, list, ,, lower, ,, x, ), ;, if, (, (, checkPoint, (, low, ,, loc, ), ==]
[lower, ,, x, ), ;, if, (, (, checkPoint, (, low, ,, loc, ), ==, Location, ., INSIDE, ), &&]
[,, x, ), ;, if, (, (, checkPoint, (, low, ,, loc, ), ==, Location, ., INSIDE, ), &&, (]
[,, x, ), ;, if, (, (, checkPoint, (, low, ,, loc, ), ==, Location, ., INSIDE, ), &&, (]
[), ;, if, (, (, checkPoint, (, low, ,, loc, ), ==, Location, ., INSIDE, ), &&, (, checkPoint, (]
[if, (, (, checkPoint, (, low, ,, loc, ), ==, Location, ., INSIDE, ), &&, (, checkPoint, (, high, ,]
[checkPoint, (, low, ,, loc, ), ==, Location, ., INSIDE, ), &&, (, checkPoint, (, high, ,, loc, ), ==]
[checkPoint, (, low, ,, loc, ), ==, Location, ., INSIDE, ), &&, (, checkPoint, (, high, ,, loc, ), ==]
[==, Location, ., INSIDE, ), &&, (, checkPoint, (, high, ,, loc, ), ==, Location, ., INSIDE, ), ), {]
[., INSIDE, ), &&, (, checkPoint, (, high, ,, loc, ), ==, Location, ., INSIDE, ), ), {, x, =]
[., INSIDE, ), &&, (, checkPoint, (, high, ,, loc, ), ==, Location, ., INSIDE, ), ), {, x, =]
[., INSIDE, ), &&, (, checkPoint, (, high, ,, loc, ), ==, Location, ., INSIDE, ), ), {, x, =]
[(, checkPoint, (, high, ,, loc, ), ==, Location, ., INSIDE, ), ), {, x, =, list, ., remove, (]
[(, checkPoint, (, high, ,, loc, ), ==, Location, ., INSIDE, ), ), {, x, =, list, ., remove, (]
[(, checkPoint, (, high, ,, loc, ), ==, Location, ., INSIDE, ), ), {, x, =, list, ., remove, (]
[), ==, Location, ., INSIDE, ), ), {, x, =, list, ., remove, (, list, ., size, (, ), -]
[x, =, list, ., remove, (, list, ., size, (, ), -, 1, ), ., getInf, (, ), ;, }]
[list, ., remove, (, list, ., size, (, ), -, 1, ), ., getInf, (, ), ;, }, recurseList, (]
[remove, (, list, ., size, (, ), -, 1, ), ., getInf, (, ), ;, }, recurseList, (, high, ,]
[list, ., size, (, ), -, 1, ), ., getInf, (, ), ;, }, recurseList, (, high, ,, list, ,]
[size, (, ), -, 1, ), ., getInf, (, ), ;, }, recurseList, (, high, ,, list, ,, x, ,]
