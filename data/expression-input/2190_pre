[annotation, ., Nullable, ;, class, PeepholeRemoveDeadCode, extends, AbstractPeepholeOptimization, {, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (]
[annotation, ., Nullable, ;, class, PeepholeRemoveDeadCode, extends, AbstractPeepholeOptimization, {, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (]
[{, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (, subtree, ., getType, (, ), ), {, case]
[{, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (, subtree, ., getType, (, ), ), {, case]
[(, Node, subtree, ), {, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return]
[subtree, ), {, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return, tryFoldAssignment, (]
[(, subtree, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return, tryFoldAssignment, (, subtree, ), ;, case]
[(, subtree, ., getType, (, ), ), {, case, Token, ., ASSIGN, :, return, tryFoldAssignment, (, subtree, ), ;, case]
[), ), {, case, Token, ., ASSIGN, :, return, tryFoldAssignment, (, subtree, ), ;, case, Token, ., COMMA, :, return]
[{, case, Token, ., ASSIGN, :, return, tryFoldAssignment, (, subtree, ), ;, case, Token, ., COMMA, :, return, tryFoldComma, (]
[ASSIGN, :, return, tryFoldAssignment, (, subtree, ), ;, case, Token, ., COMMA, :, return, tryFoldComma, (, subtree, ), ;, case]
[ASSIGN, :, return, tryFoldAssignment, (, subtree, ), ;, case, Token, ., COMMA, :, return, tryFoldComma, (, subtree, ), ;, case]
[subtree, ), ;, case, Token, ., COMMA, :, return, tryFoldComma, (, subtree, ), ;, case, Token, ., SCRIPT, :, case]
[subtree, ), ;, case, Token, ., COMMA, :, return, tryFoldComma, (, subtree, ), ;, case, Token, ., SCRIPT, :, case]
[., COMMA, :, return, tryFoldComma, (, subtree, ), ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, return]
[:, return, tryFoldComma, (, subtree, ), ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, return, tryOptimizeBlock, (]
[subtree, ), ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, return, tryOptimizeBlock, (, subtree, ), ;, case]
[subtree, ), ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, return, tryOptimizeBlock, (, subtree, ), ;, case]
[Token, ., SCRIPT, :, case, Token, ., BLOCK, :, return, tryOptimizeBlock, (, subtree, ), ;, case, Token, ., EXPR_RESULT, :]
[SCRIPT, :, case, Token, ., BLOCK, :, return, tryOptimizeBlock, (, subtree, ), ;, case, Token, ., EXPR_RESULT, :, subtree, =]
[case, Token, ., BLOCK, :, return, tryOptimizeBlock, (, subtree, ), ;, case, Token, ., EXPR_RESULT, :, subtree, =, tryFoldExpr, (]
[:, return, tryOptimizeBlock, (, subtree, ), ;, case, Token, ., EXPR_RESULT, :, subtree, =, tryFoldExpr, (, subtree, ), ;, return]
[(, subtree, ), ;, case, Token, ., EXPR_RESULT, :, subtree, =, tryFoldExpr, (, subtree, ), ;, return, subtree, ;, case]
[(, subtree, ), ;, case, Token, ., EXPR_RESULT, :, subtree, =, tryFoldExpr, (, subtree, ), ;, return, subtree, ;, case]
[Token, ., EXPR_RESULT, :, subtree, =, tryFoldExpr, (, subtree, ), ;, return, subtree, ;, case, Token, ., HOOK, :, return]
[EXPR_RESULT, :, subtree, =, tryFoldExpr, (, subtree, ), ;, return, subtree, ;, case, Token, ., HOOK, :, return, tryFoldHook, (]
[tryFoldExpr, (, subtree, ), ;, return, subtree, ;, case, Token, ., HOOK, :, return, tryFoldHook, (, subtree, ), ;, case]
[tryFoldExpr, (, subtree, ), ;, return, subtree, ;, case, Token, ., HOOK, :, return, tryFoldHook, (, subtree, ), ;, case]
[return, subtree, ;, case, Token, ., HOOK, :, return, tryFoldHook, (, subtree, ), ;, case, Token, ., SWITCH, :, return]
[;, case, Token, ., HOOK, :, return, tryFoldHook, (, subtree, ), ;, case, Token, ., SWITCH, :, return, tryOptimizeSwitch, (]
[HOOK, :, return, tryFoldHook, (, subtree, ), ;, case, Token, ., SWITCH, :, return, tryOptimizeSwitch, (, subtree, ), ;, case]
[HOOK, :, return, tryFoldHook, (, subtree, ), ;, case, Token, ., SWITCH, :, return, tryOptimizeSwitch, (, subtree, ), ;, case]
[subtree, ), ;, case, Token, ., SWITCH, :, return, tryOptimizeSwitch, (, subtree, ), ;, case, Token, ., IF, :, return]
[;, case, Token, ., SWITCH, :, return, tryOptimizeSwitch, (, subtree, ), ;, case, Token, ., IF, :, return, tryFoldIf, (]
[SWITCH, :, return, tryOptimizeSwitch, (, subtree, ), ;, case, Token, ., IF, :, return, tryFoldIf, (, subtree, ), ;, case]
[SWITCH, :, return, tryOptimizeSwitch, (, subtree, ), ;, case, Token, ., IF, :, return, tryFoldIf, (, subtree, ), ;, case]
[subtree, ), ;, case, Token, ., IF, :, return, tryFoldIf, (, subtree, ), ;, case, Token, ., WHILE, :, return]
[;, case, Token, ., IF, :, return, tryFoldIf, (, subtree, ), ;, case, Token, ., WHILE, :, return, tryFoldWhile, (]
[IF, :, return, tryFoldIf, (, subtree, ), ;, case, Token, ., WHILE, :, return, tryFoldWhile, (, subtree, ), ;, case]
[IF, :, return, tryFoldIf, (, subtree, ), ;, case, Token, ., WHILE, :, return, tryFoldWhile, (, subtree, ), ;, case]
[case, Token, ., WHILE, :, return, tryFoldWhile, (, subtree, ), ;, case, Token, ., FOR, :, {, Node, condition, =]
[case, Token, ., WHILE, :, return, tryFoldWhile, (, subtree, ), ;, case, Token, ., FOR, :, {, Node, condition, =]
[:, return, tryFoldWhile, (, subtree, ), ;, case, Token, ., FOR, :, {, Node, condition, =, NodeUtil, ., getConditionExpression, (]
[), ;, case, Token, ., FOR, :, {, Node, condition, =, NodeUtil, ., getConditionExpression, (, subtree, ), ;, if, (]
[), ;, case, Token, ., FOR, :, {, Node, condition, =, NodeUtil, ., getConditionExpression, (, subtree, ), ;, if, (]
[case, Token, ., FOR, :, {, Node, condition, =, NodeUtil, ., getConditionExpression, (, subtree, ), ;, if, (, condition, !=]
[FOR, :, {, Node, condition, =, NodeUtil, ., getConditionExpression, (, subtree, ), ;, if, (, condition, !=, null, ), {]
[{, Node, condition, =, NodeUtil, ., getConditionExpression, (, subtree, ), ;, if, (, condition, !=, null, ), {, tryFoldForCondition, (]
[getConditionExpression, (, subtree, ), ;, if, (, condition, !=, null, ), {, tryFoldForCondition, (, condition, ), ;, }, }, return]
[subtree, ), ;, if, (, condition, !=, null, ), {, tryFoldForCondition, (, condition, ), ;, }, }, return, tryFoldFor, (]
[(, condition, !=, null, ), {, tryFoldForCondition, (, condition, ), ;, }, }, return, tryFoldFor, (, subtree, ), ;, case]
[(, condition, !=, null, ), {, tryFoldForCondition, (, condition, ), ;, }, }, return, tryFoldFor, (, subtree, ), ;, case]
[{, tryFoldForCondition, (, condition, ), ;, }, }, return, tryFoldFor, (, subtree, ), ;, case, Token, ., DO, :, return]
[(, condition, ), ;, }, }, return, tryFoldFor, (, subtree, ), ;, case, Token, ., DO, :, return, tryFoldDo, (]
[}, }, return, tryFoldFor, (, subtree, ), ;, case, Token, ., DO, :, return, tryFoldDo, (, subtree, ), ;, case]
[}, }, return, tryFoldFor, (, subtree, ), ;, case, Token, ., DO, :, return, tryFoldDo, (, subtree, ), ;, case]
[subtree, ), ;, case, Token, ., DO, :, return, tryFoldDo, (, subtree, ), ;, case, Token, ., TRY, :, return]
[;, case, Token, ., DO, :, return, tryFoldDo, (, subtree, ), ;, case, Token, ., TRY, :, return, tryFoldTry, (]
[return, tryFoldDo, (, subtree, ), ;, case, Token, ., TRY, :, return, tryFoldTry, (, subtree, ), ;, default, :, return]
[tryFoldTry, (, subtree, ), ;, default, :, return, subtree, ;, }, }, private, Node, tryFoldTry, (, Node, n, ), {]
[tryFoldTry, (, subtree, ), ;, default, :, return, subtree, ;, }, }, private, Node, tryFoldTry, (, Node, n, ), {]
[;, default, :, return, subtree, ;, }, }, private, Node, tryFoldTry, (, Node, n, ), {, Preconditions, ., checkState, (]
[;, default, :, return, subtree, ;, }, }, private, Node, tryFoldTry, (, Node, n, ), {, Preconditions, ., checkState, (]
[tryFoldTry, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isTry, (, ), ), ;, Node, body, =]
[tryFoldTry, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isTry, (, ), ), ;, Node, body, =]
[(, n, ., isTry, (, ), ), ;, Node, body, =, n, ., getFirstChild, (, ), ;, Node, catchBlock, =]
[(, n, ., isTry, (, ), ), ;, Node, body, =, n, ., getFirstChild, (, ), ;, Node, catchBlock, =]
[body, =, n, ., getFirstChild, (, ), ;, Node, catchBlock, =, body, ., getNext, (, ), ;, Node, finallyBlock, =]
[body, =, n, ., getFirstChild, (, ), ;, Node, catchBlock, =, body, ., getNext, (, ), ;, Node, finallyBlock, =]
[Node, catchBlock, =, body, ., getNext, (, ), ;, Node, finallyBlock, =, catchBlock, ., getNext, (, ), ;, if, (]
[Node, catchBlock, =, body, ., getNext, (, ), ;, Node, finallyBlock, =, catchBlock, ., getNext, (, ), ;, if, (]
[catchBlock, =, body, ., getNext, (, ), ;, Node, finallyBlock, =, catchBlock, ., getNext, (, ), ;, if, (, !]
[catchBlock, =, body, ., getNext, (, ), ;, Node, finallyBlock, =, catchBlock, ., getNext, (, ), ;, if, (, !]
[), ;, Node, finallyBlock, =, catchBlock, ., getNext, (, ), ;, if, (, !, catchBlock, ., hasChildren, (, ), &&]
[;, Node, finallyBlock, =, catchBlock, ., getNext, (, ), ;, if, (, !, catchBlock, ., hasChildren, (, ), &&, (]
[;, Node, finallyBlock, =, catchBlock, ., getNext, (, ), ;, if, (, !, catchBlock, ., hasChildren, (, ), &&, (]
[;, Node, finallyBlock, =, catchBlock, ., getNext, (, ), ;, if, (, !, catchBlock, ., hasChildren, (, ), &&, (]
[finallyBlock, =, catchBlock, ., getNext, (, ), ;, if, (, !, catchBlock, ., hasChildren, (, ), &&, (, finallyBlock, ==]
[catchBlock, ., getNext, (, ), ;, if, (, !, catchBlock, ., hasChildren, (, ), &&, (, finallyBlock, ==, null, ||]
[., getNext, (, ), ;, if, (, !, catchBlock, ., hasChildren, (, ), &&, (, finallyBlock, ==, null, ||, !]
[., getNext, (, ), ;, if, (, !, catchBlock, ., hasChildren, (, ), &&, (, finallyBlock, ==, null, ||, !]
[catchBlock, ., hasChildren, (, ), &&, (, finallyBlock, ==, null, ||, !, finallyBlock, ., hasChildren, (, ), ), ), {]
[catchBlock, ., hasChildren, (, ), &&, (, finallyBlock, ==, null, ||, !, finallyBlock, ., hasChildren, (, ), ), ), {]
[), &&, (, finallyBlock, ==, null, ||, !, finallyBlock, ., hasChildren, (, ), ), ), {, n, ., removeChild, (]
[finallyBlock, ==, null, ||, !, finallyBlock, ., hasChildren, (, ), ), ), {, n, ., removeChild, (, body, ), ;]
[finallyBlock, ==, null, ||, !, finallyBlock, ., hasChildren, (, ), ), ), {, n, ., removeChild, (, body, ), ;]
[finallyBlock, ==, null, ||, !, finallyBlock, ., hasChildren, (, ), ), ), {, n, ., removeChild, (, body, ), ;]
[(, ), ), ), {, n, ., removeChild, (, body, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ), {, n, ., removeChild, (, body, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[n, ., removeChild, (, body, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, body, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, body, ), ;, reportCodeChange, (, ), ;, return]
[(, ), ., replaceChild, (, n, ,, body, ), ;, reportCodeChange, (, ), ;, return, body, ;, }, if, (]
[), ., replaceChild, (, n, ,, body, ), ;, reportCodeChange, (, ), ;, return, body, ;, }, if, (, !]
[), ., replaceChild, (, n, ,, body, ), ;, reportCodeChange, (, ), ;, return, body, ;, }, if, (, !]
[), ;, reportCodeChange, (, ), ;, return, body, ;, }, if, (, !, body, ., hasChildren, (, ), ), {]
[), ;, reportCodeChange, (, ), ;, return, body, ;, }, if, (, !, body, ., hasChildren, (, ), ), {]
[), ;, return, body, ;, }, if, (, !, body, ., hasChildren, (, ), ), {, NodeUtil, ., redeclareVarsInsideBranch, (]
[}, if, (, !, body, ., hasChildren, (, ), ), {, NodeUtil, ., redeclareVarsInsideBranch, (, catchBlock, ), ;, if, (]
[}, if, (, !, body, ., hasChildren, (, ), ), {, NodeUtil, ., redeclareVarsInsideBranch, (, catchBlock, ), ;, if, (]
[(, !, body, ., hasChildren, (, ), ), {, NodeUtil, ., redeclareVarsInsideBranch, (, catchBlock, ), ;, if, (, finallyBlock, !=]
[., hasChildren, (, ), ), {, NodeUtil, ., redeclareVarsInsideBranch, (, catchBlock, ), ;, if, (, finallyBlock, !=, null, ), {]
[., hasChildren, (, ), ), {, NodeUtil, ., redeclareVarsInsideBranch, (, catchBlock, ), ;, if, (, finallyBlock, !=, null, ), {]
[), {, NodeUtil, ., redeclareVarsInsideBranch, (, catchBlock, ), ;, if, (, finallyBlock, !=, null, ), {, n, ., removeChild, (]
[., redeclareVarsInsideBranch, (, catchBlock, ), ;, if, (, finallyBlock, !=, null, ), {, n, ., removeChild, (, finallyBlock, ), ;]
[., redeclareVarsInsideBranch, (, catchBlock, ), ;, if, (, finallyBlock, !=, null, ), {, n, ., removeChild, (, finallyBlock, ), ;]
[., redeclareVarsInsideBranch, (, catchBlock, ), ;, if, (, finallyBlock, !=, null, ), {, n, ., removeChild, (, finallyBlock, ), ;]
[finallyBlock, !=, null, ), {, n, ., removeChild, (, finallyBlock, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[null, ), {, n, ., removeChild, (, finallyBlock, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[(, finallyBlock, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, finallyBlock, ), ;, }, else, {]
[(, finallyBlock, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, finallyBlock, ), ;, }, else, {]
[(, finallyBlock, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, finallyBlock, ), ;, }, else, {]
[), ., replaceChild, (, n, ,, finallyBlock, ), ;, }, else, {, n, ., getParent, (, ), ., removeChild, (]
[n, ,, finallyBlock, ), ;, }, else, {, n, ., getParent, (, ), ., removeChild, (, n, ), ;, }]
[}, else, {, n, ., getParent, (, ), ., removeChild, (, n, ), ;, }, reportCodeChange, (, ), ;, return]
[., getParent, (, ), ., removeChild, (, n, ), ;, }, reportCodeChange, (, ), ;, return, finallyBlock, ;, }, return]
[reportCodeChange, (, ), ;, return, finallyBlock, ;, }, return, n, ;, }, private, Node, tryFoldAssignment, (, Node, subtree, ), {]
[reportCodeChange, (, ), ;, return, finallyBlock, ;, }, return, n, ;, }, private, Node, tryFoldAssignment, (, Node, subtree, ), {]
[return, finallyBlock, ;, }, return, n, ;, }, private, Node, tryFoldAssignment, (, Node, subtree, ), {, Preconditions, ., checkState, (]
[return, finallyBlock, ;, }, return, n, ;, }, private, Node, tryFoldAssignment, (, Node, subtree, ), {, Preconditions, ., checkState, (]
[tryFoldAssignment, (, Node, subtree, ), {, Preconditions, ., checkState, (, subtree, ., isAssign, (, ), ), ;, Node, left, =]
[tryFoldAssignment, (, Node, subtree, ), {, Preconditions, ., checkState, (, subtree, ., isAssign, (, ), ), ;, Node, left, =]
[(, subtree, ., isAssign, (, ), ), ;, Node, left, =, subtree, ., getFirstChild, (, ), ;, Node, right, =]
[(, subtree, ., isAssign, (, ), ), ;, Node, left, =, subtree, ., getFirstChild, (, ), ;, Node, right, =]
[Node, left, =, subtree, ., getFirstChild, (, ), ;, Node, right, =, subtree, ., getLastChild, (, ), ;, if, (]
[Node, left, =, subtree, ., getFirstChild, (, ), ;, Node, right, =, subtree, ., getLastChild, (, ), ;, if, (]
[Node, left, =, subtree, ., getFirstChild, (, ), ;, Node, right, =, subtree, ., getLastChild, (, ), ;, if, (]
[Node, left, =, subtree, ., getFirstChild, (, ), ;, Node, right, =, subtree, ., getLastChild, (, ), ;, if, (]
[(, ), ;, Node, right, =, subtree, ., getLastChild, (, ), ;, if, (, left, ., isName, (, ), &&]
[(, ), ;, Node, right, =, subtree, ., getLastChild, (, ), ;, if, (, left, ., isName, (, ), &&]
[subtree, ., getLastChild, (, ), ;, if, (, left, ., isName, (, ), &&, right, ., isName, (, ), &&]
[subtree, ., getLastChild, (, ), ;, if, (, left, ., isName, (, ), &&, right, ., isName, (, ), &&]
[subtree, ., getLastChild, (, ), ;, if, (, left, ., isName, (, ), &&, right, ., isName, (, ), &&]
[left, ., isName, (, ), &&, right, ., isName, (, ), &&, left, ., getString, (, ), ., equals, (]
[left, ., isName, (, ), &&, right, ., isName, (, ), &&, left, ., getString, (, ), ., equals, (]
[isName, (, ), &&, left, ., getString, (, ), ., equals, (, right, ., getString, (, ), ), ), {]
[isName, (, ), &&, left, ., getString, (, ), ., equals, (, right, ., getString, (, ), ), ), {]
[isName, (, ), &&, left, ., getString, (, ), ., equals, (, right, ., getString, (, ), ), ), {]
[), ., equals, (, right, ., getString, (, ), ), ), {, subtree, ., getParent, (, ), ., replaceChild, (]
[equals, (, right, ., getString, (, ), ), ), {, subtree, ., getParent, (, ), ., replaceChild, (, subtree, ,]
[equals, (, right, ., getString, (, ), ), ), {, subtree, ., getParent, (, ), ., replaceChild, (, subtree, ,]
[), ), {, subtree, ., getParent, (, ), ., replaceChild, (, subtree, ,, right, ., detachFromParent, (, ), ), ;]
[getParent, (, ), ., replaceChild, (, subtree, ,, right, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return]
[replaceChild, (, subtree, ,, right, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, right, ;, }, return]
[;, return, right, ;, }, return, subtree, ;, }, private, Node, tryFoldExpr, (, Node, subtree, ), {, Node, result, =]
[right, ;, }, return, subtree, ;, }, private, Node, tryFoldExpr, (, Node, subtree, ), {, Node, result, =, trySimplifyUnusedResult, (]
[right, ;, }, return, subtree, ;, }, private, Node, tryFoldExpr, (, Node, subtree, ), {, Node, result, =, trySimplifyUnusedResult, (]
[tryFoldExpr, (, Node, subtree, ), {, Node, result, =, trySimplifyUnusedResult, (, subtree, ., getFirstChild, (, ), ), ;, if, (]
[tryFoldExpr, (, Node, subtree, ), {, Node, result, =, trySimplifyUnusedResult, (, subtree, ., getFirstChild, (, ), ), ;, if, (]
[Node, subtree, ), {, Node, result, =, trySimplifyUnusedResult, (, subtree, ., getFirstChild, (, ), ), ;, if, (, result, ==]
[=, trySimplifyUnusedResult, (, subtree, ., getFirstChild, (, ), ), ;, if, (, result, ==, null, ), {, Node, parent, =]
[=, trySimplifyUnusedResult, (, subtree, ., getFirstChild, (, ), ), ;, if, (, result, ==, null, ), {, Node, parent, =]
[), ;, if, (, result, ==, null, ), {, Node, parent, =, subtree, ., getParent, (, ), ;, if, (]
[), ;, if, (, result, ==, null, ), {, Node, parent, =, subtree, ., getParent, (, ), ;, if, (]
[parent, =, subtree, ., getParent, (, ), ;, if, (, parent, ., isLabel, (, ), ), {, Node, replacement, =]
[parent, =, subtree, ., getParent, (, ), ;, if, (, parent, ., isLabel, (, ), ), {, Node, replacement, =]
[parent, =, subtree, ., getParent, (, ), ;, if, (, parent, ., isLabel, (, ), ), {, Node, replacement, =]
[if, (, parent, ., isLabel, (, ), ), {, Node, replacement, =, IR, ., block, (, ), ., srcref, (]
[., isLabel, (, ), ), {, Node, replacement, =, IR, ., block, (, ), ., srcref, (, subtree, ), ;]
[., isLabel, (, ), ), {, Node, replacement, =, IR, ., block, (, ), ., srcref, (, subtree, ), ;]
[), {, Node, replacement, =, IR, ., block, (, ), ., srcref, (, subtree, ), ;, parent, ., replaceChild, (]
[Node, replacement, =, IR, ., block, (, ), ., srcref, (, subtree, ), ;, parent, ., replaceChild, (, subtree, ,]
[IR, ., block, (, ), ., srcref, (, subtree, ), ;, parent, ., replaceChild, (, subtree, ,, replacement, ), ;]
[block, (, ), ., srcref, (, subtree, ), ;, parent, ., replaceChild, (, subtree, ,, replacement, ), ;, subtree, =]
[(, subtree, ), ;, parent, ., replaceChild, (, subtree, ,, replacement, ), ;, subtree, =, replacement, ;, }, else, {]
[(, subtree, ), ;, parent, ., replaceChild, (, subtree, ,, replacement, ), ;, subtree, =, replacement, ;, }, else, {]
[replaceChild, (, subtree, ,, replacement, ), ;, subtree, =, replacement, ;, }, else, {, subtree, ., detachFromParent, (, ), ;]
[subtree, ,, replacement, ), ;, subtree, =, replacement, ;, }, else, {, subtree, ., detachFromParent, (, ), ;, subtree, =]
[subtree, =, replacement, ;, }, else, {, subtree, ., detachFromParent, (, ), ;, subtree, =, null, ;, }, }, return]
[;, subtree, =, null, ;, }, }, return, subtree, ;, }, private, Node, trySimplifyUnusedResult, (, Node, n, ), {, return]
[=, null, ;, }, }, return, subtree, ;, }, private, Node, trySimplifyUnusedResult, (, Node, n, ), {, return, trySimplifyUnusedResult, (]
[;, }, }, return, subtree, ;, }, private, Node, trySimplifyUnusedResult, (, Node, n, ), {, return, trySimplifyUnusedResult, (, n, ,]
[n, ,, true, ), ;, }, private, Node, trySimplifyUnusedResult, (, Node, n, ,, boolean, removeUnused, ), {, Node, result, =]
[;, }, private, Node, trySimplifyUnusedResult, (, Node, n, ,, boolean, removeUnused, ), {, Node, result, =, n, ;, switch, (]
[;, }, private, Node, trySimplifyUnusedResult, (, Node, n, ,, boolean, removeUnused, ), {, Node, result, =, n, ;, switch, (]
[,, boolean, removeUnused, ), {, Node, result, =, n, ;, switch, (, n, ., getType, (, ), ), {, case]
[,, boolean, removeUnused, ), {, Node, result, =, n, ;, switch, (, n, ., getType, (, ), ), {, case]
[=, n, ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., HOOK, :, Node, trueNode, =]
[;, switch, (, n, ., getType, (, ), ), {, case, Token, ., HOOK, :, Node, trueNode, =, trySimplifyUnusedResult, (]
[;, switch, (, n, ., getType, (, ), ), {, case, Token, ., HOOK, :, Node, trueNode, =, trySimplifyUnusedResult, (]
[;, switch, (, n, ., getType, (, ), ), {, case, Token, ., HOOK, :, Node, trueNode, =, trySimplifyUnusedResult, (]
[:, Node, trueNode, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, falseNode, =]
[trueNode, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, falseNode, =, trySimplifyUnusedResult, (]
[trueNode, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, falseNode, =, trySimplifyUnusedResult, (]
[., getNext, (, ), ), ;, Node, falseNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (]
[., getNext, (, ), ), ;, Node, falseNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (]
[., getNext, (, ), ), ;, Node, falseNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (]
[(, ), ), ;, Node, falseNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, trueNode, ==]
[), ;, Node, falseNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, trueNode, ==, null, &&]
[), ;, Node, falseNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, trueNode, ==, null, &&]
[Node, falseNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, trueNode, ==, null, &&, falseNode, !=]
[trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, trueNode, ==, null, &&, falseNode, !=, null, ), {]
[trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, trueNode, ==, null, &&, falseNode, !=, null, ), {]
[getLastChild, (, ), ), ;, if, (, trueNode, ==, null, &&, falseNode, !=, null, ), {, n, ., setType, (]
[getLastChild, (, ), ), ;, if, (, trueNode, ==, null, &&, falseNode, !=, null, ), {, n, ., setType, (]
[if, (, trueNode, ==, null, &&, falseNode, !=, null, ), {, n, ., setType, (, Token, ., OR, ), ;]
[if, (, trueNode, ==, null, &&, falseNode, !=, null, ), {, n, ., setType, (, Token, ., OR, ), ;]
[null, &&, falseNode, !=, null, ), {, n, ., setType, (, Token, ., OR, ), ;, Preconditions, ., checkState, (]
[null, &&, falseNode, !=, null, ), {, n, ., setType, (, Token, ., OR, ), ;, Preconditions, ., checkState, (]
[null, &&, falseNode, !=, null, ), {, n, ., setType, (, Token, ., OR, ), ;, Preconditions, ., checkState, (]
[{, n, ., setType, (, Token, ., OR, ), ;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==]
[OR, ), ;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (]
[OR, ), ;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (]
[OR, ), ;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (]
[;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, !=]
[., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, !=, null, &&]
[., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, !=, null, &&]
[(, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, !=, null, &&, falseNode, ==]
[getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, !=, null, &&, falseNode, ==, null, ), {]
[getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, !=, null, &&, falseNode, ==, null, ), {]
[2, ), ;, }, else, if, (, trueNode, !=, null, &&, falseNode, ==, null, ), {, n, ., setType, (]
[2, ), ;, }, else, if, (, trueNode, !=, null, &&, falseNode, ==, null, ), {, n, ., setType, (]
[if, (, trueNode, !=, null, &&, falseNode, ==, null, ), {, n, ., setType, (, Token, ., AND, ), ;]
[if, (, trueNode, !=, null, &&, falseNode, ==, null, ), {, n, ., setType, (, Token, ., AND, ), ;]
[null, &&, falseNode, ==, null, ), {, n, ., setType, (, Token, ., AND, ), ;, Preconditions, ., checkState, (]
[null, &&, falseNode, ==, null, ), {, n, ., setType, (, Token, ., AND, ), ;, Preconditions, ., checkState, (]
[null, &&, falseNode, ==, null, ), {, n, ., setType, (, Token, ., AND, ), ;, Preconditions, ., checkState, (]
[{, n, ., setType, (, Token, ., AND, ), ;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==]
[AND, ), ;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (]
[AND, ), ;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (]
[AND, ), ;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (]
[;, Preconditions, ., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, ==]
[., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, ==, null, &&]
[., checkState, (, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, ==, null, &&]
[(, n, ., getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, ==, null, &&, falseNode, ==]
[getChildCount, (, ), ==, 2, ), ;, }, else, if, (, trueNode, ==, null, &&, falseNode, ==, null, ), {]
[), ==, 2, ), ;, }, else, if, (, trueNode, ==, null, &&, falseNode, ==, null, ), {, result, =]
[2, ), ;, }, else, if, (, trueNode, ==, null, &&, falseNode, ==, null, ), {, result, =, trySimplifyUnusedResult, (]
[2, ), ;, }, else, if, (, trueNode, ==, null, &&, falseNode, ==, null, ), {, result, =, trySimplifyUnusedResult, (]
[&&, falseNode, ==, null, ), {, result, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, }, else, {]
[==, null, ), {, result, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, }, else, {, result, =]
[trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, }, else, {, result, =, n, ;, }, break, ;, case]
[trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, }, else, {, result, =, n, ;, }, break, ;, case]
[(, ), ), ;, }, else, {, result, =, n, ;, }, break, ;, case, Token, ., AND, :, case]
[(, ), ), ;, }, else, {, result, =, n, ;, }, break, ;, case, Token, ., AND, :, case]
[result, =, n, ;, }, break, ;, case, Token, ., AND, :, case, Token, ., OR, :, Node, conditionalResultNode, =]
[n, ;, }, break, ;, case, Token, ., AND, :, case, Token, ., OR, :, Node, conditionalResultNode, =, trySimplifyUnusedResult, (]
[n, ;, }, break, ;, case, Token, ., AND, :, case, Token, ., OR, :, Node, conditionalResultNode, =, trySimplifyUnusedResult, (]
[:, case, Token, ., OR, :, Node, conditionalResultNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (]
[:, case, Token, ., OR, :, Node, conditionalResultNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (]
[Token, ., OR, :, Node, conditionalResultNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, conditionalResultNode, ==]
[:, Node, conditionalResultNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, conditionalResultNode, ==, null, ), {]
[:, Node, conditionalResultNode, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, conditionalResultNode, ==, null, ), {]
[trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, conditionalResultNode, ==, null, ), {, Preconditions, ., checkState, (]
[trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, conditionalResultNode, ==, null, ), {, Preconditions, ., checkState, (]
[), ;, if, (, conditionalResultNode, ==, null, ), {, Preconditions, ., checkState, (, n, ., hasOneChild, (, ), ), ;]
[if, (, conditionalResultNode, ==, null, ), {, Preconditions, ., checkState, (, n, ., hasOneChild, (, ), ), ;, result, =]
[conditionalResultNode, ==, null, ), {, Preconditions, ., checkState, (, n, ., hasOneChild, (, ), ), ;, result, =, trySimplifyUnusedResult, (]
[conditionalResultNode, ==, null, ), {, Preconditions, ., checkState, (, n, ., hasOneChild, (, ), ), ;, result, =, trySimplifyUnusedResult, (]
[hasOneChild, (, ), ), ;, result, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, }, break, ;, case]
[hasOneChild, (, ), ), ;, result, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, }, break, ;, case]
[;, result, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :]
[=, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :, result, =]
[getFirstChild, (, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :, result, =, null, ;, break, ;, case]
[getFirstChild, (, ), ), ;, }, break, ;, case, Token, ., FUNCTION, :, result, =, null, ;, break, ;, case]
[;, case, Token, ., FUNCTION, :, result, =, null, ;, break, ;, case, Token, ., COMMA, :, Node, left, =]
[Token, ., FUNCTION, :, result, =, null, ;, break, ;, case, Token, ., COMMA, :, Node, left, =, trySimplifyUnusedResult, (]
[Token, ., FUNCTION, :, result, =, null, ;, break, ;, case, Token, ., COMMA, :, Node, left, =, trySimplifyUnusedResult, (]
[case, Token, ., COMMA, :, Node, left, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, Node, right, =]
[., COMMA, :, Node, left, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, Node, right, =, trySimplifyUnusedResult, (]
[., COMMA, :, Node, left, =, trySimplifyUnusedResult, (, n, ., getFirstChild, (, ), ), ;, Node, right, =, trySimplifyUnusedResult, (]
[., getFirstChild, (, ), ), ;, Node, right, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (]
[., getFirstChild, (, ), ), ;, Node, right, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (]
[., getFirstChild, (, ), ), ;, Node, right, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (]
[(, ), ), ;, Node, right, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, left, ==]
[), ;, Node, right, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, left, ==, null, &&]
[), ;, Node, right, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, left, ==, null, &&]
[Node, right, =, trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, left, ==, null, &&, right, ==]
[trySimplifyUnusedResult, (, n, ., getLastChild, (, ), ), ;, if, (, left, ==, null, &&, right, ==, null, ), {]
[n, ., getLastChild, (, ), ), ;, if, (, left, ==, null, &&, right, ==, null, ), {, result, =]
[;, if, (, left, ==, null, &&, right, ==, null, ), {, result, =, null, ;, }, else, if, (]
[;, if, (, left, ==, null, &&, right, ==, null, ), {, result, =, null, ;, }, else, if, (]
[(, left, ==, null, &&, right, ==, null, ), {, result, =, null, ;, }, else, if, (, left, ==]
[null, &&, right, ==, null, ), {, result, =, null, ;, }, else, if, (, left, ==, null, ), {]
[right, ==, null, ), {, result, =, null, ;, }, else, if, (, left, ==, null, ), {, result, =]
[=, null, ;, }, else, if, (, left, ==, null, ), {, result, =, right, ;, }, else, if, (]
[=, null, ;, }, else, if, (, left, ==, null, ), {, result, =, right, ;, }, else, if, (]
[;, }, else, if, (, left, ==, null, ), {, result, =, right, ;, }, else, if, (, right, ==]
[if, (, left, ==, null, ), {, result, =, right, ;, }, else, if, (, right, ==, null, ), {]
[left, ==, null, ), {, result, =, right, ;, }, else, if, (, right, ==, null, ), {, result, =]
[result, =, right, ;, }, else, if, (, right, ==, null, ), {, result, =, left, ;, }, else, {]
[right, ;, }, else, if, (, right, ==, null, ), {, result, =, left, ;, }, else, {, result, =]
[), {, result, =, left, ;, }, else, {, result, =, n, ;, }, break, ;, default, :, if, (]
[{, result, =, left, ;, }, else, {, result, =, n, ;, }, break, ;, default, :, if, (, !]
[=, left, ;, }, else, {, result, =, n, ;, }, break, ;, default, :, if, (, !, nodeTypeMayHaveSideEffects, (]
[=, n, ;, }, break, ;, default, :, if, (, !, nodeTypeMayHaveSideEffects, (, n, ), ), {, Node, resultList, =]
[(, !, nodeTypeMayHaveSideEffects, (, n, ), ), {, Node, resultList, =, null, ;, for, (, Node, next, ,, c, =]
[(, !, nodeTypeMayHaveSideEffects, (, n, ), ), {, Node, resultList, =, null, ;, for, (, Node, next, ,, c, =]
[), {, Node, resultList, =, null, ;, for, (, Node, next, ,, c, =, n, ., getFirstChild, (, ), ;]
[), {, Node, resultList, =, null, ;, for, (, Node, next, ,, c, =, n, ., getFirstChild, (, ), ;]
[Node, resultList, =, null, ;, for, (, Node, next, ,, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[=, null, ;, for, (, Node, next, ,, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;]
[;, for, (, Node, next, ,, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[Node, next, ,, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, next, ), {]
[,, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, next, ), {, next, =]
[,, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, next, ), {, next, =]
[(, ), ;, c, !=, null, ;, c, =, next, ), {, next, =, c, ., getNext, (, ), ;]
[;, c, !=, null, ;, c, =, next, ), {, next, =, c, ., getNext, (, ), ;, c, =]
[!=, null, ;, c, =, next, ), {, next, =, c, ., getNext, (, ), ;, c, =, trySimplifyUnusedResult, (]
[next, ), {, next, =, c, ., getNext, (, ), ;, c, =, trySimplifyUnusedResult, (, c, ), ;, if, (]
[next, ), {, next, =, c, ., getNext, (, ), ;, c, =, trySimplifyUnusedResult, (, c, ), ;, if, (]
[{, next, =, c, ., getNext, (, ), ;, c, =, trySimplifyUnusedResult, (, c, ), ;, if, (, c, !=]
[c, ., getNext, (, ), ;, c, =, trySimplifyUnusedResult, (, c, ), ;, if, (, c, !=, null, ), {]
[c, ., getNext, (, ), ;, c, =, trySimplifyUnusedResult, (, c, ), ;, if, (, c, !=, null, ), {]
[trySimplifyUnusedResult, (, c, ), ;, if, (, c, !=, null, ), {, c, ., detachFromParent, (, ), ;, if, (]
[trySimplifyUnusedResult, (, c, ), ;, if, (, c, !=, null, ), {, c, ., detachFromParent, (, ), ;, if, (]
[c, ), ;, if, (, c, !=, null, ), {, c, ., detachFromParent, (, ), ;, if, (, resultList, ==]
[if, (, c, !=, null, ), {, c, ., detachFromParent, (, ), ;, if, (, resultList, ==, null, ), {]
[c, !=, null, ), {, c, ., detachFromParent, (, ), ;, if, (, resultList, ==, null, ), {, resultList, =]
[c, ., detachFromParent, (, ), ;, if, (, resultList, ==, null, ), {, resultList, =, c, ;, }, else, {]
[detachFromParent, (, ), ;, if, (, resultList, ==, null, ), {, resultList, =, c, ;, }, else, {, resultList, =]
[detachFromParent, (, ), ;, if, (, resultList, ==, null, ), {, resultList, =, c, ;, }, else, {, resultList, =]
[detachFromParent, (, ), ;, if, (, resultList, ==, null, ), {, resultList, =, c, ;, }, else, {, resultList, =]
[if, (, resultList, ==, null, ), {, resultList, =, c, ;, }, else, {, resultList, =, IR, ., comma, (]
[resultList, ==, null, ), {, resultList, =, c, ;, }, else, {, resultList, =, IR, ., comma, (, resultList, ,]
[resultList, =, c, ;, }, else, {, resultList, =, IR, ., comma, (, resultList, ,, c, ), ., srcref, (]
[{, resultList, =, IR, ., comma, (, resultList, ,, c, ), ., srcref, (, c, ), ;, }, }, }]
[=, IR, ., comma, (, resultList, ,, c, ), ., srcref, (, c, ), ;, }, }, }, result, =]
[,, c, ), ., srcref, (, c, ), ;, }, }, }, result, =, resultList, ;, }, }, if, (]
[,, c, ), ., srcref, (, c, ), ;, }, }, }, result, =, resultList, ;, }, }, if, (]
[), ., srcref, (, c, ), ;, }, }, }, result, =, resultList, ;, }, }, if, (, n, !=]
[;, }, }, }, result, =, resultList, ;, }, }, if, (, n, !=, result, ), {, Node, parent, =]
[;, }, }, }, result, =, resultList, ;, }, }, if, (, n, !=, result, ), {, Node, parent, =]
[}, }, if, (, n, !=, result, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[}, }, if, (, n, !=, result, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[if, (, n, !=, result, ), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, result, ==]
[), {, Node, parent, =, n, ., getParent, (, ), ;, if, (, result, ==, null, ), {, if, (]
[parent, =, n, ., getParent, (, ), ;, if, (, result, ==, null, ), {, if, (, removeUnused, ), {]
[parent, =, n, ., getParent, (, ), ;, if, (, result, ==, null, ), {, if, (, removeUnused, ), {]
[getParent, (, ), ;, if, (, result, ==, null, ), {, if, (, removeUnused, ), {, parent, ., removeChild, (]
[result, ==, null, ), {, if, (, removeUnused, ), {, parent, ., removeChild, (, n, ), ;, }, else, {]
[null, ), {, if, (, removeUnused, ), {, parent, ., removeChild, (, n, ), ;, }, else, {, result, =]
[null, ), {, if, (, removeUnused, ), {, parent, ., removeChild, (, n, ), ;, }, else, {, result, =]
[null, ), {, if, (, removeUnused, ), {, parent, ., removeChild, (, n, ), ;, }, else, {, result, =]
[parent, ., removeChild, (, n, ), ;, }, else, {, result, =, IR, ., empty, (, ), ., srcref, (]
[(, n, ), ;, }, else, {, result, =, IR, ., empty, (, ), ., srcref, (, n, ), ;]
[(, n, ), ;, }, else, {, result, =, IR, ., empty, (, ), ., srcref, (, n, ), ;]
[}, else, {, result, =, IR, ., empty, (, ), ., srcref, (, n, ), ;, parent, ., replaceChild, (]
[{, result, =, IR, ., empty, (, ), ., srcref, (, n, ), ;, parent, ., replaceChild, (, n, ,]
[srcref, (, n, ), ;, parent, ., replaceChild, (, n, ,, result, ), ;, }, }, else, {, if, (]
[srcref, (, n, ), ;, parent, ., replaceChild, (, n, ,, result, ), ;, }, }, else, {, if, (]
[srcref, (, n, ), ;, parent, ., replaceChild, (, n, ,, result, ), ;, }, }, else, {, if, (]
[., replaceChild, (, n, ,, result, ), ;, }, }, else, {, if, (, result, ., getParent, (, ), !=]
[n, ,, result, ), ;, }, }, else, {, if, (, result, ., getParent, (, ), !=, null, ), {]
[n, ,, result, ), ;, }, }, else, {, if, (, result, ., getParent, (, ), !=, null, ), {]
[else, {, if, (, result, ., getParent, (, ), !=, null, ), {, result, ., detachFromParent, (, ), ;, }]
[else, {, if, (, result, ., getParent, (, ), !=, null, ), {, result, ., detachFromParent, (, ), ;, }]
[else, {, if, (, result, ., getParent, (, ), !=, null, ), {, result, ., detachFromParent, (, ), ;, }]
[), !=, null, ), {, result, ., detachFromParent, (, ), ;, }, n, ., getParent, (, ), ., replaceChild, (]
[null, ), {, result, ., detachFromParent, (, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[., detachFromParent, (, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, result, ), ;, }]
[n, ., getParent, (, ), ., replaceChild, (, n, ,, result, ), ;, }, reportCodeChange, (, ), ;, }, return]
[), ;, }, reportCodeChange, (, ), ;, }, return, result, ;, }, private, Node, tryOptimizeSwitch, (, Node, n, ), {]
[), ;, }, reportCodeChange, (, ), ;, }, return, result, ;, }, private, Node, tryOptimizeSwitch, (, Node, n, ), {]
[(, ), ;, }, return, result, ;, }, private, Node, tryOptimizeSwitch, (, Node, n, ), {, Preconditions, ., checkState, (]
[(, ), ;, }, return, result, ;, }, private, Node, tryOptimizeSwitch, (, Node, n, ), {, Preconditions, ., checkState, (]
[tryOptimizeSwitch, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isSwitch, (, ), ), ;, Node, defaultCase, =]
[Node, n, ), {, Preconditions, ., checkState, (, n, ., isSwitch, (, ), ), ;, Node, defaultCase, =, tryOptimizeDefaultCase, (]
[., checkState, (, n, ., isSwitch, (, ), ), ;, Node, defaultCase, =, tryOptimizeDefaultCase, (, n, ), ;, if, (]
[., checkState, (, n, ., isSwitch, (, ), ), ;, Node, defaultCase, =, tryOptimizeDefaultCase, (, n, ), ;, if, (]
[(, n, ., isSwitch, (, ), ), ;, Node, defaultCase, =, tryOptimizeDefaultCase, (, n, ), ;, if, (, defaultCase, ==]
[), ;, Node, defaultCase, =, tryOptimizeDefaultCase, (, n, ), ;, if, (, defaultCase, ==, null, ), {, Node, cond, =]
[), ;, Node, defaultCase, =, tryOptimizeDefaultCase, (, n, ), ;, if, (, defaultCase, ==, null, ), {, Node, cond, =]
[), ;, if, (, defaultCase, ==, null, ), {, Node, cond, =, n, ., getFirstChild, (, ), ,, prev, =]
[defaultCase, ==, null, ), {, Node, cond, =, n, ., getFirstChild, (, ), ,, prev, =, null, ,, next, =]
[cond, =, n, ., getFirstChild, (, ), ,, prev, =, null, ,, next, =, null, ,, cur, ;, for, (]
[n, ., getFirstChild, (, ), ,, prev, =, null, ,, next, =, null, ,, cur, ;, for, (, cur, =]
[n, ., getFirstChild, (, ), ,, prev, =, null, ,, next, =, null, ,, cur, ;, for, (, cur, =]
[prev, =, null, ,, next, =, null, ,, cur, ;, for, (, cur, =, cond, ., getNext, (, ), ;]
[prev, =, null, ,, next, =, null, ,, cur, ;, for, (, cur, =, cond, ., getNext, (, ), ;]
[null, ,, next, =, null, ,, cur, ;, for, (, cur, =, cond, ., getNext, (, ), ;, cur, !=]
[next, =, null, ,, cur, ;, for, (, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;]
[null, ,, cur, ;, for, (, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;, cur, =]
[;, for, (, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;, cur, =, next, ), {]
[(, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;, cur, =, next, ), {, next, =]
[(, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;, cur, =, next, ), {, next, =]
[;, cur, !=, null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;, if, (]
[;, cur, !=, null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;, if, (]
[cur, !=, null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;, if, (, !]
[null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;, if, (, !, mayHaveSideEffects, (]
[null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;, if, (, !, mayHaveSideEffects, (]
[next, =, cur, ., getNext, (, ), ;, if, (, !, mayHaveSideEffects, (, cur, ., getFirstChild, (, ), ), &&]
[cur, ., getNext, (, ), ;, if, (, !, mayHaveSideEffects, (, cur, ., getFirstChild, (, ), ), &&, isUselessCase, (]
[getNext, (, ), ;, if, (, !, mayHaveSideEffects, (, cur, ., getFirstChild, (, ), ), &&, isUselessCase, (, cur, ,]
[if, (, !, mayHaveSideEffects, (, cur, ., getFirstChild, (, ), ), &&, isUselessCase, (, cur, ,, prev, ), ), {]
[!, mayHaveSideEffects, (, cur, ., getFirstChild, (, ), ), &&, isUselessCase, (, cur, ,, prev, ), ), {, removeCase, (]
[(, cur, ., getFirstChild, (, ), ), &&, isUselessCase, (, cur, ,, prev, ), ), {, removeCase, (, n, ,]
[), &&, isUselessCase, (, cur, ,, prev, ), ), {, removeCase, (, n, ,, cur, ), ;, }, else, {]
[isUselessCase, (, cur, ,, prev, ), ), {, removeCase, (, n, ,, cur, ), ;, }, else, {, prev, =]
[), {, removeCase, (, n, ,, cur, ), ;, }, else, {, prev, =, cur, ;, }, }, if, (]
[), {, removeCase, (, n, ,, cur, ), ;, }, else, {, prev, =, cur, ;, }, }, if, (]
[n, ,, cur, ), ;, }, else, {, prev, =, cur, ;, }, }, if, (, NodeUtil, ., isLiteralValue, (]
[cur, ), ;, }, else, {, prev, =, cur, ;, }, }, if, (, NodeUtil, ., isLiteralValue, (, cond, ,]
[}, }, if, (, NodeUtil, ., isLiteralValue, (, cond, ,, false, ), ), {, Node, caseLabel, ;, TernaryValue, caseMatches, =]
[}, }, if, (, NodeUtil, ., isLiteralValue, (, cond, ,, false, ), ), {, Node, caseLabel, ;, TernaryValue, caseMatches, =]
[isLiteralValue, (, cond, ,, false, ), ), {, Node, caseLabel, ;, TernaryValue, caseMatches, =, TernaryValue, ., TRUE, ;, for, (]
[cond, ,, false, ), ), {, Node, caseLabel, ;, TernaryValue, caseMatches, =, TernaryValue, ., TRUE, ;, for, (, cur, =]
[cond, ,, false, ), ), {, Node, caseLabel, ;, TernaryValue, caseMatches, =, TernaryValue, ., TRUE, ;, for, (, cur, =]
[Node, caseLabel, ;, TernaryValue, caseMatches, =, TernaryValue, ., TRUE, ;, for, (, cur, =, cond, ., getNext, (, ), ;]
[Node, caseLabel, ;, TernaryValue, caseMatches, =, TernaryValue, ., TRUE, ;, for, (, cur, =, cond, ., getNext, (, ), ;]
[;, TernaryValue, caseMatches, =, TernaryValue, ., TRUE, ;, for, (, cur, =, cond, ., getNext, (, ), ;, cur, !=]
[caseMatches, =, TernaryValue, ., TRUE, ;, for, (, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;]
[TernaryValue, ., TRUE, ;, for, (, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;, cur, =]
[;, for, (, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;, cur, =, next, ), {]
[(, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;, cur, =, next, ), {, next, =]
[(, cur, =, cond, ., getNext, (, ), ;, cur, !=, null, ;, cur, =, next, ), {, next, =]
[(, ), ;, cur, !=, null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;]
[;, cur, !=, null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;, caseLabel, =]
[;, cur, !=, null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;, caseLabel, =]
[=, next, ), {, next, =, cur, ., getNext, (, ), ;, caseLabel, =, cur, ., getFirstChild, (, ), ;]
[), {, next, =, cur, ., getNext, (, ), ;, caseLabel, =, cur, ., getFirstChild, (, ), ;, caseMatches, =]
[), {, next, =, cur, ., getNext, (, ), ;, caseLabel, =, cur, ., getFirstChild, (, ), ;, caseMatches, =]
[cur, ., getNext, (, ), ;, caseLabel, =, cur, ., getFirstChild, (, ), ;, caseMatches, =, PeepholeFoldConstants, ., evaluateComparison, (]
[cur, ., getNext, (, ), ;, caseLabel, =, cur, ., getFirstChild, (, ), ;, caseMatches, =, PeepholeFoldConstants, ., evaluateComparison, (]
[), ;, caseLabel, =, cur, ., getFirstChild, (, ), ;, caseMatches, =, PeepholeFoldConstants, ., evaluateComparison, (, Token, ., SHEQ, ,]
[caseLabel, =, cur, ., getFirstChild, (, ), ;, caseMatches, =, PeepholeFoldConstants, ., evaluateComparison, (, Token, ., SHEQ, ,, cond, ,]
[(, ), ;, caseMatches, =, PeepholeFoldConstants, ., evaluateComparison, (, Token, ., SHEQ, ,, cond, ,, caseLabel, ), ;, if, (]
[(, ), ;, caseMatches, =, PeepholeFoldConstants, ., evaluateComparison, (, Token, ., SHEQ, ,, cond, ,, caseLabel, ), ;, if, (]
[;, caseMatches, =, PeepholeFoldConstants, ., evaluateComparison, (, Token, ., SHEQ, ,, cond, ,, caseLabel, ), ;, if, (, caseMatches, ==]
[;, caseMatches, =, PeepholeFoldConstants, ., evaluateComparison, (, Token, ., SHEQ, ,, cond, ,, caseLabel, ), ;, if, (, caseMatches, ==]
[cond, ,, caseLabel, ), ;, if, (, caseMatches, ==, TernaryValue, ., TRUE, ), {, break, ;, }, else, if, (]
[cond, ,, caseLabel, ), ;, if, (, caseMatches, ==, TernaryValue, ., TRUE, ), {, break, ;, }, else, if, (]
[caseLabel, ), ;, if, (, caseMatches, ==, TernaryValue, ., TRUE, ), {, break, ;, }, else, if, (, caseMatches, ==]
[caseLabel, ), ;, if, (, caseMatches, ==, TernaryValue, ., TRUE, ), {, break, ;, }, else, if, (, caseMatches, ==]
[), {, break, ;, }, else, if, (, caseMatches, ==, TernaryValue, ., UNKNOWN, ), {, break, ;, }, else, {]
[break, ;, }, else, if, (, caseMatches, ==, TernaryValue, ., UNKNOWN, ), {, break, ;, }, else, {, removeCase, (]
[}, else, if, (, caseMatches, ==, TernaryValue, ., UNKNOWN, ), {, break, ;, }, else, {, removeCase, (, n, ,]
[., UNKNOWN, ), {, break, ;, }, else, {, removeCase, (, n, ,, cur, ), ;, }, }, if, (]
[., UNKNOWN, ), {, break, ;, }, else, {, removeCase, (, n, ,, cur, ), ;, }, }, if, (]
[), {, break, ;, }, else, {, removeCase, (, n, ,, cur, ), ;, }, }, if, (, caseMatches, !=]
[), {, break, ;, }, else, {, removeCase, (, n, ,, cur, ), ;, }, }, if, (, caseMatches, !=]
[), ;, }, }, if, (, caseMatches, !=, TernaryValue, ., UNKNOWN, ), {, Node, block, ,, lastStm, ;, while, (]
[), ;, }, }, if, (, caseMatches, !=, TernaryValue, ., UNKNOWN, ), {, Node, block, ,, lastStm, ;, while, (]
[}, }, if, (, caseMatches, !=, TernaryValue, ., UNKNOWN, ), {, Node, block, ,, lastStm, ;, while, (, cur, !=]
[(, caseMatches, !=, TernaryValue, ., UNKNOWN, ), {, Node, block, ,, lastStm, ;, while, (, cur, !=, null, ), {]
[!=, TernaryValue, ., UNKNOWN, ), {, Node, block, ,, lastStm, ;, while, (, cur, !=, null, ), {, block, =]
[!=, TernaryValue, ., UNKNOWN, ), {, Node, block, ,, lastStm, ;, while, (, cur, !=, null, ), {, block, =]
[Node, block, ,, lastStm, ;, while, (, cur, !=, null, ), {, block, =, cur, ., getLastChild, (, ), ;]
[,, lastStm, ;, while, (, cur, !=, null, ), {, block, =, cur, ., getLastChild, (, ), ;, lastStm, =]
[,, lastStm, ;, while, (, cur, !=, null, ), {, block, =, cur, ., getLastChild, (, ), ;, lastStm, =]
[!=, null, ), {, block, =, cur, ., getLastChild, (, ), ;, lastStm, =, block, ., getLastChild, (, ), ;]
[), {, block, =, cur, ., getLastChild, (, ), ;, lastStm, =, block, ., getLastChild, (, ), ;, cur, =]
[), {, block, =, cur, ., getLastChild, (, ), ;, lastStm, =, block, ., getLastChild, (, ), ;, cur, =]
[), ;, lastStm, =, block, ., getLastChild, (, ), ;, cur, =, cur, ., getNext, (, ), ;, if, (]
[), ;, lastStm, =, block, ., getLastChild, (, ), ;, cur, =, cur, ., getNext, (, ), ;, if, (]
[), ;, lastStm, =, block, ., getLastChild, (, ), ;, cur, =, cur, ., getNext, (, ), ;, if, (]
[lastStm, =, block, ., getLastChild, (, ), ;, cur, =, cur, ., getNext, (, ), ;, if, (, lastStm, !=]
[block, ., getLastChild, (, ), ;, cur, =, cur, ., getNext, (, ), ;, if, (, lastStm, !=, null, &&]
[block, ., getLastChild, (, ), ;, cur, =, cur, ., getNext, (, ), ;, if, (, lastStm, !=, null, &&]
[=, cur, ., getNext, (, ), ;, if, (, lastStm, !=, null, &&, lastStm, ., isBreak, (, ), ), {]
[=, cur, ., getNext, (, ), ;, if, (, lastStm, !=, null, &&, lastStm, ., isBreak, (, ), ), {]
[(, ), ;, if, (, lastStm, !=, null, &&, lastStm, ., isBreak, (, ), ), {, block, ., removeChild, (]
[if, (, lastStm, !=, null, &&, lastStm, ., isBreak, (, ), ), {, block, ., removeChild, (, lastStm, ), ;]
[), {, block, ., removeChild, (, lastStm, ), ;, reportCodeChange, (, ), ;, break, ;, }, }, for, (, ;]
[), {, block, ., removeChild, (, lastStm, ), ;, reportCodeChange, (, ), ;, break, ;, }, }, for, (, ;]
[block, ., removeChild, (, lastStm, ), ;, reportCodeChange, (, ), ;, break, ;, }, }, for, (, ;, cur, !=]
[removeChild, (, lastStm, ), ;, reportCodeChange, (, ), ;, break, ;, }, }, for, (, ;, cur, !=, null, ;]
[lastStm, ), ;, reportCodeChange, (, ), ;, break, ;, }, }, for, (, ;, cur, !=, null, ;, cur, =]
[reportCodeChange, (, ), ;, break, ;, }, }, for, (, ;, cur, !=, null, ;, cur, =, next, ), {]
[), ;, break, ;, }, }, for, (, ;, cur, !=, null, ;, cur, =, next, ), {, next, =]
[), ;, break, ;, }, }, for, (, ;, cur, !=, null, ;, cur, =, next, ), {, next, =]
[for, (, ;, cur, !=, null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;]
[;, cur, !=, null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;, removeCase, (]
[!=, null, ;, cur, =, next, ), {, next, =, cur, ., getNext, (, ), ;, removeCase, (, n, ,]
[=, next, ), {, next, =, cur, ., getNext, (, ), ;, removeCase, (, n, ,, cur, ), ;, }]
[), {, next, =, cur, ., getNext, (, ), ;, removeCase, (, n, ,, cur, ), ;, }, cur, =]
[), {, next, =, cur, ., getNext, (, ), ;, removeCase, (, n, ,, cur, ), ;, }, cur, =]
[), ;, removeCase, (, n, ,, cur, ), ;, }, cur, =, cond, ., getNext, (, ), ;, if, (]
[), ;, removeCase, (, n, ,, cur, ), ;, }, cur, =, cond, ., getNext, (, ), ;, if, (]
[), ;, removeCase, (, n, ,, cur, ), ;, }, cur, =, cond, ., getNext, (, ), ;, if, (]
[removeCase, (, n, ,, cur, ), ;, }, cur, =, cond, ., getNext, (, ), ;, if, (, cur, !=]
[n, ,, cur, ), ;, }, cur, =, cond, ., getNext, (, ), ;, if, (, cur, !=, null, &&]
[n, ,, cur, ), ;, }, cur, =, cond, ., getNext, (, ), ;, if, (, cur, !=, null, &&]
[n, ,, cur, ), ;, }, cur, =, cond, ., getNext, (, ), ;, if, (, cur, !=, null, &&]
[cur, =, cond, ., getNext, (, ), ;, if, (, cur, !=, null, &&, cur, ., getNext, (, ), ==]
[., getNext, (, ), ;, if, (, cur, !=, null, &&, cur, ., getNext, (, ), ==, null, ), {]
[(, ), ;, if, (, cur, !=, null, &&, cur, ., getNext, (, ), ==, null, ), {, block, =]
[(, ), ;, if, (, cur, !=, null, &&, cur, ., getNext, (, ), ==, null, ), {, block, =]
[&&, cur, ., getNext, (, ), ==, null, ), {, block, =, cur, ., getLastChild, (, ), ;, if, (]
[cur, ., getNext, (, ), ==, null, ), {, block, =, cur, ., getLastChild, (, ), ;, if, (, !]
[., getNext, (, ), ==, null, ), {, block, =, cur, ., getLastChild, (, ), ;, if, (, !, (]
[., getNext, (, ), ==, null, ), {, block, =, cur, ., getLastChild, (, ), ;, if, (, !, (]
[==, null, ), {, block, =, cur, ., getLastChild, (, ), ;, if, (, !, (, NodeUtil, ., containsType, (]
[), {, block, =, cur, ., getLastChild, (, ), ;, if, (, !, (, NodeUtil, ., containsType, (, block, ,]
[), {, block, =, cur, ., getLastChild, (, ), ;, if, (, !, (, NodeUtil, ., containsType, (, block, ,]
[cur, ., getLastChild, (, ), ;, if, (, !, (, NodeUtil, ., containsType, (, block, ,, Token, ., BREAK, ,]
[cur, ., getLastChild, (, ), ;, if, (, !, (, NodeUtil, ., containsType, (, block, ,, Token, ., BREAK, ,]
[(, !, (, NodeUtil, ., containsType, (, block, ,, Token, ., BREAK, ,, NodeUtil, ., MATCH_NOT_FUNCTION, ), ), ), {]
[(, !, (, NodeUtil, ., containsType, (, block, ,, Token, ., BREAK, ,, NodeUtil, ., MATCH_NOT_FUNCTION, ), ), ), {]
[., containsType, (, block, ,, Token, ., BREAK, ,, NodeUtil, ., MATCH_NOT_FUNCTION, ), ), ), {, cur, ., removeChild, (]
[block, ,, Token, ., BREAK, ,, NodeUtil, ., MATCH_NOT_FUNCTION, ), ), ), {, cur, ., removeChild, (, block, ), ;]
[block, ,, Token, ., BREAK, ,, NodeUtil, ., MATCH_NOT_FUNCTION, ), ), ), {, cur, ., removeChild, (, block, ), ;]
[block, ,, Token, ., BREAK, ,, NodeUtil, ., MATCH_NOT_FUNCTION, ), ), ), {, cur, ., removeChild, (, block, ), ;]
[MATCH_NOT_FUNCTION, ), ), ), {, cur, ., removeChild, (, block, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ), {, cur, ., removeChild, (, block, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[cur, ., removeChild, (, block, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, block, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, block, ), ;, reportCodeChange, (, ), ;, return]
[(, n, ,, block, ), ;, reportCodeChange, (, ), ;, return, block, ;, }, }, }, }, }, if, (]
[(, n, ,, block, ), ;, reportCodeChange, (, ), ;, return, block, ;, }, }, }, }, }, if, (]
[return, block, ;, }, }, }, }, }, if, (, n, ., hasOneChild, (, ), ), {, Node, condition, =]
[return, block, ;, }, }, }, }, }, if, (, n, ., hasOneChild, (, ), ), {, Node, condition, =]
[(, n, ., hasOneChild, (, ), ), {, Node, condition, =, n, ., removeFirstChild, (, ), ;, Node, replacement, =]
[(, n, ., hasOneChild, (, ), ), {, Node, condition, =, n, ., removeFirstChild, (, ), ;, Node, replacement, =]
[(, n, ., hasOneChild, (, ), ), {, Node, condition, =, n, ., removeFirstChild, (, ), ;, Node, replacement, =]
[(, ), ), {, Node, condition, =, n, ., removeFirstChild, (, ), ;, Node, replacement, =, IR, ., exprResult, (]
[condition, =, n, ., removeFirstChild, (, ), ;, Node, replacement, =, IR, ., exprResult, (, condition, ), ., srcref, (]
[., removeFirstChild, (, ), ;, Node, replacement, =, IR, ., exprResult, (, condition, ), ., srcref, (, n, ), ;]
[., removeFirstChild, (, ), ;, Node, replacement, =, IR, ., exprResult, (, condition, ), ., srcref, (, n, ), ;]
[., removeFirstChild, (, ), ;, Node, replacement, =, IR, ., exprResult, (, condition, ), ., srcref, (, n, ), ;]
[IR, ., exprResult, (, condition, ), ., srcref, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[exprResult, (, condition, ), ., srcref, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[), ., srcref, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
[getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, return]
[reportCodeChange, (, ), ;, return, replacement, ;, }, return, null, ;, }, private, Node, tryOptimizeDefaultCase, (, Node, n, ), {]
[reportCodeChange, (, ), ;, return, replacement, ;, }, return, null, ;, }, private, Node, tryOptimizeDefaultCase, (, Node, n, ), {]
[return, replacement, ;, }, return, null, ;, }, private, Node, tryOptimizeDefaultCase, (, Node, n, ), {, Preconditions, ., checkState, (]
[return, replacement, ;, }, return, null, ;, }, private, Node, tryOptimizeDefaultCase, (, Node, n, ), {, Preconditions, ., checkState, (]
[tryOptimizeDefaultCase, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isSwitch, (, ), ), ;, Node, lastNonRemovable, =]
[tryOptimizeDefaultCase, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isSwitch, (, ), ), ;, Node, lastNonRemovable, =]
[., isSwitch, (, ), ), ;, Node, lastNonRemovable, =, n, ., getFirstChild, (, ), ;, for, (, Node, c, =]
[., isSwitch, (, ), ), ;, Node, lastNonRemovable, =, n, ., getFirstChild, (, ), ;, for, (, Node, c, =]
[., isSwitch, (, ), ), ;, Node, lastNonRemovable, =, n, ., getFirstChild, (, ), ;, for, (, Node, c, =]
[., getFirstChild, (, ), ;, for, (, Node, c, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;]
[., getFirstChild, (, ), ;, for, (, Node, c, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;]
[(, ), ;, for, (, Node, c, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, c, !=]
[;, for, (, Node, c, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, c, !=, null, ;]
[(, Node, c, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, c, !=, null, ;, c, =]
[(, Node, c, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, c, !=, null, ;, c, =]
[., getNext, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[., getNext, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[=, c, ., getNext, (, ), ), {, if, (, c, ., isDefaultCase, (, ), ), {, Node, caseToRemove, =]
[=, c, ., getNext, (, ), ), {, if, (, c, ., isDefaultCase, (, ), ), {, Node, caseToRemove, =]
[., isDefaultCase, (, ), ), {, Node, caseToRemove, =, lastNonRemovable, ., getNext, (, ), ;, for, (, Node, next, ;]
[., isDefaultCase, (, ), ), {, Node, caseToRemove, =, lastNonRemovable, ., getNext, (, ), ;, for, (, Node, next, ;]
[(, ), ), {, Node, caseToRemove, =, lastNonRemovable, ., getNext, (, ), ;, for, (, Node, next, ;, caseToRemove, !=]
[), {, Node, caseToRemove, =, lastNonRemovable, ., getNext, (, ), ;, for, (, Node, next, ;, caseToRemove, !=, c, ;]
[Node, caseToRemove, =, lastNonRemovable, ., getNext, (, ), ;, for, (, Node, next, ;, caseToRemove, !=, c, ;, caseToRemove, =]
[lastNonRemovable, ., getNext, (, ), ;, for, (, Node, next, ;, caseToRemove, !=, c, ;, caseToRemove, =, next, ), {]
[getNext, (, ), ;, for, (, Node, next, ;, caseToRemove, !=, c, ;, caseToRemove, =, next, ), {, next, =]
[getNext, (, ), ;, for, (, Node, next, ;, caseToRemove, !=, c, ;, caseToRemove, =, next, ), {, next, =]
[Node, next, ;, caseToRemove, !=, c, ;, caseToRemove, =, next, ), {, next, =, caseToRemove, ., getNext, (, ), ;]
[;, caseToRemove, !=, c, ;, caseToRemove, =, next, ), {, next, =, caseToRemove, ., getNext, (, ), ;, removeCase, (]
[!=, c, ;, caseToRemove, =, next, ), {, next, =, caseToRemove, ., getNext, (, ), ;, removeCase, (, n, ,]
[{, next, =, caseToRemove, ., getNext, (, ), ;, removeCase, (, n, ,, caseToRemove, ), ;, }, Node, prevCase, =]
[{, next, =, caseToRemove, ., getNext, (, ), ;, removeCase, (, n, ,, caseToRemove, ), ;, }, Node, prevCase, =]
[next, =, caseToRemove, ., getNext, (, ), ;, removeCase, (, n, ,, caseToRemove, ), ;, }, Node, prevCase, =, (]
[next, =, caseToRemove, ., getNext, (, ), ;, removeCase, (, n, ,, caseToRemove, ), ;, }, Node, prevCase, =, (]
[caseToRemove, ., getNext, (, ), ;, removeCase, (, n, ,, caseToRemove, ), ;, }, Node, prevCase, =, (, lastNonRemovable, ==]
[caseToRemove, ., getNext, (, ), ;, removeCase, (, n, ,, caseToRemove, ), ;, }, Node, prevCase, =, (, lastNonRemovable, ==]
[(, n, ,, caseToRemove, ), ;, }, Node, prevCase, =, (, lastNonRemovable, ==, n, ., getFirstChild, (, ), ), ?]
[,, caseToRemove, ), ;, }, Node, prevCase, =, (, lastNonRemovable, ==, n, ., getFirstChild, (, ), ), ?, null, :]
[}, Node, prevCase, =, (, lastNonRemovable, ==, n, ., getFirstChild, (, ), ), ?, null, :, lastNonRemovable, ;, if, (]
[prevCase, =, (, lastNonRemovable, ==, n, ., getFirstChild, (, ), ), ?, null, :, lastNonRemovable, ;, if, (, isUselessCase, (]
[(, lastNonRemovable, ==, n, ., getFirstChild, (, ), ), ?, null, :, lastNonRemovable, ;, if, (, isUselessCase, (, c, ,]
[., getFirstChild, (, ), ), ?, null, :, lastNonRemovable, ;, if, (, isUselessCase, (, c, ,, prevCase, ), ), {]
[(, ), ), ?, null, :, lastNonRemovable, ;, if, (, isUselessCase, (, c, ,, prevCase, ), ), {, removeCase, (]
[), ?, null, :, lastNonRemovable, ;, if, (, isUselessCase, (, c, ,, prevCase, ), ), {, removeCase, (, n, ,]
[lastNonRemovable, ;, if, (, isUselessCase, (, c, ,, prevCase, ), ), {, removeCase, (, n, ,, c, ), ;, return]
[isUselessCase, (, c, ,, prevCase, ), ), {, removeCase, (, n, ,, c, ), ;, return, null, ;, }, return]
[), ), {, removeCase, (, n, ,, c, ), ;, return, null, ;, }, return, c, ;, }, else, {]
[), ), {, removeCase, (, n, ,, c, ), ;, return, null, ;, }, return, c, ;, }, else, {]
[(, n, ,, c, ), ;, return, null, ;, }, return, c, ;, }, else, {, Preconditions, ., checkState, (]
[(, n, ,, c, ), ;, return, null, ;, }, return, c, ;, }, else, {, Preconditions, ., checkState, (]
[}, return, c, ;, }, else, {, Preconditions, ., checkState, (, c, ., isCase, (, ), ), ;, if, (]
[}, return, c, ;, }, else, {, Preconditions, ., checkState, (, c, ., isCase, (, ), ), ;, if, (]
[}, return, c, ;, }, else, {, Preconditions, ., checkState, (, c, ., isCase, (, ), ), ;, if, (]
[}, return, c, ;, }, else, {, Preconditions, ., checkState, (, c, ., isCase, (, ), ), ;, if, (]
[(, c, ., isCase, (, ), ), ;, if, (, c, ., getLastChild, (, ), ., hasChildren, (, ), ||]
[., isCase, (, ), ), ;, if, (, c, ., getLastChild, (, ), ., hasChildren, (, ), ||, mayHaveSideEffects, (]
[., isCase, (, ), ), ;, if, (, c, ., getLastChild, (, ), ., hasChildren, (, ), ||, mayHaveSideEffects, (]
[c, ., getLastChild, (, ), ., hasChildren, (, ), ||, mayHaveSideEffects, (, c, ., getFirstChild, (, ), ), ), {]
[getLastChild, (, ), ., hasChildren, (, ), ||, mayHaveSideEffects, (, c, ., getFirstChild, (, ), ), ), {, lastNonRemovable, =]
[), ||, mayHaveSideEffects, (, c, ., getFirstChild, (, ), ), ), {, lastNonRemovable, =, c, ;, }, }, }, return]
[c, ;, }, }, }, return, null, ;, }, private, void, removeCase, (, Node, switchNode, ,, Node, caseNode, ), {]
[c, ;, }, }, }, return, null, ;, }, private, void, removeCase, (, Node, switchNode, ,, Node, caseNode, ), {]
[}, return, null, ;, }, private, void, removeCase, (, Node, switchNode, ,, Node, caseNode, ), {, NodeUtil, ., redeclareVarsInsideBranch, (]
[;, }, private, void, removeCase, (, Node, switchNode, ,, Node, caseNode, ), {, NodeUtil, ., redeclareVarsInsideBranch, (, caseNode, ), ;]
[;, }, private, void, removeCase, (, Node, switchNode, ,, Node, caseNode, ), {, NodeUtil, ., redeclareVarsInsideBranch, (, caseNode, ), ;]
[removeCase, (, Node, switchNode, ,, Node, caseNode, ), {, NodeUtil, ., redeclareVarsInsideBranch, (, caseNode, ), ;, switchNode, ., removeChild, (]
[switchNode, ,, Node, caseNode, ), {, NodeUtil, ., redeclareVarsInsideBranch, (, caseNode, ), ;, switchNode, ., removeChild, (, caseNode, ), ;]
[), ;, reportCodeChange, (, ), ;, }, private, boolean, isUselessCase, (, Node, caseNode, ,, @, Nullable, Node, previousCase, ), {]
[), ;, reportCodeChange, (, ), ;, }, private, boolean, isUselessCase, (, Node, caseNode, ,, @, Nullable, Node, previousCase, ), {]
[), ;, }, private, boolean, isUselessCase, (, Node, caseNode, ,, @, Nullable, Node, previousCase, ), {, Preconditions, ., checkState, (]
[), ;, }, private, boolean, isUselessCase, (, Node, caseNode, ,, @, Nullable, Node, previousCase, ), {, Preconditions, ., checkState, (]
[), ;, }, private, boolean, isUselessCase, (, Node, caseNode, ,, @, Nullable, Node, previousCase, ), {, Preconditions, ., checkState, (]
[}, private, boolean, isUselessCase, (, Node, caseNode, ,, @, Nullable, Node, previousCase, ), {, Preconditions, ., checkState, (, previousCase, ==]
[boolean, isUselessCase, (, Node, caseNode, ,, @, Nullable, Node, previousCase, ), {, Preconditions, ., checkState, (, previousCase, ==, null, ||]
[boolean, isUselessCase, (, Node, caseNode, ,, @, Nullable, Node, previousCase, ), {, Preconditions, ., checkState, (, previousCase, ==, null, ||]
[boolean, isUselessCase, (, Node, caseNode, ,, @, Nullable, Node, previousCase, ), {, Preconditions, ., checkState, (, previousCase, ==, null, ||]
[@, Nullable, Node, previousCase, ), {, Preconditions, ., checkState, (, previousCase, ==, null, ||, previousCase, ., getNext, (, ), ==]
[Preconditions, ., checkState, (, previousCase, ==, null, ||, previousCase, ., getNext, (, ), ==, caseNode, ), ;, Node, switchNode, =]
[Preconditions, ., checkState, (, previousCase, ==, null, ||, previousCase, ., getNext, (, ), ==, caseNode, ), ;, Node, switchNode, =]
[previousCase, ., getNext, (, ), ==, caseNode, ), ;, Node, switchNode, =, caseNode, ., getParent, (, ), ;, if, (]
[previousCase, ., getNext, (, ), ==, caseNode, ), ;, Node, switchNode, =, caseNode, ., getParent, (, ), ;, if, (]
[previousCase, ., getNext, (, ), ==, caseNode, ), ;, Node, switchNode, =, caseNode, ., getParent, (, ), ;, if, (]
[previousCase, ., getNext, (, ), ==, caseNode, ), ;, Node, switchNode, =, caseNode, ., getParent, (, ), ;, if, (]
[caseNode, ), ;, Node, switchNode, =, caseNode, ., getParent, (, ), ;, if, (, switchNode, ., getLastChild, (, ), !=]
[;, Node, switchNode, =, caseNode, ., getParent, (, ), ;, if, (, switchNode, ., getLastChild, (, ), !=, caseNode, &&]
[;, Node, switchNode, =, caseNode, ., getParent, (, ), ;, if, (, switchNode, ., getLastChild, (, ), !=, caseNode, &&]
[switchNode, =, caseNode, ., getParent, (, ), ;, if, (, switchNode, ., getLastChild, (, ), !=, caseNode, &&, previousCase, !=]
[), ;, if, (, switchNode, ., getLastChild, (, ), !=, caseNode, &&, previousCase, !=, null, ), {, Node, previousBlock, =]
[), ;, if, (, switchNode, ., getLastChild, (, ), !=, caseNode, &&, previousCase, !=, null, ), {, Node, previousBlock, =]
[), !=, caseNode, &&, previousCase, !=, null, ), {, Node, previousBlock, =, previousCase, ., getLastChild, (, ), ;, if, (]
[), !=, caseNode, &&, previousCase, !=, null, ), {, Node, previousBlock, =, previousCase, ., getLastChild, (, ), ;, if, (]
[!=, caseNode, &&, previousCase, !=, null, ), {, Node, previousBlock, =, previousCase, ., getLastChild, (, ), ;, if, (, !]
[!=, caseNode, &&, previousCase, !=, null, ), {, Node, previousBlock, =, previousCase, ., getLastChild, (, ), ;, if, (, !]
[), {, Node, previousBlock, =, previousCase, ., getLastChild, (, ), ;, if, (, !, previousBlock, ., hasChildren, (, ), ||]
[{, Node, previousBlock, =, previousCase, ., getLastChild, (, ), ;, if, (, !, previousBlock, ., hasChildren, (, ), ||, !]
[previousBlock, =, previousCase, ., getLastChild, (, ), ;, if, (, !, previousBlock, ., hasChildren, (, ), ||, !, isExit, (]
[previousBlock, =, previousCase, ., getLastChild, (, ), ;, if, (, !, previousBlock, ., hasChildren, (, ), ||, !, isExit, (]
[(, !, previousBlock, ., hasChildren, (, ), ||, !, isExit, (, previousBlock, ., getLastChild, (, ), ), ), {, return]
[||, !, isExit, (, previousBlock, ., getLastChild, (, ), ), ), {, return, false, ;, }, }, Node, executingCase, =]
[previousBlock, ., getLastChild, (, ), ), ), {, return, false, ;, }, }, Node, executingCase, =, caseNode, ;, while, (]
[previousBlock, ., getLastChild, (, ), ), ), {, return, false, ;, }, }, Node, executingCase, =, caseNode, ;, while, (]
[getLastChild, (, ), ), ), {, return, false, ;, }, }, Node, executingCase, =, caseNode, ;, while, (, executingCase, !=]
[), ), {, return, false, ;, }, }, Node, executingCase, =, caseNode, ;, while, (, executingCase, !=, null, ), {]
[), ), {, return, false, ;, }, }, Node, executingCase, =, caseNode, ;, while, (, executingCase, !=, null, ), {]
[false, ;, }, }, Node, executingCase, =, caseNode, ;, while, (, executingCase, !=, null, ), {, Preconditions, ., checkState, (]
[false, ;, }, }, Node, executingCase, =, caseNode, ;, while, (, executingCase, !=, null, ), {, Preconditions, ., checkState, (]
[false, ;, }, }, Node, executingCase, =, caseNode, ;, while, (, executingCase, !=, null, ), {, Preconditions, ., checkState, (]
[=, caseNode, ;, while, (, executingCase, !=, null, ), {, Preconditions, ., checkState, (, executingCase, ., isDefaultCase, (, ), ||]
[=, caseNode, ;, while, (, executingCase, !=, null, ), {, Preconditions, ., checkState, (, executingCase, ., isDefaultCase, (, ), ||]
[null, ), {, Preconditions, ., checkState, (, executingCase, ., isDefaultCase, (, ), ||, executingCase, ., isCase, (, ), ), ;]
[null, ), {, Preconditions, ., checkState, (, executingCase, ., isDefaultCase, (, ), ||, executingCase, ., isCase, (, ), ), ;]
[., checkState, (, executingCase, ., isDefaultCase, (, ), ||, executingCase, ., isCase, (, ), ), ;, Preconditions, ., checkState, (]
[., checkState, (, executingCase, ., isDefaultCase, (, ), ||, executingCase, ., isCase, (, ), ), ;, Preconditions, ., checkState, (]
[., checkState, (, executingCase, ., isDefaultCase, (, ), ||, executingCase, ., isCase, (, ), ), ;, Preconditions, ., checkState, (]
[(, executingCase, ., isDefaultCase, (, ), ||, executingCase, ., isCase, (, ), ), ;, Preconditions, ., checkState, (, caseNode, ==]
[., isDefaultCase, (, ), ||, executingCase, ., isCase, (, ), ), ;, Preconditions, ., checkState, (, caseNode, ==, executingCase, ||]
[isDefaultCase, (, ), ||, executingCase, ., isCase, (, ), ), ;, Preconditions, ., checkState, (, caseNode, ==, executingCase, ||, !]
[isDefaultCase, (, ), ||, executingCase, ., isCase, (, ), ), ;, Preconditions, ., checkState, (, caseNode, ==, executingCase, ||, !]
[;, Preconditions, ., checkState, (, caseNode, ==, executingCase, ||, !, executingCase, ., isDefaultCase, (, ), ), ;, Node, block, =]
[;, Preconditions, ., checkState, (, caseNode, ==, executingCase, ||, !, executingCase, ., isDefaultCase, (, ), ), ;, Node, block, =]
[==, executingCase, ||, !, executingCase, ., isDefaultCase, (, ), ), ;, Node, block, =, executingCase, ., getLastChild, (, ), ;]
[==, executingCase, ||, !, executingCase, ., isDefaultCase, (, ), ), ;, Node, block, =, executingCase, ., getLastChild, (, ), ;]
[executingCase, ., isDefaultCase, (, ), ), ;, Node, block, =, executingCase, ., getLastChild, (, ), ;, Preconditions, ., checkState, (]
[executingCase, ., isDefaultCase, (, ), ), ;, Node, block, =, executingCase, ., getLastChild, (, ), ;, Preconditions, ., checkState, (]
[=, executingCase, ., getLastChild, (, ), ;, Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, if, (]
[=, executingCase, ., getLastChild, (, ), ;, Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, if, (]
[., isBlock, (, ), ), ;, if, (, block, ., hasChildren, (, ), ), {, for, (, Node, blockChild, :]
[., isBlock, (, ), ), ;, if, (, block, ., hasChildren, (, ), ), {, for, (, Node, blockChild, :]
[., hasChildren, (, ), ), {, for, (, Node, blockChild, :, block, ., children, (, ), ), {, switch, (]
[., hasChildren, (, ), ), {, for, (, Node, blockChild, :, block, ., children, (, ), ), {, switch, (]
[Node, blockChild, :, block, ., children, (, ), ), {, switch, (, blockChild, ., getType, (, ), ), {, case]
[Node, blockChild, :, block, ., children, (, ), ), {, switch, (, blockChild, ., getType, (, ), ), {, case]
[children, (, ), ), {, switch, (, blockChild, ., getType, (, ), ), {, case, Token, ., BREAK, :, return]
[children, (, ), ), {, switch, (, blockChild, ., getType, (, ), ), {, case, Token, ., BREAK, :, return]
[children, (, ), ), {, switch, (, blockChild, ., getType, (, ), ), {, case, Token, ., BREAK, :, return]
[(, blockChild, ., getType, (, ), ), {, case, Token, ., BREAK, :, return, blockChild, ., getFirstChild, (, ), ==]
[getType, (, ), ), {, case, Token, ., BREAK, :, return, blockChild, ., getFirstChild, (, ), ==, null, ;, case]
[getType, (, ), ), {, case, Token, ., BREAK, :, return, blockChild, ., getFirstChild, (, ), ==, null, ;, case]
[Token, ., BREAK, :, return, blockChild, ., getFirstChild, (, ), ==, null, ;, case, Token, ., VAR, :, if, (]
[Token, ., BREAK, :, return, blockChild, ., getFirstChild, (, ), ==, null, ;, case, Token, ., VAR, :, if, (]
[Token, ., BREAK, :, return, blockChild, ., getFirstChild, (, ), ==, null, ;, case, Token, ., VAR, :, if, (]
[., getFirstChild, (, ), ==, null, ;, case, Token, ., VAR, :, if, (, blockChild, ., hasOneChild, (, ), &&]
[., getFirstChild, (, ), ==, null, ;, case, Token, ., VAR, :, if, (, blockChild, ., hasOneChild, (, ), &&]
[., getFirstChild, (, ), ==, null, ;, case, Token, ., VAR, :, if, (, blockChild, ., hasOneChild, (, ), &&]
[., getFirstChild, (, ), ==, null, ;, case, Token, ., VAR, :, if, (, blockChild, ., hasOneChild, (, ), &&]
[VAR, :, if, (, blockChild, ., hasOneChild, (, ), &&, blockChild, ., getFirstChild, (, ), ., getFirstChild, (, ), ==]
[(, ), &&, blockChild, ., getFirstChild, (, ), ., getFirstChild, (, ), ==, null, ), {, continue, ;, }, return]
[getFirstChild, (, ), ., getFirstChild, (, ), ==, null, ), {, continue, ;, }, return, false, ;, default, :, return]
[==, null, ), {, continue, ;, }, return, false, ;, default, :, return, false, ;, }, }, }, else, {]
[), {, continue, ;, }, return, false, ;, default, :, return, false, ;, }, }, }, else, {, executingCase, =]
[), {, continue, ;, }, return, false, ;, default, :, return, false, ;, }, }, }, else, {, executingCase, =]
[:, return, false, ;, }, }, }, else, {, executingCase, =, executingCase, ., getNext, (, ), ;, }, }, return]
[getNext, (, ), ;, }, }, return, true, ;, }, private, boolean, isExit, (, Node, n, ), {, switch, (]
[getNext, (, ), ;, }, }, return, true, ;, }, private, boolean, isExit, (, Node, n, ), {, switch, (]
[;, }, private, boolean, isExit, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, private, boolean, isExit, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., BREAK, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., BREAK, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., BREAK, :, case, Token, ., CONTINUE, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., BREAK, :, case, Token, ., CONTINUE, :, case]
[(, ), ), {, case, Token, ., BREAK, :, case, Token, ., CONTINUE, :, case, Token, ., RETURN, :, case]
[(, ), ), {, case, Token, ., BREAK, :, case, Token, ., CONTINUE, :, case, Token, ., RETURN, :, case]
[Token, ., BREAK, :, case, Token, ., CONTINUE, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, return]
[Token, ., CONTINUE, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, return, true, ;, default, :, return]
[true, ;, default, :, return, false, ;, }, }, private, Node, tryFoldComma, (, Node, n, ), {, Node, parent, =]
[true, ;, default, :, return, false, ;, }, }, private, Node, tryFoldComma, (, Node, n, ), {, Node, parent, =]
[private, Node, tryFoldComma, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, left, =]
[private, Node, tryFoldComma, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, left, =]
[parent, =, n, ., getParent, (, ), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =]
[parent, =, n, ., getParent, (, ), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =]
[), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;]
[Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, left, =]
[=, n, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, left, =, trySimplifyUnusedResult, (]
[), ;, Node, right, =, left, ., getNext, (, ), ;, left, =, trySimplifyUnusedResult, (, left, ), ;, if, (]
[), ;, Node, right, =, left, ., getNext, (, ), ;, left, =, trySimplifyUnusedResult, (, left, ), ;, if, (]
[), ;, Node, right, =, left, ., getNext, (, ), ;, left, =, trySimplifyUnusedResult, (, left, ), ;, if, (]
[Node, right, =, left, ., getNext, (, ), ;, left, =, trySimplifyUnusedResult, (, left, ), ;, if, (, left, ==]
[=, left, ., getNext, (, ), ;, left, =, trySimplifyUnusedResult, (, left, ), ;, if, (, left, ==, null, ||]
[left, ., getNext, (, ), ;, left, =, trySimplifyUnusedResult, (, left, ), ;, if, (, left, ==, null, ||, !]
[getNext, (, ), ;, left, =, trySimplifyUnusedResult, (, left, ), ;, if, (, left, ==, null, ||, !, mayHaveSideEffects, (]
[left, =, trySimplifyUnusedResult, (, left, ), ;, if, (, left, ==, null, ||, !, mayHaveSideEffects, (, left, ), ), {]
[left, =, trySimplifyUnusedResult, (, left, ), ;, if, (, left, ==, null, ||, !, mayHaveSideEffects, (, left, ), ), {]
[left, ), ;, if, (, left, ==, null, ||, !, mayHaveSideEffects, (, left, ), ), {, n, ., removeChild, (]
[if, (, left, ==, null, ||, !, mayHaveSideEffects, (, left, ), ), {, n, ., removeChild, (, right, ), ;]
[if, (, left, ==, null, ||, !, mayHaveSideEffects, (, left, ), ), {, n, ., removeChild, (, right, ), ;]
[null, ||, !, mayHaveSideEffects, (, left, ), ), {, n, ., removeChild, (, right, ), ;, parent, ., replaceChild, (]
[!, mayHaveSideEffects, (, left, ), ), {, n, ., removeChild, (, right, ), ;, parent, ., replaceChild, (, n, ,]
[left, ), ), {, n, ., removeChild, (, right, ), ;, parent, ., replaceChild, (, n, ,, right, ), ;]
[., removeChild, (, right, ), ;, parent, ., replaceChild, (, n, ,, right, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, right, ), ;, reportCodeChange, (, ), ;, return, right, ;, }, return]
[return, right, ;, }, return, n, ;, }, Node, tryOptimizeBlock, (, Node, n, ), {, for, (, Node, c, =]
[return, right, ;, }, return, n, ;, }, Node, tryOptimizeBlock, (, Node, n, ), {, for, (, Node, c, =]
[;, }, Node, tryOptimizeBlock, (, Node, n, ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[;, }, Node, tryOptimizeBlock, (, Node, n, ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[Node, tryOptimizeBlock, (, Node, n, ), {, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, ), {, Node, next, =]
[for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, ), {, Node, next, =]
[(, ), ;, c, !=, null, ;, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (]
[(, ), ;, c, !=, null, ;, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (]
[), ;, c, !=, null, ;, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (, !]
[c, !=, null, ;, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (, !, isUnremovableNode, (]
[;, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (, !, isUnremovableNode, (, c, ), &&]
[), {, Node, next, =, c, ., getNext, (, ), ;, if, (, !, isUnremovableNode, (, c, ), &&, !]
[Node, next, =, c, ., getNext, (, ), ;, if, (, !, isUnremovableNode, (, c, ), &&, !, mayHaveSideEffects, (]
[., getNext, (, ), ;, if, (, !, isUnremovableNode, (, c, ), &&, !, mayHaveSideEffects, (, c, ), ), {]
[., getNext, (, ), ;, if, (, !, isUnremovableNode, (, c, ), &&, !, mayHaveSideEffects, (, c, ), ), {]
[;, if, (, !, isUnremovableNode, (, c, ), &&, !, mayHaveSideEffects, (, c, ), ), {, n, ., removeChild, (]
[!, isUnremovableNode, (, c, ), &&, !, mayHaveSideEffects, (, c, ), ), {, n, ., removeChild, (, c, ), ;]
[mayHaveSideEffects, (, c, ), ), {, n, ., removeChild, (, c, ), ;, reportCodeChange, (, ), ;, }, else, {]
[c, ), ), {, n, ., removeChild, (, c, ), ;, reportCodeChange, (, ), ;, }, else, {, tryOptimizeConditionalAfterAssign, (]
[n, ., removeChild, (, c, ), ;, reportCodeChange, (, ), ;, }, else, {, tryOptimizeConditionalAfterAssign, (, c, ), ;, }]
[removeChild, (, c, ), ;, reportCodeChange, (, ), ;, }, else, {, tryOptimizeConditionalAfterAssign, (, c, ), ;, }, c, =]
[reportCodeChange, (, ), ;, }, else, {, tryOptimizeConditionalAfterAssign, (, c, ), ;, }, c, =, next, ;, }, if, (]
[reportCodeChange, (, ), ;, }, else, {, tryOptimizeConditionalAfterAssign, (, c, ), ;, }, c, =, next, ;, }, if, (]
[reportCodeChange, (, ), ;, }, else, {, tryOptimizeConditionalAfterAssign, (, c, ), ;, }, c, =, next, ;, }, if, (]
[{, tryOptimizeConditionalAfterAssign, (, c, ), ;, }, c, =, next, ;, }, if, (, n, ., isSyntheticBlock, (, ), ||]
[{, tryOptimizeConditionalAfterAssign, (, c, ), ;, }, c, =, next, ;, }, if, (, n, ., isSyntheticBlock, (, ), ||]
[{, tryOptimizeConditionalAfterAssign, (, c, ), ;, }, c, =, next, ;, }, if, (, n, ., isSyntheticBlock, (, ), ||]
[}, c, =, next, ;, }, if, (, n, ., isSyntheticBlock, (, ), ||, n, ., getParent, (, ), ==]
[;, }, if, (, n, ., isSyntheticBlock, (, ), ||, n, ., getParent, (, ), ==, null, ), {, return]
[., isSyntheticBlock, (, ), ||, n, ., getParent, (, ), ==, null, ), {, return, n, ;, }, if, (]
[., isSyntheticBlock, (, ), ||, n, ., getParent, (, ), ==, null, ), {, return, n, ;, }, if, (]
[||, n, ., getParent, (, ), ==, null, ), {, return, n, ;, }, if, (, NodeUtil, ., tryMergeBlock, (]
[(, ), ==, null, ), {, return, n, ;, }, if, (, NodeUtil, ., tryMergeBlock, (, n, ), ), {]
[{, return, n, ;, }, if, (, NodeUtil, ., tryMergeBlock, (, n, ), ), {, reportCodeChange, (, ), ;, return]
[}, if, (, NodeUtil, ., tryMergeBlock, (, n, ), ), {, reportCodeChange, (, ), ;, return, null, ;, }, return]
[(, ), ;, return, null, ;, }, return, n, ;, }, private, boolean, isUnremovableNode, (, Node, n, ), {, return]
[(, ), ;, return, null, ;, }, return, n, ;, }, private, boolean, isUnremovableNode, (, Node, n, ), {, return]
[), ;, return, null, ;, }, return, n, ;, }, private, boolean, isUnremovableNode, (, Node, n, ), {, return, (]
[), ;, return, null, ;, }, return, n, ;, }, private, boolean, isUnremovableNode, (, Node, n, ), {, return, (]
[), ;, return, null, ;, }, return, n, ;, }, private, boolean, isUnremovableNode, (, Node, n, ), {, return, (]
[return, n, ;, }, private, boolean, isUnremovableNode, (, Node, n, ), {, return, (, n, ., isBlock, (, ), &&]
[return, n, ;, }, private, boolean, isUnremovableNode, (, Node, n, ), {, return, (, n, ., isBlock, (, ), &&]
[(, Node, n, ), {, return, (, n, ., isBlock, (, ), &&, n, ., isSyntheticBlock, (, ), ), ||]
[(, Node, n, ), {, return, (, n, ., isBlock, (, ), &&, n, ., isSyntheticBlock, (, ), ), ||]
[), ||, n, ., isScript, (, ), ;, }, private, void, tryOptimizeConditionalAfterAssign, (, Node, n, ), {, Node, next, =]
[), ||, n, ., isScript, (, ), ;, }, private, void, tryOptimizeConditionalAfterAssign, (, Node, n, ), {, Node, next, =]
[}, private, void, tryOptimizeConditionalAfterAssign, (, Node, n, ), {, Node, next, =, n, ., getNext, (, ), ;, if, (]
[}, private, void, tryOptimizeConditionalAfterAssign, (, Node, n, ), {, Node, next, =, n, ., getNext, (, ), ;, if, (]
[void, tryOptimizeConditionalAfterAssign, (, Node, n, ), {, Node, next, =, n, ., getNext, (, ), ;, if, (, isSimpleAssignment, (]
[Node, n, ), {, Node, next, =, n, ., getNext, (, ), ;, if, (, isSimpleAssignment, (, n, ), &&]
[), {, Node, next, =, n, ., getNext, (, ), ;, if, (, isSimpleAssignment, (, n, ), &&, isConditionalStatement, (]
[getNext, (, ), ;, if, (, isSimpleAssignment, (, n, ), &&, isConditionalStatement, (, next, ), ), {, Node, lhsAssign, =]
[), ;, if, (, isSimpleAssignment, (, n, ), &&, isConditionalStatement, (, next, ), ), {, Node, lhsAssign, =, getSimpleAssignmentName, (]
[n, ), &&, isConditionalStatement, (, next, ), ), {, Node, lhsAssign, =, getSimpleAssignmentName, (, n, ), ;, Node, condition, =]
[&&, isConditionalStatement, (, next, ), ), {, Node, lhsAssign, =, getSimpleAssignmentName, (, n, ), ;, Node, condition, =, getConditionalStatementCondition, (]
[), {, Node, lhsAssign, =, getSimpleAssignmentName, (, n, ), ;, Node, condition, =, getConditionalStatementCondition, (, next, ), ;, if, (]
[), {, Node, lhsAssign, =, getSimpleAssignmentName, (, n, ), ;, Node, condition, =, getConditionalStatementCondition, (, next, ), ;, if, (]
[), {, Node, lhsAssign, =, getSimpleAssignmentName, (, n, ), ;, Node, condition, =, getConditionalStatementCondition, (, next, ), ;, if, (]
[), {, Node, lhsAssign, =, getSimpleAssignmentName, (, n, ), ;, Node, condition, =, getConditionalStatementCondition, (, next, ), ;, if, (]
[(, n, ), ;, Node, condition, =, getConditionalStatementCondition, (, next, ), ;, if, (, lhsAssign, ., isName, (, ), &&]
[(, n, ), ;, Node, condition, =, getConditionalStatementCondition, (, next, ), ;, if, (, lhsAssign, ., isName, (, ), &&]
[=, getConditionalStatementCondition, (, next, ), ;, if, (, lhsAssign, ., isName, (, ), &&, condition, ., isName, (, ), &&]
[=, getConditionalStatementCondition, (, next, ), ;, if, (, lhsAssign, ., isName, (, ), &&, condition, ., isName, (, ), &&]
[=, getConditionalStatementCondition, (, next, ), ;, if, (, lhsAssign, ., isName, (, ), &&, condition, ., isName, (, ), &&]
[lhsAssign, ., isName, (, ), &&, condition, ., isName, (, ), &&, lhsAssign, ., getString, (, ), ., equals, (]
[lhsAssign, ., isName, (, ), &&, condition, ., isName, (, ), &&, lhsAssign, ., getString, (, ), ., equals, (]
[&&, lhsAssign, ., getString, (, ), ., equals, (, condition, ., getString, (, ), ), ), {, Node, rhsAssign, =]
[., getString, (, ), ., equals, (, condition, ., getString, (, ), ), ), {, Node, rhsAssign, =, getSimpleAssignmentValue, (]
[(, condition, ., getString, (, ), ), ), {, Node, rhsAssign, =, getSimpleAssignmentValue, (, n, ), ;, TernaryValue, value, =]
[(, condition, ., getString, (, ), ), ), {, Node, rhsAssign, =, getSimpleAssignmentValue, (, n, ), ;, TernaryValue, value, =]
[(, ), ), ), {, Node, rhsAssign, =, getSimpleAssignmentValue, (, n, ), ;, TernaryValue, value, =, NodeUtil, ., getImpureBooleanValue, (]
[Node, rhsAssign, =, getSimpleAssignmentValue, (, n, ), ;, TernaryValue, value, =, NodeUtil, ., getImpureBooleanValue, (, rhsAssign, ), ;, if, (]
[Node, rhsAssign, =, getSimpleAssignmentValue, (, n, ), ;, TernaryValue, value, =, NodeUtil, ., getImpureBooleanValue, (, rhsAssign, ), ;, if, (]
[=, getSimpleAssignmentValue, (, n, ), ;, TernaryValue, value, =, NodeUtil, ., getImpureBooleanValue, (, rhsAssign, ), ;, if, (, value, !=]
[=, getSimpleAssignmentValue, (, n, ), ;, TernaryValue, value, =, NodeUtil, ., getImpureBooleanValue, (, rhsAssign, ), ;, if, (, value, !=]
[=, NodeUtil, ., getImpureBooleanValue, (, rhsAssign, ), ;, if, (, value, !=, TernaryValue, ., UNKNOWN, ), {, Node, replacementConditionNode, =]
[=, NodeUtil, ., getImpureBooleanValue, (, rhsAssign, ), ;, if, (, value, !=, TernaryValue, ., UNKNOWN, ), {, Node, replacementConditionNode, =]
[(, rhsAssign, ), ;, if, (, value, !=, TernaryValue, ., UNKNOWN, ), {, Node, replacementConditionNode, =, NodeUtil, ., booleanNode, (]
[(, rhsAssign, ), ;, if, (, value, !=, TernaryValue, ., UNKNOWN, ), {, Node, replacementConditionNode, =, NodeUtil, ., booleanNode, (]
[if, (, value, !=, TernaryValue, ., UNKNOWN, ), {, Node, replacementConditionNode, =, NodeUtil, ., booleanNode, (, value, ., toBoolean, (]
[TernaryValue, ., UNKNOWN, ), {, Node, replacementConditionNode, =, NodeUtil, ., booleanNode, (, value, ., toBoolean, (, true, ), ), ;]
[TernaryValue, ., UNKNOWN, ), {, Node, replacementConditionNode, =, NodeUtil, ., booleanNode, (, value, ., toBoolean, (, true, ), ), ;]
[TernaryValue, ., UNKNOWN, ), {, Node, replacementConditionNode, =, NodeUtil, ., booleanNode, (, value, ., toBoolean, (, true, ), ), ;]
[NodeUtil, ., booleanNode, (, value, ., toBoolean, (, true, ), ), ;, condition, ., getParent, (, ), ., replaceChild, (]
[booleanNode, (, value, ., toBoolean, (, true, ), ), ;, condition, ., getParent, (, ), ., replaceChild, (, condition, ,]
[., toBoolean, (, true, ), ), ;, condition, ., getParent, (, ), ., replaceChild, (, condition, ,, replacementConditionNode, ), ;]
[), ;, reportCodeChange, (, ), ;, }, }, }, }, private, boolean, isSimpleAssignment, (, Node, n, ), {, if, (]
[), ;, reportCodeChange, (, ), ;, }, }, }, }, private, boolean, isSimpleAssignment, (, Node, n, ), {, if, (]
[), ;, reportCodeChange, (, ), ;, }, }, }, }, private, boolean, isSimpleAssignment, (, Node, n, ), {, if, (]
[), ;, }, }, }, }, private, boolean, isSimpleAssignment, (, Node, n, ), {, if, (, NodeUtil, ., isExprAssign, (]
[}, }, }, private, boolean, isSimpleAssignment, (, Node, n, ), {, if, (, NodeUtil, ., isExprAssign, (, n, ), &&]
[}, }, }, private, boolean, isSimpleAssignment, (, Node, n, ), {, if, (, NodeUtil, ., isExprAssign, (, n, ), &&]
[}, }, }, private, boolean, isSimpleAssignment, (, Node, n, ), {, if, (, NodeUtil, ., isExprAssign, (, n, ), &&]
[}, }, }, private, boolean, isSimpleAssignment, (, Node, n, ), {, if, (, NodeUtil, ., isExprAssign, (, n, ), &&]
[(, n, ), &&, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ., isName, (, ), ), {, return]
[getFirstChild, (, ), ., getFirstChild, (, ), ., isName, (, ), ), {, return, true, ;, }, else, if, (]
[getFirstChild, (, ), ., getFirstChild, (, ), ., isName, (, ), ), {, return, true, ;, }, else, if, (]
[getFirstChild, (, ), ., getFirstChild, (, ), ., isName, (, ), ), {, return, true, ;, }, else, if, (]
[getFirstChild, (, ), ., getFirstChild, (, ), ., isName, (, ), ), {, return, true, ;, }, else, if, (]
[), ., isName, (, ), ), {, return, true, ;, }, else, if, (, n, ., isVar, (, ), &&]
[), ., isName, (, ), ), {, return, true, ;, }, else, if, (, n, ., isVar, (, ), &&]
[{, return, true, ;, }, else, if, (, n, ., isVar, (, ), &&, n, ., hasOneChild, (, ), &&]
[{, return, true, ;, }, else, if, (, n, ., isVar, (, ), &&, n, ., hasOneChild, (, ), &&]
[{, return, true, ;, }, else, if, (, n, ., isVar, (, ), &&, n, ., hasOneChild, (, ), &&]
[{, return, true, ;, }, else, if, (, n, ., isVar, (, ), &&, n, ., hasOneChild, (, ), &&]
[isVar, (, ), &&, n, ., hasOneChild, (, ), &&, n, ., getFirstChild, (, ), ., getFirstChild, (, ), !=]
[n, ., hasOneChild, (, ), &&, n, ., getFirstChild, (, ), ., getFirstChild, (, ), !=, null, ), {, return]
[), &&, n, ., getFirstChild, (, ), ., getFirstChild, (, ), !=, null, ), {, return, true, ;, }, return]
[!=, null, ), {, return, true, ;, }, return, false, ;, }, private, Node, getSimpleAssignmentName, (, Node, n, ), {]
[!=, null, ), {, return, true, ;, }, return, false, ;, }, private, Node, getSimpleAssignmentName, (, Node, n, ), {]
[return, true, ;, }, return, false, ;, }, private, Node, getSimpleAssignmentName, (, Node, n, ), {, Preconditions, ., checkState, (]
[;, }, return, false, ;, }, private, Node, getSimpleAssignmentName, (, Node, n, ), {, Preconditions, ., checkState, (, isSimpleAssignment, (]
[private, Node, getSimpleAssignmentName, (, Node, n, ), {, Preconditions, ., checkState, (, isSimpleAssignment, (, n, ), ), ;, if, (]
[private, Node, getSimpleAssignmentName, (, Node, n, ), {, Preconditions, ., checkState, (, isSimpleAssignment, (, n, ), ), ;, if, (]
[Node, n, ), {, Preconditions, ., checkState, (, isSimpleAssignment, (, n, ), ), ;, if, (, NodeUtil, ., isExprAssign, (]
[., checkState, (, isSimpleAssignment, (, n, ), ), ;, if, (, NodeUtil, ., isExprAssign, (, n, ), ), {, return]
[., checkState, (, isSimpleAssignment, (, n, ), ), ;, if, (, NodeUtil, ., isExprAssign, (, n, ), ), {, return]
[., checkState, (, isSimpleAssignment, (, n, ), ), ;, if, (, NodeUtil, ., isExprAssign, (, n, ), ), {, return]
[(, n, ), ), {, return, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, else, {, return]
[(, n, ), ), {, return, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, else, {, return]
[}, else, {, return, n, ., getFirstChild, (, ), ;, }, }, private, Node, getSimpleAssignmentValue, (, Node, n, ), {]
[}, else, {, return, n, ., getFirstChild, (, ), ;, }, }, private, Node, getSimpleAssignmentValue, (, Node, n, ), {]
[n, ., getFirstChild, (, ), ;, }, }, private, Node, getSimpleAssignmentValue, (, Node, n, ), {, Preconditions, ., checkState, (]
[getFirstChild, (, ), ;, }, }, private, Node, getSimpleAssignmentValue, (, Node, n, ), {, Preconditions, ., checkState, (, isSimpleAssignment, (]
[}, private, Node, getSimpleAssignmentValue, (, Node, n, ), {, Preconditions, ., checkState, (, isSimpleAssignment, (, n, ), ), ;, return]
[}, private, Node, getSimpleAssignmentValue, (, Node, n, ), {, Preconditions, ., checkState, (, isSimpleAssignment, (, n, ), ), ;, return]
[}, private, Node, getSimpleAssignmentValue, (, Node, n, ), {, Preconditions, ., checkState, (, isSimpleAssignment, (, n, ), ), ;, return]
[n, ., getFirstChild, (, ), ., getLastChild, (, ), ;, }, private, boolean, isConditionalStatement, (, Node, n, ), {, return]
[n, ., getFirstChild, (, ), ., getLastChild, (, ), ;, }, private, boolean, isConditionalStatement, (, Node, n, ), {, return]
[n, ., getFirstChild, (, ), ., getLastChild, (, ), ;, }, private, boolean, isConditionalStatement, (, Node, n, ), {, return]
[getFirstChild, (, ), ., getLastChild, (, ), ;, }, private, boolean, isConditionalStatement, (, Node, n, ), {, return, n, !=]
[), ., getLastChild, (, ), ;, }, private, boolean, isConditionalStatement, (, Node, n, ), {, return, n, !=, null, &&]
[., getLastChild, (, ), ;, }, private, boolean, isConditionalStatement, (, Node, n, ), {, return, n, !=, null, &&, (]
[., getLastChild, (, ), ;, }, private, boolean, isConditionalStatement, (, Node, n, ), {, return, n, !=, null, &&, (]
[., getLastChild, (, ), ;, }, private, boolean, isConditionalStatement, (, Node, n, ), {, return, n, !=, null, &&, (]
[private, boolean, isConditionalStatement, (, Node, n, ), {, return, n, !=, null, &&, (, n, ., isIf, (, ), ||]
[isConditionalStatement, (, Node, n, ), {, return, n, !=, null, &&, (, n, ., isIf, (, ), ||, isExprConditional, (]
[(, ), ||, isExprConditional, (, n, ), ), ;, }, private, boolean, isExprConditional, (, Node, n, ), {, if, (]
[(, ), ||, isExprConditional, (, n, ), ), ;, }, private, boolean, isExprConditional, (, Node, n, ), {, if, (]
[}, private, boolean, isExprConditional, (, Node, n, ), {, if, (, n, ., isExprResult, (, ), ), {, switch, (]
[}, private, boolean, isExprConditional, (, Node, n, ), {, if, (, n, ., isExprResult, (, ), ), {, switch, (]
[}, private, boolean, isExprConditional, (, Node, n, ), {, if, (, n, ., isExprResult, (, ), ), {, switch, (]
[., isExprResult, (, ), ), {, switch, (, n, ., getFirstChild, (, ), ., getType, (, ), ), {, case]
[., isExprResult, (, ), ), {, switch, (, n, ., getFirstChild, (, ), ., getType, (, ), ), {, case]
[{, switch, (, n, ., getFirstChild, (, ), ., getType, (, ), ), {, case, Token, ., HOOK, :, case]
[{, switch, (, n, ., getFirstChild, (, ), ., getType, (, ), ), {, case, Token, ., HOOK, :, case]
[getFirstChild, (, ), ., getType, (, ), ), {, case, Token, ., HOOK, :, case, Token, ., AND, :, case]
[getFirstChild, (, ), ., getType, (, ), ), {, case, Token, ., HOOK, :, case, Token, ., AND, :, case]
[(, ), ), {, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return]
[Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, true, ;, }, }, return]
[:, return, true, ;, }, }, return, false, ;, }, private, Node, getConditionalStatementCondition, (, Node, n, ), {, if, (]
[:, return, true, ;, }, }, return, false, ;, }, private, Node, getConditionalStatementCondition, (, Node, n, ), {, if, (]
[;, }, private, Node, getConditionalStatementCondition, (, Node, n, ), {, if, (, n, ., isIf, (, ), ), {, return]
[;, }, private, Node, getConditionalStatementCondition, (, Node, n, ), {, if, (, n, ., isIf, (, ), ), {, return]
[getConditionalStatementCondition, (, Node, n, ), {, if, (, n, ., isIf, (, ), ), {, return, NodeUtil, ., getConditionExpression, (]
[if, (, n, ., isIf, (, ), ), {, return, NodeUtil, ., getConditionExpression, (, n, ), ;, }, else, {]
[if, (, n, ., isIf, (, ), ), {, return, NodeUtil, ., getConditionExpression, (, n, ), ;, }, else, {]
[isIf, (, ), ), {, return, NodeUtil, ., getConditionExpression, (, n, ), ;, }, else, {, Preconditions, ., checkState, (]
[), ), {, return, NodeUtil, ., getConditionExpression, (, n, ), ;, }, else, {, Preconditions, ., checkState, (, isExprConditional, (]
[., getConditionExpression, (, n, ), ;, }, else, {, Preconditions, ., checkState, (, isExprConditional, (, n, ), ), ;, return]
[., getConditionExpression, (, n, ), ;, }, else, {, Preconditions, ., checkState, (, isExprConditional, (, n, ), ), ;, return]
[., getConditionExpression, (, n, ), ;, }, else, {, Preconditions, ., checkState, (, isExprConditional, (, n, ), ), ;, return]
[n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, }, private, Node, tryFoldIf, (, Node, n, ), {]
[n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, }, private, Node, tryFoldIf, (, Node, n, ), {]
[), ., getFirstChild, (, ), ;, }, }, private, Node, tryFoldIf, (, Node, n, ), {, Preconditions, ., checkState, (]
[), ., getFirstChild, (, ), ;, }, }, private, Node, tryFoldIf, (, Node, n, ), {, Preconditions, ., checkState, (]
[tryFoldIf, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isIf, (, ), ), ;, Node, parent, =]
[tryFoldIf, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isIf, (, ), ), ;, Node, parent, =]
[Preconditions, ., checkState, (, n, ., isIf, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;]
[Preconditions, ., checkState, (, n, ., isIf, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;]
[n, ., isIf, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (]
[;, Node, parent, =, n, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, parent, ), ;, int, type, =]
[;, Node, parent, =, n, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, parent, ), ;, int, type, =]
[;, Preconditions, ., checkNotNull, (, parent, ), ;, int, type, =, n, ., getType, (, ), ;, Node, cond, =]
[;, Preconditions, ., checkNotNull, (, parent, ), ;, int, type, =, n, ., getType, (, ), ;, Node, cond, =]
[type, =, n, ., getType, (, ), ;, Node, cond, =, n, ., getFirstChild, (, ), ;, Node, thenBody, =]
[type, =, n, ., getType, (, ), ;, Node, cond, =, n, ., getFirstChild, (, ), ;, Node, thenBody, =]
[cond, =, n, ., getFirstChild, (, ), ;, Node, thenBody, =, cond, ., getNext, (, ), ;, Node, elseBody, =]
[cond, =, n, ., getFirstChild, (, ), ;, Node, thenBody, =, cond, ., getNext, (, ), ;, Node, elseBody, =]
[Node, thenBody, =, cond, ., getNext, (, ), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, if, (]
[Node, thenBody, =, cond, ., getNext, (, ), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, if, (]
[Node, thenBody, =, cond, ., getNext, (, ), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, if, (]
[=, cond, ., getNext, (, ), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, if, (, elseBody, !=]
[., getNext, (, ), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, if, (, elseBody, !=, null, &&]
[getNext, (, ), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, if, (, elseBody, !=, null, &&, !]
[), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, if, (, elseBody, !=, null, &&, !, mayHaveSideEffects, (]
[=, thenBody, ., getNext, (, ), ;, if, (, elseBody, !=, null, &&, !, mayHaveSideEffects, (, elseBody, ), ), {]
[=, thenBody, ., getNext, (, ), ;, if, (, elseBody, !=, null, &&, !, mayHaveSideEffects, (, elseBody, ), ), {]
[(, ), ;, if, (, elseBody, !=, null, &&, !, mayHaveSideEffects, (, elseBody, ), ), {, n, ., removeChild, (]
[if, (, elseBody, !=, null, &&, !, mayHaveSideEffects, (, elseBody, ), ), {, n, ., removeChild, (, elseBody, ), ;]
[elseBody, !=, null, &&, !, mayHaveSideEffects, (, elseBody, ), ), {, n, ., removeChild, (, elseBody, ), ;, elseBody, =]
[null, &&, !, mayHaveSideEffects, (, elseBody, ), ), {, n, ., removeChild, (, elseBody, ), ;, elseBody, =, null, ;]
[), {, n, ., removeChild, (, elseBody, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (]
[), {, n, ., removeChild, (, elseBody, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (]
[{, n, ., removeChild, (, elseBody, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !]
[., removeChild, (, elseBody, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (]
[elseBody, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&]
[elseBody, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&]
[;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, !=]
[null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, !=, null, ), {]
[null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, !=, null, ), {]
[), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, !=, null, ), {, n, ., removeChild, (]
[if, (, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, !=, null, ), {, n, ., removeChild, (, elseBody, ), ;]
[if, (, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, !=, null, ), {, n, ., removeChild, (, elseBody, ), ;]
[(, thenBody, ), &&, elseBody, !=, null, ), {, n, ., removeChild, (, elseBody, ), ;, n, ., replaceChild, (]
[), &&, elseBody, !=, null, ), {, n, ., removeChild, (, elseBody, ), ;, n, ., replaceChild, (, thenBody, ,]
[{, n, ., removeChild, (, elseBody, ), ;, n, ., replaceChild, (, thenBody, ,, elseBody, ), ;, Node, notCond, =]
[removeChild, (, elseBody, ), ;, n, ., replaceChild, (, thenBody, ,, elseBody, ), ;, Node, notCond, =, new, Node, (]
[removeChild, (, elseBody, ), ;, n, ., replaceChild, (, thenBody, ,, elseBody, ), ;, Node, notCond, =, new, Node, (]
[n, ., replaceChild, (, thenBody, ,, elseBody, ), ;, Node, notCond, =, new, Node, (, Token, ., NOT, ), ;]
[n, ., replaceChild, (, thenBody, ,, elseBody, ), ;, Node, notCond, =, new, Node, (, Token, ., NOT, ), ;]
[thenBody, ,, elseBody, ), ;, Node, notCond, =, new, Node, (, Token, ., NOT, ), ;, n, ., replaceChild, (]
[elseBody, ), ;, Node, notCond, =, new, Node, (, Token, ., NOT, ), ;, n, ., replaceChild, (, cond, ,]
[Node, notCond, =, new, Node, (, Token, ., NOT, ), ;, n, ., replaceChild, (, cond, ,, notCond, ), ;]
[Node, notCond, =, new, Node, (, Token, ., NOT, ), ;, n, ., replaceChild, (, cond, ,, notCond, ), ;]
[Node, (, Token, ., NOT, ), ;, n, ., replaceChild, (, cond, ,, notCond, ), ;, notCond, ., addChildToFront, (]
[., NOT, ), ;, n, ., replaceChild, (, cond, ,, notCond, ), ;, notCond, ., addChildToFront, (, cond, ), ;]
[), ;, n, ., replaceChild, (, cond, ,, notCond, ), ;, notCond, ., addChildToFront, (, cond, ), ;, cond, =]
[n, ., replaceChild, (, cond, ,, notCond, ), ;, notCond, ., addChildToFront, (, cond, ), ;, cond, =, notCond, ;]
[replaceChild, (, cond, ,, notCond, ), ;, notCond, ., addChildToFront, (, cond, ), ;, cond, =, notCond, ;, thenBody, =]
[replaceChild, (, cond, ,, notCond, ), ;, notCond, ., addChildToFront, (, cond, ), ;, cond, =, notCond, ;, thenBody, =]
[;, notCond, ., addChildToFront, (, cond, ), ;, cond, =, notCond, ;, thenBody, =, cond, ., getNext, (, ), ;]
[., addChildToFront, (, cond, ), ;, cond, =, notCond, ;, thenBody, =, cond, ., getNext, (, ), ;, elseBody, =]
[(, cond, ), ;, cond, =, notCond, ;, thenBody, =, cond, ., getNext, (, ), ;, elseBody, =, null, ;]
[;, thenBody, =, cond, ., getNext, (, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (]
[;, thenBody, =, cond, ., getNext, (, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (]
[thenBody, =, cond, ., getNext, (, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !]
[cond, ., getNext, (, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (]
[(, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&]
[(, ), ;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&]
[;, elseBody, =, null, ;, reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, ==]
[reportCodeChange, (, ), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, ==, null, ), {, if, (]
[), ;, }, if, (, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, ==, null, ), {, if, (, mayHaveSideEffects, (]
[(, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, ==, null, ), {, if, (, mayHaveSideEffects, (, cond, ), ), {]
[(, !, mayHaveSideEffects, (, thenBody, ), &&, elseBody, ==, null, ), {, if, (, mayHaveSideEffects, (, cond, ), ), {]
[thenBody, ), &&, elseBody, ==, null, ), {, if, (, mayHaveSideEffects, (, cond, ), ), {, n, ., removeChild, (]
[), {, if, (, mayHaveSideEffects, (, cond, ), ), {, n, ., removeChild, (, cond, ), ;, Node, replacement, =]
[), {, if, (, mayHaveSideEffects, (, cond, ), ), {, n, ., removeChild, (, cond, ), ;, Node, replacement, =]
[mayHaveSideEffects, (, cond, ), ), {, n, ., removeChild, (, cond, ), ;, Node, replacement, =, NodeUtil, ., newExpr, (]
[), ), {, n, ., removeChild, (, cond, ), ;, Node, replacement, =, NodeUtil, ., newExpr, (, cond, ), ;]
[), ), {, n, ., removeChild, (, cond, ), ;, Node, replacement, =, NodeUtil, ., newExpr, (, cond, ), ;]
[., removeChild, (, cond, ), ;, Node, replacement, =, NodeUtil, ., newExpr, (, cond, ), ;, parent, ., replaceChild, (]
[(, cond, ), ;, Node, replacement, =, NodeUtil, ., newExpr, (, cond, ), ;, parent, ., replaceChild, (, n, ,]
[;, Node, replacement, =, NodeUtil, ., newExpr, (, cond, ), ;, parent, ., replaceChild, (, n, ,, replacement, ), ;]
[., newExpr, (, cond, ), ;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
[;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, else, {]
[;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, else, {]
[(, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, else, {, NodeUtil, ., removeChild, (]
[,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, else, {, NodeUtil, ., removeChild, (, parent, ,]
[;, reportCodeChange, (, ), ;, return, replacement, ;, }, else, {, NodeUtil, ., removeChild, (, parent, ,, n, ), ;]
[return, replacement, ;, }, else, {, NodeUtil, ., removeChild, (, parent, ,, n, ), ;, reportCodeChange, (, ), ;, return]
[., removeChild, (, parent, ,, n, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, }, TernaryValue, condValue, =]
[., removeChild, (, parent, ,, n, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, }, TernaryValue, condValue, =]
[,, n, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, }, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (]
[(, ), ;, return, null, ;, }, }, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (]
[(, ), ;, return, null, ;, }, }, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (]
[;, return, null, ;, }, }, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (, condValue, ==]
[;, return, null, ;, }, }, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (, condValue, ==]
[TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (, condValue, ==, TernaryValue, ., UNKNOWN, ), {, return]
[getImpureBooleanValue, (, cond, ), ;, if, (, condValue, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, if, (]
[cond, ), ;, if, (, condValue, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, if, (, mayHaveSideEffects, (]
[TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, cond, ), ), {, boolean, newConditionValue, =]
[TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, cond, ), ), {, boolean, newConditionValue, =]
[UNKNOWN, ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, cond, ), ), {, boolean, newConditionValue, =, condValue, ==]
[UNKNOWN, ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, cond, ), ), {, boolean, newConditionValue, =, condValue, ==]
[}, if, (, mayHaveSideEffects, (, cond, ), ), {, boolean, newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (]
[}, if, (, mayHaveSideEffects, (, cond, ), ), {, boolean, newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (]
[if, (, mayHaveSideEffects, (, cond, ), ), {, boolean, newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (, !]
[mayHaveSideEffects, (, cond, ), ), {, boolean, newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (, !, newConditionValue, &&]
[mayHaveSideEffects, (, cond, ), ), {, boolean, newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (, !, newConditionValue, &&]
[cond, ), ), {, boolean, newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (, !, newConditionValue, &&, elseBody, ==]
[{, boolean, newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (, !, newConditionValue, &&, elseBody, ==, null, ), {]
[newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (, !, newConditionValue, &&, elseBody, ==, null, ), {, elseBody, =]
[newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (, !, newConditionValue, &&, elseBody, ==, null, ), {, elseBody, =]
[newConditionValue, =, condValue, ==, TernaryValue, ., TRUE, ;, if, (, !, newConditionValue, &&, elseBody, ==, null, ), {, elseBody, =]
[if, (, !, newConditionValue, &&, elseBody, ==, null, ), {, elseBody, =, IR, ., block, (, ), ., srcref, (]
[newConditionValue, &&, elseBody, ==, null, ), {, elseBody, =, IR, ., block, (, ), ., srcref, (, n, ), ;]
[newConditionValue, &&, elseBody, ==, null, ), {, elseBody, =, IR, ., block, (, ), ., srcref, (, n, ), ;]
[null, ), {, elseBody, =, IR, ., block, (, ), ., srcref, (, n, ), ;, n, ., addChildToBack, (]
[block, (, ), ., srcref, (, n, ), ;, n, ., addChildToBack, (, elseBody, ), ;, }, Node, newCond, =]
[block, (, ), ., srcref, (, n, ), ;, n, ., addChildToBack, (, elseBody, ), ;, }, Node, newCond, =]
[srcref, (, n, ), ;, n, ., addChildToBack, (, elseBody, ), ;, }, Node, newCond, =, NodeUtil, ., booleanNode, (]
[), ;, n, ., addChildToBack, (, elseBody, ), ;, }, Node, newCond, =, NodeUtil, ., booleanNode, (, newConditionValue, ), ;]
[), ;, n, ., addChildToBack, (, elseBody, ), ;, }, Node, newCond, =, NodeUtil, ., booleanNode, (, newConditionValue, ), ;]
[addChildToBack, (, elseBody, ), ;, }, Node, newCond, =, NodeUtil, ., booleanNode, (, newConditionValue, ), ;, n, ., replaceChild, (]
[elseBody, ), ;, }, Node, newCond, =, NodeUtil, ., booleanNode, (, newConditionValue, ), ;, n, ., replaceChild, (, cond, ,]
[=, NodeUtil, ., booleanNode, (, newConditionValue, ), ;, n, ., replaceChild, (, cond, ,, newCond, ), ;, Node, branchToKeep, =]
[=, NodeUtil, ., booleanNode, (, newConditionValue, ), ;, n, ., replaceChild, (, cond, ,, newCond, ), ;, Node, branchToKeep, =]
[., booleanNode, (, newConditionValue, ), ;, n, ., replaceChild, (, cond, ,, newCond, ), ;, Node, branchToKeep, =, newConditionValue, ?]
[(, newConditionValue, ), ;, n, ., replaceChild, (, cond, ,, newCond, ), ;, Node, branchToKeep, =, newConditionValue, ?, thenBody, :]
[), ;, n, ., replaceChild, (, cond, ,, newCond, ), ;, Node, branchToKeep, =, newConditionValue, ?, thenBody, :, elseBody, ;]
[), ;, n, ., replaceChild, (, cond, ,, newCond, ), ;, Node, branchToKeep, =, newConditionValue, ?, thenBody, :, elseBody, ;]
[replaceChild, (, cond, ,, newCond, ), ;, Node, branchToKeep, =, newConditionValue, ?, thenBody, :, elseBody, ;, branchToKeep, ., addChildToFront, (]
[replaceChild, (, cond, ,, newCond, ), ;, Node, branchToKeep, =, newConditionValue, ?, thenBody, :, elseBody, ;, branchToKeep, ., addChildToFront, (]
[replaceChild, (, cond, ,, newCond, ), ;, Node, branchToKeep, =, newConditionValue, ?, thenBody, :, elseBody, ;, branchToKeep, ., addChildToFront, (]
[newCond, ), ;, Node, branchToKeep, =, newConditionValue, ?, thenBody, :, elseBody, ;, branchToKeep, ., addChildToFront, (, IR, ., exprResult, (]
[=, newConditionValue, ?, thenBody, :, elseBody, ;, branchToKeep, ., addChildToFront, (, IR, ., exprResult, (, cond, ), ., srcref, (]
[:, elseBody, ;, branchToKeep, ., addChildToFront, (, IR, ., exprResult, (, cond, ), ., srcref, (, cond, ), ), ;]
[., addChildToFront, (, IR, ., exprResult, (, cond, ), ., srcref, (, cond, ), ), ;, reportCodeChange, (, ), ;]
[(, IR, ., exprResult, (, cond, ), ., srcref, (, cond, ), ), ;, reportCodeChange, (, ), ;, cond, =]
[), ., srcref, (, cond, ), ), ;, reportCodeChange, (, ), ;, cond, =, newCond, ;, }, boolean, condTrue, =]
[), ., srcref, (, cond, ), ), ;, reportCodeChange, (, ), ;, cond, =, newCond, ;, }, boolean, condTrue, =]
[cond, ), ), ;, reportCodeChange, (, ), ;, cond, =, newCond, ;, }, boolean, condTrue, =, condValue, ., toBoolean, (]
[(, ), ;, cond, =, newCond, ;, }, boolean, condTrue, =, condValue, ., toBoolean, (, true, ), ;, if, (]
[(, ), ;, cond, =, newCond, ;, }, boolean, condTrue, =, condValue, ., toBoolean, (, true, ), ;, if, (]
[(, ), ;, cond, =, newCond, ;, }, boolean, condTrue, =, condValue, ., toBoolean, (, true, ), ;, if, (]
[;, }, boolean, condTrue, =, condValue, ., toBoolean, (, true, ), ;, if, (, n, ., getChildCount, (, ), ==]
[condTrue, =, condValue, ., toBoolean, (, true, ), ;, if, (, n, ., getChildCount, (, ), ==, 2, ), {]
[condTrue, =, condValue, ., toBoolean, (, true, ), ;, if, (, n, ., getChildCount, (, ), ==, 2, ), {]
[toBoolean, (, true, ), ;, if, (, n, ., getChildCount, (, ), ==, 2, ), {, Preconditions, ., checkState, (]
[toBoolean, (, true, ), ;, if, (, n, ., getChildCount, (, ), ==, 2, ), {, Preconditions, ., checkState, (]
[true, ), ;, if, (, n, ., getChildCount, (, ), ==, 2, ), {, Preconditions, ., checkState, (, type, ==]
[true, ), ;, if, (, n, ., getChildCount, (, ), ==, 2, ), {, Preconditions, ., checkState, (, type, ==]
[getChildCount, (, ), ==, 2, ), {, Preconditions, ., checkState, (, type, ==, Token, ., IF, ), ;, if, (]
[{, Preconditions, ., checkState, (, type, ==, Token, ., IF, ), ;, if, (, condTrue, ), {, Node, thenStmt, =]
[{, Preconditions, ., checkState, (, type, ==, Token, ., IF, ), ;, if, (, condTrue, ), {, Node, thenStmt, =]
[{, Preconditions, ., checkState, (, type, ==, Token, ., IF, ), ;, if, (, condTrue, ), {, Node, thenStmt, =]
[), ;, if, (, condTrue, ), {, Node, thenStmt, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;]
[), ;, if, (, condTrue, ), {, Node, thenStmt, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;]
[condTrue, ), {, Node, thenStmt, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, n, ., removeChild, (]
[Node, thenStmt, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, n, ., removeChild, (, thenStmt, ), ;]
[Node, thenStmt, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, n, ., removeChild, (, thenStmt, ), ;]
[., getFirstChild, (, ), ., getNext, (, ), ;, n, ., removeChild, (, thenStmt, ), ;, parent, ., replaceChild, (]
[(, ), ., getNext, (, ), ;, n, ., removeChild, (, thenStmt, ), ;, parent, ., replaceChild, (, n, ,]
[getNext, (, ), ;, n, ., removeChild, (, thenStmt, ), ;, parent, ., replaceChild, (, n, ,, thenStmt, ), ;]
[., removeChild, (, thenStmt, ), ;, parent, ., replaceChild, (, n, ,, thenStmt, ), ;, reportCodeChange, (, ), ;, return]
[;, parent, ., replaceChild, (, n, ,, thenStmt, ), ;, reportCodeChange, (, ), ;, return, thenStmt, ;, }, else, {]
[;, parent, ., replaceChild, (, n, ,, thenStmt, ), ;, reportCodeChange, (, ), ;, return, thenStmt, ;, }, else, {]
[(, n, ,, thenStmt, ), ;, reportCodeChange, (, ), ;, return, thenStmt, ;, }, else, {, NodeUtil, ., redeclareVarsInsideBranch, (]
[thenStmt, ), ;, reportCodeChange, (, ), ;, return, thenStmt, ;, }, else, {, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;]
[thenStmt, ), ;, reportCodeChange, (, ), ;, return, thenStmt, ;, }, else, {, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;]
[(, ), ;, return, thenStmt, ;, }, else, {, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, NodeUtil, ., removeChild, (]
[;, return, thenStmt, ;, }, else, {, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, NodeUtil, ., removeChild, (, parent, ,]
[;, }, else, {, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, NodeUtil, ., removeChild, (, parent, ,, n, ), ;]
[., redeclareVarsInsideBranch, (, n, ), ;, NodeUtil, ., removeChild, (, parent, ,, n, ), ;, reportCodeChange, (, ), ;, return]
[(, parent, ,, n, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, }, else, {, Node, trueBranch, =]
[(, parent, ,, n, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, }, else, {, Node, trueBranch, =]
[(, parent, ,, n, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, }, else, {, Node, trueBranch, =]
[}, }, else, {, Node, trueBranch, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, falseBranch, =]
[}, }, else, {, Node, trueBranch, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, falseBranch, =]
[getFirstChild, (, ), ., getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Node, branchToKeep, =]
[getFirstChild, (, ), ., getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Node, branchToKeep, =]
[), ., getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Node, branchToKeep, =, condTrue, ?]
[getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Node, branchToKeep, =, condTrue, ?, trueBranch, :]
[falseBranch, =, trueBranch, ., getNext, (, ), ;, Node, branchToKeep, =, condTrue, ?, trueBranch, :, falseBranch, ;, Node, branchToRemove, =]
[falseBranch, =, trueBranch, ., getNext, (, ), ;, Node, branchToKeep, =, condTrue, ?, trueBranch, :, falseBranch, ;, Node, branchToRemove, =]
[trueBranch, ., getNext, (, ), ;, Node, branchToKeep, =, condTrue, ?, trueBranch, :, falseBranch, ;, Node, branchToRemove, =, condTrue, ?]
[getNext, (, ), ;, Node, branchToKeep, =, condTrue, ?, trueBranch, :, falseBranch, ;, Node, branchToRemove, =, condTrue, ?, falseBranch, :]
[), ;, Node, branchToKeep, =, condTrue, ?, trueBranch, :, falseBranch, ;, Node, branchToRemove, =, condTrue, ?, falseBranch, :, trueBranch, ;]
[), ;, Node, branchToKeep, =, condTrue, ?, trueBranch, :, falseBranch, ;, Node, branchToRemove, =, condTrue, ?, falseBranch, :, trueBranch, ;]
[=, condTrue, ?, trueBranch, :, falseBranch, ;, Node, branchToRemove, =, condTrue, ?, falseBranch, :, trueBranch, ;, NodeUtil, ., redeclareVarsInsideBranch, (]
[trueBranch, :, falseBranch, ;, Node, branchToRemove, =, condTrue, ?, falseBranch, :, trueBranch, ;, NodeUtil, ., redeclareVarsInsideBranch, (, branchToRemove, ), ;]
[trueBranch, :, falseBranch, ;, Node, branchToRemove, =, condTrue, ?, falseBranch, :, trueBranch, ;, NodeUtil, ., redeclareVarsInsideBranch, (, branchToRemove, ), ;]
[Node, branchToRemove, =, condTrue, ?, falseBranch, :, trueBranch, ;, NodeUtil, ., redeclareVarsInsideBranch, (, branchToRemove, ), ;, n, ., removeChild, (]
[condTrue, ?, falseBranch, :, trueBranch, ;, NodeUtil, ., redeclareVarsInsideBranch, (, branchToRemove, ), ;, n, ., removeChild, (, branchToKeep, ), ;]
[condTrue, ?, falseBranch, :, trueBranch, ;, NodeUtil, ., redeclareVarsInsideBranch, (, branchToRemove, ), ;, n, ., removeChild, (, branchToKeep, ), ;]
[trueBranch, ;, NodeUtil, ., redeclareVarsInsideBranch, (, branchToRemove, ), ;, n, ., removeChild, (, branchToKeep, ), ;, parent, ., replaceChild, (]
[NodeUtil, ., redeclareVarsInsideBranch, (, branchToRemove, ), ;, n, ., removeChild, (, branchToKeep, ), ;, parent, ., replaceChild, (, n, ,]
[(, branchToRemove, ), ;, n, ., removeChild, (, branchToKeep, ), ;, parent, ., replaceChild, (, n, ,, branchToKeep, ), ;]
[., removeChild, (, branchToKeep, ), ;, parent, ., replaceChild, (, n, ,, branchToKeep, ), ;, reportCodeChange, (, ), ;, return]
[branchToKeep, ), ;, reportCodeChange, (, ), ;, return, branchToKeep, ;, }, }, private, Node, tryFoldHook, (, Node, n, ), {]
[branchToKeep, ), ;, reportCodeChange, (, ), ;, return, branchToKeep, ;, }, }, private, Node, tryFoldHook, (, Node, n, ), {]
[(, ), ;, return, branchToKeep, ;, }, }, private, Node, tryFoldHook, (, Node, n, ), {, Preconditions, ., checkState, (]
[(, ), ;, return, branchToKeep, ;, }, }, private, Node, tryFoldHook, (, Node, n, ), {, Preconditions, ., checkState, (]
[tryFoldHook, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isHook, (, ), ), ;, Node, parent, =]
[tryFoldHook, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isHook, (, ), ), ;, Node, parent, =]
[Preconditions, ., checkState, (, n, ., isHook, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;]
[Preconditions, ., checkState, (, n, ., isHook, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;]
[n, ., isHook, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (]
[;, Node, parent, =, n, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, parent, ), ;, Node, cond, =]
[;, Node, parent, =, n, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, parent, ), ;, Node, cond, =]
[;, Preconditions, ., checkNotNull, (, parent, ), ;, Node, cond, =, n, ., getFirstChild, (, ), ;, Node, thenBody, =]
[;, Preconditions, ., checkNotNull, (, parent, ), ;, Node, cond, =, n, ., getFirstChild, (, ), ;, Node, thenBody, =]
[cond, =, n, ., getFirstChild, (, ), ;, Node, thenBody, =, cond, ., getNext, (, ), ;, Node, elseBody, =]
[cond, =, n, ., getFirstChild, (, ), ;, Node, thenBody, =, cond, ., getNext, (, ), ;, Node, elseBody, =]
[thenBody, =, cond, ., getNext, (, ), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, TernaryValue, condValue, =]
[thenBody, =, cond, ., getNext, (, ), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, TernaryValue, condValue, =]
[getNext, (, ), ;, Node, elseBody, =, thenBody, ., getNext, (, ), ;, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (]
[elseBody, =, thenBody, ., getNext, (, ), ;, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (]
[elseBody, =, thenBody, ., getNext, (, ), ;, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (]
[thenBody, ., getNext, (, ), ;, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (, condValue, ==]
[thenBody, ., getNext, (, ), ;, TernaryValue, condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (, condValue, ==]
[condValue, =, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (, condValue, ==, TernaryValue, ., UNKNOWN, ), {, if, (]
[=, NodeUtil, ., getImpureBooleanValue, (, cond, ), ;, if, (, condValue, ==, TernaryValue, ., UNKNOWN, ), {, if, (, !]
[., getImpureBooleanValue, (, cond, ), ;, if, (, condValue, ==, TernaryValue, ., UNKNOWN, ), {, if, (, !, areNodesEqualForInlining, (]
[(, cond, ), ;, if, (, condValue, ==, TernaryValue, ., UNKNOWN, ), {, if, (, !, areNodesEqualForInlining, (, thenBody, ,]
[(, condValue, ==, TernaryValue, ., UNKNOWN, ), {, if, (, !, areNodesEqualForInlining, (, thenBody, ,, elseBody, ), ), {, return]
[., UNKNOWN, ), {, if, (, !, areNodesEqualForInlining, (, thenBody, ,, elseBody, ), ), {, return, n, ;, }, }]
[., UNKNOWN, ), {, if, (, !, areNodesEqualForInlining, (, thenBody, ,, elseBody, ), ), {, return, n, ;, }, }]
[thenBody, ,, elseBody, ), ), {, return, n, ;, }, }, n, ., detachChildren, (, ), ;, Node, branchToKeep, =]
[thenBody, ,, elseBody, ), ), {, return, n, ;, }, }, n, ., detachChildren, (, ), ;, Node, branchToKeep, =]
[thenBody, ,, elseBody, ), ), {, return, n, ;, }, }, n, ., detachChildren, (, ), ;, Node, branchToKeep, =]
[), {, return, n, ;, }, }, n, ., detachChildren, (, ), ;, Node, branchToKeep, =, condValue, ., toBoolean, (]
[n, ;, }, }, n, ., detachChildren, (, ), ;, Node, branchToKeep, =, condValue, ., toBoolean, (, true, ), ?]
[}, }, n, ., detachChildren, (, ), ;, Node, branchToKeep, =, condValue, ., toBoolean, (, true, ), ?, thenBody, :]
[;, Node, branchToKeep, =, condValue, ., toBoolean, (, true, ), ?, thenBody, :, elseBody, ;, Node, replacement, ;, if, (]
[branchToKeep, =, condValue, ., toBoolean, (, true, ), ?, thenBody, :, elseBody, ;, Node, replacement, ;, if, (, mayHaveSideEffects, (]
[toBoolean, (, true, ), ?, thenBody, :, elseBody, ;, Node, replacement, ;, if, (, mayHaveSideEffects, (, cond, ), ), {]
[true, ), ?, thenBody, :, elseBody, ;, Node, replacement, ;, if, (, mayHaveSideEffects, (, cond, ), ), {, replacement, =]
[true, ), ?, thenBody, :, elseBody, ;, Node, replacement, ;, if, (, mayHaveSideEffects, (, cond, ), ), {, replacement, =]
[true, ), ?, thenBody, :, elseBody, ;, Node, replacement, ;, if, (, mayHaveSideEffects, (, cond, ), ), {, replacement, =]
[:, elseBody, ;, Node, replacement, ;, if, (, mayHaveSideEffects, (, cond, ), ), {, replacement, =, IR, ., comma, (]
[;, Node, replacement, ;, if, (, mayHaveSideEffects, (, cond, ), ), {, replacement, =, IR, ., comma, (, cond, ,]
[(, mayHaveSideEffects, (, cond, ), ), {, replacement, =, IR, ., comma, (, cond, ,, branchToKeep, ), ., srcref, (]
[{, replacement, =, IR, ., comma, (, cond, ,, branchToKeep, ), ., srcref, (, n, ), ;, }, else, {]
[=, IR, ., comma, (, cond, ,, branchToKeep, ), ., srcref, (, n, ), ;, }, else, {, replacement, =]
[comma, (, cond, ,, branchToKeep, ), ., srcref, (, n, ), ;, }, else, {, replacement, =, branchToKeep, ;, }]
[comma, (, cond, ,, branchToKeep, ), ., srcref, (, n, ), ;, }, else, {, replacement, =, branchToKeep, ;, }]
[branchToKeep, ), ., srcref, (, n, ), ;, }, else, {, replacement, =, branchToKeep, ;, }, parent, ., replaceChild, (]
[., srcref, (, n, ), ;, }, else, {, replacement, =, branchToKeep, ;, }, parent, ., replaceChild, (, n, ,]
[n, ), ;, }, else, {, replacement, =, branchToKeep, ;, }, parent, ., replaceChild, (, n, ,, replacement, ), ;]
[{, replacement, =, branchToKeep, ;, }, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
[n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, Node, tryFoldWhile, (, Node, n, ), {]
[n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, Node, tryFoldWhile, (, Node, n, ), {]
[;, reportCodeChange, (, ), ;, return, replacement, ;, }, Node, tryFoldWhile, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[;, reportCodeChange, (, ), ;, return, replacement, ;, }, Node, tryFoldWhile, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[tryFoldWhile, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isWhile, (, ), ), ;, Node, cond, =]
[tryFoldWhile, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isWhile, (, ), ), ;, Node, cond, =]
[), {, Preconditions, ., checkArgument, (, n, ., isWhile, (, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (]
[(, n, ., isWhile, (, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (]
[(, n, ., isWhile, (, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (]
[(, n, ., isWhile, (, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (]
[(, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (]
[;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, cond, ), !=]
[;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, cond, ), !=]
[getConditionExpression, (, n, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return]
[), ;, if, (, NodeUtil, ., getPureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }]
[), ;, if, (, NodeUtil, ., getPureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }]
[NodeUtil, ., getPureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (]
[(, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;]
[(, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;]
[TernaryValue, ., FALSE, ), {, return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, NodeUtil, ., removeChild, (]
[TernaryValue, ., FALSE, ), {, return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, NodeUtil, ., removeChild, (]
[n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,]
[NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n, ), ;]
[), ;, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n, ), ;, reportCodeChange, (, ), ;, return]
[), ,, n, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, Node, tryFoldFor, (, Node, n, ), {]
[), ,, n, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, Node, tryFoldFor, (, Node, n, ), {]
[;, reportCodeChange, (, ), ;, return, null, ;, }, Node, tryFoldFor, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[;, reportCodeChange, (, ), ;, return, null, ;, }, Node, tryFoldFor, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[Node, tryFoldFor, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isFor, (, ), ), ;, if, (]
[Node, tryFoldFor, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isFor, (, ), ), ;, if, (]
[n, ), {, Preconditions, ., checkArgument, (, n, ., isFor, (, ), ), ;, if, (, NodeUtil, ., isForIn, (]
[checkArgument, (, n, ., isFor, (, ), ), ;, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return]
[), ), ;, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return, n, ;, }, Node, init, =]
[), ), ;, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return, n, ;, }, Node, init, =]
[n, ), ), {, return, n, ;, }, Node, init, =, n, ., getFirstChild, (, ), ;, Node, cond, =]
[n, ), ), {, return, n, ;, }, Node, init, =, n, ., getFirstChild, (, ), ;, Node, cond, =]
[init, =, n, ., getFirstChild, (, ), ;, Node, cond, =, init, ., getNext, (, ), ;, Node, increment, =]
[init, =, n, ., getFirstChild, (, ), ;, Node, cond, =, init, ., getNext, (, ), ;, Node, increment, =]
[Node, cond, =, init, ., getNext, (, ), ;, Node, increment, =, cond, ., getNext, (, ), ;, if, (]
[Node, cond, =, init, ., getNext, (, ), ;, Node, increment, =, cond, ., getNext, (, ), ;, if, (]
[cond, =, init, ., getNext, (, ), ;, Node, increment, =, cond, ., getNext, (, ), ;, if, (, !]
[cond, =, init, ., getNext, (, ), ;, Node, increment, =, cond, ., getNext, (, ), ;, if, (, !]
[), ;, Node, increment, =, cond, ., getNext, (, ), ;, if, (, !, init, ., isEmpty, (, ), &&]
[;, Node, increment, =, cond, ., getNext, (, ), ;, if, (, !, init, ., isEmpty, (, ), &&, !]
[;, Node, increment, =, cond, ., getNext, (, ), ;, if, (, !, init, ., isEmpty, (, ), &&, !]
[(, ), ;, if, (, !, init, ., isEmpty, (, ), &&, !, init, ., isVar, (, ), ), {]
[;, if, (, !, init, ., isEmpty, (, ), &&, !, init, ., isVar, (, ), ), {, init, =]
[(, !, init, ., isEmpty, (, ), &&, !, init, ., isVar, (, ), ), {, init, =, trySimplifyUnusedResult, (]
[init, ., isEmpty, (, ), &&, !, init, ., isVar, (, ), ), {, init, =, trySimplifyUnusedResult, (, init, ,]
[!, init, ., isVar, (, ), ), {, init, =, trySimplifyUnusedResult, (, init, ,, false, ), ;, }, if, (]
[init, ., isVar, (, ), ), {, init, =, trySimplifyUnusedResult, (, init, ,, false, ), ;, }, if, (, !]
[init, ., isVar, (, ), ), {, init, =, trySimplifyUnusedResult, (, init, ,, false, ), ;, }, if, (, !]
[init, =, trySimplifyUnusedResult, (, init, ,, false, ), ;, }, if, (, !, increment, ., isEmpty, (, ), ), {]
[trySimplifyUnusedResult, (, init, ,, false, ), ;, }, if, (, !, increment, ., isEmpty, (, ), ), {, increment, =]
[init, ,, false, ), ;, }, if, (, !, increment, ., isEmpty, (, ), ), {, increment, =, trySimplifyUnusedResult, (]
[false, ), ;, }, if, (, !, increment, ., isEmpty, (, ), ), {, increment, =, trySimplifyUnusedResult, (, increment, ,]
[!, increment, ., isEmpty, (, ), ), {, increment, =, trySimplifyUnusedResult, (, increment, ,, false, ), ;, }, if, (]
[increment, ., isEmpty, (, ), ), {, increment, =, trySimplifyUnusedResult, (, increment, ,, false, ), ;, }, if, (, !]
[increment, ., isEmpty, (, ), ), {, increment, =, trySimplifyUnusedResult, (, increment, ,, false, ), ;, }, if, (, !]
[increment, ., isEmpty, (, ), ), {, increment, =, trySimplifyUnusedResult, (, increment, ,, false, ), ;, }, if, (, !]
[,, false, ), ;, }, if, (, !, n, ., getFirstChild, (, ), ., isEmpty, (, ), ), {, return]
[if, (, !, n, ., getFirstChild, (, ), ., isEmpty, (, ), ), {, return, n, ;, }, if, (]
[if, (, !, n, ., getFirstChild, (, ), ., isEmpty, (, ), ), {, return, n, ;, }, if, (]
[if, (, !, n, ., getFirstChild, (, ), ., isEmpty, (, ), ), {, return, n, ;, }, if, (]
[., getFirstChild, (, ), ., isEmpty, (, ), ), {, return, n, ;, }, if, (, NodeUtil, ., getImpureBooleanValue, (]
[), ., isEmpty, (, ), ), {, return, n, ;, }, if, (, NodeUtil, ., getImpureBooleanValue, (, cond, ), !=]
[), ., isEmpty, (, ), ), {, return, n, ;, }, if, (, NodeUtil, ., getImpureBooleanValue, (, cond, ), !=]
[{, return, n, ;, }, if, (, NodeUtil, ., getImpureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return]
[;, }, if, (, NodeUtil, ., getImpureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }]
[;, }, if, (, NodeUtil, ., getImpureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }]
[NodeUtil, ., getImpureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (]
[), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, if, (]
[!=, TernaryValue, ., FALSE, ), {, return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, if, (, !]
[., FALSE, ), {, return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, if, (, !, mayHaveSideEffects, (]
[return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, if, (, !, mayHaveSideEffects, (, cond, ), ), {]
[return, n, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, if, (, !, mayHaveSideEffects, (, cond, ), ), {]
[NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, if, (, !, mayHaveSideEffects, (, cond, ), ), {, NodeUtil, ., removeChild, (]
[NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, if, (, !, mayHaveSideEffects, (, cond, ), ), {, NodeUtil, ., removeChild, (]
[;, if, (, !, mayHaveSideEffects, (, cond, ), ), {, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,]
[{, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n, ), ;, }, else, {, Node, statement, =]
[{, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n, ), ;, }, else, {, Node, statement, =]
[{, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n, ), ;, }, else, {, Node, statement, =]
[(, n, ., getParent, (, ), ,, n, ), ;, }, else, {, Node, statement, =, IR, ., exprResult, (]
[(, n, ., getParent, (, ), ,, n, ), ;, }, else, {, Node, statement, =, IR, ., exprResult, (]
[;, }, else, {, Node, statement, =, IR, ., exprResult, (, cond, ., detachFromParent, (, ), ), ., copyInformationFrom, (]
[{, Node, statement, =, IR, ., exprResult, (, cond, ., detachFromParent, (, ), ), ., copyInformationFrom, (, cond, ), ;]
[{, Node, statement, =, IR, ., exprResult, (, cond, ., detachFromParent, (, ), ), ., copyInformationFrom, (, cond, ), ;]
[{, Node, statement, =, IR, ., exprResult, (, cond, ., detachFromParent, (, ), ), ., copyInformationFrom, (, cond, ), ;]
[cond, ., detachFromParent, (, ), ), ., copyInformationFrom, (, cond, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[detachFromParent, (, ), ), ., copyInformationFrom, (, cond, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[., copyInformationFrom, (, cond, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, statement, ), ;, }]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, statement, ), ;, }, reportCodeChange, (, ), ;, return]
[,, statement, ), ;, }, reportCodeChange, (, ), ;, return, null, ;, }, Node, tryFoldDo, (, Node, n, ), {]
[,, statement, ), ;, }, reportCodeChange, (, ), ;, return, null, ;, }, Node, tryFoldDo, (, Node, n, ), {]
[}, reportCodeChange, (, ), ;, return, null, ;, }, Node, tryFoldDo, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[}, reportCodeChange, (, ), ;, return, null, ;, }, Node, tryFoldDo, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[tryFoldDo, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isDo, (, ), ), ;, Node, cond, =]
[tryFoldDo, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isDo, (, ), ), ;, Node, cond, =]
[), {, Preconditions, ., checkArgument, (, n, ., isDo, (, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (]
[(, n, ., isDo, (, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (]
[(, n, ., isDo, (, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (]
[(, n, ., isDo, (, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (]
[(, ), ), ;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, NodeUtil, ., getImpureBooleanValue, (]
[;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, NodeUtil, ., getImpureBooleanValue, (, cond, ), !=]
[;, Node, cond, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, NodeUtil, ., getImpureBooleanValue, (, cond, ), !=]
[getConditionExpression, (, n, ), ;, if, (, NodeUtil, ., getImpureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return]
[if, (, NodeUtil, ., getImpureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }, if, (]
[NodeUtil, ., getImpureBooleanValue, (, cond, ), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }, if, (, hasBreakOrContinue, (]
[), !=, TernaryValue, ., FALSE, ), {, return, n, ;, }, if, (, hasBreakOrContinue, (, n, ), ), {, return]
[., FALSE, ), {, return, n, ;, }, if, (, hasBreakOrContinue, (, n, ), ), {, return, n, ;, }]
[., FALSE, ), {, return, n, ;, }, if, (, hasBreakOrContinue, (, n, ), ), {, return, n, ;, }]
[return, n, ;, }, if, (, hasBreakOrContinue, (, n, ), ), {, return, n, ;, }, Preconditions, ., checkState, (]
[return, n, ;, }, if, (, hasBreakOrContinue, (, n, ), ), {, return, n, ;, }, Preconditions, ., checkState, (]
[if, (, hasBreakOrContinue, (, n, ), ), {, return, n, ;, }, Preconditions, ., checkState, (, NodeUtil, ., isControlStructureCodeBlock, (]
[hasBreakOrContinue, (, n, ), ), {, return, n, ;, }, Preconditions, ., checkState, (, NodeUtil, ., isControlStructureCodeBlock, (, n, ,]
[hasBreakOrContinue, (, n, ), ), {, return, n, ;, }, Preconditions, ., checkState, (, NodeUtil, ., isControlStructureCodeBlock, (, n, ,]
[., checkState, (, NodeUtil, ., isControlStructureCodeBlock, (, n, ,, n, ., getFirstChild, (, ), ), ), ;, Node, block, =]
[., checkState, (, NodeUtil, ., isControlStructureCodeBlock, (, n, ,, n, ., getFirstChild, (, ), ), ), ;, Node, block, =]
[n, ., getFirstChild, (, ), ), ), ;, Node, block, =, n, ., removeFirstChild, (, ), ;, Node, parent, =]
[n, ., getFirstChild, (, ), ), ), ;, Node, block, =, n, ., removeFirstChild, (, ), ;, Node, parent, =]
[), ;, Node, block, =, n, ., removeFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;]
[), ;, Node, block, =, n, ., removeFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;]
[=, n, ., removeFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;, parent, ., replaceChild, (]
[., removeFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;, parent, ., replaceChild, (, n, ,]
[Node, parent, =, n, ., getParent, (, ), ;, parent, ., replaceChild, (, n, ,, block, ), ;, if, (]
[=, n, ., getParent, (, ), ;, parent, ., replaceChild, (, n, ,, block, ), ;, if, (, mayHaveSideEffects, (]
[parent, ., replaceChild, (, n, ,, block, ), ;, if, (, mayHaveSideEffects, (, cond, ), ), {, Node, condStatement, =]
[parent, ., replaceChild, (, n, ,, block, ), ;, if, (, mayHaveSideEffects, (, cond, ), ), {, Node, condStatement, =]
[parent, ., replaceChild, (, n, ,, block, ), ;, if, (, mayHaveSideEffects, (, cond, ), ), {, Node, condStatement, =]
[n, ,, block, ), ;, if, (, mayHaveSideEffects, (, cond, ), ), {, Node, condStatement, =, IR, ., exprResult, (]
[n, ,, block, ), ;, if, (, mayHaveSideEffects, (, cond, ), ), {, Node, condStatement, =, IR, ., exprResult, (]
[cond, ), ), {, Node, condStatement, =, IR, ., exprResult, (, cond, ., detachFromParent, (, ), ), ., srcref, (]
[{, Node, condStatement, =, IR, ., exprResult, (, cond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ;]
[{, Node, condStatement, =, IR, ., exprResult, (, cond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ;]
[IR, ., exprResult, (, cond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ;, parent, ., addChildAfter, (]
[exprResult, (, cond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ;, parent, ., addChildAfter, (, condStatement, ,]
[detachFromParent, (, ), ), ., srcref, (, cond, ), ;, parent, ., addChildAfter, (, condStatement, ,, block, ), ;, }]
[srcref, (, cond, ), ;, parent, ., addChildAfter, (, condStatement, ,, block, ), ;, }, reportCodeChange, (, ), ;, return]
[block, ), ;, }, reportCodeChange, (, ), ;, return, n, ;, }, boolean, hasBreakOrContinue, (, Node, n, ), {, return]
[block, ), ;, }, reportCodeChange, (, ), ;, return, n, ;, }, boolean, hasBreakOrContinue, (, Node, n, ), {, return]
[reportCodeChange, (, ), ;, return, n, ;, }, boolean, hasBreakOrContinue, (, Node, n, ), {, return, NodeUtil, ., has, (]
[), ;, return, n, ;, }, boolean, hasBreakOrContinue, (, Node, n, ), {, return, NodeUtil, ., has, (, n, ,]
[), ;, return, n, ;, }, boolean, hasBreakOrContinue, (, Node, n, ), {, return, NodeUtil, ., has, (, n, ,]
[hasBreakOrContinue, (, Node, n, ), {, return, NodeUtil, ., has, (, n, ,, Predicates, ., <, Node, >, or, (]
[{, return, NodeUtil, ., has, (, n, ,, Predicates, ., <, Node, >, or, (, new, NodeUtil, ., MatchNodeType, (]
[{, return, NodeUtil, ., has, (, n, ,, Predicates, ., <, Node, >, or, (, new, NodeUtil, ., MatchNodeType, (]
[(, n, ,, Predicates, ., <, Node, >, or, (, new, NodeUtil, ., MatchNodeType, (, Token, ., BREAK, ), ,]
[<, Node, >, or, (, new, NodeUtil, ., MatchNodeType, (, Token, ., BREAK, ), ,, new, NodeUtil, ., MatchNodeType, (]
[<, Node, >, or, (, new, NodeUtil, ., MatchNodeType, (, Token, ., BREAK, ), ,, new, NodeUtil, ., MatchNodeType, (]
[NodeUtil, ., MatchNodeType, (, Token, ., BREAK, ), ,, new, NodeUtil, ., MatchNodeType, (, Token, ., CONTINUE, ), ), ,]
[NodeUtil, ., MatchNodeType, (, Token, ., BREAK, ), ,, new, NodeUtil, ., MatchNodeType, (, Token, ., CONTINUE, ), ), ,]
[CONTINUE, ), ), ,, NodeUtil, ., MATCH_NOT_FUNCTION, ), ;, }, private, void, tryFoldForCondition, (, Node, forCondition, ), {, if, (]
[CONTINUE, ), ), ,, NodeUtil, ., MATCH_NOT_FUNCTION, ), ;, }, private, void, tryFoldForCondition, (, Node, forCondition, ), {, if, (]
[CONTINUE, ), ), ,, NodeUtil, ., MATCH_NOT_FUNCTION, ), ;, }, private, void, tryFoldForCondition, (, Node, forCondition, ), {, if, (]
[NodeUtil, ., MATCH_NOT_FUNCTION, ), ;, }, private, void, tryFoldForCondition, (, Node, forCondition, ), {, if, (, NodeUtil, ., getPureBooleanValue, (]
[), ;, }, private, void, tryFoldForCondition, (, Node, forCondition, ), {, if, (, NodeUtil, ., getPureBooleanValue, (, forCondition, ), ==]
[), ;, }, private, void, tryFoldForCondition, (, Node, forCondition, ), {, if, (, NodeUtil, ., getPureBooleanValue, (, forCondition, ), ==]
[tryFoldForCondition, (, Node, forCondition, ), {, if, (, NodeUtil, ., getPureBooleanValue, (, forCondition, ), ==, TernaryValue, ., TRUE, ), {]
[tryFoldForCondition, (, Node, forCondition, ), {, if, (, NodeUtil, ., getPureBooleanValue, (, forCondition, ), ==, TernaryValue, ., TRUE, ), {]
[tryFoldForCondition, (, Node, forCondition, ), {, if, (, NodeUtil, ., getPureBooleanValue, (, forCondition, ), ==, TernaryValue, ., TRUE, ), {]
[NodeUtil, ., getPureBooleanValue, (, forCondition, ), ==, TernaryValue, ., TRUE, ), {, forCondition, ., getParent, (, ), ., replaceChild, (]
[getPureBooleanValue, (, forCondition, ), ==, TernaryValue, ., TRUE, ), {, forCondition, ., getParent, (, ), ., replaceChild, (, forCondition, ,]
[getPureBooleanValue, (, forCondition, ), ==, TernaryValue, ., TRUE, ), {, forCondition, ., getParent, (, ), ., replaceChild, (, forCondition, ,]
[TRUE, ), {, forCondition, ., getParent, (, ), ., replaceChild, (, forCondition, ,, IR, ., empty, (, ), ), ;]
