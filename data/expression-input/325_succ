[;, private, int, astPositionCounter, ;, private, int, priorityCounter, ;, private, final, boolean, shouldTraverseFunctions, ;, private, final, boolean, edgeAnnotations, ;, private]
[;, }, }, ;, private, int, astPositionCounter, ;, private, int, priorityCounter, ;, private, final, boolean, shouldTraverseFunctions, ;, private, final, boolean]
[-, astPosition, ., get, (, b, ., getValue, (, ), ), ;, }, }, ;, private, int, astPositionCounter, ;, private]
[., get, (, a, ., getValue, (, ), ), -, astPosition, ., get, (, b, ., getValue, (, ), )]
[), -, astPosition, ., get, (, b, ., getValue, (, ), ), ;, }, }, ;, private, int, astPositionCounter, ;]
[., getValue, (, ), ), -, astPosition, ., get, (, b, ., getValue, (, ), ), ;, }, }, ;]
[;, }, }, ;, private, int, astPositionCounter, ;, private, int, priorityCounter, ;, private, final, boolean, shouldTraverseFunctions, ;, private, final, boolean]
[., get, (, b, ., getValue, (, ), ), ;, }, }, ;, private, int, astPositionCounter, ;, private, int, priorityCounter]
[), ;, }, }, ;, private, int, astPositionCounter, ;, private, int, priorityCounter, ;, private, final, boolean, shouldTraverseFunctions, ;, private, final]
[., getValue, (, ), ), ;, }, }, ;, private, int, astPositionCounter, ;, private, int, priorityCounter, ;, private, final, boolean]
[;, private, final, Multimap, <, Node, ,, Node, >, finallyMap, =, HashMultimap, ., create, (, ), ;, ControlFlowAnalysis, (, AbstractCompiler]
[;, ControlFlowAnalysis, (, AbstractCompiler, compiler, ,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {, this, ., compiler, =, compiler, ;, this]
[., create, (, ), ;, ControlFlowAnalysis, (, AbstractCompiler, compiler, ,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {, this, ., compiler]
[=, compiler, ;, this, ., shouldTraverseFunctions, =, shouldTraverseFunctions, ;, this, ., edgeAnnotations, =, edgeAnnotations, ;, }, ControlFlowGraph, <, Node, >]
[., compiler, =, compiler, ;, this, ., shouldTraverseFunctions, =, shouldTraverseFunctions, ;, this, ., edgeAnnotations, =, edgeAnnotations, ;, }, ControlFlowGraph, <]
[;, this, ., shouldTraverseFunctions, =, shouldTraverseFunctions, ;, this, ., edgeAnnotations, =, edgeAnnotations, ;, }, ControlFlowGraph, <, Node, >, getCfg, (]
[=, shouldTraverseFunctions, ;, this, ., edgeAnnotations, =, edgeAnnotations, ;, }, ControlFlowGraph, <, Node, >, getCfg, (, ), {, return, cfg]
[., shouldTraverseFunctions, =, shouldTraverseFunctions, ;, this, ., edgeAnnotations, =, edgeAnnotations, ;, }, ControlFlowGraph, <, Node, >, getCfg, (, ), {]
[;, this, ., edgeAnnotations, =, edgeAnnotations, ;, }, ControlFlowGraph, <, Node, >, getCfg, (, ), {, return, cfg, ;, }]
[=, edgeAnnotations, ;, }, ControlFlowGraph, <, Node, >, getCfg, (, ), {, return, cfg, ;, }, @, Override, public, void]
[., edgeAnnotations, =, edgeAnnotations, ;, }, ControlFlowGraph, <, Node, >, getCfg, (, ), {, return, cfg, ;, }, @, Override]
[;, }, ControlFlowGraph, <, Node, >, getCfg, (, ), {, return, cfg, ;, }, @, Override, public, void, process, (]
[;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, this, ., root, =, root]
[=, root, ;, astPositionCounter, =, 0, ;, astPosition, =, Maps, ., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap]
[., root, =, root, ;, astPositionCounter, =, 0, ;, astPosition, =, Maps, ., newHashMap, (, ), ;, nodePriorities, =, Maps]
[;, astPositionCounter, =, 0, ;, astPosition, =, Maps, ., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap, (, )]
[=, 0, ;, astPosition, =, Maps, ., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg]
[;, astPosition, =, Maps, ., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg, =, new]
[=, Maps, ., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (]
[;, nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities]
[., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (]
[=, Maps, ., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,, edgeAnnotations]
[;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (]
[., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;]
[=, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,]
[;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, ., put, (, null, ,, ++, astPositionCounter]
[,, nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, ., put]
[), ,, nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, .]
[,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, ., put, (, null]
[), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, ., put, (, null, ,, ++]
[;, astPosition, ., put, (, null, ,, ++, astPositionCounter, ), ;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch]
[., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, ., put, (, null, ,, ++, astPositionCounter, ), ;]
[,, root, ,, this, ), ;, astPosition, ., put, (, null, ,, ++, astPositionCounter, ), ;, priorityCounter, =, 0, ;]
[,, this, ), ;, astPosition, ., put, (, null, ,, ++, astPositionCounter, ), ;, priorityCounter, =, 0, ;, DiGraphNode, <]
[), ;, astPosition, ., put, (, null, ,, ++, astPositionCounter, ), ;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,]
[;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry, =, cfg, ., getEntry, (, ), ;, prioritizeFromEntryNode]
[., put, (, null, ,, ++, astPositionCounter, ), ;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry]
[,, ++, astPositionCounter, ), ;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry, =, cfg, ., getEntry]
[), ;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry, =, cfg, ., getEntry, (, ), ;]
[), ;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry, =, cfg, ., getEntry, (, ), ;]
[=, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry, =, cfg, ., getEntry, (, ), ;, prioritizeFromEntryNode, (, entry]
[;, DiGraphNode, <, Node, ,, Branch, >, entry, =, cfg, ., getEntry, (, ), ;, prioritizeFromEntryNode, (, entry, ), ;]
[;, prioritizeFromEntryNode, (, entry, ), ;, if, (, shouldTraverseFunctions, ), {, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate]
[., getEntry, (, ), ;, prioritizeFromEntryNode, (, entry, ), ;, if, (, shouldTraverseFunctions, ), {, for, (, DiGraphNode, <, Node]
[;, if, (, shouldTraverseFunctions, ), {, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (]
[), ;, if, (, shouldTraverseFunctions, ), {, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes]
[), {, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, Node]
[), {, Node, value, =, candidate, ., getValue, (, ), ;, if, (, value, !=, null, &&, value, ., isFunction]
[., getDirectedGraphNodes, (, ), ), {, Node, value, =, candidate, ., getValue, (, ), ;, if, (, value, !=, null]
[;, if, (, value, !=, null, &&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (, !, nodePriorities]
[., getValue, (, ), ;, if, (, value, !=, null, &&, value, ., isFunction, (, ), ), {, Preconditions, .]
[), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||, candidate, ==, entry, ), ;, prioritizeFromEntryNode]
[&&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||]
[!=, null, &&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate]
[&&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||]
[), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||, candidate, ==, entry, ), ;, prioritizeFromEntryNode]
[., isFunction, (, ), ), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||, candidate, ==]
[;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg]
[., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||, candidate, ==, entry, ), ;, prioritizeFromEntryNode, (, candidate, )]
[), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :]
[||, candidate, ==, entry, ), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node, ,]
[||, candidate, ==, entry, ), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node, ,]
[., containsKey, (, candidate, ), ||, candidate, ==, entry, ), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for]
[), ||, candidate, ==, entry, ), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node]
[), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :]
[==, entry, ), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node, ,, Branch, >]
[), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :]
[;, }, }, }, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (, ), )]
[), ;, }, }, }, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (, )]
[), {, if, (, !, nodePriorities, ., containsKey, (, candidate, ), ), {, nodePriorities, ., put, (, candidate, ,, ++]
[., getDirectedGraphNodes, (, ), ), {, if, (, !, nodePriorities, ., containsKey, (, candidate, ), ), {, nodePriorities, ., put]
[), {, nodePriorities, ., put, (, candidate, ,, ++, priorityCounter, ), ;, }, }, nodePriorities, ., put, (, cfg, .]
[), {, nodePriorities, ., put, (, candidate, ,, ++, priorityCounter, ), ;, }, }, nodePriorities, ., put, (, cfg, .]
[., containsKey, (, candidate, ), ), {, nodePriorities, ., put, (, candidate, ,, ++, priorityCounter, ), ;, }, }, nodePriorities]
[), ), {, nodePriorities, ., put, (, candidate, ,, ++, priorityCounter, ), ;, }, }, nodePriorities, ., put, (, cfg]
[;, }, }, nodePriorities, ., put, (, cfg, ., getImplicitReturn, (, ), ,, ++, priorityCounter, ), ;, }, private, void]
[., put, (, candidate, ,, ++, priorityCounter, ), ;, }, }, nodePriorities, ., put, (, cfg, ., getImplicitReturn, (, )]
[,, ++, priorityCounter, ), ;, }, }, nodePriorities, ., put, (, cfg, ., getImplicitReturn, (, ), ,, ++, priorityCounter, )]
[), ;, }, }, nodePriorities, ., put, (, cfg, ., getImplicitReturn, (, ), ,, ++, priorityCounter, ), ;, }, private]
[), ;, }, }, nodePriorities, ., put, (, cfg, ., getImplicitReturn, (, ), ,, ++, priorityCounter, ), ;, }, private]
[;, }, private, void, prioritizeFromEntryNode, (, DiGraphNode, <, Node, ,, Branch, >, entry, ), {, PriorityQueue, <, DiGraphNode, <, Node]
[., put, (, cfg, ., getImplicitReturn, (, ), ,, ++, priorityCounter, ), ;, }, private, void, prioritizeFromEntryNode, (, DiGraphNode, <]
[,, ++, priorityCounter, ), ;, }, private, void, prioritizeFromEntryNode, (, DiGraphNode, <, Node, ,, Branch, >, entry, ), {, PriorityQueue]
[., getImplicitReturn, (, ), ,, ++, priorityCounter, ), ;, }, private, void, prioritizeFromEntryNode, (, DiGraphNode, <, Node, ,, Branch, >]
[), ;, }, private, void, prioritizeFromEntryNode, (, DiGraphNode, <, Node, ,, Branch, >, entry, ), {, PriorityQueue, <, DiGraphNode, <]
[), ;, }, private, void, prioritizeFromEntryNode, (, DiGraphNode, <, Node, ,, Branch, >, entry, ), {, PriorityQueue, <, DiGraphNode, <]
[;, worklist, ., add, (, entry, ), ;, while, (, !, worklist, ., isEmpty, (, ), ), {, DiGraphNode, <]
[,, priorityComparator, ), ;, worklist, ., add, (, entry, ), ;, while, (, !, worklist, ., isEmpty, (, ), )]
[), ;, worklist, ., add, (, entry, ), ;, while, (, !, worklist, ., isEmpty, (, ), ), {, DiGraphNode]
[;, while, (, !, worklist, ., isEmpty, (, ), ), {, DiGraphNode, <, Node, ,, Branch, >, current, =, worklist]
[., add, (, entry, ), ;, while, (, !, worklist, ., isEmpty, (, ), ), {, DiGraphNode, <, Node, ,]
[), ;, while, (, !, worklist, ., isEmpty, (, ), ), {, DiGraphNode, <, Node, ,, Branch, >, current, =]
[), {, DiGraphNode, <, Node, ,, Branch, >, current, =, worklist, ., remove, (, ), ;, if, (, nodePriorities, .]
[), {, DiGraphNode, <, Node, ,, Branch, >, current, =, worklist, ., remove, (, ), ;, if, (, nodePriorities, .]
[., isEmpty, (, ), ), {, DiGraphNode, <, Node, ,, Branch, >, current, =, worklist, ., remove, (, ), ;]
[;, if, (, nodePriorities, ., containsKey, (, current, ), ), {, continue, ;, }, nodePriorities, ., put, (, current, ,]
[., remove, (, ), ;, if, (, nodePriorities, ., containsKey, (, current, ), ), {, continue, ;, }, nodePriorities, .]
[), {, continue, ;, }, nodePriorities, ., put, (, current, ,, ++, priorityCounter, ), ;, List, <, DiGraphNode, <, Node]
[., containsKey, (, current, ), ), {, continue, ;, }, nodePriorities, ., put, (, current, ,, ++, priorityCounter, ), ;]
[), ), {, continue, ;, }, nodePriorities, ., put, (, current, ,, ++, priorityCounter, ), ;, List, <, DiGraphNode, <]
[;, List, <, DiGraphNode, <, Node, ,, Branch, >, >, successors, =, cfg, ., getDirectedSuccNodes, (, current, ), ;, for]
[., put, (, current, ,, ++, priorityCounter, ), ;, List, <, DiGraphNode, <, Node, ,, Branch, >, >, successors, =]
[,, ++, priorityCounter, ), ;, List, <, DiGraphNode, <, Node, ,, Branch, >, >, successors, =, cfg, ., getDirectedSuccNodes, (]
[), ;, List, <, DiGraphNode, <, Node, ,, Branch, >, >, successors, =, cfg, ., getDirectedSuccNodes, (, current, ), ;]
[), ;, List, <, DiGraphNode, <, Node, ,, Branch, >, >, successors, =, cfg, ., getDirectedSuccNodes, (, current, ), ;]
[;, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, successors, ), {, worklist, ., add, (, candidate, )]
[., getDirectedSuccNodes, (, current, ), ;, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, successors, ), {, worklist]
[), ;, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, successors, ), {, worklist, ., add, (, candidate]
[), {, worklist, ., add, (, candidate, ), ;, }, }, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal]
[;, }, }, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {]
[., add, (, candidate, ), ;, }, }, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n]
[), ;, }, }, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, )]
[;, switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions, ||, n]
[., put, (, n, ,, astPositionCounter, ++, ), ;, switch, (, n, ., getType, (, ), ), {, case, Token]
[,, astPositionCounter, ++, ), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if]
[), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions, ||]
[++, ), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions]
[), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions, ||, n, ==, cfg, ., getEntry, (, ), ., getValue]
[., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions, ||, n, ==, cfg, ., getEntry]
[:, if, (, shouldTraverseFunctions, ||, n, ==, cfg, ., getEntry, (, ), ., getValue, (, ), ), {, exceptionHandler, .]
[., FUNCTION, :, if, (, shouldTraverseFunctions, ||, n, ==, cfg, ., getEntry, (, ), ., getValue, (, ), ), {]
[), {, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, return, false, ;, case, Token, ., TRY]
[||, n, ==, cfg, ., getEntry, (, ), ., getValue, (, ), ), {, exceptionHandler, ., push, (, n, )]
[), {, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, return, false, ;, case, Token, ., TRY]
[==, cfg, ., getEntry, (, ), ., getValue, (, ), ), {, exceptionHandler, ., push, (, n, ), ;, return]
[), {, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, return, false, ;, case, Token, ., TRY]
[., getValue, (, ), ), {, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, return, false, ;]
[., getEntry, (, ), ., getValue, (, ), ), {, exceptionHandler, ., push, (, n, ), ;, return, true, ;]
[;, return, true, ;, }, return, false, ;, case, Token, ., TRY, :, exceptionHandler, ., push, (, n, ), ;]
[., push, (, n, ), ;, return, true, ;, }, return, false, ;, case, Token, ., TRY, :, exceptionHandler, .]
[), ;, return, true, ;, }, return, false, ;, case, Token, ., TRY, :, exceptionHandler, ., push, (, n, )]
[;, }, return, false, ;, case, Token, ., TRY, :, exceptionHandler, ., push, (, n, ), ;, return, true, ;]
[;, case, Token, ., TRY, :, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, if, (, parent]
[:, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, if, (, parent, !=, null, ), {, switch]
[., TRY, :, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, if, (, parent, !=, null, )]
[;, return, true, ;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, ), )]
[., push, (, n, ), ;, return, true, ;, }, if, (, parent, !=, null, ), {, switch, (, parent]
[), ;, return, true, ;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, )]
[;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token]
[), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, return, n, ==, parent]
[!=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, return, n]
[), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, return, n, ==, parent]
[), {, case, Token, ., FOR, :, return, n, ==, parent, ., getLastChild, (, ), ;, case, Token, ., IF]
[., getType, (, ), ), {, case, Token, ., FOR, :, return, n, ==, parent, ., getLastChild, (, ), ;]
[:, return, n, ==, parent, ., getLastChild, (, ), ;, case, Token, ., IF, :, case, Token, ., WHILE, :]
[., FOR, :, return, n, ==, parent, ., getLastChild, (, ), ;, case, Token, ., IF, :, case, Token, .]
[;, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, return, n, !=, parent]
[==, parent, ., getLastChild, (, ), ;, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, .]
[;, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, return, n, !=, parent]
[., getLastChild, (, ), ;, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., WITH, :]
[:, case, Token, ., WHILE, :, case, Token, ., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;]
[., IF, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, return, n, !=, parent, ., getFirstChild, (]
[:, case, Token, ., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., DO, :]
[., WHILE, :, case, Token, ., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, .]
[:, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, !=, parent, .]
[., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, !=]
[;, case, Token, ., DO, :, return, n, !=, parent, ., getFirstChild, (, ), ., getNext, (, ), ;, case]
[!=, parent, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, !=, parent, ., getFirstChild, (, )]
[;, case, Token, ., DO, :, return, n, !=, parent, ., getFirstChild, (, ), ., getNext, (, ), ;, case]
[., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, !=, parent, ., getFirstChild, (, ), ., getNext]
[:, return, n, !=, parent, ., getFirstChild, (, ), ., getNext, (, ), ;, case, Token, ., SWITCH, :, case]
[., DO, :, return, n, !=, parent, ., getFirstChild, (, ), ., getNext, (, ), ;, case, Token, ., SWITCH]
[;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :, case, Token, ., LABEL]
[!=, parent, ., getFirstChild, (, ), ., getNext, (, ), ;, case, Token, ., SWITCH, :, case, Token, ., CASE]
[;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :, case, Token, ., LABEL]
[., getNext, (, ), ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :]
[., getFirstChild, (, ), ., getNext, (, ), ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case]
[:, case, Token, ., CASE, :, case, Token, ., CATCH, :, case, Token, ., LABEL, :, return, n, !=, parent]
[., SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :, case, Token, ., LABEL, :, return, n]
[:, case, Token, ., CATCH, :, case, Token, ., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;]
[., CASE, :, case, Token, ., CATCH, :, case, Token, ., LABEL, :, return, n, !=, parent, ., getFirstChild, (]
[:, case, Token, ., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :]
[., CATCH, :, case, Token, ., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, .]
[:, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, n, ==, parent, .]
[., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, n, ==]
[;, case, Token, ., FUNCTION, :, return, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext]
[!=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, n, ==, parent, ., getFirstChild, (, )]
[;, case, Token, ., FUNCTION, :, return, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext]
[., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, n, ==, parent, ., getFirstChild, (, ), ., getNext]
[:, return, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, case, Token]
[., FUNCTION, :, return, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;]
[;, case, Token, ., CONTINUE, :, case, Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR]
[==, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, case, Token, ., CONTINUE, :]
[;, case, Token, ., CONTINUE, :, case, Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR]
[., getNext, (, ), ;, case, Token, ., CONTINUE, :, case, Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :]
[., getNext, (, ), ., getNext, (, ), ;, case, Token, ., CONTINUE, :, case, Token, ., BREAK, :, case]
[., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, case, Token, ., CONTINUE, :, case, Token]
[:, case, Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR, :, case, Token, ., RETURN]
[., CONTINUE, :, case, Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR, :, case, Token]
[:, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR, :, case, Token, ., RETURN, :, case, Token, ., THROW]
[., BREAK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR, :, case, Token, ., RETURN, :, case, Token]
[:, case, Token, ., VAR, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, return, false, ;, case]
[., EXPR_RESULT, :, case, Token, ., VAR, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, return, false]
[:, case, Token, ., RETURN, :, case, Token, ., THROW, :, return, false, ;, case, Token, ., TRY, :, if]
[., VAR, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, return, false, ;, case, Token, ., TRY]
[:, case, Token, ., THROW, :, return, false, ;, case, Token, ., TRY, :, if, (, n, ==, parent, .]
[., RETURN, :, case, Token, ., THROW, :, return, false, ;, case, Token, ., TRY, :, if, (, n, ==]
[:, return, false, ;, case, Token, ., TRY, :, if, (, n, ==, parent, ., getFirstChild, (, ), ., getNext]
[., THROW, :, return, false, ;, case, Token, ., TRY, :, if, (, n, ==, parent, ., getFirstChild, (, )]
[;, case, Token, ., TRY, :, if, (, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), )]
[:, if, (, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ), {, Preconditions, ., checkState, (]
[., TRY, :, if, (, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ), {, Preconditions, .]
[), {, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, parent, ), ;, exceptionHandler, ., pop, (, )]
[==, parent, ., getFirstChild, (, ), ., getNext, (, ), ), {, Preconditions, ., checkState, (, exceptionHandler, ., peek, (]
[), {, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, parent, ), ;, exceptionHandler, ., pop, (, )]
[., getNext, (, ), ), {, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, parent, ), ;, exceptionHandler]
[., getFirstChild, (, ), ., getNext, (, ), ), {, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==]
[;, exceptionHandler, ., pop, (, ), ;, }, }, }, return, true, ;, }, @, Override, public, void, visit, (]
[., checkState, (, exceptionHandler, ., peek, (, ), ==, parent, ), ;, exceptionHandler, ., pop, (, ), ;, }, }]
[), ;, exceptionHandler, ., pop, (, ), ;, }, }, }, return, true, ;, }, @, Override, public, void, visit]
[==, parent, ), ;, exceptionHandler, ., pop, (, ), ;, }, }, }, return, true, ;, }, @, Override, public]
[., peek, (, ), ==, parent, ), ;, exceptionHandler, ., pop, (, ), ;, }, }, }, return, true, ;]
[), ;, exceptionHandler, ., pop, (, ), ;, }, }, }, return, true, ;, }, @, Override, public, void, visit]
[;, }, }, }, return, true, ;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,]
[., pop, (, ), ;, }, }, }, return, true, ;, }, @, Override, public, void, visit, (, NodeTraversal, t]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, switch, (]
[), {, case, Token, ., IF, :, handleIf, (, n, ), ;, return, ;, case, Token, ., WHILE, :, handleWhile]
[., getType, (, ), ), {, case, Token, ., IF, :, handleIf, (, n, ), ;, return, ;, case, Token]
[:, handleIf, (, n, ), ;, return, ;, case, Token, ., WHILE, :, handleWhile, (, n, ), ;, return, ;]
[., IF, :, handleIf, (, n, ), ;, return, ;, case, Token, ., WHILE, :, handleWhile, (, n, ), ;]
[;, return, ;, case, Token, ., WHILE, :, handleWhile, (, n, ), ;, return, ;, case, Token, ., DO, :]
[), ;, return, ;, case, Token, ., WHILE, :, handleWhile, (, n, ), ;, return, ;, case, Token, ., DO]
[:, handleWhile, (, n, ), ;, return, ;, case, Token, ., DO, :, handleDo, (, n, ), ;, return, ;]
[., WHILE, :, handleWhile, (, n, ), ;, return, ;, case, Token, ., DO, :, handleDo, (, n, ), ;]
[;, return, ;, case, Token, ., DO, :, handleDo, (, n, ), ;, return, ;, case, Token, ., FOR, :]
[), ;, return, ;, case, Token, ., DO, :, handleDo, (, n, ), ;, return, ;, case, Token, ., FOR]
[:, handleDo, (, n, ), ;, return, ;, case, Token, ., FOR, :, handleFor, (, n, ), ;, return, ;]
[., DO, :, handleDo, (, n, ), ;, return, ;, case, Token, ., FOR, :, handleFor, (, n, ), ;]
[;, return, ;, case, Token, ., FOR, :, handleFor, (, n, ), ;, return, ;, case, Token, ., SWITCH, :]
[), ;, return, ;, case, Token, ., FOR, :, handleFor, (, n, ), ;, return, ;, case, Token, ., SWITCH]
[:, handleFor, (, n, ), ;, return, ;, case, Token, ., SWITCH, :, handleSwitch, (, n, ), ;, return, ;]
[., FOR, :, handleFor, (, n, ), ;, return, ;, case, Token, ., SWITCH, :, handleSwitch, (, n, ), ;]
[;, return, ;, case, Token, ., SWITCH, :, handleSwitch, (, n, ), ;, return, ;, case, Token, ., CASE, :]
[), ;, return, ;, case, Token, ., SWITCH, :, handleSwitch, (, n, ), ;, return, ;, case, Token, ., CASE]
[:, handleSwitch, (, n, ), ;, return, ;, case, Token, ., CASE, :, handleCase, (, n, ), ;, return, ;]
[., SWITCH, :, handleSwitch, (, n, ), ;, return, ;, case, Token, ., CASE, :, handleCase, (, n, ), ;]
[;, return, ;, case, Token, ., CASE, :, handleCase, (, n, ), ;, return, ;, case, Token, ., DEFAULT_CASE, :]
[), ;, return, ;, case, Token, ., CASE, :, handleCase, (, n, ), ;, return, ;, case, Token, ., DEFAULT_CASE]
[:, handleCase, (, n, ), ;, return, ;, case, Token, ., DEFAULT_CASE, :, handleDefault, (, n, ), ;, return, ;]
[., CASE, :, handleCase, (, n, ), ;, return, ;, case, Token, ., DEFAULT_CASE, :, handleDefault, (, n, ), ;]
[;, return, ;, case, Token, ., DEFAULT_CASE, :, handleDefault, (, n, ), ;, return, ;, case, Token, ., BLOCK, :]
[), ;, return, ;, case, Token, ., DEFAULT_CASE, :, handleDefault, (, n, ), ;, return, ;, case, Token, ., BLOCK]
[:, handleDefault, (, n, ), ;, return, ;, case, Token, ., BLOCK, :, case, Token, ., SCRIPT, :, handleStmtList, (]
[., DEFAULT_CASE, :, handleDefault, (, n, ), ;, return, ;, case, Token, ., BLOCK, :, case, Token, ., SCRIPT, :]
[;, return, ;, case, Token, ., BLOCK, :, case, Token, ., SCRIPT, :, handleStmtList, (, n, ), ;, return, ;]
[), ;, return, ;, case, Token, ., BLOCK, :, case, Token, ., SCRIPT, :, handleStmtList, (, n, ), ;, return]
[:, case, Token, ., SCRIPT, :, handleStmtList, (, n, ), ;, return, ;, case, Token, ., FUNCTION, :, handleFunction, (]
[., BLOCK, :, case, Token, ., SCRIPT, :, handleStmtList, (, n, ), ;, return, ;, case, Token, ., FUNCTION, :]
[:, handleStmtList, (, n, ), ;, return, ;, case, Token, ., FUNCTION, :, handleFunction, (, n, ), ;, return, ;]
[., SCRIPT, :, handleStmtList, (, n, ), ;, return, ;, case, Token, ., FUNCTION, :, handleFunction, (, n, ), ;]
[;, return, ;, case, Token, ., FUNCTION, :, handleFunction, (, n, ), ;, return, ;, case, Token, ., EXPR_RESULT, :]
[), ;, return, ;, case, Token, ., FUNCTION, :, handleFunction, (, n, ), ;, return, ;, case, Token, ., EXPR_RESULT]
[:, handleFunction, (, n, ), ;, return, ;, case, Token, ., EXPR_RESULT, :, handleExpr, (, n, ), ;, return, ;]
[., FUNCTION, :, handleFunction, (, n, ), ;, return, ;, case, Token, ., EXPR_RESULT, :, handleExpr, (, n, ), ;]
[;, return, ;, case, Token, ., EXPR_RESULT, :, handleExpr, (, n, ), ;, return, ;, case, Token, ., THROW, :]
[), ;, return, ;, case, Token, ., EXPR_RESULT, :, handleExpr, (, n, ), ;, return, ;, case, Token, ., THROW]
[:, handleExpr, (, n, ), ;, return, ;, case, Token, ., THROW, :, handleThrow, (, n, ), ;, return, ;]
[., EXPR_RESULT, :, handleExpr, (, n, ), ;, return, ;, case, Token, ., THROW, :, handleThrow, (, n, ), ;]
[;, return, ;, case, Token, ., THROW, :, handleThrow, (, n, ), ;, return, ;, case, Token, ., TRY, :]
[), ;, return, ;, case, Token, ., THROW, :, handleThrow, (, n, ), ;, return, ;, case, Token, ., TRY]
[:, handleThrow, (, n, ), ;, return, ;, case, Token, ., TRY, :, handleTry, (, n, ), ;, return, ;]
[., THROW, :, handleThrow, (, n, ), ;, return, ;, case, Token, ., TRY, :, handleTry, (, n, ), ;]
[;, return, ;, case, Token, ., TRY, :, handleTry, (, n, ), ;, return, ;, case, Token, ., CATCH, :]
[), ;, return, ;, case, Token, ., TRY, :, handleTry, (, n, ), ;, return, ;, case, Token, ., CATCH]
[:, handleTry, (, n, ), ;, return, ;, case, Token, ., CATCH, :, handleCatch, (, n, ), ;, return, ;]
[., TRY, :, handleTry, (, n, ), ;, return, ;, case, Token, ., CATCH, :, handleCatch, (, n, ), ;]
[;, return, ;, case, Token, ., CATCH, :, handleCatch, (, n, ), ;, return, ;, case, Token, ., BREAK, :]
[), ;, return, ;, case, Token, ., CATCH, :, handleCatch, (, n, ), ;, return, ;, case, Token, ., BREAK]
[:, handleCatch, (, n, ), ;, return, ;, case, Token, ., BREAK, :, handleBreak, (, n, ), ;, return, ;]
[., CATCH, :, handleCatch, (, n, ), ;, return, ;, case, Token, ., BREAK, :, handleBreak, (, n, ), ;]
[;, return, ;, case, Token, ., BREAK, :, handleBreak, (, n, ), ;, return, ;, case, Token, ., CONTINUE, :]
[), ;, return, ;, case, Token, ., BREAK, :, handleBreak, (, n, ), ;, return, ;, case, Token, ., CONTINUE]
[:, handleBreak, (, n, ), ;, return, ;, case, Token, ., CONTINUE, :, handleContinue, (, n, ), ;, return, ;]
[., BREAK, :, handleBreak, (, n, ), ;, return, ;, case, Token, ., CONTINUE, :, handleContinue, (, n, ), ;]
[;, return, ;, case, Token, ., CONTINUE, :, handleContinue, (, n, ), ;, return, ;, case, Token, ., RETURN, :]
[), ;, return, ;, case, Token, ., CONTINUE, :, handleContinue, (, n, ), ;, return, ;, case, Token, ., RETURN]
[:, handleContinue, (, n, ), ;, return, ;, case, Token, ., RETURN, :, handleReturn, (, n, ), ;, return, ;]
[., CONTINUE, :, handleContinue, (, n, ), ;, return, ;, case, Token, ., RETURN, :, handleReturn, (, n, ), ;]
[;, return, ;, case, Token, ., RETURN, :, handleReturn, (, n, ), ;, return, ;, case, Token, ., WITH, :]
[), ;, return, ;, case, Token, ., RETURN, :, handleReturn, (, n, ), ;, return, ;, case, Token, ., WITH]
[:, handleReturn, (, n, ), ;, return, ;, case, Token, ., WITH, :, handleWith, (, n, ), ;, return, ;]
[., RETURN, :, handleReturn, (, n, ), ;, return, ;, case, Token, ., WITH, :, handleWith, (, n, ), ;]
[;, return, ;, case, Token, ., WITH, :, handleWith, (, n, ), ;, return, ;, case, Token, ., LABEL, :]
[), ;, return, ;, case, Token, ., WITH, :, handleWith, (, n, ), ;, return, ;, case, Token, ., LABEL]
[:, handleWith, (, n, ), ;, return, ;, case, Token, ., LABEL, :, return, ;, default, :, handleStmt, (, n]
[., WITH, :, handleWith, (, n, ), ;, return, ;, case, Token, ., LABEL, :, return, ;, default, :, handleStmt]
[;, return, ;, case, Token, ., LABEL, :, return, ;, default, :, handleStmt, (, n, ), ;, return, ;, }]
[), ;, return, ;, case, Token, ., LABEL, :, return, ;, default, :, handleStmt, (, n, ), ;, return, ;]
[:, return, ;, default, :, handleStmt, (, n, ), ;, return, ;, }, }, private, void, handleIf, (, Node, node]
[., LABEL, :, return, ;, default, :, handleStmt, (, n, ), ;, return, ;, }, }, private, void, handleIf, (]
[;, return, ;, }, }, private, void, handleIf, (, Node, node, ), {, Node, thenBlock, =, node, ., getFirstChild, (]
[), ;, return, ;, }, }, private, void, handleIf, (, Node, node, ), {, Node, thenBlock, =, node, ., getFirstChild]
[;, Node, elseBlock, =, thenBlock, ., getNext, (, ), ;, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[., getNext, (, ), ;, Node, elseBlock, =, thenBlock, ., getNext, (, ), ;, createEdge, (, node, ,, Branch, .]
[., getFirstChild, (, ), ., getNext, (, ), ;, Node, elseBlock, =, thenBlock, ., getNext, (, ), ;, createEdge, (]
[;, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (, elseBlock, ==, null]
[., getNext, (, ), ;, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if]
[;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,]
[,, Branch, ., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (, elseBlock, ==, null, ), {, createEdge, (]
[,, computeFallThrough, (, thenBlock, ), ), ;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,, Branch, .]
[., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,]
[), ;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node]
[), ), ;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (]
[), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, else]
[==, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;]
[), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, else]
[;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;, }, connectToPossibleExceptionHandler]
[,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, else, {, createEdge, (, node, ,]
[,, computeFollowNode, (, node, ,, this, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,]
[., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, .]
[), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;, }]
[,, this, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, )]
[), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;]
[;, }, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleWhile, (, Node]
[,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;, }, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (]
[,, computeFallThrough, (, elseBlock, ), ), ;, }, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;]
[., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;, }, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, )]
[), ;, }, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleWhile, (]
[), ), ;, }, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleWhile]
[;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (]
[), ;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough]
[., getConditionExpression, (, node, ), ), ;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,]
[), ), ;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,]
[;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node]
[,, Branch, ., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ), ), ;, createEdge]
[,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ), ), ;, createEdge, (, node, ,, Branch]
[., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ), ), ;, createEdge, (, node]
[), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (]
[), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler]
[., getNext, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this]
[., getFirstChild, (, ), ., getNext, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode]
[;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleDo, (, Node, node]
[,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression]
[,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), )]
[., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node]
[), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleDo, (, Node]
[,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void]
[), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleDo, (]
[;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (]
[), ;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough]
[., getConditionExpression, (, node, ), ), ;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (, node, ,]
[), ), ;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,]
[;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node]
[,, Branch, ., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ), ), ;, createEdge, (, node, ,, Branch]
[,, computeFallThrough, (, node, ., getFirstChild, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode]
[., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE]
[), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (]
[), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler]
[., getFirstChild, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this]
[;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleFor, (, Node, forNode]
[,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression]
[,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), )]
[., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node]
[), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleFor, (, Node]
[,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void]
[), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleFor, (]
[;, }, private, void, handleFor, (, Node, forNode, ), {, if, (, forNode, ., getChildCount, (, ), ==, 4, )]
[,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleFor, (, Node, forNode, ), {, if, (]
[), ;, }, private, void, handleFor, (, Node, forNode, ), {, if, (, forNode, ., getChildCount, (, ), ==, 4]
[., getConditionExpression, (, node, ), ), ;, }, private, void, handleFor, (, Node, forNode, ), {, if, (, forNode, .]
[), ), ;, }, private, void, handleFor, (, Node, forNode, ), {, if, (, forNode, ., getChildCount, (, ), ==]
[), {, Node, init, =, forNode, ., getFirstChild, (, ), ;, Node, cond, =, init, ., getNext, (, ), ;]
[==, 4, ), {, Node, init, =, forNode, ., getFirstChild, (, ), ;, Node, cond, =, init, ., getNext, (]
[., getChildCount, (, ), ==, 4, ), {, Node, init, =, forNode, ., getFirstChild, (, ), ;, Node, cond, =]
[), {, Node, init, =, forNode, ., getFirstChild, (, ), ;, Node, cond, =, init, ., getNext, (, ), ;]
[;, Node, cond, =, init, ., getNext, (, ), ;, Node, iter, =, cond, ., getNext, (, ), ;, Node]
[., getFirstChild, (, ), ;, Node, cond, =, init, ., getNext, (, ), ;, Node, iter, =, cond, ., getNext]
[;, Node, iter, =, cond, ., getNext, (, ), ;, Node, body, =, iter, ., getNext, (, ), ;, createEdge]
[., getNext, (, ), ;, Node, iter, =, cond, ., getNext, (, ), ;, Node, body, =, iter, ., getNext]
[;, Node, body, =, iter, ., getNext, (, ), ;, createEdge, (, init, ,, Branch, ., UNCOND, ,, forNode, )]
[., getNext, (, ), ;, Node, body, =, iter, ., getNext, (, ), ;, createEdge, (, init, ,, Branch, .]
[;, createEdge, (, init, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,]
[., getNext, (, ), ;, createEdge, (, init, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,]
[;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch]
[,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, )]
[,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (]
[., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,]
[;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (, iter]
[,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode]
[,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this]
[., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (]
[), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge]
[;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler]
[,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (, iter, ,, Branch, ., UNCOND]
[,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;]
[., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode]
[), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;]
[,, this, ), ), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,]
[), ), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, )]
[;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (, iter, ,, iter]
[,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond]
[,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (]
[., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;]
[), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (, iter, ,]
[;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (, iter, ,, iter, ), ;, }, else, {, Node, item]
[,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (, iter, ,, iter, ), ;, }, else]
[), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (, iter, ,, iter, ), ;, }, else, {, Node]
[;, connectToPossibleExceptionHandler, (, iter, ,, iter, ), ;, }, else, {, Node, item, =, forNode, ., getFirstChild, (, ), ;]
[,, cond, ), ;, connectToPossibleExceptionHandler, (, iter, ,, iter, ), ;, }, else, {, Node, item, =, forNode, ., getFirstChild]
[), ;, connectToPossibleExceptionHandler, (, iter, ,, iter, ), ;, }, else, {, Node, item, =, forNode, ., getFirstChild, (, )]
[;, }, else, {, Node, item, =, forNode, ., getFirstChild, (, ), ;, Node, collection, =, item, ., getNext, (]
[,, iter, ), ;, }, else, {, Node, item, =, forNode, ., getFirstChild, (, ), ;, Node, collection, =, item]
[), ;, }, else, {, Node, item, =, forNode, ., getFirstChild, (, ), ;, Node, collection, =, item, ., getNext]
[;, Node, collection, =, item, ., getNext, (, ), ;, Node, body, =, collection, ., getNext, (, ), ;, createEdge]
[., getFirstChild, (, ), ;, Node, collection, =, item, ., getNext, (, ), ;, Node, body, =, collection, ., getNext]
[;, Node, body, =, collection, ., getNext, (, ), ;, createEdge, (, collection, ,, Branch, ., UNCOND, ,, forNode, )]
[., getNext, (, ), ;, Node, body, =, collection, ., getNext, (, ), ;, createEdge, (, collection, ,, Branch, .]
[;, createEdge, (, collection, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,]
[., getNext, (, ), ;, createEdge, (, collection, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,]
[;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch]
[,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, )]
[,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (]
[., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,]
[;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, forNode]
[,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode]
[,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this]
[., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, connectToPossibleExceptionHandler, (]
[), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, connectToPossibleExceptionHandler]
[;, connectToPossibleExceptionHandler, (, forNode, ,, collection, ), ;, }, }, private, void, handleSwitch, (, Node, node, ), {, Node, next]
[,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, forNode, ,, collection, ), ;]
[,, computeFollowNode, (, forNode, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, forNode, ,, collection, ), ;, }, }, private, void]
[., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, forNode, ,, collection, ), ;, }, }]
[), ;, connectToPossibleExceptionHandler, (, forNode, ,, collection, ), ;, }, }, private, void, handleSwitch, (, Node, node, ), {, Node]
[,, this, ), ), ;, connectToPossibleExceptionHandler, (, forNode, ,, collection, ), ;, }, }, private, void, handleSwitch, (, Node, node]
[), ), ;, connectToPossibleExceptionHandler, (, forNode, ,, collection, ), ;, }, }, private, void, handleSwitch, (, Node, node, ), {]
[;, }, }, private, void, handleSwitch, (, Node, node, ), {, Node, next, =, getNextSiblingOfType, (, node, ., getFirstChild, (]
[,, collection, ), ;, }, }, private, void, handleSwitch, (, Node, node, ), {, Node, next, =, getNextSiblingOfType, (, node]
[), ;, }, }, private, void, handleSwitch, (, Node, node, ), {, Node, next, =, getNextSiblingOfType, (, node, ., getFirstChild]
[;, if, (, next, !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next, ), ;, }]
[,, Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (, next, !=, null, ), {, createEdge, (, node]
[., getNext, (, ), ,, Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (, next, !=, null, )]
[., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (]
[,, Token, ., EMPTY, ), ;, if, (, next, !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND]
[., CASE, ,, Token, ., EMPTY, ), ;, if, (, next, !=, null, ), {, createEdge, (, node, ,, Branch]
[), ;, if, (, next, !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next, ), ;]
[., EMPTY, ), ;, if, (, next, !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next, ), ;, }, else, {, if, (, node, .]
[!=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next, ), ;, }, else, {, if, (]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next, ), ;, }, else, {, if, (, node, .]
[;, }, else, {, if, (, node, ., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {, createEdge]
[,, Branch, ., UNCOND, ,, next, ), ;, }, else, {, if, (, node, ., getFirstChild, (, ), ., getNext]
[,, next, ), ;, }, else, {, if, (, node, ., getFirstChild, (, ), ., getNext, (, ), !=, null]
[., UNCOND, ,, next, ), ;, }, else, {, if, (, node, ., getFirstChild, (, ), ., getNext, (, )]
[), ;, }, else, {, if, (, node, ., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ., getNext, (, ), )]
[!=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ., getNext, (]
[., getNext, (, ), !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, ., getFirstChild, (]
[., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ., getNext, (, ), )]
[;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;]
[,, Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, }, else, {, createEdge]
[,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, }, else, {, createEdge, (, node, ,, Branch]
[., UNCOND, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, }, else, {, createEdge, (, node]
[), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), )]
[., getNext, (, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node]
[., getFirstChild, (, ), ., getNext, (, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND]
[;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCase, (, Node]
[,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node]
[,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, )]
[., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild]
[), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCase, (]
[,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private]
[), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCase]
[;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, node, .]
[,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (, node]
[), ;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, node]
[., getFirstChild, (, ), ), ;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (, node, ,, Branch]
[;, Node, next, =, getNextSiblingOfType, (, node, ., getNext, (, ), ,, Token, ., CASE, ), ;, if, (, next]
[,, Branch, ., ON_TRUE, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, next, =, getNextSiblingOfType]
[,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, next, =, getNextSiblingOfType, (, node, ., getNext]
[., ON_TRUE, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, next, =, getNextSiblingOfType, (, node]
[), ;, Node, next, =, getNextSiblingOfType, (, node, ., getNext, (, ), ,, Token, ., CASE, ), ;, if, (]
[., getNext, (, ), ), ;, Node, next, =, getNextSiblingOfType, (, node, ., getNext, (, ), ,, Token, ., CASE]
[., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, next, =, getNextSiblingOfType, (, node, ., getNext, (, )]
[;, if, (, next, !=, null, ), {, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;, createEdge]
[,, Token, ., CASE, ), ;, if, (, next, !=, null, ), {, Preconditions, ., checkState, (, next, ., isCase]
[., getNext, (, ), ,, Token, ., CASE, ), ;, if, (, next, !=, null, ), {, Preconditions, ., checkState]
[), ;, if, (, next, !=, null, ), {, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;]
[., CASE, ), ;, if, (, next, !=, null, ), {, Preconditions, ., checkState, (, next, ., isCase, (, )]
[), {, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE]
[!=, null, ), {, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;, createEdge, (, node, ,, Branch]
[), {, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE]
[;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, next, ), ;, }, else, {, Node, parent, =, node, .]
[., checkState, (, next, ., isCase, (, ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, next, )]
[), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, next, ), ;, }, else, {, Node, parent, =, node]
[., isCase, (, ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, next, ), ;, }, else, {]
[;, }, else, {, Node, parent, =, node, ., getParent, (, ), ;, Node, deflt, =, getNextSiblingOfType, (, parent, .]
[,, Branch, ., ON_FALSE, ,, next, ), ;, }, else, {, Node, parent, =, node, ., getParent, (, ), ;]
[,, next, ), ;, }, else, {, Node, parent, =, node, ., getParent, (, ), ;, Node, deflt, =, getNextSiblingOfType]
[., ON_FALSE, ,, next, ), ;, }, else, {, Node, parent, =, node, ., getParent, (, ), ;, Node, deflt]
[), ;, }, else, {, Node, parent, =, node, ., getParent, (, ), ;, Node, deflt, =, getNextSiblingOfType, (, parent]
[;, Node, deflt, =, getNextSiblingOfType, (, parent, ., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., DEFAULT_CASE, )]
[., getParent, (, ), ;, Node, deflt, =, getNextSiblingOfType, (, parent, ., getFirstChild, (, ), ., getNext, (, ), ,]
[;, if, (, deflt, !=, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;, }]
[,, Token, ., DEFAULT_CASE, ), ;, if, (, deflt, !=, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE]
[., getNext, (, ), ,, Token, ., DEFAULT_CASE, ), ;, if, (, deflt, !=, null, ), {, createEdge, (, node]
[., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., DEFAULT_CASE, ), ;, if, (, deflt, !=, null, )]
[), ;, if, (, deflt, !=, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;]
[., DEFAULT_CASE, ), ;, if, (, deflt, !=, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt]
[), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (, node, ,]
[!=, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (]
[), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (, node, ,]
[;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;]
[,, Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode]
[,, deflt, ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this]
[., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node]
[), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), )]
[;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleDefault, (, Node]
[,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node]
[,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, )]
[., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild]
[), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleDefault, (]
[,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private]
[), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleDefault]
[;, }, private, void, handleDefault, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, .]
[,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleDefault, (, Node, node, ), {, createEdge, (, node]
[), ;, }, private, void, handleDefault, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node]
[., getFirstChild, (, ), ), ;, }, private, void, handleDefault, (, Node, node, ), {, createEdge, (, node, ,, Branch]
[;, }, private, void, handleWith, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, .]
[,, Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleWith, (, Node, node, )]
[,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleWith, (, Node, node, ), {, createEdge, (, node]
[., UNCOND, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleWith, (, Node, node, ), {, createEdge]
[), ;, }, private, void, handleWith, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node]
[., getFirstChild, (, ), ), ;, }, private, void, handleWith, (, Node, node, ), {, createEdge, (, node, ,, Branch]
[;, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleStmtList, (, Node, node, )]
[,, Branch, ., UNCOND, ,, node, ., getLastChild, (, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (]
[,, node, ., getLastChild, (, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }]
[., UNCOND, ,, node, ., getLastChild, (, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), )]
[), ;, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleStmtList, (, Node, node]
[., getLastChild, (, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void]
[;, }, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =, node, ., getParent, (, ), ;, if]
[,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =]
[), ;, }, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =, node, ., getParent, (, ), ;]
[., getFirstChild, (, ), ), ;, }, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =, node, .]
[;, if, (, node, ., isBlock, (, ), &&, parent, !=, null, &&, parent, ., isTry, (, ), &&, NodeUtil]
[., getParent, (, ), ;, if, (, node, ., isBlock, (, ), &&, parent, !=, null, &&, parent, ., isTry]
[), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (, child, !=, null, &&]
[&&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =, node, ., getFirstChild, (]
[&&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return]
[&&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler]
[&&, parent, !=, null, &&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&]
[., isBlock, (, ), &&, parent, !=, null, &&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent]
[&&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler]
[!=, null, &&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !, NodeUtil]
[&&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler]
[&&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return]
[., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler, (, node]
[&&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =, node, ., getFirstChild, (]
[==, node, &&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =, node, .]
[., getCatchBlock, (, parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return, ;, }]
[), ==, node, &&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =, node]
[&&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =, node, ., getFirstChild, (]
[), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (, child, !=, null, &&]
[), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (, child, !=, null, &&]
[., hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while]
[), ), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (, child, !=, null]
[;, while, (, child, !=, null, &&, child, ., isFunction, (, ), ), {, child, =, child, ., getNext, (]
[., getFirstChild, (, ), ;, while, (, child, !=, null, &&, child, ., isFunction, (, ), ), {, child, =]
[), {, child, =, child, ., getNext, (, ), ;, }, if, (, child, !=, null, ), {, createEdge, (]
[&&, child, ., isFunction, (, ), ), {, child, =, child, ., getNext, (, ), ;, }, if, (, child]
[!=, null, &&, child, ., isFunction, (, ), ), {, child, =, child, ., getNext, (, ), ;, }, if]
[&&, child, ., isFunction, (, ), ), {, child, =, child, ., getNext, (, ), ;, }, if, (, child]
[), {, child, =, child, ., getNext, (, ), ;, }, if, (, child, !=, null, ), {, createEdge, (]
[., isFunction, (, ), ), {, child, =, child, ., getNext, (, ), ;, }, if, (, child, !=, null]
[=, child, ., getNext, (, ), ;, }, if, (, child, !=, null, ), {, createEdge, (, node, ,, Branch]
[;, }, if, (, child, !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, child]
[., getNext, (, ), ;, }, if, (, child, !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge]
[!=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge]
[;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;]
[,, Branch, ., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, .]
[,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (]
[., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), )]
[), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, )]
[;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token]
[,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, if, (, parent, !=, null, )]
[,, computeFollowNode, (, node, ,, this, ), ), ;, }, if, (, parent, !=, null, ), {, switch, (, parent]
[., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, if, (, parent, !=, null, ), {, switch]
[), ;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case]
[,, this, ), ), ;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, )]
[), ), ;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {]
[), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., DEFAULT_CASE, :, case, Token, ., CASE]
[!=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., DEFAULT_CASE, :, case, Token]
[), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., DEFAULT_CASE, :, case, Token, ., CASE]
[), {, case, Token, ., DEFAULT_CASE, :, case, Token, ., CASE, :, case, Token, ., TRY, :, break, ;, default]
[., getType, (, ), ), {, case, Token, ., DEFAULT_CASE, :, case, Token, ., CASE, :, case, Token, ., TRY]
[:, case, Token, ., CASE, :, case, Token, ., TRY, :, break, ;, default, :, if, (, node, ., isBlock]
[., DEFAULT_CASE, :, case, Token, ., CASE, :, case, Token, ., TRY, :, break, ;, default, :, if, (, node]
[:, case, Token, ., TRY, :, break, ;, default, :, if, (, node, ., isBlock, (, ), &&, node, .]
[., CASE, :, case, Token, ., TRY, :, break, ;, default, :, if, (, node, ., isBlock, (, ), &&]
[:, break, ;, default, :, if, (, node, ., isBlock, (, ), &&, node, ., isSyntheticBlock, (, ), ), {]
[., TRY, :, break, ;, default, :, if, (, node, ., isBlock, (, ), &&, node, ., isSyntheticBlock, (, )]
[), {, createEdge, (, node, ,, Branch, ., SYN_BLOCK, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, break]
[&&, node, ., isSyntheticBlock, (, ), ), {, createEdge, (, node, ,, Branch, ., SYN_BLOCK, ,, computeFollowNode, (, node, ,]
[., isBlock, (, ), &&, node, ., isSyntheticBlock, (, ), ), {, createEdge, (, node, ,, Branch, ., SYN_BLOCK, ,]
[), {, createEdge, (, node, ,, Branch, ., SYN_BLOCK, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, break]
[., isSyntheticBlock, (, ), ), {, createEdge, (, node, ,, Branch, ., SYN_BLOCK, ,, computeFollowNode, (, node, ,, this, )]
[;, }, break, ;, }, }, }, private, void, handleFunction, (, Node, node, ), {, Preconditions, ., checkState, (, node]
[,, Branch, ., SYN_BLOCK, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, break, ;, }, }, }, private]
[,, computeFollowNode, (, node, ,, this, ), ), ;, }, break, ;, }, }, }, private, void, handleFunction, (, Node]
[., SYN_BLOCK, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, break, ;, }, }, }, private, void, handleFunction]
[), ;, }, break, ;, }, }, }, private, void, handleFunction, (, Node, node, ), {, Preconditions, ., checkState, (]
[,, this, ), ), ;, }, break, ;, }, }, }, private, void, handleFunction, (, Node, node, ), {, Preconditions]
[), ), ;, }, break, ;, }, }, }, private, void, handleFunction, (, Node, node, ), {, Preconditions, ., checkState]
[;, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, )]
[., checkState, (, node, ., getChildCount, (, ), >=, 3, ), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (]
[>=, 3, ), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, node, ., getFirstChild, (, ), .]
[., getChildCount, (, ), >=, 3, ), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, node, .]
[), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (]
[;, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, node, ), ;, exceptionHandler, ., pop, (, ), ;]
[,, Branch, ., UNCOND, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, )]
[,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ), ), ;, Preconditions]
[., UNCOND, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ), )]
[), ;, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, node, ), ;, exceptionHandler, ., pop, (, )]
[), ), ;, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, node, ), ;, exceptionHandler, ., pop, (]
[., getNext, (, ), ), ), ;, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, node, ), ;]
[., getNext, (, ), ., getNext, (, ), ), ), ;, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, )]
[., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ), ), ;, Preconditions, ., checkState, (, exceptionHandler]
[;, exceptionHandler, ., pop, (, ), ;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (, node, ,]
[., checkState, (, exceptionHandler, ., peek, (, ), ==, node, ), ;, exceptionHandler, ., pop, (, ), ;, }, private]
[), ;, exceptionHandler, ., pop, (, ), ;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (, node]
[==, node, ), ;, exceptionHandler, ., pop, (, ), ;, }, private, void, handleExpr, (, Node, node, ), {, createEdge]
[., peek, (, ), ==, node, ), ;, exceptionHandler, ., pop, (, ), ;, }, private, void, handleExpr, (, Node]
[), ;, exceptionHandler, ., pop, (, ), ;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (, node]
[;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (]
[., pop, (, ), ;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (, node, ,, Branch, .]
[;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleThrow, (, Node, node, ), {, connectToPossibleExceptionHandler, (, node]
[,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;]
[,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleThrow]
[., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private]
[), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleThrow, (, Node, node, ), {, connectToPossibleExceptionHandler, (]
[,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleThrow, (, Node, node, )]
[), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleThrow, (, Node, node, ), {, connectToPossibleExceptionHandler]
[;, }, private, void, handleThrow, (, Node, node, ), {, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void]
[,, node, ), ;, }, private, void, handleThrow, (, Node, node, ), {, connectToPossibleExceptionHandler, (, node, ,, node, ), ;]
[), ;, }, private, void, handleThrow, (, Node, node, ), {, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private]
[;, }, private, void, handleTry, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, .]
[,, node, ), ;, }, private, void, handleTry, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND]
[), ;, }, private, void, handleTry, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node]
[;, }, private, void, handleCatch, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, .]
[,, Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCatch, (, Node, node, )]
[,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCatch, (, Node, node, ), {, createEdge, (, node]
[., UNCOND, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCatch, (, Node, node, ), {, createEdge]
[), ;, }, private, void, handleCatch, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node]
[., getFirstChild, (, ), ), ;, }, private, void, handleCatch, (, Node, node, ), {, createEdge, (, node, ,, Branch]
[;, }, private, void, handleBreak, (, Node, node, ), {, String, label, =, null, ;, if, (, node, ., hasChildren]
[,, Branch, ., UNCOND, ,, node, ., getLastChild, (, ), ), ;, }, private, void, handleBreak, (, Node, node, )]
[,, node, ., getLastChild, (, ), ), ;, }, private, void, handleBreak, (, Node, node, ), {, String, label, =]
[., UNCOND, ,, node, ., getLastChild, (, ), ), ;, }, private, void, handleBreak, (, Node, node, ), {, String]
[), ;, }, private, void, handleBreak, (, Node, node, ), {, String, label, =, null, ;, if, (, node, .]
[., getLastChild, (, ), ), ;, }, private, void, handleBreak, (, Node, node, ), {, String, label, =, null, ;]
[;, if, (, node, ., hasChildren, (, ), ), {, label, =, node, ., getFirstChild, (, ), ., getString, (]
[), {, label, =, node, ., getFirstChild, (, ), ., getString, (, ), ;, }, Node, cur, ;, Node, previous]
[., hasChildren, (, ), ), {, label, =, node, ., getFirstChild, (, ), ., getString, (, ), ;, }, Node]
[=, node, ., getFirstChild, (, ), ., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;]
[;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (]
[., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =]
[., getFirstChild, (, ), ., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump]
[;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump]
[;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,, label, ), ;, cur]
[., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,]
[=, node, ,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,, label, ), ;, cur, =, parent, ,, parent]
[,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,, label, ), ;, cur, =, parent, ,, parent, =, parent]
[=, node, ;, !, isBreakTarget, (, cur, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent]
[;, !, isBreakTarget, (, cur, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, )]
[;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (]
[;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (]
[,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur]
[), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry]
[=, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&]
[,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, .]
[=, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (]
[), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild]
[., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, )]
[), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (, cur]
[&&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump]
[&&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump]
[., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, )]
[&&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump]
[., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node]
[), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (]
[), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (, cur]
[!=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough]
[., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch]
[), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (, cur]
[), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;]
[==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (, cur, ., getLastChild, (, ), )]
[), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;]
[;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;]
[,, Branch, ., UNCOND, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, else, {, finallyMap, .]
[,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[., UNCOND, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, else, {, finallyMap, ., put, (]
[), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), )]
[), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), )]
[., getLastChild, (, ), ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, .]
[;, }, lastJump, =, cur, ;, }, if, (, parent, ==, null, ), {, if, (, compiler, ., isIdeMode, (]
[., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;]
[,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, if, (, parent]
[), ;, }, lastJump, =, cur, ;, }, if, (, parent, ==, null, ), {, if, (, compiler, ., isIdeMode]
[), ), ;, }, lastJump, =, cur, ;, }, if, (, parent, ==, null, ), {, if, (, compiler, .]
[., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, if, (, parent, ==, null, ), {]
[=, cur, ;, }, if, (, parent, ==, null, ), {, if, (, compiler, ., isIdeMode, (, ), ), {]
[;, }, if, (, parent, ==, null, ), {, if, (, compiler, ., isIdeMode, (, ), ), {, return, ;]
[), {, if, (, compiler, ., isIdeMode, (, ), ), {, return, ;, }, else, {, throw, new, IllegalStateException, (]
[==, null, ), {, if, (, compiler, ., isIdeMode, (, ), ), {, return, ;, }, else, {, throw, new]
[), {, if, (, compiler, ., isIdeMode, (, ), ), {, return, ;, }, else, {, throw, new, IllegalStateException, (]
[), {, return, ;, }, else, {, throw, new, IllegalStateException, (, "Cannot find break target.", ), ;, }, }, previous, =, cur, ;]
[., isIdeMode, (, ), ), {, return, ;, }, else, {, throw, new, IllegalStateException, (, "Cannot find break target.", ), ;, }, }]
[;, }, }, previous, =, cur, ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch]
[), ;, }, }, previous, =, cur, ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,]
[=, cur, ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFollowNode]
[;, }, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFollowNode, (, cur]
[), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else]
[==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFollowNode, (, cur, ,, this, ), ), ;]
[), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else]
[;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, }]
[,, Branch, ., UNCOND, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else, {, finallyMap, ., put, (]
[,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFollowNode, (]
[., UNCOND, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }]
[,, this, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFollowNode, (, cur, ,, this, )]
[), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFollowNode, (, cur, ,, this, ), ), ;]
[;, }, }, private, void, handleContinue, (, Node, node, ), {, String, label, =, null, ;, if, (, node, .]
[., put, (, lastJump, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, }, private, void, handleContinue, (, Node]
[,, computeFollowNode, (, cur, ,, this, ), ), ;, }, }, private, void, handleContinue, (, Node, node, ), {, String]
[), ;, }, }, private, void, handleContinue, (, Node, node, ), {, String, label, =, null, ;, if, (, node]
[,, this, ), ), ;, }, }, private, void, handleContinue, (, Node, node, ), {, String, label, =, null, ;]
[), ), ;, }, }, private, void, handleContinue, (, Node, node, ), {, String, label, =, null, ;, if, (]
[;, if, (, node, ., hasChildren, (, ), ), {, label, =, node, ., getFirstChild, (, ), ., getString, (]
[), {, label, =, node, ., getFirstChild, (, ), ., getString, (, ), ;, }, Node, cur, ;, Node, previous]
[., hasChildren, (, ), ), {, label, =, node, ., getFirstChild, (, ), ., getString, (, ), ;, }, Node]
[=, node, ., getFirstChild, (, ), ., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;]
[;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (]
[., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =]
[., getFirstChild, (, ), ., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump]
[;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump]
[;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isContinueTarget, (, cur, ,, parent, ,, label, )]
[., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isContinueTarget, (, cur, ,]
[=, node, ,, lastJump, =, node, ;, !, isContinueTarget, (, cur, ,, parent, ,, label, ), ;, cur, =, parent]
[,, lastJump, =, node, ;, !, isContinueTarget, (, cur, ,, parent, ,, label, ), ;, cur, =, parent, ,, parent]
[=, node, ;, !, isContinueTarget, (, cur, ,, parent, ,, label, ), ;, cur, =, parent, ,, parent, =, parent]
[;, !, isContinueTarget, (, cur, ,, parent, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent]
[;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (]
[;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (]
[,, parent, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if]
[,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur]
[), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry]
[=, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&]
[,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, .]
[=, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (]
[), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild]
[., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, )]
[), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, cur, ., getLastChild]
[&&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump]
[&&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump]
[., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, )]
[&&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump]
[., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node]
[), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (]
[), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, cur, ., getLastChild]
[!=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, cur]
[., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch]
[), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, cur, ., getLastChild]
[), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {]
[==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }]
[), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {]
[;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;]
[,, Branch, ., UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump]
[,, cur, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur]
[., UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough]
[), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), )]
[., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild]
[;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous, =]
[., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;]
[,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState]
[), ;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous]
[), ), ;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (, parent, !=, null, ,, "Cannot find continue target.", ), ;]
[., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (, parent, !=, null]
[=, cur, ;, }, Preconditions, ., checkState, (, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }]
[;, }, Preconditions, ., checkState, (, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }, Node, iter]
[;, previous, =, cur, ;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==, 4]
[., checkState, (, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }, Node, iter, =, cur, ;]
[,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (]
[!=, null, ,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }, Node, iter, =, cur, ;, if, (, cur, .]
[,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (]
[), ;, previous, =, cur, ;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==]
[=, cur, ;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==, 4, ), {]
[;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==, 4, ), {, iter, =]
[;, if, (, cur, ., getChildCount, (, ), ==, 4, ), {, iter, =, cur, ., getFirstChild, (, ), .]
[), {, iter, =, cur, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, if]
[==, 4, ), {, iter, =, cur, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;]
[., getChildCount, (, ), ==, 4, ), {, iter, =, cur, ., getFirstChild, (, ), ., getNext, (, ), .]
[), {, iter, =, cur, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, if]
[=, cur, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, if, (, lastJump, ==]
[;, }, if, (, lastJump, ==, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, iter, ), ;]
[., getNext, (, ), ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND]
[., getNext, (, ), ., getNext, (, ), ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, node]
[., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, if, (, lastJump, ==, node, )]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, iter, ), ;, }, else, {, finallyMap, ., put, (]
[==, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, iter, ), ;, }, else, {, finallyMap, .]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, iter, ), ;, }, else, {, finallyMap, ., put, (]
[;, }, else, {, finallyMap, ., put, (, lastJump, ,, iter, ), ;, }, }, private, void, handleReturn, (, Node]
[,, Branch, ., UNCOND, ,, iter, ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, iter, ), ;]
[,, iter, ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, iter, ), ;, }, }, private, void]
[., UNCOND, ,, iter, ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, iter, ), ;, }, }]
[), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, iter, ), ;, }, }, private, void, handleReturn, (]
[;, }, }, private, void, handleReturn, (, Node, node, ), {, Node, lastJump, =, null, ;, for, (, Iterator, <]
[., put, (, lastJump, ,, iter, ), ;, }, }, private, void, handleReturn, (, Node, node, ), {, Node, lastJump]
[,, iter, ), ;, }, }, private, void, handleReturn, (, Node, node, ), {, Node, lastJump, =, null, ;, for]
[), ;, }, }, private, void, handleReturn, (, Node, node, ), {, Node, lastJump, =, null, ;, for, (, Iterator]
[;, for, (, Iterator, <, Node, >, iter, =, exceptionHandler, ., iterator, (, ), ;, iter, ., hasNext, (, )]
[;, iter, ., hasNext, (, ), ;, ), {, Node, curHandler, =, iter, ., next, (, ), ;, if, (]
[., iterator, (, ), ;, iter, ., hasNext, (, ), ;, ), {, Node, curHandler, =, iter, ., next, (]
[;, ), {, Node, curHandler, =, iter, ., next, (, ), ;, if, (, curHandler, ., isFunction, (, ), )]
[., hasNext, (, ), ;, ), {, Node, curHandler, =, iter, ., next, (, ), ;, if, (, curHandler, .]
[;, if, (, curHandler, ., isFunction, (, ), ), {, break, ;, }, if, (, NodeUtil, ., hasFinally, (, curHandler]
[., next, (, ), ;, if, (, curHandler, ., isFunction, (, ), ), {, break, ;, }, if, (, NodeUtil]
[), {, break, ;, }, if, (, NodeUtil, ., hasFinally, (, curHandler, ), ), {, if, (, lastJump, ==, null]
[., isFunction, (, ), ), {, break, ;, }, if, (, NodeUtil, ., hasFinally, (, curHandler, ), ), {, if]
[), {, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, curHandler, ., getLastChild]
[., hasFinally, (, curHandler, ), ), {, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, .]
[), ), {, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, curHandler, .]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {]
[==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {]
[;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, curHandler, ., getLastChild, (, ), ), ), ;]
[,, Branch, ., UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump]
[,, curHandler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, curHandler]
[., UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough]
[), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, curHandler, ., getLastChild, (, ), ), )]
[., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, curHandler, ., getLastChild]
[;, }, lastJump, =, curHandler, ;, }, }, if, (, node, ., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (, node]
[., put, (, lastJump, ,, computeFallThrough, (, curHandler, ., getLastChild, (, ), ), ), ;, }, lastJump, =, curHandler, ;]
[,, computeFallThrough, (, curHandler, ., getLastChild, (, ), ), ), ;, }, lastJump, =, curHandler, ;, }, }, if, (]
[), ;, }, lastJump, =, curHandler, ;, }, }, if, (, node, ., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (]
[), ), ;, }, lastJump, =, curHandler, ;, }, }, if, (, node, ., hasChildren, (, ), ), {, connectToPossibleExceptionHandler]
[., getLastChild, (, ), ), ), ;, }, lastJump, =, curHandler, ;, }, }, if, (, node, ., hasChildren, (]
[=, curHandler, ;, }, }, if, (, node, ., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (, node, ,, node, .]
[;, }, }, if, (, node, ., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (]
[), {, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, if, (, lastJump, ==, null, )]
[., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, if, (]
[;, }, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, null, ), ;]
[,, node, ., getFirstChild, (, ), ), ;, }, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,]
[), ;, }, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, null, )]
[., getFirstChild, (, ), ), ;, }, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, .]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, null, ), ;, }, else, {, finallyMap, ., put, (]
[==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, null, ), ;, }, else, {, finallyMap, .]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, null, ), ;, }, else, {, finallyMap, ., put, (]
[;, }, else, {, finallyMap, ., put, (, lastJump, ,, null, ), ;, }, }, private, void, handleStmt, (, Node]
[,, Branch, ., UNCOND, ,, null, ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, null, ), ;]
[,, null, ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, null, ), ;, }, }, private, void]
[., UNCOND, ,, null, ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, null, ), ;, }, }]
[), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, null, ), ;, }, }, private, void, handleStmt, (]
[;, }, }, private, void, handleStmt, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode]
[., put, (, lastJump, ,, null, ), ;, }, }, private, void, handleStmt, (, Node, node, ), {, createEdge, (]
[,, null, ), ;, }, }, private, void, handleStmt, (, Node, node, ), {, createEdge, (, node, ,, Branch, .]
[), ;, }, }, private, void, handleStmt, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa, ), {]
[,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;]
[,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, static, Node, computeFollowNode]
[., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, static]
[), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa, )]
[,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, static, Node, computeFollowNode, (, Node, node, ,]
[), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa]
[;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa, ), {, return, computeFollowNode, (, node, ,, node, ,]
[,, node, ), ;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa, ), {, return, computeFollowNode, (, node]
[), ;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa, ), {, return, computeFollowNode, (, node, ,, node]
[;, }, static, Node, computeFollowNode, (, Node, node, ), {, return, computeFollowNode, (, node, ,, node, ,, null, ), ;]
[,, node, ,, cfa, ), ;, }, static, Node, computeFollowNode, (, Node, node, ), {, return, computeFollowNode, (, node, ,]
[,, cfa, ), ;, }, static, Node, computeFollowNode, (, Node, node, ), {, return, computeFollowNode, (, node, ,, node, ,]
[), ;, }, static, Node, computeFollowNode, (, Node, node, ), {, return, computeFollowNode, (, node, ,, node, ,, null, )]
[;, }, private, static, Node, computeFollowNode, (, Node, fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa, ), {, Node, parent, =]
[,, node, ,, null, ), ;, }, private, static, Node, computeFollowNode, (, Node, fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa]
[,, null, ), ;, }, private, static, Node, computeFollowNode, (, Node, fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa, ), {]
[), ;, }, private, static, Node, computeFollowNode, (, Node, fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa, ), {, Node, parent]
[;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (, cfa, !=, null, &&, node, ==]
[., getParent, (, ), ;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (, cfa, !=]
[), {, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :]
[||, (, cfa, !=, null, &&, node, ==, cfa, ., root, ), ), {, return, null, ;, }, switch, (]
[||, parent, ., isFunction, (, ), ||, (, cfa, !=, null, &&, node, ==, cfa, ., root, ), ), {]
[==, null, ||, parent, ., isFunction, (, ), ||, (, cfa, !=, null, &&, node, ==, cfa, ., root, )]
[||, parent, ., isFunction, (, ), ||, (, cfa, !=, null, &&, node, ==, cfa, ., root, ), ), {]
[||, (, cfa, !=, null, &&, node, ==, cfa, ., root, ), ), {, return, null, ;, }, switch, (]
[., isFunction, (, ), ||, (, cfa, !=, null, &&, node, ==, cfa, ., root, ), ), {, return, null]
[), {, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :]
[), ), {, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF]
[&&, node, ==, cfa, ., root, ), ), {, return, null, ;, }, switch, (, parent, ., getType, (, )]
[!=, null, &&, node, ==, cfa, ., root, ), ), {, return, null, ;, }, switch, (, parent, ., getType]
[&&, node, ==, cfa, ., root, ), ), {, return, null, ;, }, switch, (, parent, ., getType, (, )]
[), ), {, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF]
[==, cfa, ., root, ), ), {, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {]
[), ), {, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF]
[., root, ), ), {, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {, case, Token]
[;, }, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, return, computeFollowNode, (, fromNode]
[), {, case, Token, ., IF, :, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, case, Token, .]
[., getType, (, ), ), {, case, Token, ., IF, :, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, )]
[:, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE]
[., IF, :, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, case, Token, ., CASE, :, case, Token]
[;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, if, (, parent, ., getNext, (, ), !=, null]
[,, parent, ,, cfa, ), ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, if, (, parent, .]
[,, cfa, ), ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, if, (, parent, ., getNext, (]
[), ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, if, (, parent, ., getNext, (, ), !=]
[:, case, Token, ., DEFAULT_CASE, :, if, (, parent, ., getNext, (, ), !=, null, ), {, if, (, parent]
[., CASE, :, case, Token, ., DEFAULT_CASE, :, if, (, parent, ., getNext, (, ), !=, null, ), {, if]
[:, if, (, parent, ., getNext, (, ), !=, null, ), {, if, (, parent, ., getNext, (, ), .]
[., DEFAULT_CASE, :, if, (, parent, ., getNext, (, ), !=, null, ), {, if, (, parent, ., getNext, (]
[), {, if, (, parent, ., getNext, (, ), ., isCase, (, ), ), {, return, parent, ., getNext, (]
[!=, null, ), {, if, (, parent, ., getNext, (, ), ., isCase, (, ), ), {, return, parent, .]
[., getNext, (, ), !=, null, ), {, if, (, parent, ., getNext, (, ), ., isCase, (, ), )]
[), {, if, (, parent, ., getNext, (, ), ., isCase, (, ), ), {, return, parent, ., getNext, (]
[), {, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ., getNext, (, ), ;, }, else, if]
[., isCase, (, ), ), {, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ., getNext, (, )]
[., getNext, (, ), ., isCase, (, ), ), {, return, parent, ., getNext, (, ), ., getFirstChild, (, )]
[;, }, else, if, (, parent, ., getNext, (, ), ., isDefaultCase, (, ), ), {, return, parent, ., getNext]
[., getNext, (, ), ;, }, else, if, (, parent, ., getNext, (, ), ., isDefaultCase, (, ), ), {]
[., getFirstChild, (, ), ., getNext, (, ), ;, }, else, if, (, parent, ., getNext, (, ), ., isDefaultCase]
[., getNext, (, ), ., getFirstChild, (, ), ., getNext, (, ), ;, }, else, if, (, parent, ., getNext]
[), {, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ;, }, else, {, Preconditions, ., checkState, (]
[., isDefaultCase, (, ), ), {, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ;, }, else, {]
[., getNext, (, ), ., isDefaultCase, (, ), ), {, return, parent, ., getNext, (, ), ., getFirstChild, (, )]
[;, }, else, {, Preconditions, ., checkState, (, false, ,, "Not reachable", ), ;, }, }, else, {, return, computeFollowNode, (]
[., getFirstChild, (, ), ;, }, else, {, Preconditions, ., checkState, (, false, ,, "Not reachable", ), ;, }, }, else]
[., getNext, (, ), ., getFirstChild, (, ), ;, }, else, {, Preconditions, ., checkState, (, false, ,, "Not reachable", )]
[;, }, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, break, ;, case, Token]
[., checkState, (, false, ,, "Not reachable", ), ;, }, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa]
[,, "Not reachable", ), ;, }, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, break]
[), ;, }, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, break, ;, case]
[;, }, break, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return]
[,, parent, ,, cfa, ), ;, }, break, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (]
[,, cfa, ), ;, }, break, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, )]
[), ;, }, break, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {]
[:, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, parent, ;, }, else, {, return, parent, .]
[., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, parent, ;, }, else, {, return]
[), {, return, parent, ;, }, else, {, return, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext]
[., isForIn, (, parent, ), ), {, return, parent, ;, }, else, {, return, parent, ., getFirstChild, (, ), .]
[), ), {, return, parent, ;, }, else, {, return, parent, ., getFirstChild, (, ), ., getNext, (, ), .]
[;, }, else, {, return, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }]
[;, }, case, Token, ., WHILE, :, case, Token, ., DO, :, return, parent, ;, case, Token, ., TRY, :]
[., getNext, (, ), ;, }, case, Token, ., WHILE, :, case, Token, ., DO, :, return, parent, ;, case]
[., getNext, (, ), ., getNext, (, ), ;, }, case, Token, ., WHILE, :, case, Token, ., DO, :]
[., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, case, Token, ., WHILE, :, case]
[:, case, Token, ., DO, :, return, parent, ;, case, Token, ., TRY, :, if, (, parent, ., getFirstChild, (]
[., WHILE, :, case, Token, ., DO, :, return, parent, ;, case, Token, ., TRY, :, if, (, parent, .]
[:, return, parent, ;, case, Token, ., TRY, :, if, (, parent, ., getFirstChild, (, ), ==, node, ), {]
[., DO, :, return, parent, ;, case, Token, ., TRY, :, if, (, parent, ., getFirstChild, (, ), ==, node]
[;, case, Token, ., TRY, :, if, (, parent, ., getFirstChild, (, ), ==, node, ), {, if, (, NodeUtil]
[:, if, (, parent, ., getFirstChild, (, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, )]
[., TRY, :, if, (, parent, ., getFirstChild, (, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (]
[), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (, parent, ., getLastChild, (, )]
[==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (, parent, ., getLastChild]
[., getFirstChild, (, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough]
[), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (, parent, ., getLastChild, (, )]
[), {, return, computeFallThrough, (, parent, ., getLastChild, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,]
[., hasFinally, (, parent, ), ), {, return, computeFallThrough, (, parent, ., getLastChild, (, ), ), ;, }, else, {]
[), ), {, return, computeFallThrough, (, parent, ., getLastChild, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode]
[;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (, NodeUtil]
[), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (]
[., getLastChild, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }]
[;, }, }, else, if, (, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, ), {, if, (, NodeUtil, .]
[,, parent, ,, cfa, ), ;, }, }, else, if, (, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, )]
[,, cfa, ), ;, }, }, else, if, (, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, ), {, if]
[), ;, }, }, else, if, (, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, ), {, if, (, NodeUtil]
[), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (, node, ., getNext, (, )]
[==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (, node, ., getNext]
[., getCatchBlock, (, parent, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return]
[), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (, node, .]
[), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (, node, ., getNext, (, )]
[), {, return, computeFallThrough, (, node, ., getNext, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,]
[., hasFinally, (, parent, ), ), {, return, computeFallThrough, (, node, ., getNext, (, ), ), ;, }, else, {]
[), ), {, return, computeFallThrough, (, node, ., getNext, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode]
[;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (, parent]
[), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (]
[., getNext, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }]
[;, }, }, else, if, (, parent, ., getLastChild, (, ), ==, node, ), {, if, (, cfa, !=, null]
[,, parent, ,, cfa, ), ;, }, }, else, if, (, parent, ., getLastChild, (, ), ==, node, ), {]
[,, cfa, ), ;, }, }, else, if, (, parent, ., getLastChild, (, ), ==, node, ), {, if, (]
[), ;, }, }, else, if, (, parent, ., getLastChild, (, ), ==, node, ), {, if, (, cfa, !=]
[), {, if, (, cfa, !=, null, ), {, for, (, Node, finallyNode, :, cfa, ., finallyMap, ., get, (]
[==, node, ), {, if, (, cfa, !=, null, ), {, for, (, Node, finallyNode, :, cfa, ., finallyMap, .]
[., getLastChild, (, ), ==, node, ), {, if, (, cfa, !=, null, ), {, for, (, Node, finallyNode, :]
[), {, if, (, cfa, !=, null, ), {, for, (, Node, finallyNode, :, cfa, ., finallyMap, ., get, (]
[), {, for, (, Node, finallyNode, :, cfa, ., finallyMap, ., get, (, parent, ), ), {, cfa, ., createEdge]
[!=, null, ), {, for, (, Node, finallyNode, :, cfa, ., finallyMap, ., get, (, parent, ), ), {, cfa]
[), {, for, (, Node, finallyNode, :, cfa, ., finallyMap, ., get, (, parent, ), ), {, cfa, ., createEdge]
[), {, cfa, ., createEdge, (, fromNode, ,, Branch, ., ON_EX, ,, finallyNode, ), ;, }, }, return, computeFollowNode, (]
[., get, (, parent, ), ), {, cfa, ., createEdge, (, fromNode, ,, Branch, ., ON_EX, ,, finallyNode, ), ;]
[., finallyMap, ., get, (, parent, ), ), {, cfa, ., createEdge, (, fromNode, ,, Branch, ., ON_EX, ,, finallyNode]
[), ), {, cfa, ., createEdge, (, fromNode, ,, Branch, ., ON_EX, ,, finallyNode, ), ;, }, }, return, computeFollowNode]
[;, }, }, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, Node, nextSibling, =, node, .]
[., createEdge, (, fromNode, ,, Branch, ., ON_EX, ,, finallyNode, ), ;, }, }, return, computeFollowNode, (, fromNode, ,, parent]
[,, Branch, ., ON_EX, ,, finallyNode, ), ;, }, }, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;]
[,, finallyNode, ), ;, }, }, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, Node, nextSibling]
[., ON_EX, ,, finallyNode, ), ;, }, }, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }]
[), ;, }, }, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, Node, nextSibling, =, node]
[;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (, nextSibling, !=, null, &&, nextSibling, .]
[,, parent, ,, cfa, ), ;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (, nextSibling]
[,, cfa, ), ;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (, nextSibling, !=, null]
[), ;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (, nextSibling, !=, null, &&, nextSibling]
[;, while, (, nextSibling, !=, null, &&, nextSibling, ., isFunction, (, ), ), {, nextSibling, =, nextSibling, ., getNext, (]
[., getNext, (, ), ;, while, (, nextSibling, !=, null, &&, nextSibling, ., isFunction, (, ), ), {, nextSibling, =]
[), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (, nextSibling, !=, null, ), {, return, computeFallThrough]
[&&, nextSibling, ., isFunction, (, ), ), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (, nextSibling]
[!=, null, &&, nextSibling, ., isFunction, (, ), ), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if]
[&&, nextSibling, ., isFunction, (, ), ), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (, nextSibling]
[), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (, nextSibling, !=, null, ), {, return, computeFallThrough]
[., isFunction, (, ), ), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (, nextSibling, !=, null]
[=, nextSibling, ., getNext, (, ), ;, }, if, (, nextSibling, !=, null, ), {, return, computeFallThrough, (, nextSibling, )]
[;, }, if, (, nextSibling, !=, null, ), {, return, computeFallThrough, (, nextSibling, ), ;, }, else, {, return, computeFollowNode]
[., getNext, (, ), ;, }, if, (, nextSibling, !=, null, ), {, return, computeFallThrough, (, nextSibling, ), ;, }]
[), {, return, computeFallThrough, (, nextSibling, ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, )]
[!=, null, ), {, return, computeFallThrough, (, nextSibling, ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,]
[), {, return, computeFallThrough, (, nextSibling, ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, )]
[;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, static, Node, computeFallThrough, (]
[), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, static, Node, computeFallThrough]
[;, }, }, static, Node, computeFallThrough, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[,, parent, ,, cfa, ), ;, }, }, static, Node, computeFallThrough, (, Node, n, ), {, switch, (, n, .]
[,, cfa, ), ;, }, }, static, Node, computeFallThrough, (, Node, n, ), {, switch, (, n, ., getType, (]
[), ;, }, }, static, Node, computeFallThrough, (, Node, n, ), {, switch, (, n, ., getType, (, ), )]
[), {, case, Token, ., DO, :, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, .]
[., getType, (, ), ), {, case, Token, ., DO, :, return, computeFallThrough, (, n, ., getFirstChild, (, ), )]
[:, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., FOR, :, if, (, NodeUtil, .]
[., DO, :, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., FOR, :, if, (]
[;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return, n, ., getFirstChild]
[), ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return, n, .]
[., getFirstChild, (, ), ), ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, n, ), )]
[:, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return, n, ., getFirstChild, (, ), ., getNext, (]
[., FOR, :, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return, n, ., getFirstChild, (, ), .]
[), {, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, return, computeFallThrough, (, n, ., getFirstChild]
[., isForIn, (, n, ), ), {, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, return]
[), ), {, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, return, computeFallThrough, (, n, .]
[;, }, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., LABEL, :, return, computeFallThrough, (]
[., getNext, (, ), ;, }, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., LABEL]
[., getFirstChild, (, ), ., getNext, (, ), ;, }, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;]
[;, case, Token, ., LABEL, :, return, computeFallThrough, (, n, ., getLastChild, (, ), ), ;, default, :, return, n]
[), ;, case, Token, ., LABEL, :, return, computeFallThrough, (, n, ., getLastChild, (, ), ), ;, default, :, return]
[., getFirstChild, (, ), ), ;, case, Token, ., LABEL, :, return, computeFallThrough, (, n, ., getLastChild, (, ), )]
[:, return, computeFallThrough, (, n, ., getLastChild, (, ), ), ;, default, :, return, n, ;, }, }, private, void]
[., LABEL, :, return, computeFallThrough, (, n, ., getLastChild, (, ), ), ;, default, :, return, n, ;, }, }]
[;, default, :, return, n, ;, }, }, private, void, createEdge, (, Node, fromNode, ,, ControlFlowGraph, ., Branch, branch, ,]
[), ;, default, :, return, n, ;, }, }, private, void, createEdge, (, Node, fromNode, ,, ControlFlowGraph, ., Branch, branch]
[., getLastChild, (, ), ), ;, default, :, return, n, ;, }, }, private, void, createEdge, (, Node, fromNode, ,]
[;, }, }, private, void, createEdge, (, Node, fromNode, ,, ControlFlowGraph, ., Branch, branch, ,, Node, toNode, ), {, cfg]
[;, cfg, ., createNode, (, toNode, ), ;, cfg, ., connectIfNotFound, (, fromNode, ,, branch, ,, toNode, ), ;, }]
[., createNode, (, fromNode, ), ;, cfg, ., createNode, (, toNode, ), ;, cfg, ., connectIfNotFound, (, fromNode, ,, branch]
[), ;, cfg, ., createNode, (, toNode, ), ;, cfg, ., connectIfNotFound, (, fromNode, ,, branch, ,, toNode, ), ;]
[;, cfg, ., connectIfNotFound, (, fromNode, ,, branch, ,, toNode, ), ;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,]
[., createNode, (, toNode, ), ;, cfg, ., connectIfNotFound, (, fromNode, ,, branch, ,, toNode, ), ;, }, private, void]
[), ;, cfg, ., connectIfNotFound, (, fromNode, ,, branch, ,, toNode, ), ;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode]
[;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (, mayThrowException, (, target, ), &&]
[., connectIfNotFound, (, fromNode, ,, branch, ,, toNode, ), ;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target]
[,, branch, ,, toNode, ), ;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (]
[,, toNode, ), ;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (, mayThrowException, (]
[), ;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (, mayThrowException, (, target, )]
[), {, Node, lastJump, =, cfgNode, ;, for, (, Node, handler, :, exceptionHandler, ), {, if, (, handler, ., isFunction]
[&&, !, exceptionHandler, ., isEmpty, (, ), ), {, Node, lastJump, =, cfgNode, ;, for, (, Node, handler, :, exceptionHandler]
[), &&, !, exceptionHandler, ., isEmpty, (, ), ), {, Node, lastJump, =, cfgNode, ;, for, (, Node, handler, :]
[), {, Node, lastJump, =, cfgNode, ;, for, (, Node, handler, :, exceptionHandler, ), {, if, (, handler, ., isFunction]
[), {, Node, lastJump, =, cfgNode, ;, for, (, Node, handler, :, exceptionHandler, ), {, if, (, handler, ., isFunction]
[., isEmpty, (, ), ), {, Node, lastJump, =, cfgNode, ;, for, (, Node, handler, :, exceptionHandler, ), {, if]
[;, for, (, Node, handler, :, exceptionHandler, ), {, if, (, handler, ., isFunction, (, ), ), {, return, ;]
[), {, if, (, handler, ., isFunction, (, ), ), {, return, ;, }, Preconditions, ., checkState, (, handler, .]
[), {, return, ;, }, Preconditions, ., checkState, (, handler, ., isTry, (, ), ), ;, Node, catchBlock, =, NodeUtil]
[., isFunction, (, ), ), {, return, ;, }, Preconditions, ., checkState, (, handler, ., isTry, (, ), ), ;]
[;, Node, catchBlock, =, NodeUtil, ., getCatchBlock, (, handler, ), ;, if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock, )]
[., checkState, (, handler, ., isTry, (, ), ), ;, Node, catchBlock, =, NodeUtil, ., getCatchBlock, (, handler, ), ;]
[), ;, Node, catchBlock, =, NodeUtil, ., getCatchBlock, (, handler, ), ;, if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock]
[., isTry, (, ), ), ;, Node, catchBlock, =, NodeUtil, ., getCatchBlock, (, handler, ), ;, if, (, !, NodeUtil]
[;, if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (, lastJump, ==, cfgNode, ), {, createEdge]
[., getCatchBlock, (, handler, ), ;, if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (, lastJump]
[), ;, if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (, lastJump, ==, cfgNode, ), {]
[), {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, handler, ., getLastChild]
[), {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, handler, ., getLastChild]
[., hasCatchHandler, (, catchBlock, ), ), {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, .]
[), ), {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, handler, .]
[), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }, else, {]
[==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }]
[), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }, else, {]
[;, }, else, {, finallyMap, ., put, (, lastJump, ,, handler, ., getLastChild, (, ), ), ;, }, }, else]
[,, Branch, ., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump]
[,, handler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, handler, ., getLastChild]
[., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, handler]
[), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, handler, ., getLastChild, (, ), ), ;, }, }]
[., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, handler, ., getLastChild, (, )]
[;, }, }, else, {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,]
[., put, (, lastJump, ,, handler, ., getLastChild, (, ), ), ;, }, }, else, {, if, (, lastJump, ==]
[,, handler, ., getLastChild, (, ), ), ;, }, }, else, {, if, (, lastJump, ==, cfgNode, ), {, createEdge]
[), ;, }, }, else, {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX]
[., getLastChild, (, ), ), ;, }, }, else, {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode]
[), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, catchBlock, ), ;, return, ;, }, else, {, finallyMap, .]
[==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, catchBlock, ), ;, return, ;, }, else, {]
[), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, catchBlock, ), ;, return, ;, }, else, {, finallyMap, .]
[;, return, ;, }, else, {, finallyMap, ., put, (, lastJump, ,, catchBlock, ), ;, }, }, lastJump, =, handler]
[,, Branch, ., ON_EX, ,, catchBlock, ), ;, return, ;, }, else, {, finallyMap, ., put, (, lastJump, ,, catchBlock]
[,, catchBlock, ), ;, return, ;, }, else, {, finallyMap, ., put, (, lastJump, ,, catchBlock, ), ;, }, }]
[., ON_EX, ,, catchBlock, ), ;, return, ;, }, else, {, finallyMap, ., put, (, lastJump, ,, catchBlock, ), ;]
[), ;, return, ;, }, else, {, finallyMap, ., put, (, lastJump, ,, catchBlock, ), ;, }, }, lastJump, =]
[;, }, }, lastJump, =, handler, ;, }, }, }, private, static, Node, getNextSiblingOfType, (, Node, first, ,, int, ...]
[., put, (, lastJump, ,, catchBlock, ), ;, }, }, lastJump, =, handler, ;, }, }, }, private, static, Node]
[,, catchBlock, ), ;, }, }, lastJump, =, handler, ;, }, }, }, private, static, Node, getNextSiblingOfType, (, Node, first]
[), ;, }, }, lastJump, =, handler, ;, }, }, }, private, static, Node, getNextSiblingOfType, (, Node, first, ,, int]
[=, handler, ;, }, }, }, private, static, Node, getNextSiblingOfType, (, Node, first, ,, int, ..., types, ), {, for]
[;, }, }, }, private, static, Node, getNextSiblingOfType, (, Node, first, ,, int, ..., types, ), {, for, (, Node]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, for, (, int, type, :, types]
[;, c, =, c, ., getNext, (, ), ), {, for, (, int, type, :, types, ), {, if, (]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, for, (, int, type, :, types, ), {]
[;, c, =, c, ., getNext, (, ), ), {, for, (, int, type, :, types, ), {, if, (]
[=, c, ., getNext, (, ), ), {, for, (, int, type, :, types, ), {, if, (, c, .]
[), {, for, (, int, type, :, types, ), {, if, (, c, ., getType, (, ), ==, type, )]
[., getNext, (, ), ), {, for, (, int, type, :, types, ), {, if, (, c, ., getType, (]
[), {, if, (, c, ., getType, (, ), ==, type, ), {, return, c, ;, }, }, }, return]
[), {, return, c, ;, }, }, }, return, null, ;, }, public, static, boolean, isBreakTarget, (, Node, target, ,]
[==, type, ), {, return, c, ;, }, }, }, return, null, ;, }, public, static, boolean, isBreakTarget, (, Node]
[., getType, (, ), ==, type, ), {, return, c, ;, }, }, }, return, null, ;, }, public, static]
[), {, return, c, ;, }, }, }, return, null, ;, }, public, static, boolean, isBreakTarget, (, Node, target, ,]
[;, }, }, }, return, null, ;, }, public, static, boolean, isBreakTarget, (, Node, target, ,, String, label, ), {]
[;, }, public, static, boolean, isBreakTarget, (, Node, target, ,, String, label, ), {, return, isBreakStructure, (, target, ,, label]
[;, }, private, static, boolean, isContinueTarget, (, Node, target, ,, Node, parent, ,, String, label, ), {, return, isContinueStructure, (]
[&&, matchLabel, (, target, ., getParent, (, ), ,, label, ), ;, }, private, static, boolean, isContinueTarget, (, Node, target]
[,, label, !=, null, ), &&, matchLabel, (, target, ., getParent, (, ), ,, label, ), ;, }, private, static]
[), &&, matchLabel, (, target, ., getParent, (, ), ,, label, ), ;, }, private, static, boolean, isContinueTarget, (, Node]
[!=, null, ), &&, matchLabel, (, target, ., getParent, (, ), ,, label, ), ;, }, private, static, boolean, isContinueTarget]
[), &&, matchLabel, (, target, ., getParent, (, ), ,, label, ), ;, }, private, static, boolean, isContinueTarget, (, Node]
[;, }, private, static, boolean, isContinueTarget, (, Node, target, ,, Node, parent, ,, String, label, ), {, return, isContinueStructure, (]
[,, label, ), ;, }, private, static, boolean, isContinueTarget, (, Node, target, ,, Node, parent, ,, String, label, ), {]
[., getParent, (, ), ,, label, ), ;, }, private, static, boolean, isContinueTarget, (, Node, target, ,, Node, parent, ,]
[), ;, }, private, static, boolean, isContinueTarget, (, Node, target, ,, Node, parent, ,, String, label, ), {, return, isContinueStructure]
[;, }, private, static, boolean, matchLabel, (, Node, target, ,, String, label, ), {, if, (, label, ==, null, )]
[&&, matchLabel, (, parent, ,, label, ), ;, }, private, static, boolean, matchLabel, (, Node, target, ,, String, label, )]
[), &&, matchLabel, (, parent, ,, label, ), ;, }, private, static, boolean, matchLabel, (, Node, target, ,, String, label]
[;, }, private, static, boolean, matchLabel, (, Node, target, ,, String, label, ), {, if, (, label, ==, null, )]
[,, label, ), ;, }, private, static, boolean, matchLabel, (, Node, target, ,, String, label, ), {, if, (, label]
[), ;, }, private, static, boolean, matchLabel, (, Node, target, ,, String, label, ), {, if, (, label, ==, null]
[), {, return, true, ;, }, while, (, target, ., isLabel, (, ), ), {, if, (, target, ., getFirstChild]
[==, null, ), {, return, true, ;, }, while, (, target, ., isLabel, (, ), ), {, if, (, target]
[), {, return, true, ;, }, while, (, target, ., isLabel, (, ), ), {, if, (, target, ., getFirstChild]
[;, }, while, (, target, ., isLabel, (, ), ), {, if, (, target, ., getFirstChild, (, ), ., getString]
[), {, if, (, target, ., getFirstChild, (, ), ., getString, (, ), ., equals, (, label, ), ), {]
[., isLabel, (, ), ), {, if, (, target, ., getFirstChild, (, ), ., getString, (, ), ., equals, (]
[), {, return, true, ;, }, target, =, target, ., getParent, (, ), ;, }, return, false, ;, }, public]
[., equals, (, label, ), ), {, return, true, ;, }, target, =, target, ., getParent, (, ), ;, }]
[., getString, (, ), ., equals, (, label, ), ), {, return, true, ;, }, target, =, target, ., getParent]
[., getFirstChild, (, ), ., getString, (, ), ., equals, (, label, ), ), {, return, true, ;, }, target]
[), ), {, return, true, ;, }, target, =, target, ., getParent, (, ), ;, }, return, false, ;, }]
[;, }, target, =, target, ., getParent, (, ), ;, }, return, false, ;, }, public, static, boolean, mayThrowException, (]
[=, target, ., getParent, (, ), ;, }, return, false, ;, }, public, static, boolean, mayThrowException, (, Node, n, )]
[;, }, return, false, ;, }, public, static, boolean, mayThrowException, (, Node, n, ), {, switch, (, n, ., getType]
[., getParent, (, ), ;, }, return, false, ;, }, public, static, boolean, mayThrowException, (, Node, n, ), {, switch]
[;, }, public, static, boolean, mayThrowException, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), {, case, Token, ., CALL, :, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., CALL, :, case, Token, ., GETPROP, :, case, Token, ., GETELEM]
[:, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, case, Token, ., THROW, :, case, Token, ., NEW]
[., CALL, :, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, case, Token, ., THROW, :, case, Token]
[:, case, Token, ., GETELEM, :, case, Token, ., THROW, :, case, Token, ., NEW, :, case, Token, ., ASSIGN]
[., GETPROP, :, case, Token, ., GETELEM, :, case, Token, ., THROW, :, case, Token, ., NEW, :, case, Token]
[:, case, Token, ., THROW, :, case, Token, ., NEW, :, case, Token, ., ASSIGN, :, case, Token, ., INC]
[., GETELEM, :, case, Token, ., THROW, :, case, Token, ., NEW, :, case, Token, ., ASSIGN, :, case, Token]
[:, case, Token, ., NEW, :, case, Token, ., ASSIGN, :, case, Token, ., INC, :, case, Token, ., DEC]
[., THROW, :, case, Token, ., NEW, :, case, Token, ., ASSIGN, :, case, Token, ., INC, :, case, Token]
[:, case, Token, ., ASSIGN, :, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., INSTANCEOF]
[., NEW, :, case, Token, ., ASSIGN, :, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token]
[:, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., INSTANCEOF, :, return, true, ;, case]
[., ASSIGN, :, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., INSTANCEOF, :, return, true]
[:, case, Token, ., DEC, :, case, Token, ., INSTANCEOF, :, return, true, ;, case, Token, ., FUNCTION, :, return]
[., INC, :, case, Token, ., DEC, :, case, Token, ., INSTANCEOF, :, return, true, ;, case, Token, ., FUNCTION]
[:, case, Token, ., INSTANCEOF, :, return, true, ;, case, Token, ., FUNCTION, :, return, false, ;, }, for, (]
[., DEC, :, case, Token, ., INSTANCEOF, :, return, true, ;, case, Token, ., FUNCTION, :, return, false, ;, }]
[:, return, true, ;, case, Token, ., FUNCTION, :, return, false, ;, }, for, (, Node, c, =, n, .]
[., INSTANCEOF, :, return, true, ;, case, Token, ., FUNCTION, :, return, false, ;, }, for, (, Node, c, =]
[;, case, Token, ., FUNCTION, :, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, )]
[:, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;]
[., FUNCTION, :, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), &&]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c]
[;, c, =, c, ., getNext, (, ), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), &&]
[=, c, ., getNext, (, ), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), &&, mayThrowException, (]
[), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), &&, mayThrowException, (, c, ), ), {, return, true]
[., getNext, (, ), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), &&, mayThrowException, (, c, )]
[), {, return, true, ;, }, }, return, false, ;, }, static, boolean, isBreakStructure, (, Node, n, ,, boolean, labeled]
[&&, mayThrowException, (, c, ), ), {, return, true, ;, }, }, return, false, ;, }, static, boolean, isBreakStructure, (]
[&&, mayThrowException, (, c, ), ), {, return, true, ;, }, }, return, false, ;, }, static, boolean, isBreakStructure, (]
[., isEnteringNewCfgNode, (, c, ), &&, mayThrowException, (, c, ), ), {, return, true, ;, }, }, return, false, ;]
[), &&, mayThrowException, (, c, ), ), {, return, true, ;, }, }, return, false, ;, }, static, boolean, isBreakStructure]
[), {, return, true, ;, }, }, return, false, ;, }, static, boolean, isBreakStructure, (, Node, n, ,, boolean, labeled]
[), ), {, return, true, ;, }, }, return, false, ;, }, static, boolean, isBreakStructure, (, Node, n, ,, boolean]
[;, }, }, return, false, ;, }, static, boolean, isBreakStructure, (, Node, n, ,, boolean, labeled, ), {, switch, (]
[;, }, static, boolean, isBreakStructure, (, Node, n, ,, boolean, labeled, ), {, switch, (, n, ., getType, (, )]
[), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE]
[:, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., SWITCH, :, return, true, ;, case]
[., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., SWITCH, :, return, true]
[:, case, Token, ., WHILE, :, case, Token, ., SWITCH, :, return, true, ;, case, Token, ., BLOCK, :, case]
[., DO, :, case, Token, ., WHILE, :, case, Token, ., SWITCH, :, return, true, ;, case, Token, ., BLOCK]
[:, case, Token, ., SWITCH, :, return, true, ;, case, Token, ., BLOCK, :, case, Token, ., IF, :, case]
[., WHILE, :, case, Token, ., SWITCH, :, return, true, ;, case, Token, ., BLOCK, :, case, Token, ., IF]
[:, return, true, ;, case, Token, ., BLOCK, :, case, Token, ., IF, :, case, Token, ., TRY, :, return]
[., SWITCH, :, return, true, ;, case, Token, ., BLOCK, :, case, Token, ., IF, :, case, Token, ., TRY]
[;, case, Token, ., BLOCK, :, case, Token, ., IF, :, case, Token, ., TRY, :, return, labeled, ;, default]
[:, case, Token, ., IF, :, case, Token, ., TRY, :, return, labeled, ;, default, :, return, false, ;, }]
[., BLOCK, :, case, Token, ., IF, :, case, Token, ., TRY, :, return, labeled, ;, default, :, return, false]
[:, case, Token, ., TRY, :, return, labeled, ;, default, :, return, false, ;, }, }, static, boolean, isContinueStructure, (]
[., IF, :, case, Token, ., TRY, :, return, labeled, ;, default, :, return, false, ;, }, }, static, boolean]
[:, return, labeled, ;, default, :, return, false, ;, }, }, static, boolean, isContinueStructure, (, Node, n, ), {, switch]
[., TRY, :, return, labeled, ;, default, :, return, false, ;, }, }, static, boolean, isContinueStructure, (, Node, n, )]
[;, default, :, return, false, ;, }, }, static, boolean, isContinueStructure, (, Node, n, ), {, switch, (, n, .]
[;, }, }, static, boolean, isContinueStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, return, true, ;]
[., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE]
[:, case, Token, ., DO, :, case, Token, ., WHILE, :, return, true, ;, default, :, return, false, ;, }]
[., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, return, true, ;, default, :, return, false]
[:, case, Token, ., WHILE, :, return, true, ;, default, :, return, false, ;, }, }, static, Node, getExceptionHandler, (]
[., DO, :, case, Token, ., WHILE, :, return, true, ;, default, :, return, false, ;, }, }, static, Node]
[:, return, true, ;, default, :, return, false, ;, }, }, static, Node, getExceptionHandler, (, Node, n, ), {, for]
[., WHILE, :, return, true, ;, default, :, return, false, ;, }, }, static, Node, getExceptionHandler, (, Node, n, )]
[;, default, :, return, false, ;, }, }, static, Node, getExceptionHandler, (, Node, n, ), {, for, (, Node, cur]
[;, }, }, static, Node, getExceptionHandler, (, Node, n, ), {, for, (, Node, cur, =, n, ;, !, cur]
[;, !, cur, ., isScript, (, ), &&, !, cur, ., isFunction, (, ), ;, cur, =, cur, ., getParent]
[;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (]
[&&, !, cur, ., isFunction, (, ), ;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =]
[&&, !, cur, ., isFunction, (, ), ;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =]
[., isScript, (, ), &&, !, cur, ., isFunction, (, ), ;, cur, =, cur, ., getParent, (, ), )]
[;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (]
[;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (]
[., isFunction, (, ), ;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur]
[=, cur, ., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (, catchNode, !=]
[), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (, catchNode, !=, null, ), {, return, catchNode, ;]
[., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (, catchNode, !=, null, )]
[;, if, (, catchNode, !=, null, ), {, return, catchNode, ;, }, }, return, null, ;, }, static, Node, getCatchHandlerForBlock]
[), ;, if, (, catchNode, !=, null, ), {, return, catchNode, ;, }, }, return, null, ;, }, static, Node]
[), {, return, catchNode, ;, }, }, return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if]
[!=, null, ), {, return, catchNode, ;, }, }, return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, )]
[), {, return, catchNode, ;, }, }, return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if]
[;, }, }, return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if, (, block, ., isBlock]
[;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if, (, block, ., isBlock, (, ), &&, block, .]
[), {, for, (, Node, s, =, block, ., getNext, (, ), ;, s, !=, null, ;, s, =, s]
[&&, block, ., getParent, (, ), ., getFirstChild, (, ), ==, block, ), {, for, (, Node, s, =, block]
[&&, block, ., getParent, (, ), ., isTry, (, ), &&, block, ., getParent, (, ), ., getFirstChild, (, )]
[., isBlock, (, ), &&, block, ., getParent, (, ), ., isTry, (, ), &&, block, ., getParent, (, )]
[&&, block, ., getParent, (, ), ., getFirstChild, (, ), ==, block, ), {, for, (, Node, s, =, block]
[., isTry, (, ), &&, block, ., getParent, (, ), ., getFirstChild, (, ), ==, block, ), {, for, (]
[., getParent, (, ), ., isTry, (, ), &&, block, ., getParent, (, ), ., getFirstChild, (, ), ==, block]
[), {, for, (, Node, s, =, block, ., getNext, (, ), ;, s, !=, null, ;, s, =, s]
[==, block, ), {, for, (, Node, s, =, block, ., getNext, (, ), ;, s, !=, null, ;, s]
[., getFirstChild, (, ), ==, block, ), {, for, (, Node, s, =, block, ., getNext, (, ), ;, s]
[., getParent, (, ), ., getFirstChild, (, ), ==, block, ), {, for, (, Node, s, =, block, ., getNext]
[), {, for, (, Node, s, =, block, ., getNext, (, ), ;, s, !=, null, ;, s, =, s]
[;, s, !=, null, ;, s, =, s, ., getNext, (, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (]
[., getNext, (, ), ;, s, !=, null, ;, s, =, s, ., getNext, (, ), ), {, if, (]
[;, s, =, s, ., getNext, (, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, s, ), ), {]
[!=, null, ;, s, =, s, ., getNext, (, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, s, )]
[;, s, =, s, ., getNext, (, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, s, ), ), {]
[=, s, ., getNext, (, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, s, ), ), {, return, s]
[), {, if, (, NodeUtil, ., hasCatchHandler, (, s, ), ), {, return, s, ., getFirstChild, (, ), ;, }]
[., getNext, (, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, s, ), ), {, return, s, ., getFirstChild]
[), {, return, s, ., getFirstChild, (, ), ;, }, }, }, return, null, ;, }, private, static, class, AstControlFlowGraph]
[., hasCatchHandler, (, s, ), ), {, return, s, ., getFirstChild, (, ), ;, }, }, }, return, null, ;]
[), ), {, return, s, ., getFirstChild, (, ), ;, }, }, }, return, null, ;, }, private, static, class]
[;, }, }, }, return, null, ;, }, private, static, class, AstControlFlowGraph, extends, ControlFlowGraph, <, Node, >, {, private, final]
[., getFirstChild, (, ), ;, }, }, }, return, null, ;, }, private, static, class, AstControlFlowGraph, extends, ControlFlowGraph, <, Node]
[;, }, private, static, class, AstControlFlowGraph, extends, ControlFlowGraph, <, Node, >, {, private, final, Map, <, DiGraphNode, <, Node, ,]
[,, true, ,, edgeAnnotations, ), ;, this, ., priorities, =, priorities, ;, }, @, Override, public, Comparator, <, DiGraphNode, <]
[,, edgeAnnotations, ), ;, this, ., priorities, =, priorities, ;, }, @, Override, public, Comparator, <, DiGraphNode, <, Node, ,]
[), ;, this, ., priorities, =, priorities, ;, }, @, Override, public, Comparator, <, DiGraphNode, <, Node, ,, Branch, >]
[=, priorities, ;, }, @, Override, public, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, getOptionalNodeComparator, (, boolean, isForward]
[., priorities, =, priorities, ;, }, @, Override, public, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, getOptionalNodeComparator, (]
[;, }, @, Override, public, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, getOptionalNodeComparator, (, boolean, isForward, ), {]
[), {, return, new, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, (, ), {, @, Override, public, int]
[;, }, else, {, return, new, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, (, ), {, @, Override]
[;, }, }, ;, }, else, {, return, new, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, (, )]
[-, getPosition, (, n2, ), ;, }, }, ;, }, else, {, return, new, Comparator, <, DiGraphNode, <, Node, ,]
[), -, getPosition, (, n2, ), ;, }, }, ;, }, else, {, return, new, Comparator, <, DiGraphNode, <, Node]
[;, }, }, ;, }, else, {, return, new, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, (, )]
[), ;, }, }, ;, }, else, {, return, new, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, (]
[;, }, }, private, int, getPosition, (, DiGraphNode, <, Node, ,, Branch, >, n, ), {, Integer, priority, =, priorities]
[;, }, }, ;, }, }, private, int, getPosition, (, DiGraphNode, <, Node, ,, Branch, >, n, ), {, Integer]
[-, getPosition, (, n1, ), ;, }, }, ;, }, }, private, int, getPosition, (, DiGraphNode, <, Node, ,, Branch]
[), -, getPosition, (, n1, ), ;, }, }, ;, }, }, private, int, getPosition, (, DiGraphNode, <, Node, ,]
[;, }, }, ;, }, }, private, int, getPosition, (, DiGraphNode, <, Node, ,, Branch, >, n, ), {, Integer]
[), ;, }, }, ;, }, }, private, int, getPosition, (, DiGraphNode, <, Node, ,, Branch, >, n, ), {]
[;, Preconditions, ., checkNotNull, (, priority, ), ;, return, priority, ;, }, }, }]
[., get, (, n, ), ;, Preconditions, ., checkNotNull, (, priority, ), ;, return, priority, ;, }, }, }]
[), ;, Preconditions, ., checkNotNull, (, priority, ), ;, return, priority, ;, }, }, }]
[;, return, priority, ;, }, }, }]
[., checkNotNull, (, priority, ), ;, return, priority, ;, }, }, }]
[), ;, return, priority, ;, }, }, }]
[;, }, }, }]
