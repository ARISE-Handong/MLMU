[;, private, static, final, int, OR_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., OR, ), ;, private, static, final, int]
[., precedence, (, Token, ., AND, ), ;, private, static, final, int, OR_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, .]
[), ;, private, static, final, int, OR_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., OR, ), ;, private, static, final]
[., AND, ), ;, private, static, final, int, OR_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., OR, ), ;, private]
[;, private, static, final, int, NOT_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., NOT, ), ;, private, static, final, CodeGenerator]
[., precedence, (, Token, ., OR, ), ;, private, static, final, int, NOT_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, .]
[), ;, private, static, final, int, NOT_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., NOT, ), ;, private, static, final]
[., OR, ), ;, private, static, final, int, NOT_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., NOT, ), ;, private]
[;, private, static, final, CodeGenerator, REGEXP_ESCAPER, =, CodeGenerator, ., forCostEstimation, (, null, ), ;, private, final, boolean, late, ;, private]
[., precedence, (, Token, ., NOT, ), ;, private, static, final, CodeGenerator, REGEXP_ESCAPER, =, CodeGenerator, ., forCostEstimation, (, null, )]
[), ;, private, static, final, CodeGenerator, REGEXP_ESCAPER, =, CodeGenerator, ., forCostEstimation, (, null, ), ;, private, final, boolean, late, ;]
[., NOT, ), ;, private, static, final, CodeGenerator, REGEXP_ESCAPER, =, CodeGenerator, ., forCostEstimation, (, null, ), ;, private, final, boolean]
[;, private, final, boolean, late, ;, private, final, int, STRING_SPLIT_OVERHEAD, =, ".split('.')", ., length, (, ), ;, static, final, DiagnosticType]
[., forCostEstimation, (, null, ), ;, private, final, boolean, late, ;, private, final, int, STRING_SPLIT_OVERHEAD, =, ".split('.')", ., length, (]
[), ;, private, final, boolean, late, ;, private, final, int, STRING_SPLIT_OVERHEAD, =, ".split('.')", ., length, (, ), ;, static, final]
[;, static, final, DiagnosticType, INVALID_REGULAR_EXPRESSION_FLAGS, =, DiagnosticType, ., warning, (, "JSC_INVALID_REGULAR_EXPRESSION_FLAGS", ,, "Invalid flags to RegExp constructor: {0}", ), ;, static, final, Predicate, <, Node]
[., length, (, ), ;, static, final, DiagnosticType, INVALID_REGULAR_EXPRESSION_FLAGS, =, DiagnosticType, ., warning, (, "JSC_INVALID_REGULAR_EXPRESSION_FLAGS", ,, "Invalid flags to RegExp constructor: {0}", ), ;, static]
[;, static, final, Predicate, <, Node, >, DONT_TRAVERSE_FUNCTIONS_PREDICATE, =, new, Predicate, <, Node, >, (, ), {, @, Override, public]
[., warning, (, "JSC_INVALID_REGULAR_EXPRESSION_FLAGS", ,, "Invalid flags to RegExp constructor: {0}", ), ;, static, final, Predicate, <, Node, >, DONT_TRAVERSE_FUNCTIONS_PREDICATE, =, new, Predicate, <, Node]
[,, "Invalid flags to RegExp constructor: {0}", ), ;, static, final, Predicate, <, Node, >, DONT_TRAVERSE_FUNCTIONS_PREDICATE, =, new, Predicate, <, Node, >, (, ), {]
[), ;, static, final, Predicate, <, Node, >, DONT_TRAVERSE_FUNCTIONS_PREDICATE, =, new, Predicate, <, Node, >, (, ), {, @, Override]
[;, PeepholeSubstituteAlternateSyntax, (, boolean, late, ), {, this, ., late, =, late, ;, }, @, Override, @, SuppressWarnings, (, "fallthrough"]
[;, }, }, ;, PeepholeSubstituteAlternateSyntax, (, boolean, late, ), {, this, ., late, =, late, ;, }, @, Override, @]
[;, }, }, ;, PeepholeSubstituteAlternateSyntax, (, boolean, late, ), {, this, ., late, =, late, ;, }, @, Override, @]
[., isFunction, (, ), ;, }, }, ;, PeepholeSubstituteAlternateSyntax, (, boolean, late, ), {, this, ., late, =, late, ;]
[=, late, ;, }, @, Override, @, SuppressWarnings, (, "fallthrough", ), public, Node, optimizeSubtree, (, Node, node, ), {, switch]
[., late, =, late, ;, }, @, Override, @, SuppressWarnings, (, "fallthrough", ), public, Node, optimizeSubtree, (, Node, node, )]
[;, }, @, Override, @, SuppressWarnings, (, "fallthrough", ), public, Node, optimizeSubtree, (, Node, node, ), {, switch, (, node]
[public, Node, optimizeSubtree, (, Node, node, ), {, switch, (, node, ., getType, (, ), ), {, case, Token, .]
[), public, Node, optimizeSubtree, (, Node, node, ), {, switch, (, node, ., getType, (, ), ), {, case, Token]
[), {, case, Token, ., RETURN, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=]
[., getType, (, ), ), {, case, Token, ., RETURN, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;]
[:, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;]
[., RETURN, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return]
[;, if, (, result, !=, node, ), {, return, result, ;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;, if]
[), ;, if, (, result, !=, node, ), {, return, result, ;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;]
[), {, return, result, ;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;, if, (, result, !=, node, ), {]
[!=, node, ), {, return, result, ;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;, if, (, result, !=, node]
[), {, return, result, ;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;, if, (, result, !=, node, ), {]
[;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;, }]
[=, tryReplaceExitWithBreak, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReduceReturn, (]
[;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReduceReturn, (, node, ), ;, }, case]
[), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReduceReturn, (, node, ), ;, }]
[), {, return, result, ;, }, return, tryReduceReturn, (, node, ), ;, }, case, Token, ., THROW, :, {, Node]
[!=, node, ), {, return, result, ;, }, return, tryReduceReturn, (, node, ), ;, }, case, Token, ., THROW, :]
[), {, return, result, ;, }, return, tryReduceReturn, (, node, ), ;, }, case, Token, ., THROW, :, {, Node]
[;, }, return, tryReduceReturn, (, node, ), ;, }, case, Token, ., THROW, :, {, Node, result, =, tryRemoveRedundantExit, (]
[;, }, case, Token, ., THROW, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=]
[), ;, }, case, Token, ., THROW, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result]
[:, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;]
[., THROW, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return]
[;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case]
[), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }]
[), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case, Token, ., NOT, :, tryMinimizeCondition, (]
[!=, node, ), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case, Token, ., NOT, :]
[), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case, Token, ., NOT, :, tryMinimizeCondition, (]
[;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case, Token, ., NOT, :, tryMinimizeCondition, (, node, ., getFirstChild, (]
[;, }, case, Token, ., NOT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (, node]
[), ;, }, case, Token, ., NOT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (]
[:, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (, node, ), ;, case, Token, ., IF]
[., NOT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (, node, ), ;, case, Token]
[;, return, tryMinimizeNot, (, node, ), ;, case, Token, ., IF, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), )]
[), ;, return, tryMinimizeNot, (, node, ), ;, case, Token, ., IF, :, tryMinimizeCondition, (, node, ., getFirstChild, (, )]
[., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (, node, ), ;, case, Token, ., IF, :, tryMinimizeCondition, (, node]
[;, case, Token, ., IF, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node, )]
[), ;, case, Token, ., IF, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node]
[:, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node, ), ;, case, Token, ., EXPR_RESULT]
[., IF, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node, ), ;, case, Token]
[;, return, tryMinimizeIf, (, node, ), ;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), )]
[), ;, return, tryMinimizeIf, (, node, ), ;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, )]
[., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node, ), ;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (, node]
[;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token]
[), ;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case]
[:, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., HOOK, :, tryMinimizeCondition, (]
[., EXPR_RESULT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., HOOK, :]
[;, return, node, ;, case, Token, ., HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node]
[), ;, return, node, ;, case, Token, ., HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return]
[., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (]
[;, case, Token, ., HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token]
[:, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., WHILE, :, case, Token]
[., HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., WHILE, :]
[;, return, node, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (]
[), ;, return, node, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression]
[., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, tryMinimizeCondition]
[;, case, Token, ., WHILE, :, case, Token, ., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), )]
[:, case, Token, ., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return, node, ;, case]
[., WHILE, :, case, Token, ., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return, node]
[:, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return, node, ;, case, Token, ., FOR, :, if]
[., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return, node, ;, case, Token, ., FOR]
[;, return, node, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, ), ), {]
[), ;, return, node, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, ), )]
[., getConditionExpression, (, node, ), ), ;, return, node, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, .]
[), ), ;, return, node, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, )]
[;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, ), ), {, tryJoinForCondition, (, node]
[:, if, (, !, NodeUtil, ., isForIn, (, node, ), ), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (, NodeUtil]
[., FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, ), ), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition]
[), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return, node]
[), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return, node]
[., isForIn, (, node, ), ), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, )]
[), ), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return]
[;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return, node, ;, case, Token, ., TRUE, :]
[), ;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return, node, ;, case, Token, ., TRUE]
[;, }, return, node, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (, node, )]
[), ;, }, return, node, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (, node]
[., getConditionExpression, (, node, ), ), ;, }, return, node, ;, case, Token, ., TRUE, :, case, Token, ., FALSE]
[), ), ;, }, return, node, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (]
[;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (, node, ), ;, case, Token, .]
[:, case, Token, ., FALSE, :, return, reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :, node, =, tryFoldStandardConstructors]
[., TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :, node]
[:, return, reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :, node, =, tryFoldStandardConstructors, (, node, ), ;, if]
[., FALSE, :, return, reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :, node, =, tryFoldStandardConstructors, (, node, )]
[;, case, Token, ., NEW, :, node, =, tryFoldStandardConstructors, (, node, ), ;, if, (, !, node, ., isCall, (]
[), ;, case, Token, ., NEW, :, node, =, tryFoldStandardConstructors, (, node, ), ;, if, (, !, node, ., isCall]
[:, node, =, tryFoldStandardConstructors, (, node, ), ;, if, (, !, node, ., isCall, (, ), ), {, return, node]
[., NEW, :, node, =, tryFoldStandardConstructors, (, node, ), ;, if, (, !, node, ., isCall, (, ), ), {]
[=, tryFoldStandardConstructors, (, node, ), ;, if, (, !, node, ., isCall, (, ), ), {, return, node, ;, }]
[;, if, (, !, node, ., isCall, (, ), ), {, return, node, ;, }, case, Token, ., CALL, :]
[), ;, if, (, !, node, ., isCall, (, ), ), {, return, node, ;, }, case, Token, ., CALL]
[), {, return, node, ;, }, case, Token, ., CALL, :, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if]
[), {, return, node, ;, }, case, Token, ., CALL, :, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if]
[., isCall, (, ), ), {, return, node, ;, }, case, Token, ., CALL, :, Node, result, =, tryFoldLiteralConstructor, (]
[;, }, case, Token, ., CALL, :, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if, (, result, ==, node]
[:, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if, (, result, ==, node, ), {, result, =, tryFoldSimpleFunctionCall, (]
[., CALL, :, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if, (, result, ==, node, ), {, result, =]
[;, if, (, result, ==, node, ), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==, node]
[), ;, if, (, result, ==, node, ), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==]
[), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (]
[==, node, ), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==, node, ), {, result, =]
[), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (]
[=, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;]
[;, if, (, result, ==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result, ;]
[), ;, if, (, result, ==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result]
[), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result, ;, case, Token, ., COMMA, :, return]
[==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result, ;, case, Token, ., COMMA]
[), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result, ;, case, Token, ., COMMA, :, return]
[=, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result, ;, case, Token, ., COMMA, :, return, trySplitComma, (, node]
[;, }, }, return, result, ;, case, Token, ., COMMA, :, return, trySplitComma, (, node, ), ;, case, Token, .]
[), ;, }, }, return, result, ;, case, Token, ., COMMA, :, return, trySplitComma, (, node, ), ;, case, Token]
[;, case, Token, ., COMMA, :, return, trySplitComma, (, node, ), ;, case, Token, ., NAME, :, return, tryReplaceUndefined, (]
[:, return, trySplitComma, (, node, ), ;, case, Token, ., NAME, :, return, tryReplaceUndefined, (, node, ), ;, case, Token]
[., COMMA, :, return, trySplitComma, (, node, ), ;, case, Token, ., NAME, :, return, tryReplaceUndefined, (, node, ), ;]
[;, case, Token, ., NAME, :, return, tryReplaceUndefined, (, node, ), ;, case, Token, ., BLOCK, :, return, tryReplaceIf, (]
[), ;, case, Token, ., NAME, :, return, tryReplaceUndefined, (, node, ), ;, case, Token, ., BLOCK, :, return, tryReplaceIf]
[:, return, tryReplaceUndefined, (, node, ), ;, case, Token, ., BLOCK, :, return, tryReplaceIf, (, node, ), ;, case, Token]
[., NAME, :, return, tryReplaceUndefined, (, node, ), ;, case, Token, ., BLOCK, :, return, tryReplaceIf, (, node, ), ;]
[;, case, Token, ., BLOCK, :, return, tryReplaceIf, (, node, ), ;, case, Token, ., ARRAYLIT, :, return, tryMinimizeArrayLiteral, (]
[), ;, case, Token, ., BLOCK, :, return, tryReplaceIf, (, node, ), ;, case, Token, ., ARRAYLIT, :, return, tryMinimizeArrayLiteral]
[:, return, tryReplaceIf, (, node, ), ;, case, Token, ., ARRAYLIT, :, return, tryMinimizeArrayLiteral, (, node, ), ;, default, :]
[., BLOCK, :, return, tryReplaceIf, (, node, ), ;, case, Token, ., ARRAYLIT, :, return, tryMinimizeArrayLiteral, (, node, ), ;]
[;, case, Token, ., ARRAYLIT, :, return, tryMinimizeArrayLiteral, (, node, ), ;, default, :, return, node, ;, }, }, private]
[), ;, case, Token, ., ARRAYLIT, :, return, tryMinimizeArrayLiteral, (, node, ), ;, default, :, return, node, ;, }, }]
[:, return, tryMinimizeArrayLiteral, (, node, ), ;, default, :, return, node, ;, }, }, private, void, tryJoinForCondition, (, Node, n]
[., ARRAYLIT, :, return, tryMinimizeArrayLiteral, (, node, ), ;, default, :, return, node, ;, }, }, private, void, tryJoinForCondition, (]
[;, default, :, return, node, ;, }, }, private, void, tryJoinForCondition, (, Node, n, ), {, if, (, !, late]
[), ;, default, :, return, node, ;, }, }, private, void, tryJoinForCondition, (, Node, n, ), {, if, (, !]
[;, }, }, private, void, tryJoinForCondition, (, Node, n, ), {, if, (, !, late, ), {, return, ;, }]
[), {, return, ;, }, Node, block, =, n, ., getLastChild, (, ), ;, Node, maybeIf, =, block, ., getFirstChild]
[), {, return, ;, }, Node, block, =, n, ., getLastChild, (, ), ;, Node, maybeIf, =, block, ., getFirstChild]
[;, Node, maybeIf, =, block, ., getFirstChild, (, ), ;, if, (, maybeIf, !=, null, &&, maybeIf, ., isIf, (]
[., getLastChild, (, ), ;, Node, maybeIf, =, block, ., getFirstChild, (, ), ;, if, (, maybeIf, !=, null, &&]
[;, if, (, maybeIf, !=, null, &&, maybeIf, ., isIf, (, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex]
[., getFirstChild, (, ), ;, if, (, maybeIf, !=, null, &&, maybeIf, ., isIf, (, ), ), {, Node, maybeBreak]
[), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=]
[&&, maybeIf, ., isIf, (, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (]
[!=, null, &&, maybeIf, ., isIf, (, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), .]
[&&, maybeIf, ., isIf, (, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (]
[), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=]
[., isIf, (, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;]
[;, if, (, maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, ), )]
[., getFirstChild, (, ), ;, if, (, maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak, .]
[., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (]
[), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak]
[), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {, block, ., replaceChild, (, maybeIf, ,, maybeIf]
[&&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {]
[&&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount]
[!=, null, &&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (, maybeIf]
[&&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount]
[&&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {]
[., isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount, (, )]
[), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {, block, ., replaceChild, (, maybeIf, ,, maybeIf]
[), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {, block, ., replaceChild, (, maybeIf, ,, maybeIf]
[., hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {, block, ., replaceChild]
[), {, block, ., replaceChild, (, maybeIf, ,, maybeIf, ., getLastChild, (, ), ., detachFromParent, (, ), ), ;, }]
[==, 3, ), {, block, ., replaceChild, (, maybeIf, ,, maybeIf, ., getLastChild, (, ), ., detachFromParent, (, ), )]
[., getChildCount, (, ), ==, 3, ), {, block, ., replaceChild, (, maybeIf, ,, maybeIf, ., getLastChild, (, ), .]
[), {, block, ., replaceChild, (, maybeIf, ,, maybeIf, ., getLastChild, (, ), ., detachFromParent, (, ), ), ;, }]
[;, }, else, {, block, ., removeFirstChild, (, ), ;, }, Node, ifCondition, =, maybeIf, ., removeFirstChild, (, ), ;]
[., replaceChild, (, maybeIf, ,, maybeIf, ., getLastChild, (, ), ., detachFromParent, (, ), ), ;, }, else, {, block]
[,, maybeIf, ., getLastChild, (, ), ., detachFromParent, (, ), ), ;, }, else, {, block, ., removeFirstChild, (, )]
[), ;, }, else, {, block, ., removeFirstChild, (, ), ;, }, Node, ifCondition, =, maybeIf, ., removeFirstChild, (, )]
[., detachFromParent, (, ), ), ;, }, else, {, block, ., removeFirstChild, (, ), ;, }, Node, ifCondition, =, maybeIf]
[., getLastChild, (, ), ., detachFromParent, (, ), ), ;, }, else, {, block, ., removeFirstChild, (, ), ;, }]
[;, }, Node, ifCondition, =, maybeIf, ., removeFirstChild, (, ), ;, Node, fixedIfCondition, =, IR, ., not, (, ifCondition, )]
[., removeFirstChild, (, ), ;, }, Node, ifCondition, =, maybeIf, ., removeFirstChild, (, ), ;, Node, fixedIfCondition, =, IR, .]
[;, Node, fixedIfCondition, =, IR, ., not, (, ifCondition, ), ., srcref, (, ifCondition, ), ;, Node, forCondition, =, NodeUtil]
[., removeFirstChild, (, ), ;, Node, fixedIfCondition, =, IR, ., not, (, ifCondition, ), ., srcref, (, ifCondition, ), ;]
[;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, forCondition, ., isEmpty, (, ), ), {]
[., srcref, (, ifCondition, ), ;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, forCondition, .]
[., not, (, ifCondition, ), ., srcref, (, ifCondition, ), ;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (, n, )]
[), ., srcref, (, ifCondition, ), ;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, forCondition]
[), ;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, forCondition, ., isEmpty, (, ), )]
[;, if, (, forCondition, ., isEmpty, (, ), ), {, n, ., replaceChild, (, forCondition, ,, fixedIfCondition, ), ;, }]
[., getConditionExpression, (, n, ), ;, if, (, forCondition, ., isEmpty, (, ), ), {, n, ., replaceChild, (, forCondition]
[), ;, if, (, forCondition, ., isEmpty, (, ), ), {, n, ., replaceChild, (, forCondition, ,, fixedIfCondition, ), ;]
[), {, n, ., replaceChild, (, forCondition, ,, fixedIfCondition, ), ;, }, else, {, Node, replacement, =, new, Node, (]
[., isEmpty, (, ), ), {, n, ., replaceChild, (, forCondition, ,, fixedIfCondition, ), ;, }, else, {, Node, replacement]
[;, }, else, {, Node, replacement, =, new, Node, (, Token, ., AND, ), ;, n, ., replaceChild, (, forCondition]
[., replaceChild, (, forCondition, ,, fixedIfCondition, ), ;, }, else, {, Node, replacement, =, new, Node, (, Token, ., AND]
[,, fixedIfCondition, ), ;, }, else, {, Node, replacement, =, new, Node, (, Token, ., AND, ), ;, n, .]
[), ;, }, else, {, Node, replacement, =, new, Node, (, Token, ., AND, ), ;, n, ., replaceChild, (]
[;, n, ., replaceChild, (, forCondition, ,, replacement, ), ;, replacement, ., addChildToBack, (, forCondition, ), ;, replacement, ., addChildToBack]
[), ;, n, ., replaceChild, (, forCondition, ,, replacement, ), ;, replacement, ., addChildToBack, (, forCondition, ), ;, replacement, .]
[., AND, ), ;, n, ., replaceChild, (, forCondition, ,, replacement, ), ;, replacement, ., addChildToBack, (, forCondition, ), ;]
[;, replacement, ., addChildToBack, (, forCondition, ), ;, replacement, ., addChildToBack, (, fixedIfCondition, ), ;, }, reportCodeChange, (, ), ;]
[., replaceChild, (, forCondition, ,, replacement, ), ;, replacement, ., addChildToBack, (, forCondition, ), ;, replacement, ., addChildToBack, (, fixedIfCondition]
[,, replacement, ), ;, replacement, ., addChildToBack, (, forCondition, ), ;, replacement, ., addChildToBack, (, fixedIfCondition, ), ;, }, reportCodeChange]
[), ;, replacement, ., addChildToBack, (, forCondition, ), ;, replacement, ., addChildToBack, (, fixedIfCondition, ), ;, }, reportCodeChange, (, )]
[;, replacement, ., addChildToBack, (, fixedIfCondition, ), ;, }, reportCodeChange, (, ), ;, }, }, }, private, Node, tryFoldSimpleFunctionCall, (]
[., addChildToBack, (, forCondition, ), ;, replacement, ., addChildToBack, (, fixedIfCondition, ), ;, }, reportCodeChange, (, ), ;, }, }]
[), ;, replacement, ., addChildToBack, (, fixedIfCondition, ), ;, }, reportCodeChange, (, ), ;, }, }, }, private, Node, tryFoldSimpleFunctionCall]
[;, }, reportCodeChange, (, ), ;, }, }, }, private, Node, tryFoldSimpleFunctionCall, (, Node, n, ), {, Preconditions, ., checkState]
[., addChildToBack, (, fixedIfCondition, ), ;, }, reportCodeChange, (, ), ;, }, }, }, private, Node, tryFoldSimpleFunctionCall, (, Node, n]
[), ;, }, reportCodeChange, (, ), ;, }, }, }, private, Node, tryFoldSimpleFunctionCall, (, Node, n, ), {, Preconditions, .]
[;, }, }, }, private, Node, tryFoldSimpleFunctionCall, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (]
[;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (, callTarget, !=, null, &&, callTarget, ., isName, (]
[., checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if]
[), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (, callTarget, !=, null, &&, callTarget, ., isName]
[., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (, callTarget, !=, null]
[;, if, (, callTarget, !=, null, &&, callTarget, ., isName, (, ), &&, callTarget, ., getString, (, ), ., equals]
[., getFirstChild, (, ), ;, if, (, callTarget, !=, null, &&, callTarget, ., isName, (, ), &&, callTarget, ., getString]
[), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (, value, !=, null, &&, value, ., getNext]
[&&, callTarget, ., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =, callTarget, ., getNext, (]
[&&, callTarget, ., isName, (, ), &&, callTarget, ., getString, (, ), ., equals, (, "String", ), ), {, Node]
[!=, null, &&, callTarget, ., isName, (, ), &&, callTarget, ., getString, (, ), ., equals, (, "String", ), )]
[&&, callTarget, ., isName, (, ), &&, callTarget, ., getString, (, ), ., equals, (, "String", ), ), {, Node]
[&&, callTarget, ., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =, callTarget, ., getNext, (]
[., isName, (, ), &&, callTarget, ., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =]
[), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (, value, !=, null, &&, value, ., getNext]
[., equals, (, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (, value, !=]
[., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;]
[), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (, value, !=, null, &&, value, .]
[;, if, (, value, !=, null, &&, value, ., getNext, (, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value]
[., getNext, (, ), ;, if, (, value, !=, null, &&, value, ., getNext, (, ), ==, null, &&, NodeUtil]
[), {, Node, addition, =, IR, ., add, (, IR, ., string, (, "", ), ., srcref, (, callTarget, )]
[&&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, ., add, (, IR, ., string, (]
[&&, value, ., getNext, (, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =]
[!=, null, &&, value, ., getNext, (, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node]
[&&, value, ., getNext, (, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =]
[&&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, ., add, (, IR, ., string, (]
[==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, ., add, (, IR, .]
[., getNext, (, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, .]
[&&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, ., add, (, IR, ., string, (]
[), {, Node, addition, =, IR, ., add, (, IR, ., string, (, "", ), ., srcref, (, callTarget, )]
[., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, ., add, (, IR, ., string, (, "", )]
[), ), {, Node, addition, =, IR, ., add, (, IR, ., string, (, "", ), ., srcref, (, callTarget]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, addition, ), ;, reportCodeChange, (, ), ;, return, addition]
[., add, (, IR, ., string, (, "", ), ., srcref, (, callTarget, ), ,, value, ., detachFromParent, (, )]
[,, value, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, addition, )]
[., srcref, (, callTarget, ), ,, value, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild]
[., string, (, "", ), ., srcref, (, callTarget, ), ,, value, ., detachFromParent, (, ), ), ;, n, .]
[), ., srcref, (, callTarget, ), ,, value, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), .]
[), ,, value, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, addition]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, addition, ), ;, reportCodeChange, (, ), ;, return]
[., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, addition, ), ;, reportCodeChange]
[;, reportCodeChange, (, ), ;, return, addition, ;, }, }, return, n, ;, }, private, Node, tryFoldImmediateCallToBoundFunction, (, Node, n]
[., replaceChild, (, n, ,, addition, ), ;, reportCodeChange, (, ), ;, return, addition, ;, }, }, return, n, ;]
[., getParent, (, ), ., replaceChild, (, n, ,, addition, ), ;, reportCodeChange, (, ), ;, return, addition, ;, }]
[,, addition, ), ;, reportCodeChange, (, ), ;, return, addition, ;, }, }, return, n, ;, }, private, Node, tryFoldImmediateCallToBoundFunction]
[), ;, reportCodeChange, (, ), ;, return, addition, ;, }, }, return, n, ;, }, private, Node, tryFoldImmediateCallToBoundFunction, (, Node]
[;, return, addition, ;, }, }, return, n, ;, }, private, Node, tryFoldImmediateCallToBoundFunction, (, Node, n, ), {, Preconditions, .]
[;, }, }, return, n, ;, }, private, Node, tryFoldImmediateCallToBoundFunction, (, Node, n, ), {, Preconditions, ., checkState, (, n]
[;, }, private, Node, tryFoldImmediateCallToBoundFunction, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), )]
[;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, Bind, bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget]
[., checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, Bind]
[), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, Bind, bind, =, getCodingConvention, (, ), ., describeFunctionBind, (]
[., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, Bind, bind, =, getCodingConvention, (]
[;, Bind, bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,, false, ), ;, if, (, bind, !=, null]
[., getFirstChild, (, ), ;, Bind, bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,, false, ), ;, if]
[;, if, (, bind, !=, null, ), {, bind, ., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (]
[., describeFunctionBind, (, callTarget, ,, false, ), ;, if, (, bind, !=, null, ), {, bind, ., target, ., detachFromParent]
[,, false, ), ;, if, (, bind, !=, null, ), {, bind, ., target, ., detachFromParent, (, ), ;, n]
[), ;, if, (, bind, !=, null, ), {, bind, ., target, ., detachFromParent, (, ), ;, n, ., replaceChild]
[), {, bind, ., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,, bind, ., target, )]
[!=, null, ), {, bind, ., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,, bind, .]
[), {, bind, ., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,, bind, ., target, )]
[;, n, ., replaceChild, (, callTarget, ,, bind, ., target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (]
[., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,, bind, ., target, ), ;, callTarget, =, bind, .]
[., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,, bind, ., target, ), ;, callTarget, =]
[;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (, bind, .]
[., replaceChild, (, callTarget, ,, bind, ., target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, .]
[,, bind, ., target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, )]
[), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (, bind]
[., target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if]
[=, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=]
[;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=, null, &&, !, NodeUtil]
[., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=, null, &&]
[;, if, (, bind, ., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), ), {]
[,, callTarget, ), ;, if, (, bind, ., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue]
[., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (, bind]
[), ;, if, (, bind, ., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), )]
[), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,, IR, ., string, (, "call"]
[&&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget]
[!=, null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop]
[., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR]
[&&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget]
[), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,, IR, ., string, (, "call"]
[), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,, IR, ., string, (, "call"]
[., isUndefined, (, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (]
[), ), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,, IR, ., string, (]
[., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,, IR, .]
[;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (]
[., getprop, (, callTarget, ., cloneTree, (, ), ,, IR, ., string, (, "call", ), ., srcref, (, callTarget, )]
[,, IR, ., string, (, "call", ), ., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,]
[., cloneTree, (, ), ,, IR, ., string, (, "call", ), ., srcref, (, callTarget, ), ), ;, n, .]
[), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree]
[., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (]
[., string, (, "call", ), ., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, )]
[), ., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter]
[), ), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (, bind, ., thisValue, .]
[;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;, n, ., putBooleanProp, (]
[., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,]
[,, newCallTarget, ), ;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;, n]
[), ;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;, n, ., putBooleanProp]
[;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }, else, {, n, ., putBooleanProp, (, Node]
[., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;, n, ., putBooleanProp, (, Node, .]
[,, newCallTarget, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }, else, {, n, .]
[., cloneTree, (, ), ,, newCallTarget, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }]
[., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, )]
[), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }, else, {, n, ., putBooleanProp, (]
[;, }, else, {, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, reportCodeChange, (, ), ;]
[., putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }, else, {, n, ., putBooleanProp, (, Node, ., FREE_CALL]
[,, false, ), ;, }, else, {, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, reportCodeChange]
[., FREE_CALL, ,, false, ), ;, }, else, {, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;]
[), ;, }, else, {, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, reportCodeChange, (, )]
[;, }, reportCodeChange, (, ), ;, }, return, n, ;, }, private, void, addParameterAfter, (, Node, parameterList, ,, Node, after]
[., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, reportCodeChange, (, ), ;, }, return, n, ;, }]
[,, true, ), ;, }, reportCodeChange, (, ), ;, }, return, n, ;, }, private, void, addParameterAfter, (, Node, parameterList]
[., FREE_CALL, ,, true, ), ;, }, reportCodeChange, (, ), ;, }, return, n, ;, }, private, void, addParameterAfter, (]
[), ;, }, reportCodeChange, (, ), ;, }, return, n, ;, }, private, void, addParameterAfter, (, Node, parameterList, ,, Node]
[;, }, return, n, ;, }, private, void, addParameterAfter, (, Node, parameterList, ,, Node, after, ), {, if, (, parameterList]
[;, }, private, void, addParameterAfter, (, Node, parameterList, ,, Node, after, ), {, if, (, parameterList, !=, null, ), {]
[), {, addParameterAfter, (, parameterList, ., getNext, (, ), ,, after, ), ;, after, ., getParent, (, ), ., addChildAfter]
[!=, null, ), {, addParameterAfter, (, parameterList, ., getNext, (, ), ,, after, ), ;, after, ., getParent, (, )]
[), {, addParameterAfter, (, parameterList, ., getNext, (, ), ,, after, ), ;, after, ., getParent, (, ), ., addChildAfter]
[;, after, ., getParent, (, ), ., addChildAfter, (, parameterList, ., cloneTree, (, ), ,, after, ), ;, }, }]
[,, after, ), ;, after, ., getParent, (, ), ., addChildAfter, (, parameterList, ., cloneTree, (, ), ,, after, )]
[., getNext, (, ), ,, after, ), ;, after, ., getParent, (, ), ., addChildAfter, (, parameterList, ., cloneTree, (]
[), ;, after, ., getParent, (, ), ., addChildAfter, (, parameterList, ., cloneTree, (, ), ,, after, ), ;, }]
[;, }, }, private, Node, trySplitComma, (, Node, n, ), {, if, (, late, ), {, return, n, ;, }]
[., addChildAfter, (, parameterList, ., cloneTree, (, ), ,, after, ), ;, }, }, private, Node, trySplitComma, (, Node, n]
[., getParent, (, ), ., addChildAfter, (, parameterList, ., cloneTree, (, ), ,, after, ), ;, }, }, private, Node]
[,, after, ), ;, }, }, private, Node, trySplitComma, (, Node, n, ), {, if, (, late, ), {, return]
[., cloneTree, (, ), ,, after, ), ;, }, }, private, Node, trySplitComma, (, Node, n, ), {, if, (]
[), ;, }, }, private, Node, trySplitComma, (, Node, n, ), {, if, (, late, ), {, return, n, ;]
[), {, return, n, ;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, left, =, n, .]
[;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, left, =, n, ., getFirstChild, (, ), ;]
[;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if]
[., getParent, (, ), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild]
[;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, parent, ., isExprResult, (, ), &&, !, parent]
[., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, parent, ., isExprResult, (]
[;, if, (, parent, ., isExprResult, (, ), &&, !, parent, ., getParent, (, ), ., isLabel, (, ), )]
[., getLastChild, (, ), ;, if, (, parent, ., isExprResult, (, ), &&, !, parent, ., getParent, (, ), .]
[), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =]
[&&, !, parent, ., getParent, (, ), ., isLabel, (, ), ), {, n, ., detachChildren, (, ), ;, parent]
[., isExprResult, (, ), &&, !, parent, ., getParent, (, ), ., isLabel, (, ), ), {, n, ., detachChildren]
[), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =]
[), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =]
[., isLabel, (, ), ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, left, )]
[., getParent, (, ), ., isLabel, (, ), ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (]
[;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;]
[., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =, IR, ., exprResult]
[;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;, newStatement, ., copyInformationFrom, (, n, ), ;, parent, .]
[., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;, newStatement, .]
[,, left, ), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;, newStatement, ., copyInformationFrom, (, n, )]
[), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;, newStatement, ., copyInformationFrom, (, n, ), ;, parent]
[;, newStatement, ., copyInformationFrom, (, n, ), ;, parent, ., getParent, (, ), ., addChildAfter, (, newStatement, ,, parent, )]
[., exprResult, (, right, ), ;, newStatement, ., copyInformationFrom, (, n, ), ;, parent, ., getParent, (, ), ., addChildAfter]
[), ;, newStatement, ., copyInformationFrom, (, n, ), ;, parent, ., getParent, (, ), ., addChildAfter, (, newStatement, ,, parent]
[;, parent, ., getParent, (, ), ., addChildAfter, (, newStatement, ,, parent, ), ;, reportCodeChange, (, ), ;, return, left]
[., copyInformationFrom, (, n, ), ;, parent, ., getParent, (, ), ., addChildAfter, (, newStatement, ,, parent, ), ;, reportCodeChange]
[), ;, parent, ., getParent, (, ), ., addChildAfter, (, newStatement, ,, parent, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, left, ;, }, else, {, return, n, ;, }, }, private, Node, tryReplaceIf, (]
[., addChildAfter, (, newStatement, ,, parent, ), ;, reportCodeChange, (, ), ;, return, left, ;, }, else, {, return, n]
[., getParent, (, ), ., addChildAfter, (, newStatement, ,, parent, ), ;, reportCodeChange, (, ), ;, return, left, ;, }]
[,, parent, ), ;, reportCodeChange, (, ), ;, return, left, ;, }, else, {, return, n, ;, }, }, private]
[), ;, reportCodeChange, (, ), ;, return, left, ;, }, else, {, return, n, ;, }, }, private, Node, tryReplaceIf]
[;, return, left, ;, }, else, {, return, n, ;, }, }, private, Node, tryReplaceIf, (, Node, n, ), {]
[;, }, else, {, return, n, ;, }, }, private, Node, tryReplaceIf, (, Node, n, ), {, for, (, Node]
[;, }, }, private, Node, tryReplaceIf, (, Node, n, ), {, for, (, Node, child, =, n, ., getFirstChild, (]
[;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, child, ., isIf, (]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[;, child, =, child, ., getNext, (, ), ), {, if, (, child, ., isIf, (, ), ), {, Node]
[!=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, child, ., isIf, (, ), )]
[;, child, =, child, ., getNext, (, ), ), {, if, (, child, ., isIf, (, ), ), {, Node]
[=, child, ., getNext, (, ), ), {, if, (, child, ., isIf, (, ), ), {, Node, cond, =]
[), {, if, (, child, ., isIf, (, ), ), {, Node, cond, =, child, ., getFirstChild, (, ), ;]
[., getNext, (, ), ), {, if, (, child, ., isIf, (, ), ), {, Node, cond, =, child, .]
[), {, Node, cond, =, child, ., getFirstChild, (, ), ;, Node, thenBranch, =, cond, ., getNext, (, ), ;]
[., isIf, (, ), ), {, Node, cond, =, child, ., getFirstChild, (, ), ;, Node, thenBranch, =, cond, .]
[;, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node]
[., getFirstChild, (, ), ;, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext]
[;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if]
[., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node, nextNode, =, child, ., getNext]
[;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&]
[., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (, nextNode, !=, null, &&]
[;, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (]
[., getNext, (, ), ;, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&]
[), {, Node, nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen, =, nextCond, ., getNext, (, ), ;]
[&&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen, =]
[&&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =, nextNode, ., getFirstChild, (]
[&&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =]
[!=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, ), ), {, Node]
[&&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =]
[&&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =, nextNode, ., getFirstChild, (]
[==, null, &&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =, nextNode, .]
[&&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =, nextNode, ., getFirstChild, (]
[&&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen, =]
[), &&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen]
[), {, Node, nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen, =, nextCond, ., getNext, (, ), ;]
[., isIf, (, ), ), {, Node, nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen, =, nextCond, .]
[;, Node, nextThen, =, nextCond, ., getNext, (, ), ;, Node, nextElse, =, nextThen, ., getNext, (, ), ;, if]
[., getFirstChild, (, ), ;, Node, nextThen, =, nextCond, ., getNext, (, ), ;, Node, nextElse, =, nextThen, ., getNext]
[;, Node, nextElse, =, nextThen, ., getNext, (, ), ;, if, (, thenBranch, ., isEquivalentToTyped, (, nextThen, ), ), {]
[., getNext, (, ), ;, Node, nextElse, =, nextThen, ., getNext, (, ), ;, if, (, thenBranch, ., isEquivalentToTyped, (]
[;, if, (, thenBranch, ., isEquivalentToTyped, (, nextThen, ), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren]
[., getNext, (, ), ;, if, (, thenBranch, ., isEquivalentToTyped, (, nextThen, ), ), {, child, ., detachFromParent, (, )]
[), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (]
[., isEquivalentToTyped, (, nextThen, ), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node]
[), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node]
[;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., OR, ,, cond, ), ;]
[., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., OR]
[;, Node, newCond, =, new, Node, (, Token, ., OR, ,, cond, ), ;, nextNode, ., replaceChild, (, nextCond, ,]
[., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., OR, ,, cond, ), ;, nextNode, .]
[;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, )]
[,, cond, ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;]
[., OR, ,, cond, ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond]
[), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (]
[;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null, &&]
[., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }]
[,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (, nextElse]
[), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null]
[;, reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null, &&, thenBranch, ., isEquivalentToTyped, (, nextElse, ), )]
[., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null, &&, thenBranch, .]
[), ;, reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null, &&, thenBranch, ., isEquivalentToTyped, (, nextElse, )]
[;, }, else, if, (, nextElse, !=, null, &&, thenBranch, ., isEquivalentToTyped, (, nextElse, ), ), {, child, ., detachFromParent]
[), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (]
[&&, thenBranch, ., isEquivalentToTyped, (, nextElse, ), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, )]
[!=, null, &&, thenBranch, ., isEquivalentToTyped, (, nextElse, ), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren]
[&&, thenBranch, ., isEquivalentToTyped, (, nextElse, ), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, )]
[), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (]
[., isEquivalentToTyped, (, nextElse, ), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node]
[), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node]
[;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., AND, ,, IR, ., not]
[., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., AND]
[;, Node, newCond, =, new, Node, (, Token, ., AND, ,, IR, ., not, (, cond, ), ., srcref, (]
[., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., AND, ,, IR, ., not, (, cond]
[;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, )]
[,, IR, ., not, (, cond, ), ., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (, nextCond, ,]
[., AND, ,, IR, ., not, (, cond, ), ., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (]
[), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (]
[., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (]
[., not, (, cond, ), ., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, )]
[), ., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack]
[), ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange]
[;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=, null]
[., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }]
[,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (]
[), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=]
[;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (]
[., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=, null, &&, elseBranch]
[), ;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock]
[;, }, }, else, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression]
[), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {, thenExpr, =, getBlockReturnExpression, (, thenBranch]
[&&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {]
[&&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock]
[&&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null]
[!=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr]
[&&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null]
[&&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock]
[==, null, &&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if]
[&&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock]
[&&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {]
[), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), )]
[), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {, thenExpr, =, getBlockReturnExpression, (, thenBranch]
[), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {, thenExpr, =, getBlockReturnExpression, (]
[;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, thenExpr, ., detachFromParent, (]
[), {, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, thenExpr, ., detachFromParent, (, ), ;, }, else, {, thenExpr, =]
[), ), {, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, thenExpr, ., detachFromParent, (, ), ;, }, else, {, thenExpr]
[=, getBlockReturnExpression, (, thenBranch, ), ;, thenExpr, ., detachFromParent, (, ), ;, }, else, {, thenExpr, =, NodeUtil, ., newUndefinedNode]
[;, thenExpr, ., detachFromParent, (, ), ;, }, else, {, thenExpr, =, NodeUtil, ., newUndefinedNode, (, child, ), ;, }]
[), ;, thenExpr, ., detachFromParent, (, ), ;, }, else, {, thenExpr, =, NodeUtil, ., newUndefinedNode, (, child, ), ;]
[;, }, else, {, thenExpr, =, NodeUtil, ., newUndefinedNode, (, child, ), ;, }, Node, elseExpr, =, nextNode, ., getFirstChild]
[., detachFromParent, (, ), ;, }, else, {, thenExpr, =, NodeUtil, ., newUndefinedNode, (, child, ), ;, }, Node, elseExpr]
[=, NodeUtil, ., newUndefinedNode, (, child, ), ;, }, Node, elseExpr, =, nextNode, ., getFirstChild, (, ), ;, cond, .]
[;, }, Node, elseExpr, =, nextNode, ., getFirstChild, (, ), ;, cond, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent]
[., newUndefinedNode, (, child, ), ;, }, Node, elseExpr, =, nextNode, ., getFirstChild, (, ), ;, cond, ., detachFromParent, (]
[), ;, }, Node, elseExpr, =, nextNode, ., getFirstChild, (, ), ;, cond, ., detachFromParent, (, ), ;, elseExpr, .]
[;, cond, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (]
[., getFirstChild, (, ), ;, cond, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =]
[;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,]
[., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, .]
[;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref]
[., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,]
[;, n, ., replaceChild, (, child, ,, returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, )]
[., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, child, ), ), ;]
[), ;, n, ., replaceChild, (, child, ,, returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (]
[., srcref, (, child, ), ), ;, n, ., replaceChild, (, child, ,, returnNode, ), ;, n, ., removeChild, (]
[., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, child, ), ), ;, n, ., replaceChild, (]
[,, thenExpr, ,, elseExpr, ), ., srcref, (, child, ), ), ;, n, ., replaceChild, (, child, ,, returnNode, )]
[,, elseExpr, ), ., srcref, (, child, ), ), ;, n, ., replaceChild, (, child, ,, returnNode, ), ;, n]
[), ., srcref, (, child, ), ), ;, n, ., replaceChild, (, child, ,, returnNode, ), ;, n, ., removeChild]
[), ), ;, n, ., replaceChild, (, child, ,, returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange]
[;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=, null, &&]
[., replaceChild, (, child, ,, returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }]
[,, returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch]
[), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=, null]
[;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (, thenBranch, ), ), {, child]
[., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (]
[), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (, thenBranch, ), ), {]
[;, }, else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (, thenBranch, ), ), {, child, ., removeChild, (, elseBranch]
[), {, child, ., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (, elseBranch, ,, child, ), ;, reportCodeChange, (]
[&&, statementMustExitParent, (, thenBranch, ), ), {, child, ., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (, elseBranch, ,]
[!=, null, &&, statementMustExitParent, (, thenBranch, ), ), {, child, ., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (]
[&&, statementMustExitParent, (, thenBranch, ), ), {, child, ., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (, elseBranch, ,]
[), {, child, ., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (, elseBranch, ,, child, ), ;, reportCodeChange, (]
[), ), {, child, ., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (, elseBranch, ,, child, ), ;, reportCodeChange]
[;, n, ., addChildAfter, (, elseBranch, ,, child, ), ;, reportCodeChange, (, ), ;, }, }, }, return, n, ;]
[., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (, elseBranch, ,, child, ), ;, reportCodeChange, (, ), ;, }]
[), ;, n, ., addChildAfter, (, elseBranch, ,, child, ), ;, reportCodeChange, (, ), ;, }, }, }, return, n]
[;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private, boolean, statementMustExitParent, (, Node, n, ), {]
[., addChildAfter, (, elseBranch, ,, child, ), ;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private]
[,, child, ), ;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private, boolean, statementMustExitParent, (, Node]
[), ;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private, boolean, statementMustExitParent, (, Node, n, )]
[;, }, }, }, return, n, ;, }, private, boolean, statementMustExitParent, (, Node, n, ), {, switch, (, n, .]
[;, }, private, boolean, statementMustExitParent, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[), {, case, Token, ., THROW, :, case, Token, ., RETURN, :, return, true, ;, case, Token, ., BLOCK, :]
[., getType, (, ), ), {, case, Token, ., THROW, :, case, Token, ., RETURN, :, return, true, ;, case]
[:, case, Token, ., RETURN, :, return, true, ;, case, Token, ., BLOCK, :, if, (, n, ., hasChildren, (]
[., THROW, :, case, Token, ., RETURN, :, return, true, ;, case, Token, ., BLOCK, :, if, (, n, .]
[:, return, true, ;, case, Token, ., BLOCK, :, if, (, n, ., hasChildren, (, ), ), {, Node, child]
[., RETURN, :, return, true, ;, case, Token, ., BLOCK, :, if, (, n, ., hasChildren, (, ), ), {]
[;, case, Token, ., BLOCK, :, if, (, n, ., hasChildren, (, ), ), {, Node, child, =, n, .]
[:, if, (, n, ., hasChildren, (, ), ), {, Node, child, =, n, ., getLastChild, (, ), ;, return]
[., BLOCK, :, if, (, n, ., hasChildren, (, ), ), {, Node, child, =, n, ., getLastChild, (, )]
[), {, Node, child, =, n, ., getLastChild, (, ), ;, return, statementMustExitParent, (, child, ), ;, }, return, false]
[., hasChildren, (, ), ), {, Node, child, =, n, ., getLastChild, (, ), ;, return, statementMustExitParent, (, child, )]
[;, return, statementMustExitParent, (, child, ), ;, }, return, false, ;, case, Token, ., FUNCTION, :, default, :, return, false]
[., getLastChild, (, ), ;, return, statementMustExitParent, (, child, ), ;, }, return, false, ;, case, Token, ., FUNCTION, :]
[;, }, return, false, ;, case, Token, ., FUNCTION, :, default, :, return, false, ;, }, }, private, Node, tryReplaceUndefined]
[), ;, }, return, false, ;, case, Token, ., FUNCTION, :, default, :, return, false, ;, }, }, private, Node]
[;, case, Token, ., FUNCTION, :, default, :, return, false, ;, }, }, private, Node, tryReplaceUndefined, (, Node, n, )]
[:, default, :, return, false, ;, }, }, private, Node, tryReplaceUndefined, (, Node, n, ), {, if, (, isASTNormalized, (]
[., FUNCTION, :, default, :, return, false, ;, }, }, private, Node, tryReplaceUndefined, (, Node, n, ), {, if, (]
[;, }, }, private, Node, tryReplaceUndefined, (, Node, n, ), {, if, (, isASTNormalized, (, ), &&, NodeUtil, ., isUndefined]
[), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[&&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;]
[&&, NodeUtil, ., isUndefined, (, n, ), &&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =]
[&&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;]
[., isUndefined, (, n, ), &&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =, NodeUtil, .]
[), &&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, )]
[), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[., isLValue, (, n, ), ), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;, n, ., getParent]
[), ), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;, n, ., getParent, (, ), ., replaceChild]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement]
[., newUndefinedNode, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, replacement, ;, }, return, n, ;, }, private, Node, tryReduceReturn, (, Node, n, )]
[., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, return, n, ;, }]
[., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }]
[,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, return, n, ;, }, private, Node, tryReduceReturn, (]
[), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, return, n, ;, }, private, Node, tryReduceReturn, (, Node, n]
[;, return, replacement, ;, }, return, n, ;, }, private, Node, tryReduceReturn, (, Node, n, ), {, Node, result, =]
[;, }, return, n, ;, }, private, Node, tryReduceReturn, (, Node, n, ), {, Node, result, =, n, ., getFirstChild]
[;, }, private, Node, tryReduceReturn, (, Node, n, ), {, Node, result, =, n, ., getFirstChild, (, ), ;, if]
[;, if, (, result, !=, null, ), {, switch, (, result, ., getType, (, ), ), {, case, Token, .]
[., getFirstChild, (, ), ;, if, (, result, !=, null, ), {, switch, (, result, ., getType, (, ), )]
[), {, switch, (, result, ., getType, (, ), ), {, case, Token, ., VOID, :, Node, operand, =, result]
[!=, null, ), {, switch, (, result, ., getType, (, ), ), {, case, Token, ., VOID, :, Node, operand]
[), {, switch, (, result, ., getType, (, ), ), {, case, Token, ., VOID, :, Node, operand, =, result]
[), {, case, Token, ., VOID, :, Node, operand, =, result, ., getFirstChild, (, ), ;, if, (, !, mayHaveSideEffects]
[., getType, (, ), ), {, case, Token, ., VOID, :, Node, operand, =, result, ., getFirstChild, (, ), ;]
[:, Node, operand, =, result, ., getFirstChild, (, ), ;, if, (, !, mayHaveSideEffects, (, operand, ), ), {, n]
[., VOID, :, Node, operand, =, result, ., getFirstChild, (, ), ;, if, (, !, mayHaveSideEffects, (, operand, ), )]
[;, if, (, !, mayHaveSideEffects, (, operand, ), ), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;]
[., getFirstChild, (, ), ;, if, (, !, mayHaveSideEffects, (, operand, ), ), {, n, ., removeFirstChild, (, ), ;]
[), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, case, Token, ., NAME, :]
[), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, case, Token, ., NAME, :]
[), ), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, case, Token, ., NAME]
[;, reportCodeChange, (, ), ;, }, break, ;, case, Token, ., NAME, :, String, name, =, result, ., getString, (]
[., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, case, Token, ., NAME, :, String, name, =]
[;, }, break, ;, case, Token, ., NAME, :, String, name, =, result, ., getString, (, ), ;, if, (]
[:, String, name, =, result, ., getString, (, ), ;, if, (, name, ., equals, (, "undefined", ), ), {]
[., NAME, :, String, name, =, result, ., getString, (, ), ;, if, (, name, ., equals, (, "undefined", )]
[;, if, (, name, ., equals, (, "undefined", ), ), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, )]
[., getString, (, ), ;, if, (, name, ., equals, (, "undefined", ), ), {, n, ., removeFirstChild, (, )]
[), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, }, }, return, n, ;]
[., equals, (, "undefined", ), ), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;]
[), ), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, }, }, return, n]
[;, reportCodeChange, (, ), ;, }, break, ;, }, }, return, n, ;, }, private, Node, tryReplaceExitWithBreak, (, Node, n]
[., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, }, }, return, n, ;, }, private, Node]
[;, }, break, ;, }, }, return, n, ;, }, private, Node, tryReplaceExitWithBreak, (, Node, n, ), {, Node, result]
[;, }, private, Node, tryReplaceExitWithBreak, (, Node, n, ), {, Node, result, =, n, ., getFirstChild, (, ), ;, Node]
[;, Node, breakTarget, =, n, ;, for, (, ;, !, ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, ), ;, breakTarget]
[., getFirstChild, (, ), ;, Node, breakTarget, =, n, ;, for, (, ;, !, ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,]
[;, for, (, ;, !, ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, ), ;, breakTarget, =, breakTarget, ., getParent, (]
[;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (, breakTarget, ., isFunction, (, ), ||, breakTarget, .]
[;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (, breakTarget, ., isFunction, (, ), ||, breakTarget, .]
[., isBreakTarget, (, breakTarget, ,, null, ), ;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (, breakTarget]
[,, null, ), ;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (, breakTarget, ., isFunction, (, )]
[), ;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (, breakTarget, ., isFunction, (, ), ||, breakTarget]
[=, breakTarget, ., getParent, (, ), ), {, if, (, breakTarget, ., isFunction, (, ), ||, breakTarget, ., isScript, (]
[), {, if, (, breakTarget, ., isFunction, (, ), ||, breakTarget, ., isScript, (, ), ), {, return, n, ;]
[., getParent, (, ), ), {, if, (, breakTarget, ., isFunction, (, ), ||, breakTarget, ., isScript, (, ), )]
[), {, return, n, ;, }, }, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =]
[||, breakTarget, ., isScript, (, ), ), {, return, n, ;, }, }, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (]
[., isFunction, (, ), ||, breakTarget, ., isScript, (, ), ), {, return, n, ;, }, }, Node, follow, =]
[), {, return, n, ;, }, }, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =]
[., isScript, (, ), ), {, return, n, ;, }, }, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, breakTarget, )]
[;, }, }, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =]
[;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {]
[., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (]
[), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, )]
[;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (]
[=, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (, result, )]
[;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (, result, ), ), {, return, n, ;]
[), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (, result, ), ), {, return, n]
[), {, if, (, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (, follow, ==]
[!=, follow, ), {, if, (, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (]
[), {, if, (, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (, follow, ==]
[), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||]
[), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||]
[), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, )]
[;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||, result, !=, null, )]
[), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {]
[&&, (, n, ., isThrow, (, ), ||, result, !=, null, ), ), {, return, n, ;, }, if, (]
[==, null, &&, (, n, ., isThrow, (, ), ||, result, !=, null, ), ), {, return, n, ;, }]
[&&, (, n, ., isThrow, (, ), ||, result, !=, null, ), ), {, return, n, ;, }, if, (]
[), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {]
[), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), )]
[||, result, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n]
[., isThrow, (, ), ||, result, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null]
[), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), )]
[!=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow]
[), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), )]
[;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, Node, replacement, =, IR]
[), {, Node, replacement, =, IR, ., breakNode, (, ), ;, n, ., getParent, (, ), ., replaceChild, (, n]
[||, areMatchingExits, (, n, ,, follow, ), ), {, Node, replacement, =, IR, ., breakNode, (, ), ;, n, .]
[==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, Node, replacement, =, IR, ., breakNode, (, ), ;]
[||, areMatchingExits, (, n, ,, follow, ), ), {, Node, replacement, =, IR, ., breakNode, (, ), ;, n, .]
[), {, Node, replacement, =, IR, ., breakNode, (, ), ;, n, ., getParent, (, ), ., replaceChild, (, n]
[,, follow, ), ), {, Node, replacement, =, IR, ., breakNode, (, ), ;, n, ., getParent, (, ), .]
[), ), {, Node, replacement, =, IR, ., breakNode, (, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, this, ., reportCodeChange, (, ), ;]
[., breakNode, (, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, this, .]
[;, this, ., reportCodeChange, (, ), ;, return, replacement, ;, }, return, n, ;, }, private, Node, tryRemoveRedundantExit, (, Node]
[., replaceChild, (, n, ,, replacement, ), ;, this, ., reportCodeChange, (, ), ;, return, replacement, ;, }, return, n]
[., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, this, ., reportCodeChange, (, ), ;, return, replacement]
[,, replacement, ), ;, this, ., reportCodeChange, (, ), ;, return, replacement, ;, }, return, n, ;, }, private, Node]
[), ;, this, ., reportCodeChange, (, ), ;, return, replacement, ;, }, return, n, ;, }, private, Node, tryRemoveRedundantExit, (]
[;, return, replacement, ;, }, return, n, ;, }, private, Node, tryRemoveRedundantExit, (, Node, n, ), {, Node, exitExpr, =]
[., reportCodeChange, (, ), ;, return, replacement, ;, }, return, n, ;, }, private, Node, tryRemoveRedundantExit, (, Node, n, )]
[;, }, return, n, ;, }, private, Node, tryRemoveRedundantExit, (, Node, n, ), {, Node, exitExpr, =, n, ., getFirstChild]
[;, }, private, Node, tryRemoveRedundantExit, (, Node, n, ), {, Node, exitExpr, =, n, ., getFirstChild, (, ), ;, Node]
[;, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (]
[., getFirstChild, (, ), ;, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, Node, prefinallyFollows, =, follow, ;]
[;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {]
[., computeFollowNode, (, n, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (]
[), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, )]
[;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (]
[=, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (, exitExpr, )]
[;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (, exitExpr, ), ), {, return, n, ;]
[), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (, exitExpr, ), ), {, return, n]
[), {, if, (, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (, follow, ==]
[!=, follow, ), {, if, (, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (]
[), {, if, (, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (, follow, ==]
[), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||]
[), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||]
[), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, )]
[;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||, exitExpr, !=, null, )]
[), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {]
[&&, (, n, ., isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (]
[==, null, &&, (, n, ., isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return, n, ;, }]
[&&, (, n, ., isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (]
[), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {]
[), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), )]
[||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n]
[., isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null]
[), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), )]
[!=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow]
[), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), )]
[;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, n, ., detachFromParent, (]
[), {, n, ., detachFromParent, (, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, return, n, ;, }]
[||, areMatchingExits, (, n, ,, follow, ), ), {, n, ., detachFromParent, (, ), ;, reportCodeChange, (, ), ;, return]
[==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, n, ., detachFromParent, (, ), ;, reportCodeChange, (, )]
[||, areMatchingExits, (, n, ,, follow, ), ), {, n, ., detachFromParent, (, ), ;, reportCodeChange, (, ), ;, return]
[), {, n, ., detachFromParent, (, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, return, n, ;, }]
[,, follow, ), ), {, n, ., detachFromParent, (, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, return]
[), ), {, n, ., detachFromParent, (, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, return, n, ;]
[;, reportCodeChange, (, ), ;, return, null, ;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {]
[., detachFromParent, (, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, return, n, ;, }, boolean, isPure, (]
[;, return, null, ;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return, n, ==, null]
[;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return, n, ==, null, ||, (, !]
[;, }, boolean, isPure, (, Node, n, ), {, return, n, ==, null, ||, (, !, NodeUtil, ., canBeSideEffected, (]
[;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (, n]
[||, (, !, NodeUtil, ., canBeSideEffected, (, n, ), &&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes]
[==, null, ||, (, !, NodeUtil, ., canBeSideEffected, (, n, ), &&, !, mayHaveSideEffects, (, n, ), ), ;, }]
[||, (, !, NodeUtil, ., canBeSideEffected, (, n, ), &&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes]
[;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (, n]
[), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (]
[&&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=]
[&&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=]
[., canBeSideEffected, (, n, ), &&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, )]
[), &&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n]
[), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (]
[), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (]
[), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode]
[), {, n, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, }, return, n, ;, }, boolean, areMatchingExits, (, Node]
[&&, NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, ), ), {, n, =, ControlFlowAnalysis, ., computeFollowNode]
[!=, null, &&, NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, ), ), {, n, =, ControlFlowAnalysis]
[&&, NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, ), ), {, n, =, ControlFlowAnalysis, ., computeFollowNode]
[), {, n, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, }, return, n, ;, }, boolean, areMatchingExits, (, Node]
[., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, ), ), {, n, =, ControlFlowAnalysis, ., computeFollowNode, (, n]
[,, n, ), ), {, n, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, }, return, n, ;, }, boolean]
[., getParent, (, ), ,, n, ), ), {, n, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, }, return]
[), ), {, n, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, }, return, n, ;, }, boolean, areMatchingExits, (]
[=, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, }, return, n, ;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node]
[;, }, return, n, ;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo]
[., computeFollowNode, (, n, ), ;, }, return, n, ;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, )]
[), ;, }, return, n, ;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return, nodeThis, .]
[;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&]
[;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||, n]
[&&, (, !, isExceptionPossible, (, nodeThis, ), ||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, ), ), ;, }]
[., isEquivalentTo, (, nodeThat, ), &&, (, !, isExceptionPossible, (, nodeThis, ), ||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (]
[), &&, (, !, isExceptionPossible, (, nodeThis, ), ||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, ), ), ;]
[;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||, n]
[), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||]
[||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {]
[||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {]
[), ||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, )]
[), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||]
[==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (, n]
[), ==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (]
[), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||]
[), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isReturn, (, )]
[;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (]
[., checkState, (, n, ., isReturn, (, ), ||, n, ., isThrow, (, ), ), ;, return, n, ., isThrow]
[), ;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue]
[||, n, ., isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (]
[., isReturn, (, ), ||, n, ., isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||, (]
[), ;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue]
[., isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&]
[;, }, Node, getExceptionHandler, (, Node, n, ), {, return, ControlFlowAnalysis, ., getExceptionHandler, (, n, ), ;, }, private, Node]
[||, (, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (, n, ., getLastChild, (, ), ,, true]
[., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (, n, ., getLastChild]
[;, }, Node, getExceptionHandler, (, Node, n, ), {, return, ControlFlowAnalysis, ., getExceptionHandler, (, n, ), ;, }, private, Node]
[), ;, }, Node, getExceptionHandler, (, Node, n, ), {, return, ControlFlowAnalysis, ., getExceptionHandler, (, n, ), ;, }, private]
[&&, !, NodeUtil, ., isLiteralValue, (, n, ., getLastChild, (, ), ,, true, ), ), ;, }, Node, getExceptionHandler, (]
[., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (, n, ., getLastChild, (, ), ,, true, ), ), ;]
[), ;, }, Node, getExceptionHandler, (, Node, n, ), {, return, ControlFlowAnalysis, ., getExceptionHandler, (, n, ), ;, }, private]
[), ;, }, Node, getExceptionHandler, (, Node, n, ), {, return, ControlFlowAnalysis, ., getExceptionHandler, (, n, ), ;, }, private]
[., isLiteralValue, (, n, ., getLastChild, (, ), ,, true, ), ), ;, }, Node, getExceptionHandler, (, Node, n, )]
[,, true, ), ), ;, }, Node, getExceptionHandler, (, Node, n, ), {, return, ControlFlowAnalysis, ., getExceptionHandler, (, n, )]
[., getLastChild, (, ), ,, true, ), ), ;, }, Node, getExceptionHandler, (, Node, n, ), {, return, ControlFlowAnalysis, .]
[), ), ;, }, Node, getExceptionHandler, (, Node, n, ), {, return, ControlFlowAnalysis, ., getExceptionHandler, (, n, ), ;, }]
[;, }, private, Node, tryMinimizeNot, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node]
[., getExceptionHandler, (, n, ), ;, }, private, Node, tryMinimizeNot, (, Node, n, ), {, Node, parent, =, n, .]
[), ;, }, private, Node, tryMinimizeNot, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;]
[;, Node, notChild, =, n, ., getFirstChild, (, ), ;, int, complementOperator, ;, switch, (, notChild, ., getType, (, )]
[., getParent, (, ), ;, Node, notChild, =, n, ., getFirstChild, (, ), ;, int, complementOperator, ;, switch, (, notChild]
[;, int, complementOperator, ;, switch, (, notChild, ., getType, (, ), ), {, case, Token, ., EQ, :, complementOperator, =]
[., getFirstChild, (, ), ;, int, complementOperator, ;, switch, (, notChild, ., getType, (, ), ), {, case, Token, .]
[), {, case, Token, ., EQ, :, complementOperator, =, Token, ., NE, ;, break, ;, case, Token, ., NE, :]
[., getType, (, ), ), {, case, Token, ., EQ, :, complementOperator, =, Token, ., NE, ;, break, ;, case]
[:, complementOperator, =, Token, ., NE, ;, break, ;, case, Token, ., NE, :, complementOperator, =, Token, ., EQ, ;]
[., EQ, :, complementOperator, =, Token, ., NE, ;, break, ;, case, Token, ., NE, :, complementOperator, =, Token, .]
[=, Token, ., NE, ;, break, ;, case, Token, ., NE, :, complementOperator, =, Token, ., EQ, ;, break, ;]
[;, break, ;, case, Token, ., NE, :, complementOperator, =, Token, ., EQ, ;, break, ;, case, Token, ., SHEQ]
[., NE, ;, break, ;, case, Token, ., NE, :, complementOperator, =, Token, ., EQ, ;, break, ;, case, Token]
[:, complementOperator, =, Token, ., EQ, ;, break, ;, case, Token, ., SHEQ, :, complementOperator, =, Token, ., SHNE, ;]
[., NE, :, complementOperator, =, Token, ., EQ, ;, break, ;, case, Token, ., SHEQ, :, complementOperator, =, Token, .]
[=, Token, ., EQ, ;, break, ;, case, Token, ., SHEQ, :, complementOperator, =, Token, ., SHNE, ;, break, ;]
[;, break, ;, case, Token, ., SHEQ, :, complementOperator, =, Token, ., SHNE, ;, break, ;, case, Token, ., SHNE]
[., EQ, ;, break, ;, case, Token, ., SHEQ, :, complementOperator, =, Token, ., SHNE, ;, break, ;, case, Token]
[:, complementOperator, =, Token, ., SHNE, ;, break, ;, case, Token, ., SHNE, :, complementOperator, =, Token, ., SHEQ, ;]
[., SHEQ, :, complementOperator, =, Token, ., SHNE, ;, break, ;, case, Token, ., SHNE, :, complementOperator, =, Token, .]
[=, Token, ., SHNE, ;, break, ;, case, Token, ., SHNE, :, complementOperator, =, Token, ., SHEQ, ;, break, ;]
[;, break, ;, case, Token, ., SHNE, :, complementOperator, =, Token, ., SHEQ, ;, break, ;, default, :, return, n]
[., SHNE, ;, break, ;, case, Token, ., SHNE, :, complementOperator, =, Token, ., SHEQ, ;, break, ;, default, :]
[:, complementOperator, =, Token, ., SHEQ, ;, break, ;, default, :, return, n, ;, }, Node, newOperator, =, n, .]
[., SHNE, :, complementOperator, =, Token, ., SHEQ, ;, break, ;, default, :, return, n, ;, }, Node, newOperator, =]
[=, Token, ., SHEQ, ;, break, ;, default, :, return, n, ;, }, Node, newOperator, =, n, ., removeFirstChild, (]
[;, break, ;, default, :, return, n, ;, }, Node, newOperator, =, n, ., removeFirstChild, (, ), ;, newOperator, .]
[., SHEQ, ;, break, ;, default, :, return, n, ;, }, Node, newOperator, =, n, ., removeFirstChild, (, ), ;]
[;, }, Node, newOperator, =, n, ., removeFirstChild, (, ), ;, newOperator, ., setType, (, complementOperator, ), ;, parent, .]
[;, newOperator, ., setType, (, complementOperator, ), ;, parent, ., replaceChild, (, n, ,, newOperator, ), ;, reportCodeChange, (, )]
[., removeFirstChild, (, ), ;, newOperator, ., setType, (, complementOperator, ), ;, parent, ., replaceChild, (, n, ,, newOperator, )]
[;, parent, ., replaceChild, (, n, ,, newOperator, ), ;, reportCodeChange, (, ), ;, return, newOperator, ;, }, private, Node]
[., setType, (, complementOperator, ), ;, parent, ., replaceChild, (, n, ,, newOperator, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, newOperator, ), ;, reportCodeChange, (, ), ;, return, newOperator, ;, }, private]
[;, reportCodeChange, (, ), ;, return, newOperator, ;, }, private, Node, tryMinimizeIf, (, Node, n, ), {, Node, parent, =]
[., replaceChild, (, n, ,, newOperator, ), ;, reportCodeChange, (, ), ;, return, newOperator, ;, }, private, Node, tryMinimizeIf, (]
[,, newOperator, ), ;, reportCodeChange, (, ), ;, return, newOperator, ;, }, private, Node, tryMinimizeIf, (, Node, n, ), {]
[), ;, reportCodeChange, (, ), ;, return, newOperator, ;, }, private, Node, tryMinimizeIf, (, Node, n, ), {, Node, parent]
[;, return, newOperator, ;, }, private, Node, tryMinimizeIf, (, Node, n, ), {, Node, parent, =, n, ., getParent, (]
[;, }, private, Node, tryMinimizeIf, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node]
[;, Node, cond, =, n, ., getFirstChild, (, ), ;, if, (, NodeUtil, ., isLiteralValue, (, cond, ,, true, )]
[., getParent, (, ), ;, Node, cond, =, n, ., getFirstChild, (, ), ;, if, (, NodeUtil, ., isLiteralValue, (]
[;, if, (, NodeUtil, ., isLiteralValue, (, cond, ,, true, ), ), {, return, n, ;, }, Node, thenBranch, =]
[., getFirstChild, (, ), ;, if, (, NodeUtil, ., isLiteralValue, (, cond, ,, true, ), ), {, return, n, ;]
[), {, return, n, ;, }, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, .]
[., isLiteralValue, (, cond, ,, true, ), ), {, return, n, ;, }, Node, thenBranch, =, cond, ., getNext, (]
[,, true, ), ), {, return, n, ;, }, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch]
[), ), {, return, n, ;, }, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch]
[;, }, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;]
[;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, elseBranch, ==, null, ), {, if, (, isFoldableExpressBlock]
[., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, elseBranch, ==, null, )]
[;, if, (, elseBranch, ==, null, ), {, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =, getBlockExpression]
[., getNext, (, ), ;, if, (, elseBranch, ==, null, ), {, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {]
[), {, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (]
[==, null, ), {, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;]
[), {, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (]
[), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (, !, late, &&, isPropertyAssignmentInExpression, (, expr, ), )]
[), ), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (, !, late, &&, isPropertyAssignmentInExpression, (, expr, )]
[;, if, (, !, late, &&, isPropertyAssignmentInExpression, (, expr, ), ), {, return, n, ;, }, if, (, cond, .]
[), ;, if, (, !, late, &&, isPropertyAssignmentInExpression, (, expr, ), ), {, return, n, ;, }, if, (, cond]
[), {, return, n, ;, }, if, (, cond, ., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (, cond]
[&&, isPropertyAssignmentInExpression, (, expr, ), ), {, return, n, ;, }, if, (, cond, ., isNot, (, ), ), {]
[&&, isPropertyAssignmentInExpression, (, expr, ), ), {, return, n, ;, }, if, (, cond, ., isNot, (, ), ), {]
[), {, return, n, ;, }, if, (, cond, ., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (, cond]
[), ), {, return, n, ;, }, if, (, cond, ., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (]
[;, }, if, (, cond, ., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, ), &&]
[), {, if, (, isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE]
[., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild]
[), {, return, n, ;, }, Node, or, =, IR, ., or, (, cond, ., removeFirstChild, (, ), ,, expr]
[&&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return, n, ;, }, Node, or, =]
[,, OR_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return, n, ;, }]
[), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return, n, ;, }, Node, or]
[), {, return, n, ;, }, Node, or, =, IR, ., or, (, cond, ., removeFirstChild, (, ), ,, expr]
[,, OR_PRECEDENCE, ), ), {, return, n, ;, }, Node, or, =, IR, ., or, (, cond, ., removeFirstChild, (]
[., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return, n, ;, }, Node, or, =, IR, ., or, (]
[), ), {, return, n, ;, }, Node, or, =, IR, ., or, (, cond, ., removeFirstChild, (, ), ,]
[;, }, Node, or, =, IR, ., or, (, cond, ., removeFirstChild, (, ), ,, expr, ., removeFirstChild, (, )]
[;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, ), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;]
[., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, ), ;, parent, ., replaceChild, (]
[., or, (, cond, ., removeFirstChild, (, ), ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, )]
[,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (]
[., removeFirstChild, (, ), ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =]
[), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, ), ;, parent, ., replaceChild]
[., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, )]
[), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, ), ;, parent, ., replaceChild, (, n, ,, newExpr, )]
[;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (]
[., newExpr, (, or, ), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if]
[;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (]
[., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (]
[,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, )]
[), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression]
[;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (]
[;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE]
[), {, return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =, IR, ., and, (]
[&&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }, n, ., removeChild]
[,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }]
[), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }, n, .]
[), {, return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =, IR, ., and, (]
[,, AND_PRECEDENCE, ), ), {, return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =, IR]
[., getFirstChild, (, ), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }, n, ., removeChild, (, cond, ), ;]
[), ), {, return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =, IR, ., and]
[;, }, n, ., removeChild, (, cond, ), ;, Node, and, =, IR, ., and, (, cond, ,, expr, .]
[;, Node, and, =, IR, ., and, (, cond, ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n]
[., removeChild, (, cond, ), ;, Node, and, =, IR, ., and, (, cond, ,, expr, ., removeFirstChild, (, )]
[), ;, Node, and, =, IR, ., and, (, cond, ,, expr, ., removeFirstChild, (, ), ), ., srcref, (]
[;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, ), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;]
[., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, ), ;, parent, ., replaceChild, (]
[., and, (, cond, ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =]
[,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (]
[), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, ), ;, parent, ., replaceChild]
[., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, )]
[), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, ), ;, parent, ., replaceChild, (, n, ,, newExpr, )]
[;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {]
[., newExpr, (, and, ), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else]
[;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (, NodeUtil, ., isStatementBlock, (, thenBranch, ), &&]
[., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (]
[,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (, NodeUtil, ., isStatementBlock, (]
[), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (, NodeUtil, ., isStatementBlock, (, thenBranch, )]
[;, return, newExpr, ;, }, else, {, if, (, NodeUtil, ., isStatementBlock, (, thenBranch, ), &&, thenBranch, ., hasOneChild, (]
[;, }, else, {, if, (, NodeUtil, ., isStatementBlock, (, thenBranch, ), &&, thenBranch, ., hasOneChild, (, ), ), {]
[), {, Node, innerIf, =, thenBranch, ., getFirstChild, (, ), ;, if, (, innerIf, ., isIf, (, ), ), {]
[&&, thenBranch, ., hasOneChild, (, ), ), {, Node, innerIf, =, thenBranch, ., getFirstChild, (, ), ;, if, (, innerIf]
[., isStatementBlock, (, thenBranch, ), &&, thenBranch, ., hasOneChild, (, ), ), {, Node, innerIf, =, thenBranch, ., getFirstChild, (]
[), &&, thenBranch, ., hasOneChild, (, ), ), {, Node, innerIf, =, thenBranch, ., getFirstChild, (, ), ;, if, (]
[), {, Node, innerIf, =, thenBranch, ., getFirstChild, (, ), ;, if, (, innerIf, ., isIf, (, ), ), {]
[., hasOneChild, (, ), ), {, Node, innerIf, =, thenBranch, ., getFirstChild, (, ), ;, if, (, innerIf, ., isIf]
[;, if, (, innerIf, ., isIf, (, ), ), {, Node, innerCond, =, innerIf, ., getFirstChild, (, ), ;, Node]
[., getFirstChild, (, ), ;, if, (, innerIf, ., isIf, (, ), ), {, Node, innerCond, =, innerIf, ., getFirstChild]
[), {, Node, innerCond, =, innerIf, ., getFirstChild, (, ), ;, Node, innerThenBranch, =, innerCond, ., getNext, (, ), ;]
[., isIf, (, ), ), {, Node, innerCond, =, innerIf, ., getFirstChild, (, ), ;, Node, innerThenBranch, =, innerCond, .]
[;, Node, innerThenBranch, =, innerCond, ., getNext, (, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if]
[., getFirstChild, (, ), ;, Node, innerThenBranch, =, innerCond, ., getNext, (, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext]
[;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&, !, (, isLowerPrecedenceInExpression, (]
[., getNext, (, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&]
[;, if, (, innerElseBranch, ==, null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,]
[., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&]
[), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (, cond, ,, innerCond, .]
[&&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n]
[==, null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), )]
[&&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n]
[), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (, cond, ,, innerCond, .]
[), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (, cond, ,, innerCond, .]
[), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (, cond, ,, innerCond]
[&&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (]
[,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;, n]
[), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack]
[), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (, cond, ,, innerCond]
[,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (]
[), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (, cond, ,]
[;, n, ., addChildToBack, (, IR, ., and, (, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (]
[., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (, cond, ,, innerCond, ., detachFromParent, (, )]
[;, n, ., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }]
[., addChildToBack, (, IR, ., and, (, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (, cond, )]
[), ;, n, ., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, n, ;]
[., srcref, (, cond, ), ), ;, n, ., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (, ), ), ;, reportCodeChange, (]
[., and, (, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ), ;, n, .]
[,, innerCond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ), ;, n, ., addChildrenToBack, (, innerThenBranch, .]
[), ., srcref, (, cond, ), ), ;, n, ., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (, ), ), ;, reportCodeChange]
[., detachFromParent, (, ), ), ., srcref, (, cond, ), ), ;, n, ., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (]
[), ), ;, n, ., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, n]
[;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, }, return, n, ;, }, tryRemoveRepeatedStatements, (, n, )]
[., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }]
[), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, }, return, n, ;, }, tryRemoveRepeatedStatements, (, n]
[., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, }, return, n, ;]
[;, return, n, ;, }, }, }, }, return, n, ;, }, tryRemoveRepeatedStatements, (, n, ), ;, if, (, cond]
[;, }, }, }, }, return, n, ;, }, tryRemoveRepeatedStatements, (, n, ), ;, if, (, cond, ., isNot, (]
[;, }, tryRemoveRepeatedStatements, (, n, ), ;, if, (, cond, ., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, )]
[;, if, (, cond, ., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, ), ), {, n, ., replaceChild, (]
[), ;, if, (, cond, ., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, ), ), {, n, ., replaceChild]
[), {, n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch]
[&&, !, consumesDanglingElse, (, elseBranch, ), ), {, n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), )]
[., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, ), ), {, n, ., replaceChild, (, cond, ,, cond, .]
[), {, n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch]
[), {, n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch]
[), ), {, n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (]
[;, n, ., removeChild, (, thenBranch, ), ;, n, ., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return]
[., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch, ), ;, n]
[,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch, ), ;, n, ., addChildToBack, (, thenBranch]
[), ;, n, ., removeChild, (, thenBranch, ), ;, n, ., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;]
[., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch, ), ;, n, ., addChildToBack, (, thenBranch, ), ;]
[;, n, ., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, if, (, isReturnExpressBlock, (]
[., removeChild, (, thenBranch, ), ;, n, ., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return, n, ;]
[), ;, n, ., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, if, (, isReturnExpressBlock]
[;, reportCodeChange, (, ), ;, return, n, ;, }, if, (, isReturnExpressBlock, (, thenBranch, ), &&, isReturnExpressBlock, (, elseBranch, )]
[., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, if, (, isReturnExpressBlock, (, thenBranch, )]
[), ;, reportCodeChange, (, ), ;, return, n, ;, }, if, (, isReturnExpressBlock, (, thenBranch, ), &&, isReturnExpressBlock, (, elseBranch]
[;, return, n, ;, }, if, (, isReturnExpressBlock, (, thenBranch, ), &&, isReturnExpressBlock, (, elseBranch, ), ), {, Node, thenExpr]
[;, }, if, (, isReturnExpressBlock, (, thenBranch, ), &&, isReturnExpressBlock, (, elseBranch, ), ), {, Node, thenExpr, =, getBlockReturnExpression, (]
[), {, Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n, .]
[&&, isReturnExpressBlock, (, elseBranch, ), ), {, Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (]
[), &&, isReturnExpressBlock, (, elseBranch, ), ), {, Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression]
[), {, Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n, .]
[), ), {, Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n]
[;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n, ., removeChild, (, cond, ), ;, thenExpr, ., detachFromParent, (]
[), ;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n, ., removeChild, (, cond, ), ;, thenExpr, ., detachFromParent]
[;, n, ., removeChild, (, cond, ), ;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;]
[), ;, n, ., removeChild, (, cond, ), ;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, )]
[;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (]
[., removeChild, (, cond, ), ;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode]
[), ;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode]
[;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,]
[., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, .]
[;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref]
[., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,]
[;, parent, ., replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange, (, ), ;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock]
[., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ), ;]
[), ;, parent, ., replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange, (, ), ;, return, returnNode, ;, }, boolean]
[., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange, (, ), ;]
[., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (]
[,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, returnNode, )]
[,, elseExpr, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange]
[), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange, (, )]
[), ), ;, parent, ., replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange, (, ), ;, return, returnNode, ;, }]
[;, reportCodeChange, (, ), ;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;, boolean, elseBranchIsExpressionBlock, =]
[., replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange, (, ), ;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock]
[,, returnNode, ), ;, reportCodeChange, (, ), ;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;]
[), ;, reportCodeChange, (, ), ;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;, boolean, elseBranchIsExpressionBlock]
[;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, )]
[;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, ), ;, if, (]
[;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, ), ;, if, (, thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =, getBlockExpression]
[), ;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, ), ;, if, (, thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =]
[;, if, (, thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;]
[), ;, if, (, thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, )]
[), {, Node, thenOp, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, elseOp, =, getBlockExpression, (, elseBranch]
[&&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, elseOp, =, getBlockExpression]
[), {, Node, thenOp, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, elseOp, =, getBlockExpression, (, elseBranch]
[;, Node, elseOp, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, if, (, thenOp, ., getType, (, )]
[., getFirstChild, (, ), ;, Node, elseOp, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, if, (, thenOp]
[), ., getFirstChild, (, ), ;, Node, elseOp, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, if, (]
[;, if, (, thenOp, ., getType, (, ), ==, elseOp, ., getType, (, ), ), {, if, (, NodeUtil, .]
[., getFirstChild, (, ), ;, if, (, thenOp, ., getType, (, ), ==, elseOp, ., getType, (, ), ), {]
[), ., getFirstChild, (, ), ;, if, (, thenOp, ., getType, (, ), ==, elseOp, ., getType, (, ), )]
[), {, if, (, NodeUtil, ., isAssignmentOp, (, thenOp, ), ), {, Node, lhs, =, thenOp, ., getFirstChild, (, )]
[==, elseOp, ., getType, (, ), ), {, if, (, NodeUtil, ., isAssignmentOp, (, thenOp, ), ), {, Node, lhs]
[., getType, (, ), ==, elseOp, ., getType, (, ), ), {, if, (, NodeUtil, ., isAssignmentOp, (, thenOp, )]
[), {, if, (, NodeUtil, ., isAssignmentOp, (, thenOp, ), ), {, Node, lhs, =, thenOp, ., getFirstChild, (, )]
[., getType, (, ), ), {, if, (, NodeUtil, ., isAssignmentOp, (, thenOp, ), ), {, Node, lhs, =, thenOp]
[), {, Node, lhs, =, thenOp, ., getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild]
[., isAssignmentOp, (, thenOp, ), ), {, Node, lhs, =, thenOp, ., getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (]
[), ), {, Node, lhs, =, thenOp, ., getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (, lhs, ,, elseOp, .]
[;, if, (, areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild, (, ), ), &&, !, mayEffectMutableState, (, lhs, ), )]
[., getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild, (, ), ), &&, !, mayEffectMutableState]
[), {, n, ., removeChild, (, cond, ), ;, Node, assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr]
[&&, !, mayEffectMutableState, (, lhs, ), ), {, n, ., removeChild, (, cond, ), ;, Node, assignName, =, thenOp, .]
[,, elseOp, ., getFirstChild, (, ), ), &&, !, mayEffectMutableState, (, lhs, ), ), {, n, ., removeChild, (, cond]
[), &&, !, mayEffectMutableState, (, lhs, ), ), {, n, ., removeChild, (, cond, ), ;, Node, assignName, =, thenOp]
[., getFirstChild, (, ), ), &&, !, mayEffectMutableState, (, lhs, ), ), {, n, ., removeChild, (, cond, ), ;]
[), {, n, ., removeChild, (, cond, ), ;, Node, assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr]
[), {, n, ., removeChild, (, cond, ), ;, Node, assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr]
[), ), {, n, ., removeChild, (, cond, ), ;, Node, assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node]
[;, Node, assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr, =, thenOp, ., removeFirstChild, (, ), ;, Node]
[., removeChild, (, cond, ), ;, Node, assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr, =, thenOp, .]
[), ;, Node, assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr, =, thenOp, ., removeFirstChild, (, ), ;]
[;, Node, thenExpr, =, thenOp, ., removeFirstChild, (, ), ;, Node, elseExpr, =, elseOp, ., getLastChild, (, ), ;, elseOp]
[., removeFirstChild, (, ), ;, Node, thenExpr, =, thenOp, ., removeFirstChild, (, ), ;, Node, elseExpr, =, elseOp, ., getLastChild]
[;, Node, elseExpr, =, elseOp, ., getLastChild, (, ), ;, elseOp, ., removeChild, (, elseExpr, ), ;, Node, hookNode, =]
[., removeFirstChild, (, ), ;, Node, elseExpr, =, elseOp, ., getLastChild, (, ), ;, elseOp, ., removeChild, (, elseExpr, )]
[;, elseOp, ., removeChild, (, elseExpr, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr]
[., getLastChild, (, ), ;, elseOp, ., removeChild, (, elseExpr, ), ;, Node, hookNode, =, IR, ., hook, (, cond]
[;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;]
[., removeChild, (, elseExpr, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), .]
[), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, )]
[;, Node, assign, =, new, Node, (, thenOp, ., getType, (, ), ,, assignName, ,, hookNode, ), ., srcref, (]
[., srcref, (, n, ), ;, Node, assign, =, new, Node, (, thenOp, ., getType, (, ), ,, assignName, ,]
[., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, Node, assign, =, new, Node]
[,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, Node, assign, =, new, Node, (, thenOp, ., getType]
[,, elseExpr, ), ., srcref, (, n, ), ;, Node, assign, =, new, Node, (, thenOp, ., getType, (, )]
[), ., srcref, (, n, ), ;, Node, assign, =, new, Node, (, thenOp, ., getType, (, ), ,, assignName]
[), ;, Node, assign, =, new, Node, (, thenOp, ., getType, (, ), ,, assignName, ,, hookNode, ), ., srcref]
[;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;]
[., srcref, (, thenOp, ), ;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;, parent, ., replaceChild, (]
[,, assignName, ,, hookNode, ), ., srcref, (, thenOp, ), ;, Node, expr, =, NodeUtil, ., newExpr, (, assign, )]
[., getType, (, ), ,, assignName, ,, hookNode, ), ., srcref, (, thenOp, ), ;, Node, expr, =, NodeUtil, .]
[,, hookNode, ), ., srcref, (, thenOp, ), ;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;, parent]
[), ., srcref, (, thenOp, ), ;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;, parent, ., replaceChild]
[), ;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;, parent, ., replaceChild, (, n, ,, expr, )]
[;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }]
[., newExpr, (, assign, ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }]
[;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }, n, ., removeChild, (, cond, ), ;, thenOp, .]
[., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }, n, .]
[,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }, n, ., removeChild, (, cond, )]
[), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }, n, ., removeChild, (, cond, ), ;, thenOp]
[;, return, expr, ;, }, }, }, n, ., removeChild, (, cond, ), ;, thenOp, ., detachFromParent, (, ), ;]
[;, }, }, }, n, ., removeChild, (, cond, ), ;, thenOp, ., detachFromParent, (, ), ;, elseOp, ., detachFromParent]
[;, thenOp, ., detachFromParent, (, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (]
[., removeChild, (, cond, ), ;, thenOp, ., detachFromParent, (, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr]
[), ;, thenOp, ., detachFromParent, (, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult]
[;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (, IR, ., hook, (, cond, ,]
[., detachFromParent, (, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (, IR, .]
[;, Node, expr, =, IR, ., exprResult, (, IR, ., hook, (, cond, ,, thenOp, ,, elseOp, ), ., srcref]
[., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (, IR, ., hook, (, cond, ,, thenOp, ,]
[;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, boolean, thenBranchIsVar]
[., exprResult, (, IR, ., hook, (, cond, ,, thenOp, ,, elseOp, ), ., srcref, (, n, ), ), ;]
[), ;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, boolean]
[., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;]
[., hook, (, cond, ,, thenOp, ,, elseOp, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (]
[,, thenOp, ,, elseOp, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, expr, )]
[,, elseOp, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange]
[), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, )]
[), ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }]
[;, reportCodeChange, (, ), ;, return, expr, ;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =]
[., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, boolean, thenBranchIsVar, =, isVarBlock]
[,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;]
[), ;, reportCodeChange, (, ), ;, return, expr, ;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar]
[;, return, expr, ;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, )]
[;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (]
[;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (, thenBranchIsVar, &&, elseBranchIsExpressionBlock, &&, getBlockExpression, (, elseBranch, ), .]
[), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (, thenBranchIsVar, &&, elseBranchIsExpressionBlock, &&, getBlockExpression, (, elseBranch, )]
[;, if, (, thenBranchIsVar, &&, elseBranchIsExpressionBlock, &&, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), )]
[), ;, if, (, thenBranchIsVar, &&, elseBranchIsExpressionBlock, &&, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ., isAssign, (, )]
[), {, Node, var, =, getBlockVar, (, thenBranch, ), ;, Node, elseAssign, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (]
[&&, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (]
[&&, elseBranchIsExpressionBlock, &&, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =]
[&&, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (]
[), {, Node, var, =, getBlockVar, (, thenBranch, ), ;, Node, elseAssign, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (]
[., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, thenBranch, ), ;, Node, elseAssign, =, getBlockExpression, (, elseBranch]
[., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, thenBranch, ), ;, Node, elseAssign]
[), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, thenBranch, ), ;, Node]
[;, Node, elseAssign, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, Node, name1, =, var, ., getFirstChild, (]
[), ;, Node, elseAssign, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, Node, name1, =, var, ., getFirstChild]
[;, Node, name1, =, var, ., getFirstChild, (, ), ;, Node, maybeName2, =, elseAssign, ., getFirstChild, (, ), ;, if]
[., getFirstChild, (, ), ;, Node, name1, =, var, ., getFirstChild, (, ), ;, Node, maybeName2, =, elseAssign, ., getFirstChild]
[), ., getFirstChild, (, ), ;, Node, name1, =, var, ., getFirstChild, (, ), ;, Node, maybeName2, =, elseAssign, .]
[;, Node, maybeName2, =, elseAssign, ., getFirstChild, (, ), ;, if, (, name1, ., hasChildren, (, ), &&, maybeName2, .]
[., getFirstChild, (, ), ;, Node, maybeName2, =, elseAssign, ., getFirstChild, (, ), ;, if, (, name1, ., hasChildren, (]
[;, if, (, name1, ., hasChildren, (, ), &&, maybeName2, ., isName, (, ), &&, name1, ., getString, (, )]
[., getFirstChild, (, ), ;, if, (, name1, ., hasChildren, (, ), &&, maybeName2, ., isName, (, ), &&, name1]
[), {, Node, thenExpr, =, name1, ., removeChildren, (, ), ;, Node, elseExpr, =, elseAssign, ., getLastChild, (, ), .]
[&&, name1, ., getString, (, ), ., equals, (, maybeName2, ., getString, (, ), ), ), {, Node, thenExpr, =]
[&&, maybeName2, ., isName, (, ), &&, name1, ., getString, (, ), ., equals, (, maybeName2, ., getString, (, )]
[., hasChildren, (, ), &&, maybeName2, ., isName, (, ), &&, name1, ., getString, (, ), ., equals, (, maybeName2]
[&&, name1, ., getString, (, ), ., equals, (, maybeName2, ., getString, (, ), ), ), {, Node, thenExpr, =]
[., isName, (, ), &&, name1, ., getString, (, ), ., equals, (, maybeName2, ., getString, (, ), ), )]
[), {, Node, thenExpr, =, name1, ., removeChildren, (, ), ;, Node, elseExpr, =, elseAssign, ., getLastChild, (, ), .]
[., equals, (, maybeName2, ., getString, (, ), ), ), {, Node, thenExpr, =, name1, ., removeChildren, (, ), ;]
[., getString, (, ), ., equals, (, maybeName2, ., getString, (, ), ), ), {, Node, thenExpr, =, name1, .]
[), ), {, Node, thenExpr, =, name1, ., removeChildren, (, ), ;, Node, elseExpr, =, elseAssign, ., getLastChild, (, )]
[., getString, (, ), ), ), {, Node, thenExpr, =, name1, ., removeChildren, (, ), ;, Node, elseExpr, =, elseAssign]
[;, Node, elseExpr, =, elseAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, cond, ., detachFromParent, (, ), ;]
[., removeChildren, (, ), ;, Node, elseExpr, =, elseAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, cond, .]
[;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, )]
[., detachFromParent, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,]
[., getLastChild, (, ), ., detachFromParent, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, .]
[;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;]
[., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref]
[;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,]
[., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;, parent]
[., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, )]
[,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack]
[,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode]
[), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;]
[), ;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n]
[;, name1, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, )]
[., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, )]
[;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else]
[., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }]
[;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (, elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&, getBlockExpression, (, thenBranch]
[., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (]
[,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (, elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&]
[), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (, elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&, getBlockExpression, (]
[;, return, var, ;, }, }, else, if, (, elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&, getBlockExpression, (, thenBranch, ), ., getFirstChild, (]
[;, }, }, else, if, (, elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ., isAssign]
[), {, Node, var, =, getBlockVar, (, elseBranch, ), ;, Node, thenAssign, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (]
[&&, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (]
[&&, thenBranchIsExpressionBlock, &&, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =]
[&&, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (]
[), {, Node, var, =, getBlockVar, (, elseBranch, ), ;, Node, thenAssign, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (]
[., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, elseBranch, ), ;, Node, thenAssign, =, getBlockExpression, (, thenBranch]
[., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, elseBranch, ), ;, Node, thenAssign]
[), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, elseBranch, ), ;, Node]
[;, Node, thenAssign, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, maybeName1, =, thenAssign, ., getFirstChild, (]
[), ;, Node, thenAssign, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, maybeName1, =, thenAssign, ., getFirstChild]
[;, Node, maybeName1, =, thenAssign, ., getFirstChild, (, ), ;, Node, name2, =, var, ., getFirstChild, (, ), ;, if]
[., getFirstChild, (, ), ;, Node, maybeName1, =, thenAssign, ., getFirstChild, (, ), ;, Node, name2, =, var, ., getFirstChild]
[), ., getFirstChild, (, ), ;, Node, maybeName1, =, thenAssign, ., getFirstChild, (, ), ;, Node, name2, =, var, .]
[;, Node, name2, =, var, ., getFirstChild, (, ), ;, if, (, name2, ., hasChildren, (, ), &&, maybeName1, .]
[., getFirstChild, (, ), ;, Node, name2, =, var, ., getFirstChild, (, ), ;, if, (, name2, ., hasChildren, (]
[;, if, (, name2, ., hasChildren, (, ), &&, maybeName1, ., isName, (, ), &&, maybeName1, ., getString, (, )]
[., getFirstChild, (, ), ;, if, (, name2, ., hasChildren, (, ), &&, maybeName1, ., isName, (, ), &&, maybeName1]
[), {, Node, thenExpr, =, thenAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, Node, elseExpr, =, name2, .]
[&&, maybeName1, ., getString, (, ), ., equals, (, name2, ., getString, (, ), ), ), {, Node, thenExpr, =]
[&&, maybeName1, ., isName, (, ), &&, maybeName1, ., getString, (, ), ., equals, (, name2, ., getString, (, )]
[., hasChildren, (, ), &&, maybeName1, ., isName, (, ), &&, maybeName1, ., getString, (, ), ., equals, (, name2]
[&&, maybeName1, ., getString, (, ), ., equals, (, name2, ., getString, (, ), ), ), {, Node, thenExpr, =]
[., isName, (, ), &&, maybeName1, ., getString, (, ), ., equals, (, name2, ., getString, (, ), ), )]
[), {, Node, thenExpr, =, thenAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, Node, elseExpr, =, name2, .]
[., equals, (, name2, ., getString, (, ), ), ), {, Node, thenExpr, =, thenAssign, ., getLastChild, (, ), .]
[., getString, (, ), ., equals, (, name2, ., getString, (, ), ), ), {, Node, thenExpr, =, thenAssign, .]
[), ), {, Node, thenExpr, =, thenAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, Node, elseExpr, =, name2]
[., getString, (, ), ), ), {, Node, thenExpr, =, thenAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;]
[;, Node, elseExpr, =, name2, ., removeChildren, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR]
[., detachFromParent, (, ), ;, Node, elseExpr, =, name2, ., removeChildren, (, ), ;, cond, ., detachFromParent, (, ), ;]
[., getLastChild, (, ), ., detachFromParent, (, ), ;, Node, elseExpr, =, name2, ., removeChildren, (, ), ;, cond, .]
[;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, )]
[., removeChildren, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,]
[;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;]
[., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref]
[;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,]
[., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;, parent]
[., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, )]
[,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack]
[,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode]
[), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;]
[), ;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n]
[;, name2, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, )]
[., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, )]
[;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, return]
[., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }]
[;, reportCodeChange, (, ), ;, return, var, ;, }, }, return, n, ;, }, private, void, tryRemoveRepeatedStatements, (, Node, n]
[., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, return, n, ;]
[,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, return, n, ;, }, private, void, tryRemoveRepeatedStatements]
[), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, return, n, ;, }, private, void, tryRemoveRepeatedStatements, (, Node]
[;, return, var, ;, }, }, return, n, ;, }, private, void, tryRemoveRepeatedStatements, (, Node, n, ), {, Preconditions, .]
[;, }, }, return, n, ;, }, private, void, tryRemoveRepeatedStatements, (, Node, n, ), {, Preconditions, ., checkState, (, n]
[;, }, private, void, tryRemoveRepeatedStatements, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isIf, (, ), )]
[;, Node, parent, =, n, ., getParent, (, ), ;, if, (, !, NodeUtil, ., isStatementBlock, (, parent, ), )]
[., checkState, (, n, ., isIf, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if]
[), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, !, NodeUtil, ., isStatementBlock, (, parent, )]
[., isIf, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, !, NodeUtil, .]
[;, if, (, !, NodeUtil, ., isStatementBlock, (, parent, ), ), {, return, ;, }, Node, cond, =, n, .]
[., getParent, (, ), ;, if, (, !, NodeUtil, ., isStatementBlock, (, parent, ), ), {, return, ;, }, Node]
[), {, return, ;, }, Node, cond, =, n, ., getFirstChild, (, ), ;, Node, trueBranch, =, cond, ., getNext]
[), {, return, ;, }, Node, cond, =, n, ., getFirstChild, (, ), ;, Node, trueBranch, =, cond, ., getNext]
[., isStatementBlock, (, parent, ), ), {, return, ;, }, Node, cond, =, n, ., getFirstChild, (, ), ;, Node]
[), ), {, return, ;, }, Node, cond, =, n, ., getFirstChild, (, ), ;, Node, trueBranch, =, cond, .]
[;, Node, trueBranch, =, cond, ., getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Preconditions]
[., getFirstChild, (, ), ;, Node, trueBranch, =, cond, ., getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext]
[;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Preconditions, ., checkNotNull, (, trueBranch, ), ;, Preconditions, ., checkNotNull]
[., getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Preconditions, ., checkNotNull, (, trueBranch, )]
[;, Preconditions, ., checkNotNull, (, trueBranch, ), ;, Preconditions, ., checkNotNull, (, falseBranch, ), ;, while, (, true, ), {]
[., getNext, (, ), ;, Preconditions, ., checkNotNull, (, trueBranch, ), ;, Preconditions, ., checkNotNull, (, falseBranch, ), ;, while]
[;, Preconditions, ., checkNotNull, (, falseBranch, ), ;, while, (, true, ), {, Node, lastTrue, =, trueBranch, ., getLastChild, (]
[., checkNotNull, (, trueBranch, ), ;, Preconditions, ., checkNotNull, (, falseBranch, ), ;, while, (, true, ), {, Node, lastTrue]
[), ;, Preconditions, ., checkNotNull, (, falseBranch, ), ;, while, (, true, ), {, Node, lastTrue, =, trueBranch, ., getLastChild]
[;, while, (, true, ), {, Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, .]
[., checkNotNull, (, falseBranch, ), ;, while, (, true, ), {, Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;]
[), ;, while, (, true, ), {, Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch]
[), {, Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;]
[;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||, lastFalse, ==, null, ||]
[., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||]
[;, if, (, lastTrue, ==, null, ||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {]
[., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,]
[), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;, parent, ., addChildAfter]
[||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse]
[||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent]
[==, null, ||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }, lastTrue]
[||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent]
[||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse]
[==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent, (, )]
[||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse]
[), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;, parent, ., addChildAfter]
[), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;, parent, ., addChildAfter]
[,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;]
[), ), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;, parent, .]
[;, lastFalse, ., detachFromParent, (, ), ;, parent, ., addChildAfter, (, lastTrue, ,, n, ), ;, reportCodeChange, (, ), ;]
[., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;, parent, ., addChildAfter, (, lastTrue, ,, n, ), ;]
[;, parent, ., addChildAfter, (, lastTrue, ,, n, ), ;, reportCodeChange, (, ), ;, }, }, private, boolean, isFoldableExpressBlock, (]
[., detachFromParent, (, ), ;, parent, ., addChildAfter, (, lastTrue, ,, n, ), ;, reportCodeChange, (, ), ;, }, }]
[;, reportCodeChange, (, ), ;, }, }, private, boolean, isFoldableExpressBlock, (, Node, n, ), {, if, (, n, ., isBlock]
[., addChildAfter, (, lastTrue, ,, n, ), ;, reportCodeChange, (, ), ;, }, }, private, boolean, isFoldableExpressBlock, (, Node, n]
[,, n, ), ;, reportCodeChange, (, ), ;, }, }, private, boolean, isFoldableExpressBlock, (, Node, n, ), {, if, (]
[), ;, reportCodeChange, (, ), ;, }, }, private, boolean, isFoldableExpressBlock, (, Node, n, ), {, if, (, n, .]
[;, }, }, private, boolean, isFoldableExpressBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {]
[), {, if, (, n, ., hasOneChild, (, ), ), {, Node, maybeExpr, =, n, ., getFirstChild, (, ), ;]
[., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, maybeExpr, =, n, .]
[), {, Node, maybeExpr, =, n, ., getFirstChild, (, ), ;, if, (, maybeExpr, ., isExprResult, (, ), ), {]
[., hasOneChild, (, ), ), {, Node, maybeExpr, =, n, ., getFirstChild, (, ), ;, if, (, maybeExpr, ., isExprResult]
[;, if, (, maybeExpr, ., isExprResult, (, ), ), {, if, (, maybeExpr, ., getFirstChild, (, ), ., isCall, (]
[., getFirstChild, (, ), ;, if, (, maybeExpr, ., isExprResult, (, ), ), {, if, (, maybeExpr, ., getFirstChild, (]
[), {, if, (, maybeExpr, ., getFirstChild, (, ), ., isCall, (, ), ), {, Node, calledFn, =, maybeExpr, .]
[., isExprResult, (, ), ), {, if, (, maybeExpr, ., getFirstChild, (, ), ., isCall, (, ), ), {, Node]
[), {, Node, calledFn, =, maybeExpr, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, if, (, calledFn, ., isGetElem]
[., isCall, (, ), ), {, Node, calledFn, =, maybeExpr, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, if]
[., getFirstChild, (, ), ., isCall, (, ), ), {, Node, calledFn, =, maybeExpr, ., getFirstChild, (, ), ., getFirstChild]
[;, if, (, calledFn, ., isGetElem, (, ), ), {, return, false, ;, }, else, if, (, calledFn, ., isGetProp]
[., getFirstChild, (, ), ;, if, (, calledFn, ., isGetElem, (, ), ), {, return, false, ;, }, else, if]
[., getFirstChild, (, ), ., getFirstChild, (, ), ;, if, (, calledFn, ., isGetElem, (, ), ), {, return, false]
[), {, return, false, ;, }, else, if, (, calledFn, ., isGetProp, (, ), &&, calledFn, ., getLastChild, (, )]
[., isGetElem, (, ), ), {, return, false, ;, }, else, if, (, calledFn, ., isGetProp, (, ), &&, calledFn]
[;, }, else, if, (, calledFn, ., isGetProp, (, ), &&, calledFn, ., getLastChild, (, ), ., getString, (, )]
[), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }, }, return, false, ;, }]
[&&, calledFn, ., getLastChild, (, ), ., getString, (, ), ., startsWith, (, "on", ), ), {, return, false, ;]
[., isGetProp, (, ), &&, calledFn, ., getLastChild, (, ), ., getString, (, ), ., startsWith, (, "on", ), )]
[), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }, }, return, false, ;, }]
[., startsWith, (, "on", ), ), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }]
[., getString, (, ), ., startsWith, (, "on", ), ), {, return, false, ;, }, }, return, true, ;, }]
[., getLastChild, (, ), ., getString, (, ), ., startsWith, (, "on", ), ), {, return, false, ;, }, }]
[), ), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }, }, return, false, ;]
[;, }, }, return, true, ;, }, return, false, ;, }, }, return, false, ;, }, private, Node, getBlockExpression, (]
[;, }, return, false, ;, }, }, return, false, ;, }, private, Node, getBlockExpression, (, Node, n, ), {, Preconditions]
[;, }, }, return, false, ;, }, private, Node, getBlockExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isFoldableExpressBlock]
[;, }, private, Node, getBlockExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isFoldableExpressBlock, (, n, ), ), ;]
[;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, isReturnBlock, (, Node, n, ), {, if, (, n]
[., checkState, (, isFoldableExpressBlock, (, n, ), ), ;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, isReturnBlock]
[), ;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, isReturnBlock, (, Node, n, ), {, if, (]
[), ), ;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, isReturnBlock, (, Node, n, ), {, if]
[;, }, private, boolean, isReturnBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if]
[., getFirstChild, (, ), ;, }, private, boolean, isReturnBlock, (, Node, n, ), {, if, (, n, ., isBlock, (]
[), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;]
[., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, .]
[), {, Node, first, =, n, ., getFirstChild, (, ), ;, return, first, ., isReturn, (, ), ;, }, }]
[., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;, return, first, ., isReturn, (]
[;, return, first, ., isReturn, (, ), ;, }, }, return, false, ;, }, private, boolean, isReturnExpressBlock, (, Node, n]
[., getFirstChild, (, ), ;, return, first, ., isReturn, (, ), ;, }, }, return, false, ;, }, private, boolean]
[;, }, }, return, false, ;, }, private, boolean, isReturnExpressBlock, (, Node, n, ), {, if, (, n, ., isBlock]
[., isReturn, (, ), ;, }, }, return, false, ;, }, private, boolean, isReturnExpressBlock, (, Node, n, ), {, if]
[;, }, private, boolean, isReturnExpressBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if]
[), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;]
[., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, .]
[), {, Node, first, =, n, ., getFirstChild, (, ), ;, if, (, first, ., isReturn, (, ), ), {]
[., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;, if, (, first, ., isReturn]
[;, if, (, first, ., isReturn, (, ), ), {, return, first, ., hasOneChild, (, ), ;, }, }, }]
[., getFirstChild, (, ), ;, if, (, first, ., isReturn, (, ), ), {, return, first, ., hasOneChild, (, )]
[), {, return, first, ., hasOneChild, (, ), ;, }, }, }, return, false, ;, }, private, boolean, isReturnExpression, (]
[., isReturn, (, ), ), {, return, first, ., hasOneChild, (, ), ;, }, }, }, return, false, ;, }]
[;, }, }, }, return, false, ;, }, private, boolean, isReturnExpression, (, Node, n, ), {, if, (, n, .]
[., hasOneChild, (, ), ;, }, }, }, return, false, ;, }, private, boolean, isReturnExpression, (, Node, n, ), {]
[;, }, private, boolean, isReturnExpression, (, Node, n, ), {, if, (, n, ., isReturn, (, ), ), {, return]
[), {, return, n, ., hasOneChild, (, ), ;, }, return, false, ;, }, private, Node, getBlockReturnExpression, (, Node, n]
[., isReturn, (, ), ), {, return, n, ., hasOneChild, (, ), ;, }, return, false, ;, }, private, Node]
[;, }, return, false, ;, }, private, Node, getBlockReturnExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isReturnExpressBlock, (]
[., hasOneChild, (, ), ;, }, return, false, ;, }, private, Node, getBlockReturnExpression, (, Node, n, ), {, Preconditions, .]
[;, }, private, Node, getBlockReturnExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isReturnExpressBlock, (, n, ), ), ;]
[;, return, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, private, boolean, isVarBlock, (, Node, n, )]
[., checkState, (, isReturnExpressBlock, (, n, ), ), ;, return, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;]
[), ;, return, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, private, boolean, isVarBlock, (, Node, n]
[), ), ;, return, n, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, private, boolean, isVarBlock, (, Node]
[;, }, private, boolean, isVarBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if]
[., getFirstChild, (, ), ;, }, private, boolean, isVarBlock, (, Node, n, ), {, if, (, n, ., isBlock, (]
[., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, private, boolean, isVarBlock, (, Node, n, ), {, if, (]
[), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;]
[., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, .]
[), {, Node, first, =, n, ., getFirstChild, (, ), ;, if, (, first, ., isVar, (, ), ), {]
[., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;, if, (, first, ., isVar]
[;, if, (, first, ., isVar, (, ), ), {, return, first, ., hasOneChild, (, ), ;, }, }, }]
[., getFirstChild, (, ), ;, if, (, first, ., isVar, (, ), ), {, return, first, ., hasOneChild, (, )]
[), {, return, first, ., hasOneChild, (, ), ;, }, }, }, return, false, ;, }, private, Node, getBlockVar, (]
[., isVar, (, ), ), {, return, first, ., hasOneChild, (, ), ;, }, }, }, return, false, ;, }]
[;, }, }, }, return, false, ;, }, private, Node, getBlockVar, (, Node, n, ), {, Preconditions, ., checkState, (]
[., hasOneChild, (, ), ;, }, }, }, return, false, ;, }, private, Node, getBlockVar, (, Node, n, ), {]
[;, }, private, Node, getBlockVar, (, Node, n, ), {, Preconditions, ., checkState, (, isVarBlock, (, n, ), ), ;]
[;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, consumesDanglingElse, (, Node, n, ), {, while, (, true]
[., checkState, (, isVarBlock, (, n, ), ), ;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, consumesDanglingElse]
[), ;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, consumesDanglingElse, (, Node, n, ), {, while, (]
[), ), ;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, consumesDanglingElse, (, Node, n, ), {, while]
[;, }, private, boolean, consumesDanglingElse, (, Node, n, ), {, while, (, true, ), {, switch, (, n, ., getType]
[., getFirstChild, (, ), ;, }, private, boolean, consumesDanglingElse, (, Node, n, ), {, while, (, true, ), {, switch]
[), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, if, (, n, .]
[), {, case, Token, ., IF, :, if, (, n, ., getChildCount, (, ), <, 3, ), {, return, true]
[., getType, (, ), ), {, case, Token, ., IF, :, if, (, n, ., getChildCount, (, ), <, 3]
[:, if, (, n, ., getChildCount, (, ), <, 3, ), {, return, true, ;, }, n, =, n, .]
[., IF, :, if, (, n, ., getChildCount, (, ), <, 3, ), {, return, true, ;, }, n, =]
[), {, return, true, ;, }, n, =, n, ., getLastChild, (, ), ;, continue, ;, case, Token, ., WITH]
[<, 3, ), {, return, true, ;, }, n, =, n, ., getLastChild, (, ), ;, continue, ;, case, Token]
[., getChildCount, (, ), <, 3, ), {, return, true, ;, }, n, =, n, ., getLastChild, (, ), ;]
[), {, return, true, ;, }, n, =, n, ., getLastChild, (, ), ;, continue, ;, case, Token, ., WITH]
[;, }, n, =, n, ., getLastChild, (, ), ;, continue, ;, case, Token, ., WITH, :, case, Token, .]
[=, n, ., getLastChild, (, ), ;, continue, ;, case, Token, ., WITH, :, case, Token, ., WHILE, :, case]
[;, continue, ;, case, Token, ., WITH, :, case, Token, ., WHILE, :, case, Token, ., FOR, :, n, =]
[., getLastChild, (, ), ;, continue, ;, case, Token, ., WITH, :, case, Token, ., WHILE, :, case, Token, .]
[:, case, Token, ., WHILE, :, case, Token, ., FOR, :, n, =, n, ., getLastChild, (, ), ;, continue]
[., WITH, :, case, Token, ., WHILE, :, case, Token, ., FOR, :, n, =, n, ., getLastChild, (, )]
[:, case, Token, ., FOR, :, n, =, n, ., getLastChild, (, ), ;, continue, ;, default, :, return, false]
[., WHILE, :, case, Token, ., FOR, :, n, =, n, ., getLastChild, (, ), ;, continue, ;, default, :]
[:, n, =, n, ., getLastChild, (, ), ;, continue, ;, default, :, return, false, ;, }, }, }, private]
[., FOR, :, n, =, n, ., getLastChild, (, ), ;, continue, ;, default, :, return, false, ;, }, }]
[=, n, ., getLastChild, (, ), ;, continue, ;, default, :, return, false, ;, }, }, }, private, boolean, isLowerPrecedenceInExpression]
[;, continue, ;, default, :, return, false, ;, }, }, }, private, boolean, isLowerPrecedenceInExpression, (, Node, n, ,, final, int]
[., getLastChild, (, ), ;, continue, ;, default, :, return, false, ;, }, }, }, private, boolean, isLowerPrecedenceInExpression, (, Node]
[;, }, }, }, private, boolean, isLowerPrecedenceInExpression, (, Node, n, ,, final, int, precedence, ), {, Predicate, <, Node, >]
[;, return, NodeUtil, ., has, (, n, ,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, boolean, isLowerPrecedence, (, Node, n]
[;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, boolean, isLowerPrecedence]
[<, precedence, ;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private]
[., precedence, (, input, ., getType, (, ), ), <, precedence, ;, }, }, ;, return, NodeUtil, ., has, (]
[), <, precedence, ;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }]
[., getType, (, ), ), <, precedence, ;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isLowerPrecedencePredicate, ,]
[;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, boolean, isLowerPrecedence]
[;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (, n]
[., has, (, n, ,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int]
[,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int, precedence, ), {, return]
[,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, .]
[), ;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (]
[;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (, n]
[<, precedence, ;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence]
[., precedence, (, n, ., getType, (, ), ), <, precedence, ;, }, private, boolean, isHigherPrecedence, (, Node, n, ,]
[), <, precedence, ;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, .]
[., getType, (, ), ), <, precedence, ;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, )]
[;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (, n]
[;, }, private, boolean, isPropertyAssignmentInExpression, (, Node, n, ), {, Predicate, <, Node, >, isPropertyAssignmentInExpressionPredicate, =, new, Predicate, <, Node]
[>, precedence, ;, }, private, boolean, isPropertyAssignmentInExpression, (, Node, n, ), {, Predicate, <, Node, >, isPropertyAssignmentInExpressionPredicate, =, new, Predicate]
[., precedence, (, n, ., getType, (, ), ), >, precedence, ;, }, private, boolean, isPropertyAssignmentInExpression, (, Node, n, )]
[), >, precedence, ;, }, private, boolean, isPropertyAssignmentInExpression, (, Node, n, ), {, Predicate, <, Node, >, isPropertyAssignmentInExpressionPredicate, =, new]
[., getType, (, ), ), >, precedence, ;, }, private, boolean, isPropertyAssignmentInExpression, (, Node, n, ), {, Predicate, <, Node]
[;, }, private, boolean, isPropertyAssignmentInExpression, (, Node, n, ), {, Predicate, <, Node, >, isPropertyAssignmentInExpressionPredicate, =, new, Predicate, <, Node]
[;, return, NodeUtil, ., has, (, n, ,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, Node, tryMinimizeCondition, (, Node, n]
[;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, Node, tryMinimizeCondition]
[), ;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, Node]
[&&, input, ., getParent, (, ), ., isAssign, (, ), ), ;, }, }, ;, return, NodeUtil, ., has, (]
[., isGetProp, (, ), &&, input, ., getParent, (, ), ., isAssign, (, ), ), ;, }, }, ;, return]
[), ;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, Node]
[., isAssign, (, ), ), ;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, )]
[., getParent, (, ), ., isAssign, (, ), ), ;, }, }, ;, return, NodeUtil, ., has, (, n, ,]
[;, }, private, Node, tryMinimizeCondition, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, switch]
[., has, (, n, ,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, Node, tryMinimizeCondition, (, Node, n, ), {, Node]
[,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, Node, tryMinimizeCondition, (, Node, n, ), {, Node, parent, =, n, .]
[,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, Node, tryMinimizeCondition, (, Node, n, ), {, Node, parent, =, n, ., getParent, (]
[), ;, }, private, Node, tryMinimizeCondition, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;]
[;, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :, Node, first, =, n, .]
[., getParent, (, ), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :, Node]
[), {, case, Token, ., NOT, :, Node, first, =, n, ., getFirstChild, (, ), ;, switch, (, first, .]
[., getType, (, ), ), {, case, Token, ., NOT, :, Node, first, =, n, ., getFirstChild, (, ), ;]
[:, Node, first, =, n, ., getFirstChild, (, ), ;, switch, (, first, ., getType, (, ), ), {, case]
[., NOT, :, Node, first, =, n, ., getFirstChild, (, ), ;, switch, (, first, ., getType, (, ), )]
[;, switch, (, first, ., getType, (, ), ), {, case, Token, ., NOT, :, {, Node, newRoot, =, first]
[., getFirstChild, (, ), ;, switch, (, first, ., getType, (, ), ), {, case, Token, ., NOT, :, {]
[), {, case, Token, ., NOT, :, {, Node, newRoot, =, first, ., removeFirstChild, (, ), ;, parent, ., replaceChild]
[., getType, (, ), ), {, case, Token, ., NOT, :, {, Node, newRoot, =, first, ., removeFirstChild, (, )]
[:, {, Node, newRoot, =, first, ., removeFirstChild, (, ), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;]
[., NOT, :, {, Node, newRoot, =, first, ., removeFirstChild, (, ), ;, parent, ., replaceChild, (, n, ,, newRoot]
[;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, case, Token]
[., removeFirstChild, (, ), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot]
[;, reportCodeChange, (, ), ;, return, newRoot, ;, }, case, Token, ., AND, :, case, Token, ., OR, :, {]
[., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, case, Token, ., AND]
[,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, case, Token, ., AND, :, case, Token, .]
[), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, case, Token, ., AND, :, case, Token, ., OR, :]
[;, return, newRoot, ;, }, case, Token, ., AND, :, case, Token, ., OR, :, {, Node, leftParent, =, first]
[;, }, case, Token, ., AND, :, case, Token, ., OR, :, {, Node, leftParent, =, first, ., getFirstChild, (]
[:, case, Token, ., OR, :, {, Node, leftParent, =, first, ., getFirstChild, (, ), ;, Node, rightParent, =, first]
[., AND, :, case, Token, ., OR, :, {, Node, leftParent, =, first, ., getFirstChild, (, ), ;, Node, rightParent]
[:, {, Node, leftParent, =, first, ., getFirstChild, (, ), ;, Node, rightParent, =, first, ., getLastChild, (, ), ;]
[., OR, :, {, Node, leftParent, =, first, ., getFirstChild, (, ), ;, Node, rightParent, =, first, ., getLastChild, (]
[;, Node, rightParent, =, first, ., getLastChild, (, ), ;, Node, left, ,, right, ;, if, (, !, leftParent, .]
[., getFirstChild, (, ), ;, Node, rightParent, =, first, ., getLastChild, (, ), ;, Node, left, ,, right, ;, if]
[;, Node, left, ,, right, ;, if, (, !, leftParent, ., isNot, (, ), &&, !, rightParent, ., isNot, (]
[., getLastChild, (, ), ;, Node, left, ,, right, ;, if, (, !, leftParent, ., isNot, (, ), &&, !]
[), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;, if, (, (, isLowerPrecedence]
[&&, !, rightParent, ., isNot, (, ), ), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (]
[&&, !, rightParent, ., isNot, (, ), ), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (]
[., isNot, (, ), &&, !, rightParent, ., isNot, (, ), ), {, int, op_precedence, =, NodeUtil, ., precedence, (]
[), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;, if, (, (, isLowerPrecedence]
[), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;, if, (, (, isLowerPrecedence]
[., isNot, (, ), ), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;]
[;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (]
[., precedence, (, first, ., getType, (, ), ), ;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&]
[), ;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||]
[., getType, (, ), ), ;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,]
[), {, return, n, ;, }, }, if, (, leftParent, ., isNot, (, ), ), {, left, =, leftParent, .]
[||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {, return, n]
[), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {, return]
[&&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent]
[,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&]
[), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (]
[), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {, return]
[,, op_precedence, ), ), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), )]
[), ), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {]
[), {, return, n, ;, }, }, if, (, leftParent, ., isNot, (, ), ), {, left, =, leftParent, .]
[), ), {, return, n, ;, }, }, if, (, leftParent, ., isNot, (, ), ), {, left, =, leftParent]
[&&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {, return, n, ;, }, }, if, (, leftParent, ., isNot]
[,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {, return, n, ;, }, }, if, (]
[), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {, return, n, ;, }, }, if, (, leftParent, .]
[), ), {, return, n, ;, }, }, if, (, leftParent, ., isNot, (, ), ), {, left, =, leftParent]
[,, op_precedence, ), ), ), {, return, n, ;, }, }, if, (, leftParent, ., isNot, (, ), ), {]
[), ), ), {, return, n, ;, }, }, if, (, leftParent, ., isNot, (, ), ), {, left, =]
[;, }, }, if, (, leftParent, ., isNot, (, ), ), {, left, =, leftParent, ., removeFirstChild, (, ), ;]
[), {, left, =, leftParent, ., removeFirstChild, (, ), ;, }, else, {, leftParent, ., detachFromParent, (, ), ;, left]
[., isNot, (, ), ), {, left, =, leftParent, ., removeFirstChild, (, ), ;, }, else, {, leftParent, ., detachFromParent]
[=, leftParent, ., removeFirstChild, (, ), ;, }, else, {, leftParent, ., detachFromParent, (, ), ;, left, =, IR, .]
[;, }, else, {, leftParent, ., detachFromParent, (, ), ;, left, =, IR, ., not, (, leftParent, ), ., srcref]
[., removeFirstChild, (, ), ;, }, else, {, leftParent, ., detachFromParent, (, ), ;, left, =, IR, ., not, (]
[;, left, =, IR, ., not, (, leftParent, ), ., srcref, (, leftParent, ), ;, }, if, (, rightParent, .]
[., detachFromParent, (, ), ;, left, =, IR, ., not, (, leftParent, ), ., srcref, (, leftParent, ), ;, }]
[=, IR, ., not, (, leftParent, ), ., srcref, (, leftParent, ), ;, }, if, (, rightParent, ., isNot, (]
[;, }, if, (, rightParent, ., isNot, (, ), ), {, right, =, rightParent, ., removeFirstChild, (, ), ;, }]
[., srcref, (, leftParent, ), ;, }, if, (, rightParent, ., isNot, (, ), ), {, right, =, rightParent, .]
[., not, (, leftParent, ), ., srcref, (, leftParent, ), ;, }, if, (, rightParent, ., isNot, (, ), )]
[), ., srcref, (, leftParent, ), ;, }, if, (, rightParent, ., isNot, (, ), ), {, right, =, rightParent]
[), ;, }, if, (, rightParent, ., isNot, (, ), ), {, right, =, rightParent, ., removeFirstChild, (, ), ;]
[), {, right, =, rightParent, ., removeFirstChild, (, ), ;, }, else, {, rightParent, ., detachFromParent, (, ), ;, right]
[., isNot, (, ), ), {, right, =, rightParent, ., removeFirstChild, (, ), ;, }, else, {, rightParent, ., detachFromParent]
[=, rightParent, ., removeFirstChild, (, ), ;, }, else, {, rightParent, ., detachFromParent, (, ), ;, right, =, IR, .]
[;, }, else, {, rightParent, ., detachFromParent, (, ), ;, right, =, IR, ., not, (, rightParent, ), ., srcref]
[., removeFirstChild, (, ), ;, }, else, {, rightParent, ., detachFromParent, (, ), ;, right, =, IR, ., not, (]
[;, right, =, IR, ., not, (, rightParent, ), ., srcref, (, rightParent, ), ;, }, int, newOp, =, (]
[., detachFromParent, (, ), ;, right, =, IR, ., not, (, rightParent, ), ., srcref, (, rightParent, ), ;, }]
[=, IR, ., not, (, rightParent, ), ., srcref, (, rightParent, ), ;, }, int, newOp, =, (, first, .]
[;, }, int, newOp, =, (, first, ., isAnd, (, ), ), ?, Token, ., OR, :, Token, ., AND]
[., srcref, (, rightParent, ), ;, }, int, newOp, =, (, first, ., isAnd, (, ), ), ?, Token, .]
[., not, (, rightParent, ), ., srcref, (, rightParent, ), ;, }, int, newOp, =, (, first, ., isAnd, (]
[), ., srcref, (, rightParent, ), ;, }, int, newOp, =, (, first, ., isAnd, (, ), ), ?, Token]
[), ;, }, int, newOp, =, (, first, ., isAnd, (, ), ), ?, Token, ., OR, :, Token, .]
[;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right, ), ;, parent, ., replaceChild, (, n, ,]
[?, Token, ., OR, :, Token, ., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right]
[), ?, Token, ., OR, :, Token, ., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,]
[., isAnd, (, ), ), ?, Token, ., OR, :, Token, ., AND, ;, Node, newRoot, =, new, Node, (]
[:, Token, ., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right, ), ;, parent, .]
[., OR, :, Token, ., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right, ), ;]
[;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right, ), ;, parent, ., replaceChild, (, n, ,]
[., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right, ), ;, parent, ., replaceChild, (]
[;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, default, :]
[,, left, ,, right, ), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return]
[,, right, ), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;]
[), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, default]
[;, reportCodeChange, (, ), ;, return, newRoot, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, first, )]
[., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, default, :, TernaryValue, nVal]
[,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue]
[), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, first]
[;, return, newRoot, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, first, ), ;, if, (, nVal]
[;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, first, ), ;, if, (, nVal, !=, TernaryValue, .]
[;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., not, (, ), ., toBoolean]
[., getPureBooleanValue, (, first, ), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, .]
[), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., not, (, ), .]
[), {, boolean, result, =, nVal, ., not, (, ), ., toBoolean, (, true, ), ;, int, equivalentResult, =, result]
[!=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., not, (, ), ., toBoolean, (, true, ), ;]
[), {, boolean, result, =, nVal, ., not, (, ), ., toBoolean, (, true, ), ;, int, equivalentResult, =, result]
[., UNKNOWN, ), {, boolean, result, =, nVal, ., not, (, ), ., toBoolean, (, true, ), ;, int, equivalentResult]
[;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;]
[., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,]
[., not, (, ), ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return]
[), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, )]
[;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, }, return, n, ;, case, Token, ., OR]
[?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, }, return, n, ;]
[:, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, }, return, n, ;, case, Token]
[;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, }, return, n, ;, case, Token, ., OR]
[;, }, }, return, n, ;, case, Token, ., OR, :, case, Token, ., AND, :, {, Node, left, =]
[,, parent, ,, equivalentResult, ), ;, }, }, return, n, ;, case, Token, ., OR, :, case, Token, ., AND]
[,, equivalentResult, ), ;, }, }, return, n, ;, case, Token, ., OR, :, case, Token, ., AND, :, {]
[), ;, }, }, return, n, ;, case, Token, ., OR, :, case, Token, ., AND, :, {, Node, left]
[;, case, Token, ., OR, :, case, Token, ., AND, :, {, Node, left, =, n, ., getFirstChild, (, )]
[:, case, Token, ., AND, :, {, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n]
[., OR, :, case, Token, ., AND, :, {, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right]
[:, {, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;]
[., AND, :, {, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (]
[;, Node, right, =, n, ., getLastChild, (, ), ;, left, =, tryMinimizeCondition, (, left, ), ;, right, =, tryMinimizeCondition]
[., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, left, =, tryMinimizeCondition, (, left, )]
[;, left, =, tryMinimizeCondition, (, left, ), ;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =, NodeUtil, .]
[., getLastChild, (, ), ;, left, =, tryMinimizeCondition, (, left, ), ;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue]
[=, tryMinimizeCondition, (, left, ), ;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (]
[;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (]
[), ;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if]
[=, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (, NodeUtil, .]
[;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, right, ), !=]
[), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, right, )]
[;, if, (, NodeUtil, ., getPureBooleanValue, (, right, ), !=, TernaryValue, ., UNKNOWN, ), {, int, type, =, n, .]
[., getPureBooleanValue, (, right, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, right, ), !=, TernaryValue, ., UNKNOWN, ), {]
[), ;, if, (, NodeUtil, ., getPureBooleanValue, (, right, ), !=, TernaryValue, ., UNKNOWN, ), {, int, type, =, n]
[), {, int, type, =, n, ., getType, (, ), ;, Node, replacement, =, null, ;, boolean, rval, =, rightVal]
[!=, TernaryValue, ., UNKNOWN, ), {, int, type, =, n, ., getType, (, ), ;, Node, replacement, =, null, ;]
[., getPureBooleanValue, (, right, ), !=, TernaryValue, ., UNKNOWN, ), {, int, type, =, n, ., getType, (, ), ;]
[), !=, TernaryValue, ., UNKNOWN, ), {, int, type, =, n, ., getType, (, ), ;, Node, replacement, =, null]
[), {, int, type, =, n, ., getType, (, ), ;, Node, replacement, =, null, ;, boolean, rval, =, rightVal]
[., UNKNOWN, ), {, int, type, =, n, ., getType, (, ), ;, Node, replacement, =, null, ;, boolean, rval]
[;, Node, replacement, =, null, ;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==]
[., getType, (, ), ;, Node, replacement, =, null, ;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;]
[;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==, Token, ., OR, &&, !]
[;, if, (, type, ==, Token, ., OR, &&, !, rval, ||, type, ==, Token, ., AND, &&, rval, )]
[., toBoolean, (, true, ), ;, if, (, type, ==, Token, ., OR, &&, !, rval, ||, type, ==, Token]
[), ;, if, (, type, ==, Token, ., OR, &&, !, rval, ||, type, ==, Token, ., AND, &&, rval]
[), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right]
[||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects]
[&&, !, rval, ||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if]
[==, Token, ., OR, &&, !, rval, ||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left]
[&&, !, rval, ||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if]
[., OR, &&, !, rval, ||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }]
[||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects]
[||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects]
[), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right]
[&&, rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement]
[==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left]
[&&, rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement]
[., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), )]
[), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right]
[=, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right, ;, }, if]
[;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right, ;, }, if, (, replacement]
[), {, replacement, =, right, ;, }, if, (, replacement, !=, null, ), {, n, ., detachChildren, (, ), ;]
[), {, replacement, =, right, ;, }, if, (, replacement, !=, null, ), {, n, ., detachChildren, (, ), ;]
[), ), {, replacement, =, right, ;, }, if, (, replacement, !=, null, ), {, n, ., detachChildren, (, )]
[=, right, ;, }, if, (, replacement, !=, null, ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild]
[;, }, if, (, replacement, !=, null, ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n]
[), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, )]
[!=, null, ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange]
[), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, )]
[;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, }, return]
[., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement]
[;, reportCodeChange, (, ), ;, return, replacement, ;, }, }, return, n, ;, }, case, Token, ., HOOK, :, {]
[., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, }, return, n, ;]
[,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, }, return, n, ;, }, case, Token, .]
[), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, }, return, n, ;, }, case, Token, ., HOOK, :]
[;, return, replacement, ;, }, }, return, n, ;, }, case, Token, ., HOOK, :, {, Node, condition, =, n]
[;, }, }, return, n, ;, }, case, Token, ., HOOK, :, {, Node, condition, =, n, ., getFirstChild, (]
[;, }, case, Token, ., HOOK, :, {, Node, condition, =, n, ., getFirstChild, (, ), ;, Node, trueNode, =]
[:, {, Node, condition, =, n, ., getFirstChild, (, ), ;, Node, trueNode, =, n, ., getFirstChild, (, ), .]
[., HOOK, :, {, Node, condition, =, n, ., getFirstChild, (, ), ;, Node, trueNode, =, n, ., getFirstChild, (]
[;, Node, trueNode, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, falseNode, =, n, ., getLastChild]
[., getFirstChild, (, ), ;, Node, trueNode, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, falseNode]
[;, Node, falseNode, =, n, ., getLastChild, (, ), ;, trueNode, =, tryMinimizeCondition, (, trueNode, ), ;, falseNode, =, tryMinimizeCondition]
[., getNext, (, ), ;, Node, falseNode, =, n, ., getLastChild, (, ), ;, trueNode, =, tryMinimizeCondition, (, trueNode, )]
[., getFirstChild, (, ), ., getNext, (, ), ;, Node, falseNode, =, n, ., getLastChild, (, ), ;, trueNode, =]
[;, trueNode, =, tryMinimizeCondition, (, trueNode, ), ;, falseNode, =, tryMinimizeCondition, (, falseNode, ), ;, Node, replacement, =, null, ;]
[., getLastChild, (, ), ;, trueNode, =, tryMinimizeCondition, (, trueNode, ), ;, falseNode, =, tryMinimizeCondition, (, falseNode, ), ;, Node]
[=, tryMinimizeCondition, (, trueNode, ), ;, falseNode, =, tryMinimizeCondition, (, falseNode, ), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal]
[;, falseNode, =, tryMinimizeCondition, (, falseNode, ), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue, (]
[), ;, falseNode, =, tryMinimizeCondition, (, falseNode, ), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue]
[=, tryMinimizeCondition, (, falseNode, ), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue, (, trueNode, )]
[;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =, NodeUtil]
[), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =]
[;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, )]
[;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal]
[., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==]
[), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&]
[;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (]
[., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE, )]
[), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent]
[), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, .]
[&&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else]
[==, TernaryValue, ., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =]
[&&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else]
[., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;]
[), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, .]
[==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (]
[), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, .]
[., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==]
[;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE]
[., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal]
[=, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {]
[;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {, condition, .]
[), {, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, ), ;, }, else, if]
[&&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (]
[==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =]
[&&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (]
[., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, IR, .]
[), {, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, ), ;, }, else, if]
[==, TernaryValue, ., TRUE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, )]
[), {, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, ), ;, }, else, if]
[., TRUE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, ), ;, }]
[;, replacement, =, IR, ., not, (, condition, ), ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, )]
[., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, ), ;, }, else, if, (, trueNodeVal, ==]
[=, IR, ., not, (, condition, ), ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, ), {, n]
[;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, ), {, n, ., detachChildren, (, ), ;, replacement, =]
[., not, (, condition, ), ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, ), {, n, ., detachChildren]
[), ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, ), {, n, ., detachChildren, (, ), ;, replacement]
[), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., or, (, condition, ,, falseNode, ), ;, }]
[==, TernaryValue, ., TRUE, ), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., or, (, condition, ,]
[), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., or, (, condition, ,, falseNode, ), ;, }]
[., TRUE, ), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., or, (, condition, ,, falseNode, )]
[;, replacement, =, IR, ., or, (, condition, ,, falseNode, ), ;, }, else, if, (, falseNodeVal, ==, TernaryValue, .]
[., detachChildren, (, ), ;, replacement, =, IR, ., or, (, condition, ,, falseNode, ), ;, }, else, if, (]
[=, IR, ., or, (, condition, ,, falseNode, ), ;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, )]
[;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, n, ., detachChildren, (, ), ;, replacement, =]
[., or, (, condition, ,, falseNode, ), ;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, n]
[,, falseNode, ), ;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, n, ., detachChildren, (, )]
[), ;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, n, ., detachChildren, (, ), ;, replacement]
[), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., and, (, condition, ,, trueNode, ), ;, }]
[==, TernaryValue, ., FALSE, ), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., and, (, condition, ,]
[), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., and, (, condition, ,, trueNode, ), ;, }]
[., FALSE, ), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., and, (, condition, ,, trueNode, )]
[;, replacement, =, IR, ., and, (, condition, ,, trueNode, ), ;, }, if, (, replacement, !=, null, ), {]
[., detachChildren, (, ), ;, replacement, =, IR, ., and, (, condition, ,, trueNode, ), ;, }, if, (, replacement]
[=, IR, ., and, (, condition, ,, trueNode, ), ;, }, if, (, replacement, !=, null, ), {, parent, .]
[;, }, if, (, replacement, !=, null, ), {, parent, ., replaceChild, (, n, ,, replacement, ), ;, n, =]
[., and, (, condition, ,, trueNode, ), ;, }, if, (, replacement, !=, null, ), {, parent, ., replaceChild, (]
[,, trueNode, ), ;, }, if, (, replacement, !=, null, ), {, parent, ., replaceChild, (, n, ,, replacement, )]
[), ;, }, if, (, replacement, !=, null, ), {, parent, ., replaceChild, (, n, ,, replacement, ), ;, n]
[), {, parent, ., replaceChild, (, n, ,, replacement, ), ;, n, =, replacement, ;, reportCodeChange, (, ), ;, }]
[!=, null, ), {, parent, ., replaceChild, (, n, ,, replacement, ), ;, n, =, replacement, ;, reportCodeChange, (, )]
[), {, parent, ., replaceChild, (, n, ,, replacement, ), ;, n, =, replacement, ;, reportCodeChange, (, ), ;, }]
[;, n, =, replacement, ;, reportCodeChange, (, ), ;, }, return, n, ;, }, default, :, TernaryValue, nVal, =, NodeUtil]
[., replaceChild, (, n, ,, replacement, ), ;, n, =, replacement, ;, reportCodeChange, (, ), ;, }, return, n, ;]
[,, replacement, ), ;, n, =, replacement, ;, reportCodeChange, (, ), ;, }, return, n, ;, }, default, :, TernaryValue]
[), ;, n, =, replacement, ;, reportCodeChange, (, ), ;, }, return, n, ;, }, default, :, TernaryValue, nVal, =]
[=, replacement, ;, reportCodeChange, (, ), ;, }, return, n, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue]
[;, reportCodeChange, (, ), ;, }, return, n, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, n]
[;, }, return, n, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, if, (]
[;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, if, (, nVal, !=, TernaryValue, .]
[;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., toBoolean, (, true, ), ;]
[., getPureBooleanValue, (, n, ), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, .]
[), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., toBoolean, (, true, )]
[), {, boolean, result, =, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0]
[!=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =, result]
[), {, boolean, result, =, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0]
[., UNKNOWN, ), {, boolean, result, =, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1]
[;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;]
[., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,]
[), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, )]
[;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, return, n, ;, }, }, private, Node, maybeReplaceChildWithNumber]
[?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, return, n, ;, }]
[:, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, return, n, ;, }, }, private]
[;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, return, n, ;, }, }, private, Node, maybeReplaceChildWithNumber]
[;, }, return, n, ;, }, }, private, Node, maybeReplaceChildWithNumber, (, Node, n, ,, Node, parent, ,, int, num, )]
[,, parent, ,, equivalentResult, ), ;, }, return, n, ;, }, }, private, Node, maybeReplaceChildWithNumber, (, Node, n, ,, Node]
[,, equivalentResult, ), ;, }, return, n, ;, }, }, private, Node, maybeReplaceChildWithNumber, (, Node, n, ,, Node, parent, ,]
[), ;, }, return, n, ;, }, }, private, Node, maybeReplaceChildWithNumber, (, Node, n, ,, Node, parent, ,, int, num]
[;, }, }, private, Node, maybeReplaceChildWithNumber, (, Node, n, ,, Node, parent, ,, int, num, ), {, Node, newNode, =]
[;, if, (, !, newNode, ., isEquivalentTo, (, n, ), ), {, parent, ., replaceChild, (, n, ,, newNode, )]
[., number, (, num, ), ;, if, (, !, newNode, ., isEquivalentTo, (, n, ), ), {, parent, ., replaceChild]
[), ;, if, (, !, newNode, ., isEquivalentTo, (, n, ), ), {, parent, ., replaceChild, (, n, ,, newNode]
[), {, parent, ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return]
[), {, parent, ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return]
[., isEquivalentTo, (, n, ), ), {, parent, ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;]
[), ), {, parent, ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }]
[;, reportCodeChange, (, ), ;, return, newNode, ;, }, return, n, ;, }, private, static, final, ImmutableSet, <, String, >]
[., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return, n, ;, }]
[,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return, n, ;, }, private, static, final, ImmutableSet]
[), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return, n, ;, }, private, static, final, ImmutableSet, <, String]
[;, return, newNode, ;, }, return, n, ;, }, private, static, final, ImmutableSet, <, String, >, STANDARD_OBJECT_CONSTRUCTORS, =, ImmutableSet, .]
[;, }, return, n, ;, }, private, static, final, ImmutableSet, <, String, >, STANDARD_OBJECT_CONSTRUCTORS, =, ImmutableSet, ., of, (, "Object"]
[;, }, private, static, final, ImmutableSet, <, String, >, STANDARD_OBJECT_CONSTRUCTORS, =, ImmutableSet, ., of, (, "Object", ,, "Array", ,, "RegExp"]
[;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew, (, ), ), ;]
[., of, (, "Object", ,, "Array", ,, "RegExp", ,, "Error", ), ;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {]
[,, "Array", ,, "RegExp", ,, "Error", ), ;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {, Preconditions, ., checkState, (]
[,, "RegExp", ,, "Error", ), ;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {, Preconditions, ., checkState, (, n, .]
[,, "Error", ), ;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew, (]
[), ;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew, (, ), )]
[;, if, (, isASTNormalized, (, ), ), {, if, (, n, ., getFirstChild, (, ), ., isName, (, ), )]
[., checkState, (, n, ., isNew, (, ), ), ;, if, (, isASTNormalized, (, ), ), {, if, (, n]
[), ;, if, (, isASTNormalized, (, ), ), {, if, (, n, ., getFirstChild, (, ), ., isName, (, )]
[., isNew, (, ), ), ;, if, (, isASTNormalized, (, ), ), {, if, (, n, ., getFirstChild, (, )]
[), {, if, (, n, ., getFirstChild, (, ), ., isName, (, ), ), {, String, className, =, n, .]
[), {, String, className, =, n, ., getFirstChild, (, ), ., getString, (, ), ;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains]
[., isName, (, ), ), {, String, className, =, n, ., getFirstChild, (, ), ., getString, (, ), ;, if]
[., getFirstChild, (, ), ., isName, (, ), ), {, String, className, =, n, ., getFirstChild, (, ), ., getString]
[;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, ), ), {, n, ., setType, (, Token, ., CALL, ), ;]
[., getString, (, ), ;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, ), ), {, n, ., setType, (, Token]
[., getFirstChild, (, ), ., getString, (, ), ;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, ), ), {, n]
[), {, n, ., setType, (, Token, ., CALL, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true]
[., contains, (, className, ), ), {, n, ., setType, (, Token, ., CALL, ), ;, n, ., putBooleanProp, (]
[), ), {, n, ., setType, (, Token, ., CALL, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,]
[;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, reportCodeChange, (, ), ;, }, }, }, return]
[., setType, (, Token, ., CALL, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, reportCodeChange]
[), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, reportCodeChange, (, ), ;, }, }, }]
[., CALL, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, reportCodeChange, (, ), ;, }]
[;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {]
[., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, reportCodeChange, (, ), ;, }, }, }, return, n, ;]
[,, true, ), ;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor, (, Node]
[., FREE_CALL, ,, true, ), ;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor]
[), ;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, )]
[;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isCall, (, ), ||]
[;, Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (, )]
[., checkArgument, (, n, ., isCall, (, ), ||, n, ., isNew, (, ), ), ;, Node, constructorNameNode, =, n]
[), ;, Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (]
[||, n, ., isNew, (, ), ), ;, Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =]
[., isCall, (, ), ||, n, ., isNew, (, ), ), ;, Node, constructorNameNode, =, n, ., getFirstChild, (, )]
[), ;, Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (]
[., isNew, (, ), ), ;, Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;]
[;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (, ), &&, Token, ., NAME, ==, constructorNameNode, ., getType, (]
[., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (, ), &&, Token, ., NAME, ==]
[;, if, (, isASTNormalized, (, ), &&, Token, ., NAME, ==, constructorNameNode, ., getType, (, ), ), {, String, className]
[), {, String, className, =, constructorNameNode, ., getString, (, ), ;, if, (, "RegExp", ., equals, (, className, ), )]
[&&, Token, ., NAME, ==, constructorNameNode, ., getType, (, ), ), {, String, className, =, constructorNameNode, ., getString, (, )]
[), {, String, className, =, constructorNameNode, ., getString, (, ), ;, if, (, "RegExp", ., equals, (, className, ), )]
[==, constructorNameNode, ., getType, (, ), ), {, String, className, =, constructorNameNode, ., getString, (, ), ;, if, (, "RegExp"]
[., NAME, ==, constructorNameNode, ., getType, (, ), ), {, String, className, =, constructorNameNode, ., getString, (, ), ;, if]
[), {, String, className, =, constructorNameNode, ., getString, (, ), ;, if, (, "RegExp", ., equals, (, className, ), )]
[., getType, (, ), ), {, String, className, =, constructorNameNode, ., getString, (, ), ;, if, (, "RegExp", ., equals]
[;, if, (, "RegExp", ., equals, (, className, ), ), {, return, tryFoldRegularExpressionConstructor, (, n, ), ;, }, else, {]
[., getString, (, ), ;, if, (, "RegExp", ., equals, (, className, ), ), {, return, tryFoldRegularExpressionConstructor, (, n, )]
[), {, return, tryFoldRegularExpressionConstructor, (, n, ), ;, }, else, {, boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=]
[., equals, (, className, ), ), {, return, tryFoldRegularExpressionConstructor, (, n, ), ;, }, else, {, boolean, constructorHasArgs, =, constructorNameNode]
[), ), {, return, tryFoldRegularExpressionConstructor, (, n, ), ;, }, else, {, boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, )]
[;, }, else, {, boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=, null, ;, if, (, "Object", ., equals]
[), ;, }, else, {, boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=, null, ;, if, (, "Object", .]
[;, if, (, "Object", ., equals, (, className, ), &&, !, constructorHasArgs, ), {, newLiteralNode, =, IR, ., objectlit, (]
[!=, null, ;, if, (, "Object", ., equals, (, className, ), &&, !, constructorHasArgs, ), {, newLiteralNode, =, IR, .]
[., getNext, (, ), !=, null, ;, if, (, "Object", ., equals, (, className, ), &&, !, constructorHasArgs, ), {]
[;, if, (, "Object", ., equals, (, className, ), &&, !, constructorHasArgs, ), {, newLiteralNode, =, IR, ., objectlit, (]
[), {, newLiteralNode, =, IR, ., objectlit, (, ), ;, }, else, if, (, "Array", ., equals, (, className, )]
[&&, !, constructorHasArgs, ), {, newLiteralNode, =, IR, ., objectlit, (, ), ;, }, else, if, (, "Array", ., equals]
[., equals, (, className, ), &&, !, constructorHasArgs, ), {, newLiteralNode, =, IR, ., objectlit, (, ), ;, }, else]
[), &&, !, constructorHasArgs, ), {, newLiteralNode, =, IR, ., objectlit, (, ), ;, }, else, if, (, "Array", .]
[), {, newLiteralNode, =, IR, ., objectlit, (, ), ;, }, else, if, (, "Array", ., equals, (, className, )]
[), {, newLiteralNode, =, IR, ., objectlit, (, ), ;, }, else, if, (, "Array", ., equals, (, className, )]
[=, IR, ., objectlit, (, ), ;, }, else, if, (, "Array", ., equals, (, className, ), ), {, Node]
[;, }, else, if, (, "Array", ., equals, (, className, ), ), {, Node, arg0, =, constructorNameNode, ., getNext, (]
[., objectlit, (, ), ;, }, else, if, (, "Array", ., equals, (, className, ), ), {, Node, arg0, =]
[), {, Node, arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if]
[., equals, (, className, ), ), {, Node, arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor]
[), ), {, Node, arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;]
[;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction]
[., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS]
[;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, .]
[), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR]
[), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (, action, ==]
[||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (]
[==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;]
[||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (]
[., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, .]
[), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (, action, ==]
[==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;]
[), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (, action, ==]
[., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (]
[=, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS]
[;, n, ., removeChildren, (, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (]
[., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {]
[;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }]
[., removeChildren, (, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, )]
[), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (, newLiteralNode, !=, null, ), {, n]
[==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (, newLiteralNode, !=]
[), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (, newLiteralNode, !=, null, ), {, n]
[., SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (, newLiteralNode, !=, null, )]
[;, }, }, }, if, (, newLiteralNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild, (, n]
[., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (, newLiteralNode, !=, null, ), {, n, ., getParent, (]
[), ;, }, }, }, if, (, newLiteralNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild, (]
[), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, newLiteralNode, ), ;, reportCodeChange, (, ), ;, return]
[!=, null, ), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, newLiteralNode, ), ;, reportCodeChange, (, )]
[), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, newLiteralNode, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, newLiteralNode, ;, }, }, }, return, n, ;, }, private, static, enum, FoldArrayAction, {]
[., replaceChild, (, n, ,, newLiteralNode, ), ;, reportCodeChange, (, ), ;, return, newLiteralNode, ;, }, }, }, return, n]
[., getParent, (, ), ., replaceChild, (, n, ,, newLiteralNode, ), ;, reportCodeChange, (, ), ;, return, newLiteralNode, ;, }]
[,, newLiteralNode, ), ;, reportCodeChange, (, ), ;, return, newLiteralNode, ;, }, }, }, return, n, ;, }, private, static]
[), ;, reportCodeChange, (, ), ;, return, newLiteralNode, ;, }, }, }, return, n, ;, }, private, static, enum, FoldArrayAction]
[;, return, newLiteralNode, ;, }, }, }, return, n, ;, }, private, static, enum, FoldArrayAction, {, NOT_SAFE_TO_FOLD, ,, SAFE_TO_FOLD_WITH_ARGS, ,]
[;, }, }, }, return, n, ;, }, private, static, enum, FoldArrayAction, {, NOT_SAFE_TO_FOLD, ,, SAFE_TO_FOLD_WITH_ARGS, ,, SAFE_TO_FOLD_WITHOUT_ARGS, }, private]
[;, }, private, static, enum, FoldArrayAction, {, NOT_SAFE_TO_FOLD, ,, SAFE_TO_FOLD_WITH_ARGS, ,, SAFE_TO_FOLD_WITHOUT_ARGS, }, private, FoldArrayAction, isSafeToFoldArrayConstructor, (, Node, arg, )]
[;, if, (, arg, ==, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, .]
[., NOT_SAFE_TO_FOLD, ;, if, (, arg, ==, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (]
[), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, ., getNext, (, ), !=, null, )]
[==, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, ., getNext, (, ), !=]
[), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, ., getNext, (, ), !=, null, )]
[=, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, ., getNext, (, ), !=, null, ), {, action, =]
[;, }, else, if, (, arg, ., getNext, (, ), !=, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;]
[., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, ., getNext, (, ), !=, null, ), {, action, =, FoldArrayAction, .]
[), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (, arg, ., getType, (, ), ), {]
[!=, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (, arg, ., getType, (, )]
[., getNext, (, ), !=, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (, arg]
[), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (, arg, ., getType, (, ), ), {]
[=, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (, arg, ., getType, (, ), ), {, case, Token, .]
[;, }, else, {, switch, (, arg, ., getType, (, ), ), {, case, Token, ., STRING, :, action, =]
[., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (, arg, ., getType, (, ), ), {, case, Token, ., STRING, :]
[), {, case, Token, ., STRING, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :]
[., getType, (, ), ), {, case, Token, ., STRING, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case]
[:, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :, if, (, arg, ., getDouble, (]
[., STRING, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :, if, (, arg, .]
[=, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :, if, (, arg, ., getDouble, (, ), ==]
[;, break, ;, case, Token, ., NUMBER, :, if, (, arg, ., getDouble, (, ), ==, 0, ), {, action]
[., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :, if, (, arg, ., getDouble, (, ), ==, 0, )]
[:, if, (, arg, ., getDouble, (, ), ==, 0, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break]
[., NUMBER, :, if, (, arg, ., getDouble, (, ), ==, 0, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;]
[), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case, Token, ., ARRAYLIT, :, action, =, FoldArrayAction, .]
[==, 0, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case, Token, ., ARRAYLIT, :, action, =]
[., getDouble, (, ), ==, 0, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case, Token, .]
[), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case, Token, ., ARRAYLIT, :, action, =, FoldArrayAction, .]
[=, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case, Token, ., ARRAYLIT, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break]
[;, }, break, ;, case, Token, ., ARRAYLIT, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, default, :, }]
[., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case, Token, ., ARRAYLIT, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, default]
[:, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, default, :, }, }, return, action, ;, }, private, Node, tryFoldRegularExpressionConstructor]
[., ARRAYLIT, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, default, :, }, }, return, action, ;, }, private]
[=, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, default, :, }, }, return, action, ;, }, private, Node, tryFoldRegularExpressionConstructor, (, Node]
[;, break, ;, default, :, }, }, return, action, ;, }, private, Node, tryFoldRegularExpressionConstructor, (, Node, n, ), {, Node]
[., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, default, :, }, }, return, action, ;, }, private, Node, tryFoldRegularExpressionConstructor, (, Node, n, )]
[;, }, private, Node, tryFoldRegularExpressionConstructor, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node]
[;, Node, constructor, =, n, ., getFirstChild, (, ), ;, Node, pattern, =, constructor, ., getNext, (, ), ;, Node]
[., getParent, (, ), ;, Node, constructor, =, n, ., getFirstChild, (, ), ;, Node, pattern, =, constructor, ., getNext]
[;, Node, pattern, =, constructor, ., getNext, (, ), ;, Node, flags, =, null, !=, pattern, ?, pattern, ., getNext]
[., getFirstChild, (, ), ;, Node, pattern, =, constructor, ., getNext, (, ), ;, Node, flags, =, null, !=, pattern]
[;, Node, flags, =, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==]
[., getNext, (, ), ;, Node, flags, =, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;]
[;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&, null, !=, flags, ., getNext, (, ), )]
[?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&]
[!=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (, null, !=]
[?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&]
[:, null, ;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&, null, !=, flags, ., getNext, (]
[., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&, null, !=]
[;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&, null, !=, flags, ., getNext, (, ), )]
[), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern]
[||, (, null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }]
[==, pattern, ||, (, null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n]
[||, (, null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }]
[), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern]
[), ), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (]
[&&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (, pattern, ., isString]
[!=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (, pattern]
[&&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (, pattern, ., isString]
[), ), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (]
[!=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (, pattern, ., isString, (, )]
[), ), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (]
[., getNext, (, ), ), ), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !]
[;, }, if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, )]
[), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, "", .]
[&&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), ), ), {, pattern, =]
[&&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape]
[&&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, .]
[&&, !, "", ., equals, (, pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length]
[., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, ), ), &&, pattern, ., getString]
[&&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, .]
[&&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, .]
[., equals, (, pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <]
[), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags]
[., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null]
[&&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape]
[<, 100, &&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||]
[., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (]
[., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, ., isString, (]
[&&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape]
[&&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), ), ), {, pattern, =]
[), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), ), ), {, pattern]
[||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (]
[==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, .]
[||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (]
[), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), ), ), {, pattern]
[., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), )]
[), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, "", .]
[), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, ""]
[||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), ), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;]
[), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, ""]
[), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, ""]
[), ), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||]
[., getString, (, ), ), ), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (]
[=, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, "", ., equals, (, flags]
[;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, "", ., equals, (, flags, ., getString, (, ), )]
[), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, "", ., equals, (, flags, ., getString, (, )]
[), {, regexLiteral, =, IR, ., regexp, (, pattern, ), ;, }, else, {, if, (, !, areValidRegexpFlags, (, flags]
[||, "", ., equals, (, flags, ., getString, (, ), ), ), {, regexLiteral, =, IR, ., regexp, (, pattern]
[==, flags, ||, "", ., equals, (, flags, ., getString, (, ), ), ), {, regexLiteral, =, IR, ., regexp]
[||, "", ., equals, (, flags, ., getString, (, ), ), ), {, regexLiteral, =, IR, ., regexp, (, pattern]
[), {, regexLiteral, =, IR, ., regexp, (, pattern, ), ;, }, else, {, if, (, !, areValidRegexpFlags, (, flags]
[., equals, (, flags, ., getString, (, ), ), ), {, regexLiteral, =, IR, ., regexp, (, pattern, ), ;]
[), ), {, regexLiteral, =, IR, ., regexp, (, pattern, ), ;, }, else, {, if, (, !, areValidRegexpFlags, (]
[., getString, (, ), ), ), {, regexLiteral, =, IR, ., regexp, (, pattern, ), ;, }, else, {, if]
[=, IR, ., regexp, (, pattern, ), ;, }, else, {, if, (, !, areValidRegexpFlags, (, flags, ., getString, (]
[;, }, else, {, if, (, !, areValidRegexpFlags, (, flags, ., getString, (, ), ), ), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS]
[., regexp, (, pattern, ), ;, }, else, {, if, (, !, areValidRegexpFlags, (, flags, ., getString, (, ), )]
[), ;, }, else, {, if, (, !, areValidRegexpFlags, (, flags, ., getString, (, ), ), ), {, report, (]
[), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, ), ;, return, n, ;, }, if, (, !, areSafeFlagsToFold, (, flags, .]
[), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, ), ;, return, n, ;, }, if, (, !, areSafeFlagsToFold, (, flags, .]
[), ), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, ), ;, return, n, ;, }, if, (, !, areSafeFlagsToFold, (, flags]
[., getString, (, ), ), ), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, ), ;, return, n, ;, }, if, (]
[;, return, n, ;, }, if, (, !, areSafeFlagsToFold, (, flags, ., getString, (, ), ), ), {, return, n]
[,, flags, ), ;, return, n, ;, }, if, (, !, areSafeFlagsToFold, (, flags, ., getString, (, ), ), )]
[), ;, return, n, ;, }, if, (, !, areSafeFlagsToFold, (, flags, ., getString, (, ), ), ), {, return]
[;, }, if, (, !, areSafeFlagsToFold, (, flags, ., getString, (, ), ), ), {, return, n, ;, }, n]
[), {, return, n, ;, }, n, ., removeChild, (, flags, ), ;, regexLiteral, =, IR, ., regexp, (, pattern]
[), {, return, n, ;, }, n, ., removeChild, (, flags, ), ;, regexLiteral, =, IR, ., regexp, (, pattern]
[), ), {, return, n, ;, }, n, ., removeChild, (, flags, ), ;, regexLiteral, =, IR, ., regexp, (]
[., getString, (, ), ), ), {, return, n, ;, }, n, ., removeChild, (, flags, ), ;, regexLiteral, =]
[;, }, n, ., removeChild, (, flags, ), ;, regexLiteral, =, IR, ., regexp, (, pattern, ,, flags, ), ;]
[;, regexLiteral, =, IR, ., regexp, (, pattern, ,, flags, ), ;, }, parent, ., replaceChild, (, n, ,, regexLiteral]
[., removeChild, (, flags, ), ;, regexLiteral, =, IR, ., regexp, (, pattern, ,, flags, ), ;, }, parent, .]
[), ;, regexLiteral, =, IR, ., regexp, (, pattern, ,, flags, ), ;, }, parent, ., replaceChild, (, n, ,]
[=, IR, ., regexp, (, pattern, ,, flags, ), ;, }, parent, ., replaceChild, (, n, ,, regexLiteral, ), ;]
[;, }, parent, ., replaceChild, (, n, ,, regexLiteral, ), ;, reportCodeChange, (, ), ;, return, regexLiteral, ;, }, return]
[., regexp, (, pattern, ,, flags, ), ;, }, parent, ., replaceChild, (, n, ,, regexLiteral, ), ;, reportCodeChange, (]
[,, flags, ), ;, }, parent, ., replaceChild, (, n, ,, regexLiteral, ), ;, reportCodeChange, (, ), ;, return, regexLiteral]
[), ;, }, parent, ., replaceChild, (, n, ,, regexLiteral, ), ;, reportCodeChange, (, ), ;, return, regexLiteral, ;, }]
[;, reportCodeChange, (, ), ;, return, regexLiteral, ;, }, return, n, ;, }, private, Node, reduceTrueFalse, (, Node, n, )]
[., replaceChild, (, n, ,, regexLiteral, ), ;, reportCodeChange, (, ), ;, return, regexLiteral, ;, }, return, n, ;, }]
[,, regexLiteral, ), ;, reportCodeChange, (, ), ;, return, regexLiteral, ;, }, return, n, ;, }, private, Node, reduceTrueFalse, (]
[), ;, reportCodeChange, (, ), ;, return, regexLiteral, ;, }, return, n, ;, }, private, Node, reduceTrueFalse, (, Node, n]
[;, return, regexLiteral, ;, }, return, n, ;, }, private, Node, reduceTrueFalse, (, Node, n, ), {, if, (, late]
[;, }, return, n, ;, }, private, Node, reduceTrueFalse, (, Node, n, ), {, if, (, late, ), {, Node]
[;, }, private, Node, reduceTrueFalse, (, Node, n, ), {, if, (, late, ), {, Node, not, =, IR, .]
[), {, Node, not, =, IR, ., not, (, IR, ., number, (, n, ., isTrue, (, ), ?, 0]
[;, not, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, not, )]
[., not, (, IR, ., number, (, n, ., isTrue, (, ), ?, 0, :, 1, ), ), ;, not]
[), ;, not, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, not]
[., number, (, n, ., isTrue, (, ), ?, 0, :, 1, ), ), ;, not, ., copyInformationFromForTree, (, n]
[), ), ;, not, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[?, 0, :, 1, ), ), ;, not, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), .]
[., isTrue, (, ), ?, 0, :, 1, ), ), ;, not, ., copyInformationFromForTree, (, n, ), ;, n, .]
[:, 1, ), ), ;, not, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ), ;, not, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, not, ), ;, reportCodeChange, (, ), ;, return, not]
[., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, not, ), ;, reportCodeChange]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, not, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, not, ;, }, return, n, ;, }, private, Node, tryMinimizeArrayLiteral, (, Node, n, )]
[., replaceChild, (, n, ,, not, ), ;, reportCodeChange, (, ), ;, return, not, ;, }, return, n, ;, }]
[., getParent, (, ), ., replaceChild, (, n, ,, not, ), ;, reportCodeChange, (, ), ;, return, not, ;, }]
[,, not, ), ;, reportCodeChange, (, ), ;, return, not, ;, }, return, n, ;, }, private, Node, tryMinimizeArrayLiteral, (]
[), ;, reportCodeChange, (, ), ;, return, not, ;, }, return, n, ;, }, private, Node, tryMinimizeArrayLiteral, (, Node, n]
[;, return, not, ;, }, return, n, ;, }, private, Node, tryMinimizeArrayLiteral, (, Node, n, ), {, boolean, allStrings, =]
[;, }, return, n, ;, }, private, Node, tryMinimizeArrayLiteral, (, Node, n, ), {, boolean, allStrings, =, true, ;, for]
[;, }, private, Node, tryMinimizeArrayLiteral, (, Node, n, ), {, boolean, allStrings, =, true, ;, for, (, Node, cur, =]
[;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, .]
[;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, if, (, !, cur, ., isString]
[., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, if, (]
[;, cur, =, cur, ., getNext, (, ), ), {, if, (, !, cur, ., isString, (, ), ), {]
[!=, null, ;, cur, =, cur, ., getNext, (, ), ), {, if, (, !, cur, ., isString, (, )]
[;, cur, =, cur, ., getNext, (, ), ), {, if, (, !, cur, ., isString, (, ), ), {]
[=, cur, ., getNext, (, ), ), {, if, (, !, cur, ., isString, (, ), ), {, allStrings, =]
[), {, if, (, !, cur, ., isString, (, ), ), {, allStrings, =, false, ;, }, }, if, (]
[., getNext, (, ), ), {, if, (, !, cur, ., isString, (, ), ), {, allStrings, =, false, ;]
[), {, allStrings, =, false, ;, }, }, if, (, allStrings, ), {, return, tryMinimizeStringArrayLiteral, (, n, ), ;, }]
[), {, allStrings, =, false, ;, }, }, if, (, allStrings, ), {, return, tryMinimizeStringArrayLiteral, (, n, ), ;, }]
[., isString, (, ), ), {, allStrings, =, false, ;, }, }, if, (, allStrings, ), {, return, tryMinimizeStringArrayLiteral, (]
[=, false, ;, }, }, if, (, allStrings, ), {, return, tryMinimizeStringArrayLiteral, (, n, ), ;, }, else, {, return]
[;, }, }, if, (, allStrings, ), {, return, tryMinimizeStringArrayLiteral, (, n, ), ;, }, else, {, return, n, ;]
[), {, return, tryMinimizeStringArrayLiteral, (, n, ), ;, }, else, {, return, n, ;, }, }, private, Node, tryMinimizeStringArrayLiteral, (]
[;, }, else, {, return, n, ;, }, }, private, Node, tryMinimizeStringArrayLiteral, (, Node, n, ), {, if, (, !]
[), ;, }, else, {, return, n, ;, }, }, private, Node, tryMinimizeStringArrayLiteral, (, Node, n, ), {, if, (]
[;, }, }, private, Node, tryMinimizeStringArrayLiteral, (, Node, n, ), {, if, (, !, late, ), {, return, n, ;]
[), {, return, n, ;, }, int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =, numElements, *]
[), {, return, n, ;, }, int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =, numElements, *]
[;, }, int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =, numElements, *, 2, -, STRING_SPLIT_OVERHEAD, ;]
[;, int, saving, =, numElements, *, 2, -, STRING_SPLIT_OVERHEAD, ;, if, (, saving, <=, 0, ), {, return, n, ;]
[., getChildCount, (, ), ;, int, saving, =, numElements, *, 2, -, STRING_SPLIT_OVERHEAD, ;, if, (, saving, <=, 0, )]
[;, if, (, saving, <=, 0, ), {, return, n, ;, }, String, [, ], strings, =, new, String, []
[-, STRING_SPLIT_OVERHEAD, ;, if, (, saving, <=, 0, ), {, return, n, ;, }, String, [, ], strings, =, new]
[*, 2, -, STRING_SPLIT_OVERHEAD, ;, if, (, saving, <=, 0, ), {, return, n, ;, }, String, [, ], strings]
[-, STRING_SPLIT_OVERHEAD, ;, if, (, saving, <=, 0, ), {, return, n, ;, }, String, [, ], strings, =, new]
[;, if, (, saving, <=, 0, ), {, return, n, ;, }, String, [, ], strings, =, new, String, []
[), {, return, n, ;, }, String, [, ], strings, =, new, String, [, n, ., getChildCount, (, ), ]]
[<=, 0, ), {, return, n, ;, }, String, [, ], strings, =, new, String, [, n, ., getChildCount, (]
[), {, return, n, ;, }, String, [, ], strings, =, new, String, [, n, ., getChildCount, (, ), ]]
[;, }, String, [, ], strings, =, new, String, [, n, ., getChildCount, (, ), ], ;, int, idx, =]
[;, int, idx, =, 0, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=, null]
[], ;, int, idx, =, 0, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=]
[., getChildCount, (, ), ], ;, int, idx, =, 0, ;, for, (, Node, cur, =, n, ., getFirstChild, (]
[;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, .]
[;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, strings, [, idx, ++, ], =]
[., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, strings, []
[;, cur, =, cur, ., getNext, (, ), ), {, strings, [, idx, ++, ], =, cur, ., getString, (]
[!=, null, ;, cur, =, cur, ., getNext, (, ), ), {, strings, [, idx, ++, ], =, cur, .]
[;, cur, =, cur, ., getNext, (, ), ), {, strings, [, idx, ++, ], =, cur, ., getString, (]
[=, cur, ., getNext, (, ), ), {, strings, [, idx, ++, ], =, cur, ., getString, (, ), ;]
[), {, strings, [, idx, ++, ], =, cur, ., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (]
[., getNext, (, ), ), {, strings, [, idx, ++, ], =, cur, ., getString, (, ), ;, }, String]
[=, cur, ., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (, delimiter, !=]
[[, idx, ++, ], =, cur, ., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;]
[], =, cur, ., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (, delimiter]
[++, ], =, cur, ., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (]
[;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (, delimiter, !=, null, ), {, String, template, =]
[., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (, delimiter, !=, null, )]
[;, if, (, delimiter, !=, null, ), {, String, template, =, Joiner, ., on, (, delimiter, ), ., join, (]
[), ;, if, (, delimiter, !=, null, ), {, String, template, =, Joiner, ., on, (, delimiter, ), ., join]
[), {, String, template, =, Joiner, ., on, (, delimiter, ), ., join, (, strings, ), ;, Node, call, =]
[!=, null, ), {, String, template, =, Joiner, ., on, (, delimiter, ), ., join, (, strings, ), ;, Node]
[), {, String, template, =, Joiner, ., on, (, delimiter, ), ., join, (, strings, ), ;, Node, call, =]
[;, Node, call, =, IR, ., call, (, IR, ., getprop, (, IR, ., string, (, template, ), ,, IR]
[., join, (, strings, ), ;, Node, call, =, IR, ., call, (, IR, ., getprop, (, IR, ., string]
[., on, (, delimiter, ), ., join, (, strings, ), ;, Node, call, =, IR, ., call, (, IR, .]
[), ., join, (, strings, ), ;, Node, call, =, IR, ., call, (, IR, ., getprop, (, IR, .]
[), ;, Node, call, =, IR, ., call, (, IR, ., getprop, (, IR, ., string, (, template, ), ,]
[;, call, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, call, )]
[., call, (, IR, ., getprop, (, IR, ., string, (, template, ), ,, IR, ., string, (, "split", )]
[,, IR, ., string, (, "", +, delimiter, ), ), ;, call, ., copyInformationFromForTree, (, n, ), ;, n, .]
[., getprop, (, IR, ., string, (, template, ), ,, IR, ., string, (, "split", ), ), ,, IR, .]
[,, IR, ., string, (, "split", ), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;, call]
[., string, (, template, ), ,, IR, ., string, (, "split", ), ), ,, IR, ., string, (, "", +]
[), ,, IR, ., string, (, "split", ), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;]
[), ,, IR, ., string, (, "", +, delimiter, ), ), ;, call, ., copyInformationFromForTree, (, n, ), ;, n]
[., string, (, "split", ), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;, call, ., copyInformationFromForTree]
[), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;, call, ., copyInformationFromForTree, (, n, ), ;]
[), ;, call, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, call]
[., string, (, "", +, delimiter, ), ), ;, call, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (]
[), ), ;, call, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[+, delimiter, ), ), ;, call, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ), ;, call, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, call, ), ;, reportCodeChange, (, ), ;, return, call]
[., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, call, ), ;, reportCodeChange]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, call, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, call, ;, }, return, n, ;, }, private, String, pickDelimiter, (, String, [, ]]
[., replaceChild, (, n, ,, call, ), ;, reportCodeChange, (, ), ;, return, call, ;, }, return, n, ;, }]
[., getParent, (, ), ., replaceChild, (, n, ,, call, ), ;, reportCodeChange, (, ), ;, return, call, ;, }]
[,, call, ), ;, reportCodeChange, (, ), ;, return, call, ;, }, return, n, ;, }, private, String, pickDelimiter, (]
[), ;, reportCodeChange, (, ), ;, return, call, ;, }, return, n, ;, }, private, String, pickDelimiter, (, String, []
[;, return, call, ;, }, return, n, ;, }, private, String, pickDelimiter, (, String, [, ], strings, ), {, boolean]
[;, }, return, n, ;, }, private, String, pickDelimiter, (, String, [, ], strings, ), {, boolean, allLength1, =, true]
[;, }, private, String, pickDelimiter, (, String, [, ], strings, ), {, boolean, allLength1, =, true, ;, for, (, String]
[;, for, (, String, s, :, strings, ), {, if, (, s, ., length, (, ), !=, 1, ), {]
[), {, if, (, s, ., length, (, ), !=, 1, ), {, allLength1, =, false, ;, break, ;, }]
[), {, allLength1, =, false, ;, break, ;, }, }, if, (, allLength1, ), {, return, "", ;, }, String]
[!=, 1, ), {, allLength1, =, false, ;, break, ;, }, }, if, (, allLength1, ), {, return, "", ;]
[., length, (, ), !=, 1, ), {, allLength1, =, false, ;, break, ;, }, }, if, (, allLength1, )]
[), {, allLength1, =, false, ;, break, ;, }, }, if, (, allLength1, ), {, return, "", ;, }, String]
[=, false, ;, break, ;, }, }, if, (, allLength1, ), {, return, "", ;, }, String, [, ], delimiters]
[;, break, ;, }, }, if, (, allLength1, ), {, return, "", ;, }, String, [, ], delimiters, =, new]
[), {, return, "", ;, }, String, [, ], delimiters, =, new, String, [, ], {, " ", ,, ";", ,]
[;, }, String, [, ], delimiters, =, new, String, [, ], {, " ", ,, ";", ,, ",", ,, "{", ,]
[;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, [, i, ], !=, null, ;, i, ++]
[;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, [, i, ], !=, null, ;, i, ++]
[,, ";", ,, ",", ,, "{", ,, "}", ,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for]
[,, ",", ,, "{", ,, "}", ,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;]
[,, "{", ,, "}", ,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, []
[,, "}", ,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, [, i, ]]
[,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, [, i, ], !=, null]
[}, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, [, i, ], !=, null, ;, i]
[;, NEXT_DELIMITER, :, for, (, ;, delimiters, [, i, ], !=, null, ;, i, ++, ), {, for, (, String]
[;, i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (, cur, ., contains, (, delimiters]
[!=, null, ;, i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (, cur, ., contains]
[[, i, ], !=, null, ;, i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (]
[], !=, null, ;, i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (, cur, .]
[;, i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (, cur, ., contains, (, delimiters]
[), {, for, (, String, cur, :, strings, ), {, if, (, cur, ., contains, (, delimiters, [, i, ]]
[++, ), {, for, (, String, cur, :, strings, ), {, if, (, cur, ., contains, (, delimiters, [, i]
[), {, if, (, cur, ., contains, (, delimiters, [, i, ], ), ), {, continue, NEXT_DELIMITER, ;, }, }]
[), {, continue, NEXT_DELIMITER, ;, }, }, break, ;, }, return, delimiters, [, i, ], ;, }, private, static, final]
[., contains, (, delimiters, [, i, ], ), ), {, continue, NEXT_DELIMITER, ;, }, }, break, ;, }, return, delimiters]
[), ), {, continue, NEXT_DELIMITER, ;, }, }, break, ;, }, return, delimiters, [, i, ], ;, }, private, static]
[[, i, ], ), ), {, continue, NEXT_DELIMITER, ;, }, }, break, ;, }, return, delimiters, [, i, ], ;]
[], ), ), {, continue, NEXT_DELIMITER, ;, }, }, break, ;, }, return, delimiters, [, i, ], ;, }, private]
[;, }, private, static, final, Pattern, REGEXP_FLAGS_RE, =, Pattern, ., compile, (, "^[gmi]*$", ), ;, private, static, boolean, areValidRegexpFlags, (]
[[, i, ], ;, }, private, static, final, Pattern, REGEXP_FLAGS_RE, =, Pattern, ., compile, (, "^[gmi]*$", ), ;, private, static]
[], ;, }, private, static, final, Pattern, REGEXP_FLAGS_RE, =, Pattern, ., compile, (, "^[gmi]*$", ), ;, private, static, boolean, areValidRegexpFlags]
[;, private, static, boolean, areValidRegexpFlags, (, String, flags, ), {, return, REGEXP_FLAGS_RE, ., matcher, (, flags, ), ., matches, (]
[., compile, (, "^[gmi]*$", ), ;, private, static, boolean, areValidRegexpFlags, (, String, flags, ), {, return, REGEXP_FLAGS_RE, ., matcher, (]
[), ;, private, static, boolean, areValidRegexpFlags, (, String, flags, ), {, return, REGEXP_FLAGS_RE, ., matcher, (, flags, ), ., matches]
[;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return, isEcmaScript5OrGreater, (, ), ||, flags, ., indexOf, (, 'g']
[., matches, (, ), ;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return, isEcmaScript5OrGreater, (, ), ||, flags]
[., matcher, (, flags, ), ., matches, (, ), ;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return]
[), ., matches, (, ), ;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return, isEcmaScript5OrGreater, (, ), ||]
[;, }, private, static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {, String, s, =, n, ., getString, (, ), ;]
[||, flags, ., indexOf, (, 'g', ), <, 0, ;, }, private, static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {]
[;, }, private, static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {, String, s, =, n, ., getString, (, ), ;]
[<, 0, ;, }, private, static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {, String, s, =, n, ., getString, (]
[., indexOf, (, 'g', ), <, 0, ;, }, private, static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {, String, s]
[), <, 0, ;, }, private, static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {, String, s, =, n, ., getString]
[;, }, private, static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {, String, s, =, n, ., getString, (, ), ;]
[;, StringBuilder, sb, =, null, ;, int, pos, =, 0, ;, boolean, isEscaped, =, false, ,, inCharset, =, false, ;]
[., getString, (, ), ;, StringBuilder, sb, =, null, ;, int, pos, =, 0, ;, boolean, isEscaped, =, false, ,]
[;, int, pos, =, 0, ;, boolean, isEscaped, =, false, ,, inCharset, =, false, ;, for, (, int, i, =]
[;, boolean, isEscaped, =, false, ,, inCharset, =, false, ;, for, (, int, i, =, 0, ;, i, <, s]
[,, inCharset, =, false, ;, for, (, int, i, =, 0, ;, i, <, s, ., length, (, ), ;]
[;, for, (, int, i, =, 0, ;, i, <, s, ., length, (, ), ;, ++, i, ), {]
[;, i, <, s, ., length, (, ), ;, ++, i, ), {, char, ch, =, s, ., charAt, (]
[;, ++, i, ), {, char, ch, =, s, ., charAt, (, i, ), ;, switch, (, ch, ), {]
[<, s, ., length, (, ), ;, ++, i, ), {, char, ch, =, s, ., charAt, (, i, )]
[;, ++, i, ), {, char, ch, =, s, ., charAt, (, i, ), ;, switch, (, ch, ), {]
[., length, (, ), ;, ++, i, ), {, char, ch, =, s, ., charAt, (, i, ), ;, switch]
[), {, char, ch, =, s, ., charAt, (, i, ), ;, switch, (, ch, ), {, case, '\\', :]
[), {, char, ch, =, s, ., charAt, (, i, ), ;, switch, (, ch, ), {, case, '\\', :]
[;, switch, (, ch, ), {, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue, ;, case, '/', :, if]
[., charAt, (, i, ), ;, switch, (, ch, ), {, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue]
[), ;, switch, (, ch, ), {, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue, ;, case, '/', :]
[), {, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue, ;, case, '/', :, if, (, !, isEscaped, &&]
[:, isEscaped, =, !, isEscaped, ;, continue, ;, case, '/', :, if, (, !, isEscaped, &&, !, inCharset, ), {]
[=, !, isEscaped, ;, continue, ;, case, '/', :, if, (, !, isEscaped, &&, !, inCharset, ), {, if, (]
[;, continue, ;, case, '/', :, if, (, !, isEscaped, &&, !, inCharset, ), {, if, (, null, ==, sb]
[;, continue, ;, case, '/', :, if, (, !, isEscaped, &&, !, inCharset, ), {, if, (, null, ==, sb]
[:, if, (, !, isEscaped, &&, !, inCharset, ), {, if, (, null, ==, sb, ), {, sb, =, new]
[), {, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +]
[&&, !, inCharset, ), {, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length]
[&&, !, inCharset, ), {, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length]
[), {, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +]
[), {, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +]
[), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, sb, ., append]
[==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, sb]
[), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, sb, ., append]
[=, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, sb, ., append, (, s, ,]
[;, }, sb, ., append, (, s, ,, pos, ,, i, ), ., append, (, '\\', ), ;, pos, =]
[), ;, }, sb, ., append, (, s, ,, pos, ,, i, ), ., append, (, '\\', ), ;, pos]
[+, 16, ), ;, }, sb, ., append, (, s, ,, pos, ,, i, ), ., append, (, '\\', )]
[., length, (, ), +, 16, ), ;, }, sb, ., append, (, s, ,, pos, ,, i, ), .]
[), ;, }, sb, ., append, (, s, ,, pos, ,, i, ), ., append, (, '\\', ), ;, pos]
[;, pos, =, i, ;, }, break, ;, case, '[', :, if, (, !, isEscaped, ), {, inCharset, =, true]
[., append, (, '\\', ), ;, pos, =, i, ;, }, break, ;, case, '[', :, if, (, !, isEscaped]
[., append, (, s, ,, pos, ,, i, ), ., append, (, '\\', ), ;, pos, =, i, ;, }]
[,, pos, ,, i, ), ., append, (, '\\', ), ;, pos, =, i, ;, }, break, ;, case, '[']
[,, i, ), ., append, (, '\\', ), ;, pos, =, i, ;, }, break, ;, case, '[', :, if]
[), ., append, (, '\\', ), ;, pos, =, i, ;, }, break, ;, case, '[', :, if, (, !]
[), ;, pos, =, i, ;, }, break, ;, case, '[', :, if, (, !, isEscaped, ), {, inCharset, =]
[=, i, ;, }, break, ;, case, '[', :, if, (, !, isEscaped, ), {, inCharset, =, true, ;, }]
[;, }, break, ;, case, '[', :, if, (, !, isEscaped, ), {, inCharset, =, true, ;, }, break, ;]
[:, if, (, !, isEscaped, ), {, inCharset, =, true, ;, }, break, ;, case, ']', :, if, (, !]
[), {, inCharset, =, true, ;, }, break, ;, case, ']', :, if, (, !, isEscaped, ), {, inCharset, =]
[), {, inCharset, =, true, ;, }, break, ;, case, ']', :, if, (, !, isEscaped, ), {, inCharset, =]
[=, true, ;, }, break, ;, case, ']', :, if, (, !, isEscaped, ), {, inCharset, =, false, ;, }]
[;, }, break, ;, case, ']', :, if, (, !, isEscaped, ), {, inCharset, =, false, ;, }, break, ;]
[:, if, (, !, isEscaped, ), {, inCharset, =, false, ;, }, break, ;, case, '\r', :, case, '\n', :]
[), {, inCharset, =, false, ;, }, break, ;, case, '\r', :, case, '\n', :, case, '\u2028', :, case, '\u2029']
[), {, inCharset, =, false, ;, }, break, ;, case, '\r', :, case, '\n', :, case, '\u2028', :, case, '\u2029']
[=, false, ;, }, break, ;, case, '\r', :, case, '\n', :, case, '\u2028', :, case, '\u2029', :, if, (]
[;, }, break, ;, case, '\r', :, case, '\n', :, case, '\u2028', :, case, '\u2029', :, if, (, null, ==]
[:, case, '\n', :, case, '\u2028', :, case, '\u2029', :, if, (, null, ==, sb, ), {, sb, =, new]
[:, case, '\u2028', :, case, '\u2029', :, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s]
[:, case, '\u2029', :, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (]
[:, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16]
[), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, if, (, isEscaped]
[==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, if]
[), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, if, (, isEscaped]
[=, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, if, (, isEscaped, ), {, sb]
[;, }, if, (, isEscaped, ), {, sb, ., append, (, s, ,, pos, ,, i, -, 1, ), ;]
[), ;, }, if, (, isEscaped, ), {, sb, ., append, (, s, ,, pos, ,, i, -, 1, )]
[+, 16, ), ;, }, if, (, isEscaped, ), {, sb, ., append, (, s, ,, pos, ,, i, -]
[., length, (, ), +, 16, ), ;, }, if, (, isEscaped, ), {, sb, ., append, (, s, ,]
[), ;, }, if, (, isEscaped, ), {, sb, ., append, (, s, ,, pos, ,, i, -, 1, )]
[), {, sb, ., append, (, s, ,, pos, ,, i, -, 1, ), ;, }, else, {, sb, .]
[;, }, else, {, sb, ., append, (, s, ,, pos, ,, i, ), ;, }, switch, (, ch, )]
[., append, (, s, ,, pos, ,, i, -, 1, ), ;, }, else, {, sb, ., append, (, s]
[,, pos, ,, i, -, 1, ), ;, }, else, {, sb, ., append, (, s, ,, pos, ,, i]
[,, i, -, 1, ), ;, }, else, {, sb, ., append, (, s, ,, pos, ,, i, ), ;]
[), ;, }, else, {, sb, ., append, (, s, ,, pos, ,, i, ), ;, }, switch, (, ch]
[-, 1, ), ;, }, else, {, sb, ., append, (, s, ,, pos, ,, i, ), ;, }, switch]
[), ;, }, else, {, sb, ., append, (, s, ,, pos, ,, i, ), ;, }, switch, (, ch]
[;, }, switch, (, ch, ), {, case, '\r', :, sb, ., append, (, "\\r", ), ;, break, ;, case]
[., append, (, s, ,, pos, ,, i, ), ;, }, switch, (, ch, ), {, case, '\r', :, sb]
[,, pos, ,, i, ), ;, }, switch, (, ch, ), {, case, '\r', :, sb, ., append, (, "\\r"]
[,, i, ), ;, }, switch, (, ch, ), {, case, '\r', :, sb, ., append, (, "\\r", ), ;]
[), ;, }, switch, (, ch, ), {, case, '\r', :, sb, ., append, (, "\\r", ), ;, break, ;]
[), {, case, '\r', :, sb, ., append, (, "\\r", ), ;, break, ;, case, '\n', :, sb, ., append]
[:, sb, ., append, (, "\\r", ), ;, break, ;, case, '\n', :, sb, ., append, (, "\\n", ), ;]
[;, break, ;, case, '\n', :, sb, ., append, (, "\\n", ), ;, break, ;, case, '\u2028', :, sb, .]
[., append, (, "\\r", ), ;, break, ;, case, '\n', :, sb, ., append, (, "\\n", ), ;, break, ;]
[), ;, break, ;, case, '\n', :, sb, ., append, (, "\\n", ), ;, break, ;, case, '\u2028', :, sb]
[:, sb, ., append, (, "\\n", ), ;, break, ;, case, '\u2028', :, sb, ., append, (, "\\u2028", ), ;]
[;, break, ;, case, '\u2028', :, sb, ., append, (, "\\u2028", ), ;, break, ;, case, '\u2029', :, sb, .]
[., append, (, "\\n", ), ;, break, ;, case, '\u2028', :, sb, ., append, (, "\\u2028", ), ;, break, ;]
[), ;, break, ;, case, '\u2028', :, sb, ., append, (, "\\u2028", ), ;, break, ;, case, '\u2029', :, sb]
[:, sb, ., append, (, "\\u2028", ), ;, break, ;, case, '\u2029', :, sb, ., append, (, "\\u2029", ), ;]
[;, break, ;, case, '\u2029', :, sb, ., append, (, "\\u2029", ), ;, break, ;, }, pos, =, i, +]
[., append, (, "\\u2028", ), ;, break, ;, case, '\u2029', :, sb, ., append, (, "\\u2029", ), ;, break, ;]
[), ;, break, ;, case, '\u2029', :, sb, ., append, (, "\\u2029", ), ;, break, ;, }, pos, =, i]
[:, sb, ., append, (, "\\u2029", ), ;, break, ;, }, pos, =, i, +, 1, ;, break, ;, }]
[;, break, ;, }, pos, =, i, +, 1, ;, break, ;, }, isEscaped, =, false, ;, }, if, (]
[., append, (, "\\u2029", ), ;, break, ;, }, pos, =, i, +, 1, ;, break, ;, }, isEscaped, =]
[), ;, break, ;, }, pos, =, i, +, 1, ;, break, ;, }, isEscaped, =, false, ;, }, if]
[=, i, +, 1, ;, break, ;, }, isEscaped, =, false, ;, }, if, (, null, ==, sb, ), {]
[;, break, ;, }, isEscaped, =, false, ;, }, if, (, null, ==, sb, ), {, return, n, ., cloneTree]
[+, 1, ;, break, ;, }, isEscaped, =, false, ;, }, if, (, null, ==, sb, ), {, return, n]
[;, break, ;, }, isEscaped, =, false, ;, }, if, (, null, ==, sb, ), {, return, n, ., cloneTree]
[=, false, ;, }, if, (, null, ==, sb, ), {, return, n, ., cloneTree, (, ), ;, }, sb]
[;, }, if, (, null, ==, sb, ), {, return, n, ., cloneTree, (, ), ;, }, sb, ., append]
[), {, return, n, ., cloneTree, (, ), ;, }, sb, ., append, (, s, ,, pos, ,, s, .]
[==, sb, ), {, return, n, ., cloneTree, (, ), ;, }, sb, ., append, (, s, ,, pos, ,]
[), {, return, n, ., cloneTree, (, ), ;, }, sb, ., append, (, s, ,, pos, ,, s, .]
[;, }, sb, ., append, (, s, ,, pos, ,, s, ., length, (, ), ), ;, return, IR, .]
[., cloneTree, (, ), ;, }, sb, ., append, (, s, ,, pos, ,, s, ., length, (, ), )]
[;, return, IR, ., string, (, sb, ., toString, (, ), ), ., srcref, (, n, ), ;, }, static]
[., append, (, s, ,, pos, ,, s, ., length, (, ), ), ;, return, IR, ., string, (, sb]
[,, pos, ,, s, ., length, (, ), ), ;, return, IR, ., string, (, sb, ., toString, (, )]
[,, s, ., length, (, ), ), ;, return, IR, ., string, (, sb, ., toString, (, ), ), .]
[), ;, return, IR, ., string, (, sb, ., toString, (, ), ), ., srcref, (, n, ), ;, }]
[., length, (, ), ), ;, return, IR, ., string, (, sb, ., toString, (, ), ), ., srcref, (]
[;, }, static, boolean, containsUnicodeEscape, (, String, s, ), {, String, esc, =, REGEXP_ESCAPER, ., regexpEscape, (, s, ), ;]
[., srcref, (, n, ), ;, }, static, boolean, containsUnicodeEscape, (, String, s, ), {, String, esc, =, REGEXP_ESCAPER, .]
[., string, (, sb, ., toString, (, ), ), ., srcref, (, n, ), ;, }, static, boolean, containsUnicodeEscape, (]
[), ., srcref, (, n, ), ;, }, static, boolean, containsUnicodeEscape, (, String, s, ), {, String, esc, =, REGEXP_ESCAPER]
[., toString, (, ), ), ., srcref, (, n, ), ;, }, static, boolean, containsUnicodeEscape, (, String, s, ), {]
[), ;, }, static, boolean, containsUnicodeEscape, (, String, s, ), {, String, esc, =, REGEXP_ESCAPER, ., regexpEscape, (, s, )]
[;, for, (, int, i, =, -, 1, ;, (, i, =, esc, ., indexOf, (, "\\u", ,, i, +]
[., regexpEscape, (, s, ), ;, for, (, int, i, =, -, 1, ;, (, i, =, esc, ., indexOf]
[), ;, for, (, int, i, =, -, 1, ;, (, i, =, esc, ., indexOf, (, "\\u", ,, i]
[;, (, i, =, esc, ., indexOf, (, "\\u", ,, i, +, 1, ), ), >=, 0, ;, ), {]
[;, (, i, =, esc, ., indexOf, (, "\\u", ,, i, +, 1, ), ), >=, 0, ;, ), {]
[;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==, esc, .]
[>=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==]
[=, esc, ., indexOf, (, "\\u", ,, i, +, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =]
[), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\']
[., indexOf, (, "\\u", ,, i, +, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;]
[,, i, +, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -]
[), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&]
[+, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >]
[), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&]
[;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==, esc, .]
[;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1]
[), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {, return, true, ;]
[&&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if]
[>, 0, &&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;]
[-, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++]
[>, 0, &&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;]
[&&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if]
[), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {, return, true, ;]
[==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if, (, 0]
[), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {, return, true, ;]
[., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (]
[), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {, return, true]
[-, 1, ), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {]
[-, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, )]
[-, 1, ), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {]
[), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {, return, true]
[;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {, return, true, ;, }, }, return, false]
[;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {, return, true, ;, }, }, return, false]
[), {, return, true, ;, }, }, return, false, ;, }, }]
[==, (, nSlashes, &, 1, ), ), {, return, true, ;, }, }, return, false, ;, }, }]
[), {, return, true, ;, }, }, return, false, ;, }, }]
[), ), {, return, true, ;, }, }, return, false, ;, }, }]
[&, 1, ), ), {, return, true, ;, }, }, return, false, ;, }, }]
[), ), {, return, true, ;, }, }, return, false, ;, }, }]
[;, }, }, return, false, ;, }, }]
[;, }, }]
