[;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =, DiagnosticType, ., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,, "Array index out of bounds: {0}", ), ;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =]
[., warning, (, "JSC_INVALID_GETELEM_INDEX_ERROR", ,, "Array index not integer: {0}", ), ;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =, DiagnosticType, ., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,, "Array index out of bounds: {0}"]
[,, "Array index not integer: {0}", ), ;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =, DiagnosticType, ., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,, "Array index out of bounds: {0}", ), ;, static, final]
[), ;, static, final, DiagnosticType, INDEX_OUT_OF_BOUNDS_ERROR, =, DiagnosticType, ., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,, "Array index out of bounds: {0}", ), ;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR]
[;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =, DiagnosticType, ., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,, "Can't negate non-numeric value: {0}", ), ;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =]
[., warning, (, "JSC_INDEX_OUT_OF_BOUNDS_ERROR", ,, "Array index out of bounds: {0}", ), ;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =, DiagnosticType, ., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,, "Can't negate non-numeric value: {0}"]
[,, "Array index out of bounds: {0}", ), ;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =, DiagnosticType, ., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,, "Can't negate non-numeric value: {0}", ), ;, static, final]
[), ;, static, final, DiagnosticType, NEGATING_A_NON_NUMBER_ERROR, =, DiagnosticType, ., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,, "Can't negate non-numeric value: {0}", ), ;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE]
[;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =, DiagnosticType, ., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,, "Operand out of range, bitwise operation will lose information: {0}", ), ;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =]
[., warning, (, "JSC_NEGATING_A_NON_NUMBER_ERROR", ,, "Can't negate non-numeric value: {0}", ), ;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =, DiagnosticType, ., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,, "Operand out of range, bitwise operation will lose information: {0}"]
[,, "Can't negate non-numeric value: {0}", ), ;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =, DiagnosticType, ., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,, "Operand out of range, bitwise operation will lose information: {0}", ), ;, static, final]
[), ;, static, final, DiagnosticType, BITWISE_OPERAND_OUT_OF_RANGE, =, DiagnosticType, ., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,, "Operand out of range, bitwise operation will lose information: {0}", ), ;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS]
[;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =, DiagnosticType, ., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,, "Shift amount out of bounds: {0}", ), ;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =]
[., warning, (, "JSC_BITWISE_OPERAND_OUT_OF_RANGE", ,, "Operand out of range, bitwise operation will lose information: {0}", ), ;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =, DiagnosticType, ., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,, "Shift amount out of bounds: {0}"]
[,, "Operand out of range, bitwise operation will lose information: {0}", ), ;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =, DiagnosticType, ., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,, "Shift amount out of bounds: {0}", ), ;, static, final]
[), ;, static, final, DiagnosticType, SHIFT_AMOUNT_OUT_OF_BOUNDS, =, DiagnosticType, ., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,, "Shift amount out of bounds: {0}", ), ;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND]
[;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =, DiagnosticType, ., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,, "Fractional bitwise operand: {0}", ), ;, private, static, final, double, MAX_FOLD_NUMBER]
[., warning, (, "JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS", ,, "Shift amount out of bounds: {0}", ), ;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =, DiagnosticType, ., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,, "Fractional bitwise operand: {0}"]
[,, "Shift amount out of bounds: {0}", ), ;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =, DiagnosticType, ., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,, "Fractional bitwise operand: {0}", ), ;, private, static]
[), ;, static, final, DiagnosticType, FRACTIONAL_BITWISE_OPERAND, =, DiagnosticType, ., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,, "Fractional bitwise operand: {0}", ), ;, private, static, final, double]
[;, private, static, final, double, MAX_FOLD_NUMBER, =, Math, ., pow, (, 2, ,, 53, ), ;, private, final, boolean, late]
[., warning, (, "JSC_FRACTIONAL_BITWISE_OPERAND", ,, "Fractional bitwise operand: {0}", ), ;, private, static, final, double, MAX_FOLD_NUMBER, =, Math, ., pow, (, 2, ,]
[,, "Fractional bitwise operand: {0}", ), ;, private, static, final, double, MAX_FOLD_NUMBER, =, Math, ., pow, (, 2, ,, 53, ), ;, private]
[), ;, private, static, final, double, MAX_FOLD_NUMBER, =, Math, ., pow, (, 2, ,, 53, ), ;, private, final, boolean]
[;, private, final, boolean, late, ;, PeepholeFoldConstants, (, boolean, late, ), {, this, ., late, =, late, ;, }, @]
[., pow, (, 2, ,, 53, ), ;, private, final, boolean, late, ;, PeepholeFoldConstants, (, boolean, late, ), {, this]
[,, 53, ), ;, private, final, boolean, late, ;, PeepholeFoldConstants, (, boolean, late, ), {, this, ., late, =, late]
[), ;, private, final, boolean, late, ;, PeepholeFoldConstants, (, boolean, late, ), {, this, ., late, =, late, ;, }]
[=, late, ;, }, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (, subtree, ., getType, (, )]
[., late, =, late, ;, }, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (, subtree, ., getType]
[;, }, @, Override, Node, optimizeSubtree, (, Node, subtree, ), {, switch, (, subtree, ., getType, (, ), ), {]
[), {, case, Token, ., NEW, :, return, tryFoldCtorCall, (, subtree, ), ;, case, Token, ., TYPEOF, :, return, tryFoldTypeof]
[., getType, (, ), ), {, case, Token, ., NEW, :, return, tryFoldCtorCall, (, subtree, ), ;, case, Token, .]
[:, return, tryFoldCtorCall, (, subtree, ), ;, case, Token, ., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case, Token]
[., NEW, :, return, tryFoldCtorCall, (, subtree, ), ;, case, Token, ., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;]
[;, case, Token, ., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case, Token, ., NOT, :, case, Token, .]
[), ;, case, Token, ., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case, Token, ., NOT, :, case, Token]
[:, return, tryFoldTypeof, (, subtree, ), ;, case, Token, ., NOT, :, case, Token, ., POS, :, case, Token, .]
[., TYPEOF, :, return, tryFoldTypeof, (, subtree, ), ;, case, Token, ., NOT, :, case, Token, ., POS, :, case]
[;, case, Token, ., NOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., BITNOT]
[), ;, case, Token, ., NOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, .]
[:, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (, subtree, )]
[., NOT, :, case, Token, ., POS, :, case, Token, ., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (]
[:, case, Token, ., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (, subtree]
[., POS, :, case, Token, ., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator]
[:, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (, subtree, ), ;, case, Token, .]
[., NEG, :, case, Token, ., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (, subtree, ), ;, case]
[:, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (, subtree, ), ;, case, Token, ., VOID, :, return, tryReduceVoid, (]
[., BITNOT, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldUnaryOperator, (, subtree, ), ;, case, Token, ., VOID, :, return]
[;, return, tryFoldUnaryOperator, (, subtree, ), ;, case, Token, ., VOID, :, return, tryReduceVoid, (, subtree, ), ;, default, :]
[), ;, return, tryFoldUnaryOperator, (, subtree, ), ;, case, Token, ., VOID, :, return, tryReduceVoid, (, subtree, ), ;, default]
[;, case, Token, ., VOID, :, return, tryReduceVoid, (, subtree, ), ;, default, :, tryReduceOperandsForOp, (, subtree, ), ;, return]
[), ;, case, Token, ., VOID, :, return, tryReduceVoid, (, subtree, ), ;, default, :, tryReduceOperandsForOp, (, subtree, ), ;]
[:, return, tryReduceVoid, (, subtree, ), ;, default, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldBinaryOperator, (, subtree, ), ;]
[., VOID, :, return, tryReduceVoid, (, subtree, ), ;, default, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldBinaryOperator, (, subtree]
[;, default, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldBinaryOperator, (, subtree, ), ;, }, }, private, Node, tryFoldBinaryOperator, (]
[), ;, default, :, tryReduceOperandsForOp, (, subtree, ), ;, return, tryFoldBinaryOperator, (, subtree, ), ;, }, }, private, Node, tryFoldBinaryOperator]
[;, return, tryFoldBinaryOperator, (, subtree, ), ;, }, }, private, Node, tryFoldBinaryOperator, (, Node, subtree, ), {, Node, left, =]
[), ;, return, tryFoldBinaryOperator, (, subtree, ), ;, }, }, private, Node, tryFoldBinaryOperator, (, Node, subtree, ), {, Node, left]
[;, }, }, private, Node, tryFoldBinaryOperator, (, Node, subtree, ), {, Node, left, =, subtree, ., getFirstChild, (, ), ;]
[), ;, }, }, private, Node, tryFoldBinaryOperator, (, Node, subtree, ), {, Node, left, =, subtree, ., getFirstChild, (, )]
[;, if, (, left, ==, null, ), {, return, subtree, ;, }, Node, right, =, left, ., getNext, (, )]
[., getFirstChild, (, ), ;, if, (, left, ==, null, ), {, return, subtree, ;, }, Node, right, =, left]
[), {, return, subtree, ;, }, Node, right, =, left, ., getNext, (, ), ;, if, (, right, ==, null]
[==, null, ), {, return, subtree, ;, }, Node, right, =, left, ., getNext, (, ), ;, if, (, right]
[), {, return, subtree, ;, }, Node, right, =, left, ., getNext, (, ), ;, if, (, right, ==, null]
[;, }, Node, right, =, left, ., getNext, (, ), ;, if, (, right, ==, null, ), {, return, subtree]
[;, if, (, right, ==, null, ), {, return, subtree, ;, }, switch, (, subtree, ., getType, (, ), )]
[., getNext, (, ), ;, if, (, right, ==, null, ), {, return, subtree, ;, }, switch, (, subtree, .]
[), {, return, subtree, ;, }, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., GETPROP, :]
[==, null, ), {, return, subtree, ;, }, switch, (, subtree, ., getType, (, ), ), {, case, Token, .]
[), {, return, subtree, ;, }, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., GETPROP, :]
[;, }, switch, (, subtree, ., getType, (, ), ), {, case, Token, ., GETPROP, :, return, tryFoldGetProp, (, subtree]
[), {, case, Token, ., GETPROP, :, return, tryFoldGetProp, (, subtree, ,, left, ,, right, ), ;, case, Token, .]
[., getType, (, ), ), {, case, Token, ., GETPROP, :, return, tryFoldGetProp, (, subtree, ,, left, ,, right, )]
[:, return, tryFoldGetProp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree]
[., GETPROP, :, return, tryFoldGetProp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem]
[;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case, Token, ., INSTANCEOF]
[,, left, ,, right, ), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,, right, )]
[,, right, ), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case]
[), ;, case, Token, ., GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case, Token, .]
[:, return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree]
[., GETELEM, :, return, tryFoldGetElem, (, subtree, ,, left, ,, right, ), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof]
[;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case, Token, ., AND]
[,, left, ,, right, ), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, )]
[,, right, ), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case]
[), ;, case, Token, ., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case, Token, .]
[:, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case, Token, ., AND, :, case, Token, ., OR]
[., INSTANCEOF, :, return, tryFoldInstanceof, (, subtree, ,, left, ,, right, ), ;, case, Token, ., AND, :, case, Token]
[;, case, Token, ., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,, right, )]
[,, left, ,, right, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree]
[,, right, ), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left]
[), ;, case, Token, ., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,, right]
[:, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LSH]
[., AND, :, case, Token, ., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case, Token]
[:, return, tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LSH, :, case, Token, ., RSH]
[., OR, :, return, tryFoldAndOr, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LSH, :, case, Token]
[;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (, subtree]
[,, left, ,, right, ), ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH]
[,, right, ), ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return]
[), ;, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (]
[:, case, Token, ., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (, subtree, ,, left, ,, right, )]
[., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (, subtree, ,, left, ,]
[:, case, Token, ., URSH, :, return, tryFoldShift, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN]
[., RSH, :, case, Token, ., URSH, :, return, tryFoldShift, (, subtree, ,, left, ,, right, ), ;, case, Token]
[:, return, tryFoldShift, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree]
[., URSH, :, return, tryFoldShift, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign]
[;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN_BITOR]
[,, left, ,, right, ), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,, right, )]
[,, right, ), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case]
[), ;, case, Token, ., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case, Token, .]
[:, return, tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR]
[., ASSIGN, :, return, tryFoldAssign, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case, Token]
[;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH]
[,, left, ,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND]
[,, right, ), ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[), ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, .]
[:, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH]
[., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token]
[:, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH]
[., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token]
[:, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD]
[., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token]
[:, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB]
[., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token]
[:, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL]
[., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token]
[:, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV]
[., ASSIGN_URSH, :, case, Token, ., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token]
[:, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD]
[., ASSIGN_ADD, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token]
[:, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree]
[., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp]
[:, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, )]
[., ASSIGN_MUL, :, case, Token, ., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,]
[:, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ADD]
[., ASSIGN_DIV, :, case, Token, ., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, ), ;, case, Token]
[:, return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ADD, :, return, tryFoldAdd, (, subtree]
[., ASSIGN_MOD, :, return, tryUnfoldAssignOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., ADD, :, return, tryFoldAdd]
[;, case, Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case, Token, ., SUB]
[,, left, ,, right, ), ;, case, Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,, right, )]
[,, right, ), ;, case, Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case]
[), ;, case, Token, ., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case, Token, .]
[:, return, tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case, Token, ., SUB, :, case, Token, ., DIV]
[., ADD, :, return, tryFoldAdd, (, subtree, ,, left, ,, right, ), ;, case, Token, ., SUB, :, case, Token]
[;, case, Token, ., SUB, :, case, Token, ., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree]
[,, left, ,, right, ), ;, case, Token, ., SUB, :, case, Token, ., DIV, :, case, Token, ., MOD]
[,, right, ), ;, case, Token, ., SUB, :, case, Token, ., DIV, :, case, Token, ., MOD, :, return]
[), ;, case, Token, ., SUB, :, case, Token, ., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (]
[:, case, Token, ., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, )]
[., SUB, :, case, Token, ., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,]
[:, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., MUL]
[., DIV, :, case, Token, ., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case, Token]
[:, return, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., MUL, :, case, Token, ., BITAND]
[., MOD, :, return, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., MUL, :, case, Token]
[;, case, Token, ., MUL, :, case, Token, ., BITAND, :, case, Token, ., BITOR, :, case, Token, ., BITXOR]
[,, left, ,, right, ), ;, case, Token, ., MUL, :, case, Token, ., BITAND, :, case, Token, ., BITOR]
[,, right, ), ;, case, Token, ., MUL, :, case, Token, ., BITAND, :, case, Token, ., BITOR, :, case]
[), ;, case, Token, ., MUL, :, case, Token, ., BITAND, :, case, Token, ., BITOR, :, case, Token, .]
[:, case, Token, ., BITAND, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp]
[., MUL, :, case, Token, ., BITAND, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, Node, result]
[:, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,]
[., BITAND, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,]
[:, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, if, (]
[., BITOR, :, case, Token, ., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;]
[:, Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, if, (, result, !=, subtree, ), {]
[., BITXOR, :, Node, result, =, tryFoldArithmeticOp, (, subtree, ,, left, ,, right, ), ;, if, (, result, !=, subtree]
[;, if, (, result, !=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,, right]
[,, left, ,, right, ), ;, if, (, result, !=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (]
[,, right, ), ;, if, (, result, !=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,]
[), ;, if, (, result, !=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,]
[), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LT]
[!=, subtree, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case, Token]
[), {, return, result, ;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LT]
[;, }, return, tryFoldLeftChildOp, (, subtree, ,, left, ,, right, ), ;, case, Token, ., LT, :, case, Token, .]
[;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE]
[,, left, ,, right, ), ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE]
[,, right, ), ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[), ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, .]
[:, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., EQ]
[., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token]
[:, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., EQ, :, case, Token, ., NE]
[., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, case, Token, ., EQ, :, case, Token]
[:, case, Token, ., GE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ]
[., LE, :, case, Token, ., GE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token]
[:, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE]
[., GE, :, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token]
[:, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, tryFoldComparison, (, subtree]
[., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, tryFoldComparison]
[:, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, tryFoldComparison, (, subtree, ,, left, ,, right, )]
[., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, tryFoldComparison, (, subtree, ,, left, ,]
[:, case, Token, ., SHNE, :, return, tryFoldComparison, (, subtree, ,, left, ,, right, ), ;, default, :, return, subtree]
[., SHEQ, :, case, Token, ., SHNE, :, return, tryFoldComparison, (, subtree, ,, left, ,, right, ), ;, default, :]
[:, return, tryFoldComparison, (, subtree, ,, left, ,, right, ), ;, default, :, return, subtree, ;, }, }, private, Node]
[., SHNE, :, return, tryFoldComparison, (, subtree, ,, left, ,, right, ), ;, default, :, return, subtree, ;, }, }]
[;, default, :, return, subtree, ;, }, }, private, Node, tryReduceVoid, (, Node, n, ), {, Node, child, =, n]
[,, left, ,, right, ), ;, default, :, return, subtree, ;, }, }, private, Node, tryReduceVoid, (, Node, n, )]
[,, right, ), ;, default, :, return, subtree, ;, }, }, private, Node, tryReduceVoid, (, Node, n, ), {, Node]
[), ;, default, :, return, subtree, ;, }, }, private, Node, tryReduceVoid, (, Node, n, ), {, Node, child, =]
[;, }, }, private, Node, tryReduceVoid, (, Node, n, ), {, Node, child, =, n, ., getFirstChild, (, ), ;]
[;, if, (, !, child, ., isNumber, (, ), ||, child, ., getDouble, (, ), !=, 0.0, ), {, if]
[., getFirstChild, (, ), ;, if, (, !, child, ., isNumber, (, ), ||, child, ., getDouble, (, ), !=]
[), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild, (, child, ,, IR, ., number]
[||, child, ., getDouble, (, ), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n]
[||, child, ., getDouble, (, ), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n]
[., isNumber, (, ), ||, child, ., getDouble, (, ), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n]
[), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild, (, child, ,, IR, ., number]
[!=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild, (, child, ,, IR]
[., getDouble, (, ), !=, 0.0, ), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild]
[), {, if, (, !, mayHaveSideEffects, (, n, ), ), {, n, ., replaceChild, (, child, ,, IR, ., number]
[), {, n, ., replaceChild, (, child, ,, IR, ., number, (, 0, ), ), ;, reportCodeChange, (, ), ;]
[), {, n, ., replaceChild, (, child, ,, IR, ., number, (, 0, ), ), ;, reportCodeChange, (, ), ;]
[), ), {, n, ., replaceChild, (, child, ,, IR, ., number, (, 0, ), ), ;, reportCodeChange, (, )]
[;, reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, void, tryReduceOperandsForOp, (, Node, n, ), {, switch]
[., replaceChild, (, child, ,, IR, ., number, (, 0, ), ), ;, reportCodeChange, (, ), ;, }, }, return]
[,, IR, ., number, (, 0, ), ), ;, reportCodeChange, (, ), ;, }, }, return, n, ;, }, private]
[), ;, reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, void, tryReduceOperandsForOp, (, Node, n, ), {]
[., number, (, 0, ), ), ;, reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, void, tryReduceOperandsForOp]
[), ), ;, reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, void, tryReduceOperandsForOp, (, Node, n, )]
[;, }, }, return, n, ;, }, private, void, tryReduceOperandsForOp, (, Node, n, ), {, switch, (, n, ., getType]
[;, }, private, void, tryReduceOperandsForOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[), {, case, Token, ., ADD, :, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n]
[., getType, (, ), ), {, case, Token, ., ADD, :, Node, left, =, n, ., getFirstChild, (, ), ;]
[:, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if]
[., ADD, :, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, )]
[;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, !, NodeUtil, ., mayBeString, (, left, ), &&]
[., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, !, NodeUtil, ., mayBeString]
[;, if, (, !, NodeUtil, ., mayBeString, (, left, ), &&, !, NodeUtil, ., mayBeString, (, right, ), ), {]
[., getLastChild, (, ), ;, if, (, !, NodeUtil, ., mayBeString, (, left, ), &&, !, NodeUtil, ., mayBeString, (]
[), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :]
[&&, !, NodeUtil, ., mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token]
[&&, !, NodeUtil, ., mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token]
[., mayBeString, (, left, ), &&, !, NodeUtil, ., mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (, n, ), ;]
[), &&, !, NodeUtil, ., mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case]
[), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :]
[), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :]
[., mayBeString, (, right, ), ), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :]
[), ), {, tryConvertOperandsToNumber, (, n, ), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR]
[;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case]
[), ;, }, break, ;, case, Token, ., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :]
[:, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH]
[., ASSIGN_BITOR, :, case, Token, ., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token]
[:, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH]
[., ASSIGN_BITXOR, :, case, Token, ., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token]
[:, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB]
[., ASSIGN_BITAND, :, case, Token, ., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token]
[:, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL]
[., ASSIGN_LSH, :, case, Token, ., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case, Token]
[:, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD]
[., ASSIGN_RSH, :, case, Token, ., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token]
[:, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV]
[., ASSIGN_URSH, :, case, Token, ., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case, Token]
[:, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (, n, .]
[., ASSIGN_SUB, :, case, Token, ., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (]
[:, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;]
[., ASSIGN_MUL, :, case, Token, ., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (, n, ., getLastChild, (, )]
[:, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, break, ;, case, Token, .]
[., ASSIGN_MOD, :, case, Token, ., ASSIGN_DIV, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, break, ;, case]
[:, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, break, ;, case, Token, ., BITNOT, :, case, Token, .]
[., ASSIGN_DIV, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, break, ;, case, Token, ., BITNOT, :, case]
[;, break, ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token]
[), ;, break, ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case]
[., getLastChild, (, ), ), ;, break, ;, case, Token, ., BITNOT, :, case, Token, ., BITOR, :, case, Token]
[:, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH]
[., BITNOT, :, case, Token, ., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token]
[:, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH]
[., BITOR, :, case, Token, ., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token]
[:, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH]
[., BITXOR, :, case, Token, ., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token]
[:, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB]
[., BITAND, :, case, Token, ., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token]
[:, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL]
[., LSH, :, case, Token, ., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token]
[:, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD]
[., RSH, :, case, Token, ., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token]
[:, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV]
[., URSH, :, case, Token, ., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token]
[:, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., POS]
[., SUB, :, case, Token, ., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token]
[:, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., POS, :, case, Token, ., NEG]
[., MUL, :, case, Token, ., MOD, :, case, Token, ., DIV, :, case, Token, ., POS, :, case, Token]
[:, case, Token, ., DIV, :, case, Token, ., POS, :, case, Token, ., NEG, :, tryConvertOperandsToNumber, (, n, )]
[., MOD, :, case, Token, ., DIV, :, case, Token, ., POS, :, case, Token, ., NEG, :, tryConvertOperandsToNumber, (]
[:, case, Token, ., POS, :, case, Token, ., NEG, :, tryConvertOperandsToNumber, (, n, ), ;, break, ;, }, }]
[., DIV, :, case, Token, ., POS, :, case, Token, ., NEG, :, tryConvertOperandsToNumber, (, n, ), ;, break, ;]
[:, case, Token, ., NEG, :, tryConvertOperandsToNumber, (, n, ), ;, break, ;, }, }, private, void, tryConvertOperandsToNumber, (, Node]
[., POS, :, case, Token, ., NEG, :, tryConvertOperandsToNumber, (, n, ), ;, break, ;, }, }, private, void, tryConvertOperandsToNumber]
[:, tryConvertOperandsToNumber, (, n, ), ;, break, ;, }, }, private, void, tryConvertOperandsToNumber, (, Node, n, ), {, Node, next]
[., NEG, :, tryConvertOperandsToNumber, (, n, ), ;, break, ;, }, }, private, void, tryConvertOperandsToNumber, (, Node, n, ), {]
[;, break, ;, }, }, private, void, tryConvertOperandsToNumber, (, Node, n, ), {, Node, next, ;, for, (, Node, c]
[), ;, break, ;, }, }, private, void, tryConvertOperandsToNumber, (, Node, n, ), {, Node, next, ;, for, (, Node]
[;, c, !=, null, ;, c, =, next, ), {, next, =, c, ., getNext, (, ), ;, tryConvertToNumber, (]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, next, ), {, next, =, c, ., getNext, (]
[;, c, =, next, ), {, next, =, c, ., getNext, (, ), ;, tryConvertToNumber, (, c, ), ;, }]
[!=, null, ;, c, =, next, ), {, next, =, c, ., getNext, (, ), ;, tryConvertToNumber, (, c, )]
[;, c, =, next, ), {, next, =, c, ., getNext, (, ), ;, tryConvertToNumber, (, c, ), ;, }]
[=, next, ), {, next, =, c, ., getNext, (, ), ;, tryConvertToNumber, (, c, ), ;, }, }, private]
[), {, next, =, c, ., getNext, (, ), ;, tryConvertToNumber, (, c, ), ;, }, }, private, void, tryConvertToNumber]
[=, c, ., getNext, (, ), ;, tryConvertToNumber, (, c, ), ;, }, }, private, void, tryConvertToNumber, (, Node, n]
[;, tryConvertToNumber, (, c, ), ;, }, }, private, void, tryConvertToNumber, (, Node, n, ), {, switch, (, n, .]
[., getNext, (, ), ;, tryConvertToNumber, (, c, ), ;, }, }, private, void, tryConvertToNumber, (, Node, n, ), {]
[;, }, }, private, void, tryConvertToNumber, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), ;, }, }, private, void, tryConvertToNumber, (, Node, n, ), {, switch, (, n, ., getType, (, ), )]
[), {, case, Token, ., NUMBER, :, return, ;, case, Token, ., AND, :, case, Token, ., OR, :, case]
[., getType, (, ), ), {, case, Token, ., NUMBER, :, return, ;, case, Token, ., AND, :, case, Token]
[:, return, ;, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, ., COMMA, :, tryConvertToNumber, (]
[., NUMBER, :, return, ;, case, Token, ., AND, :, case, Token, ., OR, :, case, Token, ., COMMA, :]
[:, case, Token, ., OR, :, case, Token, ., COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;]
[., AND, :, case, Token, ., OR, :, case, Token, ., COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, )]
[:, case, Token, ., COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, .]
[., OR, :, case, Token, ., COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case]
[:, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (, n]
[., COMMA, :, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber]
[;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (, n, ., getChildAtIndex, (, 1, ), ), ;, tryConvertToNumber, (]
[), ;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (, n, ., getChildAtIndex, (, 1, ), ), ;, tryConvertToNumber]
[., getLastChild, (, ), ), ;, return, ;, case, Token, ., HOOK, :, tryConvertToNumber, (, n, ., getChildAtIndex, (, 1]
[:, tryConvertToNumber, (, n, ., getChildAtIndex, (, 1, ), ), ;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;]
[., HOOK, :, tryConvertToNumber, (, n, ., getChildAtIndex, (, 1, ), ), ;, tryConvertToNumber, (, n, ., getLastChild, (, )]
[;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., NAME, :, if, (, !]
[), ;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., NAME, :, if, (]
[., getChildAtIndex, (, 1, ), ), ;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token]
[), ), ;, tryConvertToNumber, (, n, ., getLastChild, (, ), ), ;, return, ;, case, Token, ., NAME, :, if]
[;, return, ;, case, Token, ., NAME, :, if, (, !, NodeUtil, ., isUndefined, (, n, ), ), {, return]
[), ;, return, ;, case, Token, ., NAME, :, if, (, !, NodeUtil, ., isUndefined, (, n, ), ), {]
[., getLastChild, (, ), ), ;, return, ;, case, Token, ., NAME, :, if, (, !, NodeUtil, ., isUndefined, (]
[:, if, (, !, NodeUtil, ., isUndefined, (, n, ), ), {, return, ;, }, break, ;, }, Double, result]
[., NAME, :, if, (, !, NodeUtil, ., isUndefined, (, n, ), ), {, return, ;, }, break, ;, }]
[), {, return, ;, }, break, ;, }, Double, result, =, NodeUtil, ., getNumberValue, (, n, ), ;, if, (]
[), {, return, ;, }, break, ;, }, Double, result, =, NodeUtil, ., getNumberValue, (, n, ), ;, if, (]
[., isUndefined, (, n, ), ), {, return, ;, }, break, ;, }, Double, result, =, NodeUtil, ., getNumberValue, (]
[), ), {, return, ;, }, break, ;, }, Double, result, =, NodeUtil, ., getNumberValue, (, n, ), ;, if]
[;, if, (, result, ==, null, ), {, return, ;, }, double, value, =, result, ;, Node, replacement, =, NodeUtil]
[., getNumberValue, (, n, ), ;, if, (, result, ==, null, ), {, return, ;, }, double, value, =, result]
[), ;, if, (, result, ==, null, ), {, return, ;, }, double, value, =, result, ;, Node, replacement, =]
[), {, return, ;, }, double, value, =, result, ;, Node, replacement, =, NodeUtil, ., numberNode, (, value, ,, n]
[==, null, ), {, return, ;, }, double, value, =, result, ;, Node, replacement, =, NodeUtil, ., numberNode, (, value]
[), {, return, ;, }, double, value, =, result, ;, Node, replacement, =, NodeUtil, ., numberNode, (, value, ,, n]
[;, Node, replacement, =, NodeUtil, ., numberNode, (, value, ,, n, ), ;, if, (, replacement, ., isEquivalentTo, (, n]
[;, if, (, replacement, ., isEquivalentTo, (, n, ), ), {, return, ;, }, n, ., getParent, (, ), .]
[., numberNode, (, value, ,, n, ), ;, if, (, replacement, ., isEquivalentTo, (, n, ), ), {, return, ;]
[,, n, ), ;, if, (, replacement, ., isEquivalentTo, (, n, ), ), {, return, ;, }, n, ., getParent]
[), ;, if, (, replacement, ., isEquivalentTo, (, n, ), ), {, return, ;, }, n, ., getParent, (, )]
[), {, return, ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (]
[., isEquivalentTo, (, n, ), ), {, return, ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[), ), {, return, ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange]
[;, reportCodeChange, (, ), ;, }, private, Node, tryFoldTypeof, (, Node, originalTypeofNode, ), {, Preconditions, ., checkArgument, (, originalTypeofNode, .]
[., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, }, private, Node, tryFoldTypeof, (, Node, originalTypeofNode, )]
[., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, }, private, Node, tryFoldTypeof]
[,, replacement, ), ;, reportCodeChange, (, ), ;, }, private, Node, tryFoldTypeof, (, Node, originalTypeofNode, ), {, Preconditions, ., checkArgument]
[), ;, reportCodeChange, (, ), ;, }, private, Node, tryFoldTypeof, (, Node, originalTypeofNode, ), {, Preconditions, ., checkArgument, (, originalTypeofNode]
[;, }, private, Node, tryFoldTypeof, (, Node, originalTypeofNode, ), {, Preconditions, ., checkArgument, (, originalTypeofNode, ., isTypeOf, (, ), )]
[;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (, argumentNode, ==, null, ||, !, NodeUtil, ., isLiteralValue]
[., checkArgument, (, originalTypeofNode, ., isTypeOf, (, ), ), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if]
[), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (, argumentNode, ==, null, ||, !, NodeUtil, .]
[., isTypeOf, (, ), ), ;, Node, argumentNode, =, originalTypeofNode, ., getFirstChild, (, ), ;, if, (, argumentNode, ==, null]
[;, if, (, argumentNode, ==, null, ||, !, NodeUtil, ., isLiteralValue, (, argumentNode, ,, true, ), ), {, return, originalTypeofNode]
[., getFirstChild, (, ), ;, if, (, argumentNode, ==, null, ||, !, NodeUtil, ., isLiteralValue, (, argumentNode, ,, true, )]
[), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (, ), ), {]
[||, !, NodeUtil, ., isLiteralValue, (, argumentNode, ,, true, ), ), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null]
[==, null, ||, !, NodeUtil, ., isLiteralValue, (, argumentNode, ,, true, ), ), {, return, originalTypeofNode, ;, }, String, typeNameString]
[||, !, NodeUtil, ., isLiteralValue, (, argumentNode, ,, true, ), ), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null]
[), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (, ), ), {]
[), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (, ), ), {]
[., isLiteralValue, (, argumentNode, ,, true, ), ), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (]
[,, true, ), ), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (]
[), ), {, return, originalTypeofNode, ;, }, String, typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (, ), )]
[;, }, String, typeNameString, =, null, ;, switch, (, argumentNode, ., getType, (, ), ), {, case, Token, ., FUNCTION]
[;, switch, (, argumentNode, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, typeNameString, =, "function", ;, break]
[), {, case, Token, ., FUNCTION, :, typeNameString, =, "function", ;, break, ;, case, Token, ., STRING, :, typeNameString, =]
[., getType, (, ), ), {, case, Token, ., FUNCTION, :, typeNameString, =, "function", ;, break, ;, case, Token, .]
[:, typeNameString, =, "function", ;, break, ;, case, Token, ., STRING, :, typeNameString, =, "string", ;, break, ;, case, Token]
[., FUNCTION, :, typeNameString, =, "function", ;, break, ;, case, Token, ., STRING, :, typeNameString, =, "string", ;, break, ;]
[=, "function", ;, break, ;, case, Token, ., STRING, :, typeNameString, =, "string", ;, break, ;, case, Token, ., NUMBER]
[;, break, ;, case, Token, ., STRING, :, typeNameString, =, "string", ;, break, ;, case, Token, ., NUMBER, :, typeNameString]
[:, typeNameString, =, "string", ;, break, ;, case, Token, ., NUMBER, :, typeNameString, =, "number", ;, break, ;, case, Token]
[., STRING, :, typeNameString, =, "string", ;, break, ;, case, Token, ., NUMBER, :, typeNameString, =, "number", ;, break, ;]
[=, "string", ;, break, ;, case, Token, ., NUMBER, :, typeNameString, =, "number", ;, break, ;, case, Token, ., TRUE]
[;, break, ;, case, Token, ., NUMBER, :, typeNameString, =, "number", ;, break, ;, case, Token, ., TRUE, :, case]
[:, typeNameString, =, "number", ;, break, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, typeNameString, =, "boolean"]
[., NUMBER, :, typeNameString, =, "number", ;, break, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, typeNameString]
[=, "number", ;, break, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, typeNameString, =, "boolean", ;, break]
[;, break, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case]
[:, case, Token, ., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case, Token, ., NULL, :, case, Token, .]
[., TRUE, :, case, Token, ., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case, Token, ., NULL, :, case]
[:, typeNameString, =, "boolean", ;, break, ;, case, Token, ., NULL, :, case, Token, ., OBJECTLIT, :, case, Token, .]
[., FALSE, :, typeNameString, =, "boolean", ;, break, ;, case, Token, ., NULL, :, case, Token, ., OBJECTLIT, :, case]
[=, "boolean", ;, break, ;, case, Token, ., NULL, :, case, Token, ., OBJECTLIT, :, case, Token, ., ARRAYLIT, :]
[;, break, ;, case, Token, ., NULL, :, case, Token, ., OBJECTLIT, :, case, Token, ., ARRAYLIT, :, typeNameString, =]
[:, case, Token, ., OBJECTLIT, :, case, Token, ., ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case, Token, .]
[., NULL, :, case, Token, ., OBJECTLIT, :, case, Token, ., ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case]
[:, case, Token, ., ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case, Token, ., VOID, :, typeNameString, =, "undefined"]
[., OBJECTLIT, :, case, Token, ., ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case, Token, ., VOID, :, typeNameString]
[:, typeNameString, =, "object", ;, break, ;, case, Token, ., VOID, :, typeNameString, =, "undefined", ;, break, ;, case, Token]
[., ARRAYLIT, :, typeNameString, =, "object", ;, break, ;, case, Token, ., VOID, :, typeNameString, =, "undefined", ;, break, ;]
[=, "object", ;, break, ;, case, Token, ., VOID, :, typeNameString, =, "undefined", ;, break, ;, case, Token, ., NAME]
[;, break, ;, case, Token, ., VOID, :, typeNameString, =, "undefined", ;, break, ;, case, Token, ., NAME, :, if]
[:, typeNameString, =, "undefined", ;, break, ;, case, Token, ., NAME, :, if, (, "undefined", ., equals, (, argumentNode, .]
[., VOID, :, typeNameString, =, "undefined", ;, break, ;, case, Token, ., NAME, :, if, (, "undefined", ., equals, (]
[=, "undefined", ;, break, ;, case, Token, ., NAME, :, if, (, "undefined", ., equals, (, argumentNode, ., getString, (]
[;, break, ;, case, Token, ., NAME, :, if, (, "undefined", ., equals, (, argumentNode, ., getString, (, ), )]
[:, if, (, "undefined", ., equals, (, argumentNode, ., getString, (, ), ), ), {, typeNameString, =, "undefined", ;, }]
[., NAME, :, if, (, "undefined", ., equals, (, argumentNode, ., getString, (, ), ), ), {, typeNameString, =, "undefined"]
[), {, typeNameString, =, "undefined", ;, }, break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode, =]
[., equals, (, argumentNode, ., getString, (, ), ), ), {, typeNameString, =, "undefined", ;, }, break, ;, }, if]
[), ), {, typeNameString, =, "undefined", ;, }, break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode]
[., getString, (, ), ), ), {, typeNameString, =, "undefined", ;, }, break, ;, }, if, (, typeNameString, !=, null]
[=, "undefined", ;, }, break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode, =, IR, ., string]
[;, }, break, ;, }, if, (, typeNameString, !=, null, ), {, Node, newNode, =, IR, ., string, (, typeNameString]
[), {, Node, newNode, =, IR, ., string, (, typeNameString, ), ;, originalTypeofNode, ., getParent, (, ), ., replaceChild, (]
[!=, null, ), {, Node, newNode, =, IR, ., string, (, typeNameString, ), ;, originalTypeofNode, ., getParent, (, ), .]
[), {, Node, newNode, =, IR, ., string, (, typeNameString, ), ;, originalTypeofNode, ., getParent, (, ), ., replaceChild, (]
[;, originalTypeofNode, ., getParent, (, ), ., replaceChild, (, originalTypeofNode, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode]
[., string, (, typeNameString, ), ;, originalTypeofNode, ., getParent, (, ), ., replaceChild, (, originalTypeofNode, ,, newNode, ), ;, reportCodeChange]
[), ;, originalTypeofNode, ., getParent, (, ), ., replaceChild, (, originalTypeofNode, ,, newNode, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, newNode, ;, }, return, originalTypeofNode, ;, }, private, Node, tryFoldUnaryOperator, (, Node, n, )]
[., replaceChild, (, originalTypeofNode, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return, originalTypeofNode, ;, }]
[., getParent, (, ), ., replaceChild, (, originalTypeofNode, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }]
[,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return, originalTypeofNode, ;, }, private, Node, tryFoldUnaryOperator, (]
[), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return, originalTypeofNode, ;, }, private, Node, tryFoldUnaryOperator, (, Node, n]
[;, return, newNode, ;, }, return, originalTypeofNode, ;, }, private, Node, tryFoldUnaryOperator, (, Node, n, ), {, Preconditions, ., checkState]
[;, }, return, originalTypeofNode, ;, }, private, Node, tryFoldUnaryOperator, (, Node, n, ), {, Preconditions, ., checkState, (, n, .]
[;, }, private, Node, tryFoldUnaryOperator, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., hasOneChild, (, ), )]
[;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;, if]
[., checkState, (, n, ., hasOneChild, (, ), ), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node]
[), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;]
[., hasOneChild, (, ), ), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, parent, =, n, .]
[;, Node, parent, =, n, ., getParent, (, ), ;, if, (, left, ==, null, ), {, return, n, ;]
[., getFirstChild, (, ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, left, ==, null, )]
[;, if, (, left, ==, null, ), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left]
[., getParent, (, ), ;, if, (, left, ==, null, ), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil]
[), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left, ), ;, if, (, leftVal, ==]
[==, null, ), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left, ), ;, if, (]
[), {, return, n, ;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left, ), ;, if, (, leftVal, ==]
[;, }, TernaryValue, leftVal, =, NodeUtil, ., getPureBooleanValue, (, left, ), ;, if, (, leftVal, ==, TernaryValue, ., UNKNOWN, )]
[;, if, (, leftVal, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, switch, (, n, ., getType, (]
[., getPureBooleanValue, (, left, ), ;, if, (, leftVal, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, switch]
[), ;, if, (, leftVal, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, switch, (, n, ., getType]
[), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :]
[==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :]
[., UNKNOWN, ), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, .]
[;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :, if, (, late, &&]
[), {, case, Token, ., NOT, :, if, (, late, &&, left, ., isNumber, (, ), ), {, double, numValue]
[., getType, (, ), ), {, case, Token, ., NOT, :, if, (, late, &&, left, ., isNumber, (, )]
[:, if, (, late, &&, left, ., isNumber, (, ), ), {, double, numValue, =, left, ., getDouble, (, )]
[., NOT, :, if, (, late, &&, left, ., isNumber, (, ), ), {, double, numValue, =, left, ., getDouble]
[), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (, numValue, ==, 0, ||, numValue, ==, 1]
[&&, left, ., isNumber, (, ), ), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (, numValue]
[), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (, numValue, ==, 0, ||, numValue, ==, 1]
[., isNumber, (, ), ), {, double, numValue, =, left, ., getDouble, (, ), ;, if, (, numValue, ==, 0]
[;, if, (, numValue, ==, 0, ||, numValue, ==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =]
[., getDouble, (, ), ;, if, (, numValue, ==, 0, ||, numValue, ==, 1, ), {, return, n, ;, }]
[), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean, (, true]
[||, numValue, ==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal]
[==, 0, ||, numValue, ==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (]
[||, numValue, ==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal]
[), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean, (, true]
[==, 1, ), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean]
[), {, return, n, ;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean, (, true]
[;, }, }, Node, replacementNode, =, NodeUtil, ., booleanNode, (, !, leftVal, ., toBoolean, (, true, ), ), ;, parent]
[;, parent, ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token, .]
[., booleanNode, (, !, leftVal, ., toBoolean, (, true, ), ), ;, parent, ., replaceChild, (, n, ,, replacementNode, )]
[), ;, parent, ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token]
[), ;, parent, ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token]
[., toBoolean, (, true, ), ), ;, parent, ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;]
[), ), ;, parent, ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case]
[;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (, left]
[., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token, ., POS, :]
[,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token, ., POS, :, if, (, NodeUtil, .]
[), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, case, Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (]
[;, return, replacementNode, ;, case, Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (, left, ), ), {, parent]
[;, case, Token, ., POS, :, if, (, NodeUtil, ., isNumericResult, (, left, ), ), {, parent, ., replaceChild, (]
[:, if, (, NodeUtil, ., isNumericResult, (, left, ), ), {, parent, ., replaceChild, (, n, ,, left, ., detachFromParent]
[., POS, :, if, (, NodeUtil, ., isNumericResult, (, left, ), ), {, parent, ., replaceChild, (, n, ,, left]
[), {, parent, ., replaceChild, (, n, ,, left, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return]
[., isNumericResult, (, left, ), ), {, parent, ., replaceChild, (, n, ,, left, ., detachFromParent, (, ), ), ;]
[), ), {, parent, ., replaceChild, (, n, ,, left, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;]
[;, reportCodeChange, (, ), ;, return, left, ;, }, return, n, ;, case, Token, ., NEG, :, if, (, left]
[., replaceChild, (, n, ,, left, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, left, ;, }]
[,, left, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, left, ;, }, return, n, ;, case]
[), ;, reportCodeChange, (, ), ;, return, left, ;, }, return, n, ;, case, Token, ., NEG, :, if, (]
[., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, left, ;, }, return, n, ;, case, Token, .]
[;, return, left, ;, }, return, n, ;, case, Token, ., NEG, :, if, (, left, ., isName, (, )]
[;, }, return, n, ;, case, Token, ., NEG, :, if, (, left, ., isName, (, ), ), {, if]
[;, case, Token, ., NEG, :, if, (, left, ., isName, (, ), ), {, if, (, left, ., getString]
[:, if, (, left, ., isName, (, ), ), {, if, (, left, ., getString, (, ), ., equals, (]
[., NEG, :, if, (, left, ., isName, (, ), ), {, if, (, left, ., getString, (, ), .]
[), {, if, (, left, ., getString, (, ), ., equals, (, "Infinity", ), ), {, return, n, ;, }]
[., isName, (, ), ), {, if, (, left, ., getString, (, ), ., equals, (, "Infinity", ), ), {]
[), {, return, n, ;, }, else, if, (, left, ., getString, (, ), ., equals, (, "NaN", ), )]
[., equals, (, "Infinity", ), ), {, return, n, ;, }, else, if, (, left, ., getString, (, ), .]
[., getString, (, ), ., equals, (, "Infinity", ), ), {, return, n, ;, }, else, if, (, left, .]
[), ), {, return, n, ;, }, else, if, (, left, ., getString, (, ), ., equals, (, "NaN", )]
[;, }, else, if, (, left, ., getString, (, ), ., equals, (, "NaN", ), ), {, n, ., removeChild]
[), {, n, ., removeChild, (, left, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, reportCodeChange, (]
[., equals, (, "NaN", ), ), {, n, ., removeChild, (, left, ), ;, parent, ., replaceChild, (, n, ,]
[., getString, (, ), ., equals, (, "NaN", ), ), {, n, ., removeChild, (, left, ), ;, parent, .]
[), ), {, n, ., removeChild, (, left, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, reportCodeChange]
[;, parent, ., replaceChild, (, n, ,, left, ), ;, reportCodeChange, (, ), ;, return, left, ;, }, }, if]
[., removeChild, (, left, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, left, ), ;, reportCodeChange, (, ), ;, return, left, ;, }, }]
[;, reportCodeChange, (, ), ;, return, left, ;, }, }, if, (, left, ., isNumber, (, ), ), {, double]
[., replaceChild, (, n, ,, left, ), ;, reportCodeChange, (, ), ;, return, left, ;, }, }, if, (, left]
[,, left, ), ;, reportCodeChange, (, ), ;, return, left, ;, }, }, if, (, left, ., isNumber, (, )]
[), ;, reportCodeChange, (, ), ;, return, left, ;, }, }, if, (, left, ., isNumber, (, ), ), {]
[;, return, left, ;, }, }, if, (, left, ., isNumber, (, ), ), {, double, negNum, =, -, left]
[;, }, }, if, (, left, ., isNumber, (, ), ), {, double, negNum, =, -, left, ., getDouble, (]
[), {, double, negNum, =, -, left, ., getDouble, (, ), ;, Node, negNumNode, =, IR, ., number, (, negNum]
[., isNumber, (, ), ), {, double, negNum, =, -, left, ., getDouble, (, ), ;, Node, negNumNode, =, IR]
[;, Node, negNumNode, =, IR, ., number, (, negNum, ), ;, parent, ., replaceChild, (, n, ,, negNumNode, ), ;]
[;, Node, negNumNode, =, IR, ., number, (, negNum, ), ;, parent, ., replaceChild, (, n, ,, negNumNode, ), ;]
[., getDouble, (, ), ;, Node, negNumNode, =, IR, ., number, (, negNum, ), ;, parent, ., replaceChild, (, n]
[;, parent, ., replaceChild, (, n, ,, negNumNode, ), ;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else, {]
[., number, (, negNum, ), ;, parent, ., replaceChild, (, n, ,, negNumNode, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, negNumNode, ), ;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else]
[;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else, {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return, n]
[., replaceChild, (, n, ,, negNumNode, ), ;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else, {, report, (]
[,, negNumNode, ), ;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else, {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, )]
[), ;, reportCodeChange, (, ), ;, return, negNumNode, ;, }, else, {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return]
[;, return, negNumNode, ;, }, else, {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return, n, ;, }, case, Token]
[;, }, else, {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return, n, ;, }, case, Token, ., BITNOT, :]
[;, return, n, ;, }, case, Token, ., BITNOT, :, try, {, double, val, =, left, ., getDouble, (, )]
[,, left, ), ;, return, n, ;, }, case, Token, ., BITNOT, :, try, {, double, val, =, left, .]
[), ;, return, n, ;, }, case, Token, ., BITNOT, :, try, {, double, val, =, left, ., getDouble, (]
[;, }, case, Token, ., BITNOT, :, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (]
[:, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (, val, >=, Integer, ., MIN_VALUE, &&]
[., BITNOT, :, try, {, double, val, =, left, ., getDouble, (, ), ;, if, (, val, >=, Integer, .]
[;, if, (, val, >=, Integer, ., MIN_VALUE, &&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (]
[., getDouble, (, ), ;, if, (, val, >=, Integer, ., MIN_VALUE, &&, val, <=, Integer, ., MAX_VALUE, ), {]
[), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =]
[&&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==]
[>=, Integer, ., MIN_VALUE, &&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (, int, ), val, ;]
[&&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==]
[., MIN_VALUE, &&, val, <=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (, int, ), val, ;, if, (]
[), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =]
[<=, Integer, ., MAX_VALUE, ), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==, val, )]
[), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =]
[., MAX_VALUE, ), {, int, intVal, =, (, int, ), val, ;, if, (, intVal, ==, val, ), {, Node]
[;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;, parent]
[;, if, (, intVal, ==, val, ), {, Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;, parent]
[), {, Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;, parent, ., replaceChild, (, n, ,, notIntValNode]
[==, val, ), {, Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;, parent, ., replaceChild, (, n]
[), {, Node, notIntValNode, =, IR, ., number, (, ~, intVal, ), ;, parent, ., replaceChild, (, n, ,, notIntValNode]
[;, parent, ., replaceChild, (, n, ,, notIntValNode, ), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else, {]
[., number, (, ~, intVal, ), ;, parent, ., replaceChild, (, n, ,, notIntValNode, ), ;, reportCodeChange, (, ), ;]
[), ;, parent, ., replaceChild, (, n, ,, notIntValNode, ), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else]
[), ;, parent, ., replaceChild, (, n, ,, notIntValNode, ), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else]
[;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n]
[., replaceChild, (, n, ,, notIntValNode, ), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else, {, report, (]
[,, notIntValNode, ), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, )]
[), ;, reportCodeChange, (, ), ;, return, notIntValNode, ;, }, else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return]
[;, return, notIntValNode, ;, }, else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, }, else]
[;, }, else, {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, }, else, {, report, (]
[;, return, n, ;, }, }, else, {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, }]
[,, left, ), ;, return, n, ;, }, }, else, {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n]
[), ;, return, n, ;, }, }, else, {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }]
[;, }, }, else, {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, }, catch, (, UnsupportedOperationException]
[;, return, n, ;, }, }, catch, (, UnsupportedOperationException, ex, ), {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return]
[,, left, ), ;, return, n, ;, }, }, catch, (, UnsupportedOperationException, ex, ), {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left]
[), ;, return, n, ;, }, }, catch, (, UnsupportedOperationException, ex, ), {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;]
[;, }, }, catch, (, UnsupportedOperationException, ex, ), {, report, (, NEGATING_A_NON_NUMBER_ERROR, ,, left, ), ;, return, n, ;, }]
[;, return, n, ;, }, default, :, return, n, ;, }, }, private, Node, tryFoldInstanceof, (, Node, n, ,, Node]
[,, left, ), ;, return, n, ;, }, default, :, return, n, ;, }, }, private, Node, tryFoldInstanceof, (, Node]
[), ;, return, n, ;, }, default, :, return, n, ;, }, }, private, Node, tryFoldInstanceof, (, Node, n, ,]
[;, }, default, :, return, n, ;, }, }, private, Node, tryFoldInstanceof, (, Node, n, ,, Node, left, ,, Node]
[;, }, }, private, Node, tryFoldInstanceof, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument]
[;, if, (, NodeUtil, ., isLiteralValue, (, left, ,, true, ), &&, !, mayHaveSideEffects, (, right, ), ), {, Node]
[., checkArgument, (, n, ., isInstanceOf, (, ), ), ;, if, (, NodeUtil, ., isLiteralValue, (, left, ,, true, )]
[), ;, if, (, NodeUtil, ., isLiteralValue, (, left, ,, true, ), &&, !, mayHaveSideEffects, (, right, ), ), {]
[., isInstanceOf, (, ), ), ;, if, (, NodeUtil, ., isLiteralValue, (, left, ,, true, ), &&, !, mayHaveSideEffects, (]
[), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =, IR]
[&&, !, mayHaveSideEffects, (, right, ), ), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (, left]
[., isLiteralValue, (, left, ,, true, ), &&, !, mayHaveSideEffects, (, right, ), ), {, Node, replacementNode, =, null, ;]
[,, true, ), &&, !, mayHaveSideEffects, (, right, ), ), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, .]
[), &&, !, mayHaveSideEffects, (, right, ), ), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (]
[), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =, IR]
[), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =, IR]
[), ), {, Node, replacementNode, =, null, ;, if, (, NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =]
[;, if, (, NodeUtil, ., isImmutableValue, (, left, ), ), {, replacementNode, =, IR, ., falseNode, (, ), ;, }]
[), {, replacementNode, =, IR, ., falseNode, (, ), ;, }, else, if, (, right, ., isName, (, ), &&]
[., isImmutableValue, (, left, ), ), {, replacementNode, =, IR, ., falseNode, (, ), ;, }, else, if, (, right]
[), ), {, replacementNode, =, IR, ., falseNode, (, ), ;, }, else, if, (, right, ., isName, (, )]
[=, IR, ., falseNode, (, ), ;, }, else, if, (, right, ., isName, (, ), &&, "Object", ., equals]
[;, }, else, if, (, right, ., isName, (, ), &&, "Object", ., equals, (, right, ., getString, (, )]
[., falseNode, (, ), ;, }, else, if, (, right, ., isName, (, ), &&, "Object", ., equals, (, right]
[), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (, replacementNode, !=, null, ), {, n, .]
[&&, "Object", ., equals, (, right, ., getString, (, ), ), ), {, replacementNode, =, IR, ., trueNode, (, )]
[., isName, (, ), &&, "Object", ., equals, (, right, ., getString, (, ), ), ), {, replacementNode, =, IR]
[), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (, replacementNode, !=, null, ), {, n, .]
[., equals, (, right, ., getString, (, ), ), ), {, replacementNode, =, IR, ., trueNode, (, ), ;, }]
[), ), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (, replacementNode, !=, null, ), {, n]
[., getString, (, ), ), ), {, replacementNode, =, IR, ., trueNode, (, ), ;, }, if, (, replacementNode, !=]
[=, IR, ., trueNode, (, ), ;, }, if, (, replacementNode, !=, null, ), {, n, ., getParent, (, )]
[;, }, if, (, replacementNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacementNode]
[., trueNode, (, ), ;, }, if, (, replacementNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild]
[), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return]
[!=, null, ), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, )]
[), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, replacementNode, ;, }, }, return, n, ;, }, private, Node, tryFoldAssign, (, Node, n]
[., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, }, }, return, n, ;]
[., getParent, (, ), ., replaceChild, (, n, ,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, }]
[,, replacementNode, ), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, }, }, return, n, ;, }, private, Node, tryFoldAssign]
[), ;, reportCodeChange, (, ), ;, return, replacementNode, ;, }, }, return, n, ;, }, private, Node, tryFoldAssign, (, Node]
[;, return, replacementNode, ;, }, }, return, n, ;, }, private, Node, tryFoldAssign, (, Node, n, ,, Node, left, ,]
[;, }, }, return, n, ;, }, private, Node, tryFoldAssign, (, Node, n, ,, Node, left, ,, Node, right, )]
[;, }, private, Node, tryFoldAssign, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, if, (, !, late, ), {, return, n, ;, }, if, (, !, right, ., hasChildren, (, ), ||]
[., checkArgument, (, n, ., isAssign, (, ), ), ;, if, (, !, late, ), {, return, n, ;, }]
[), ;, if, (, !, late, ), {, return, n, ;, }, if, (, !, right, ., hasChildren, (, )]
[., isAssign, (, ), ), ;, if, (, !, late, ), {, return, n, ;, }, if, (, !, right]
[), {, return, n, ;, }, if, (, !, right, ., hasChildren, (, ), ||, right, ., getFirstChild, (, )]
[), {, return, n, ;, }, if, (, !, right, ., hasChildren, (, ), ||, right, ., getFirstChild, (, )]
[;, }, if, (, !, right, ., hasChildren, (, ), ||, right, ., getFirstChild, (, ), ., getNext, (, )]
[), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, Node, newRight]
[||, right, ., getFirstChild, (, ), ., getNext, (, ), !=, right, ., getLastChild, (, ), ), {, return, n]
[||, right, ., getFirstChild, (, ), ., getNext, (, ), !=, right, ., getLastChild, (, ), ), {, return, n]
[., hasChildren, (, ), ||, right, ., getFirstChild, (, ), ., getNext, (, ), !=, right, ., getLastChild, (, )]
[), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, Node, newRight]
[!=, right, ., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {]
[., getNext, (, ), !=, right, ., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (]
[., getFirstChild, (, ), ., getNext, (, ), !=, right, ., getLastChild, (, ), ), {, return, n, ;, }]
[), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, Node, newRight]
[., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n]
[;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, Node, newRight, ;, if, (, areNodesEqualForInlining]
[), {, return, n, ;, }, Node, newRight, ;, if, (, areNodesEqualForInlining, (, left, ,, right, ., getFirstChild, (, )]
[), ), {, return, n, ;, }, Node, newRight, ;, if, (, areNodesEqualForInlining, (, left, ,, right, ., getFirstChild, (]
[;, }, Node, newRight, ;, if, (, areNodesEqualForInlining, (, left, ,, right, ., getFirstChild, (, ), ), ), {, newRight]
[), {, newRight, =, right, ., getLastChild, (, ), ;, }, else, if, (, NodeUtil, ., isCommutative, (, right, .]
[,, right, ., getFirstChild, (, ), ), ), {, newRight, =, right, ., getLastChild, (, ), ;, }, else, if]
[), ), {, newRight, =, right, ., getLastChild, (, ), ;, }, else, if, (, NodeUtil, ., isCommutative, (, right]
[., getFirstChild, (, ), ), ), {, newRight, =, right, ., getLastChild, (, ), ;, }, else, if, (, NodeUtil]
[=, right, ., getLastChild, (, ), ;, }, else, if, (, NodeUtil, ., isCommutative, (, right, ., getType, (, )]
[;, }, else, if, (, NodeUtil, ., isCommutative, (, right, ., getType, (, ), ), &&, areNodesEqualForInlining, (, left, ,]
[., getLastChild, (, ), ;, }, else, if, (, NodeUtil, ., isCommutative, (, right, ., getType, (, ), ), &&]
[), {, newRight, =, right, ., getFirstChild, (, ), ;, }, else, {, return, n, ;, }, int, newType, =]
[&&, areNodesEqualForInlining, (, left, ,, right, ., getLastChild, (, ), ), ), {, newRight, =, right, ., getFirstChild, (, )]
[., isCommutative, (, right, ., getType, (, ), ), &&, areNodesEqualForInlining, (, left, ,, right, ., getLastChild, (, ), )]
[), &&, areNodesEqualForInlining, (, left, ,, right, ., getLastChild, (, ), ), ), {, newRight, =, right, ., getFirstChild, (]
[., getType, (, ), ), &&, areNodesEqualForInlining, (, left, ,, right, ., getLastChild, (, ), ), ), {, newRight, =]
[), {, newRight, =, right, ., getFirstChild, (, ), ;, }, else, {, return, n, ;, }, int, newType, =]
[,, right, ., getLastChild, (, ), ), ), {, newRight, =, right, ., getFirstChild, (, ), ;, }, else, {]
[), ), {, newRight, =, right, ., getFirstChild, (, ), ;, }, else, {, return, n, ;, }, int, newType]
[., getLastChild, (, ), ), ), {, newRight, =, right, ., getFirstChild, (, ), ;, }, else, {, return, n]
[=, right, ., getFirstChild, (, ), ;, }, else, {, return, n, ;, }, int, newType, =, -, 1, ;]
[;, }, else, {, return, n, ;, }, int, newType, =, -, 1, ;, switch, (, right, ., getType, (]
[., getFirstChild, (, ), ;, }, else, {, return, n, ;, }, int, newType, =, -, 1, ;, switch, (]
[;, }, int, newType, =, -, 1, ;, switch, (, right, ., getType, (, ), ), {, case, Token, .]
[;, switch, (, right, ., getType, (, ), ), {, case, Token, ., ADD, :, newType, =, Token, ., ASSIGN_ADD]
[;, switch, (, right, ., getType, (, ), ), {, case, Token, ., ADD, :, newType, =, Token, ., ASSIGN_ADD]
[), {, case, Token, ., ADD, :, newType, =, Token, ., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :]
[., getType, (, ), ), {, case, Token, ., ADD, :, newType, =, Token, ., ASSIGN_ADD, ;, break, ;, case]
[:, newType, =, Token, ., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;]
[., ADD, :, newType, =, Token, ., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :, newType, =, Token, .]
[=, Token, ., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;]
[;, break, ;, case, Token, ., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR]
[., ASSIGN_ADD, ;, break, ;, case, Token, ., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;, case, Token]
[:, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;]
[., BITAND, :, newType, =, Token, ., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR, :, newType, =, Token, .]
[=, Token, ., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;]
[;, break, ;, case, Token, ., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR]
[., ASSIGN_BITAND, ;, break, ;, case, Token, ., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;, case, Token]
[:, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;]
[., BITOR, :, newType, =, Token, ., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR, :, newType, =, Token, .]
[=, Token, ., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;]
[;, break, ;, case, Token, ., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV]
[., ASSIGN_BITOR, ;, break, ;, case, Token, ., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token]
[:, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;]
[., BITXOR, :, newType, =, Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV, :, newType, =, Token, .]
[=, Token, ., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;, break, ;]
[;, break, ;, case, Token, ., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH]
[., ASSIGN_BITXOR, ;, break, ;, case, Token, ., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;, break, ;, case, Token]
[:, newType, =, Token, ., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;]
[., DIV, :, newType, =, Token, ., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH, :, newType, =, Token, .]
[=, Token, ., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;, break, ;]
[;, break, ;, case, Token, ., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD]
[., ASSIGN_DIV, ;, break, ;, case, Token, ., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;, break, ;, case, Token]
[:, newType, =, Token, ., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;]
[., LSH, :, newType, =, Token, ., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD, :, newType, =, Token, .]
[=, Token, ., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;, break, ;]
[;, break, ;, case, Token, ., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL]
[., ASSIGN_LSH, ;, break, ;, case, Token, ., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;, break, ;, case, Token]
[:, newType, =, Token, ., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;]
[., MOD, :, newType, =, Token, ., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL, :, newType, =, Token, .]
[=, Token, ., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;, break, ;]
[;, break, ;, case, Token, ., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH]
[., ASSIGN_MOD, ;, break, ;, case, Token, ., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;, break, ;, case, Token]
[:, newType, =, Token, ., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;]
[., MUL, :, newType, =, Token, ., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH, :, newType, =, Token, .]
[=, Token, ., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;, break, ;]
[;, break, ;, case, Token, ., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB]
[., ASSIGN_MUL, ;, break, ;, case, Token, ., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;, break, ;, case, Token]
[:, newType, =, Token, ., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;]
[., RSH, :, newType, =, Token, ., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB, :, newType, =, Token, .]
[=, Token, ., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;, break, ;]
[;, break, ;, case, Token, ., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;, break, ;, case, Token, ., URSH]
[., ASSIGN_RSH, ;, break, ;, case, Token, ., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;, break, ;, case, Token]
[:, newType, =, Token, ., ASSIGN_SUB, ;, break, ;, case, Token, ., URSH, :, newType, =, Token, ., ASSIGN_URSH, ;]
[., SUB, :, newType, =, Token, ., ASSIGN_SUB, ;, break, ;, case, Token, ., URSH, :, newType, =, Token, .]
[=, Token, ., ASSIGN_SUB, ;, break, ;, case, Token, ., URSH, :, newType, =, Token, ., ASSIGN_URSH, ;, break, ;]
[;, break, ;, case, Token, ., URSH, :, newType, =, Token, ., ASSIGN_URSH, ;, break, ;, default, :, return, n]
[., ASSIGN_SUB, ;, break, ;, case, Token, ., URSH, :, newType, =, Token, ., ASSIGN_URSH, ;, break, ;, default, :]
[:, newType, =, Token, ., ASSIGN_URSH, ;, break, ;, default, :, return, n, ;, }, Node, newNode, =, new, Node]
[., URSH, :, newType, =, Token, ., ASSIGN_URSH, ;, break, ;, default, :, return, n, ;, }, Node, newNode, =]
[=, Token, ., ASSIGN_URSH, ;, break, ;, default, :, return, n, ;, }, Node, newNode, =, new, Node, (, newType]
[;, break, ;, default, :, return, n, ;, }, Node, newNode, =, new, Node, (, newType, ,, left, ., detachFromParent]
[., ASSIGN_URSH, ;, break, ;, default, :, return, n, ;, }, Node, newNode, =, new, Node, (, newType, ,, left]
[;, }, Node, newNode, =, new, Node, (, newType, ,, left, ., detachFromParent, (, ), ,, newRight, ., detachFromParent, (]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode]
[,, left, ., detachFromParent, (, ), ,, newRight, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), .]
[,, newRight, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, )]
[., detachFromParent, (, ), ,, newRight, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return]
[., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange]
[;, reportCodeChange, (, ), ;, return, newNode, ;, }, private, Node, tryUnfoldAssignOp, (, Node, n, ,, Node, left, ,, Node]
[., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, private, Node, tryUnfoldAssignOp, (]
[., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }]
[,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, private, Node, tryUnfoldAssignOp, (, Node, n, ,, Node]
[), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, private, Node, tryUnfoldAssignOp, (, Node, n, ,, Node, left, ,]
[;, return, newNode, ;, }, private, Node, tryUnfoldAssignOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, if]
[;, }, private, Node, tryUnfoldAssignOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, late, )]
[), {, return, n, ;, }, if, (, !, n, ., hasChildren, (, ), ||, n, ., getFirstChild, (, )]
[;, }, if, (, !, n, ., hasChildren, (, ), ||, n, ., getFirstChild, (, ), ., getNext, (, )]
[), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, int, op]
[||, n, ., getFirstChild, (, ), ., getNext, (, ), !=, n, ., getLastChild, (, ), ), {, return, n]
[||, n, ., getFirstChild, (, ), ., getNext, (, ), !=, n, ., getLastChild, (, ), ), {, return, n]
[., hasChildren, (, ), ||, n, ., getFirstChild, (, ), ., getNext, (, ), !=, n, ., getLastChild, (, )]
[), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, int, op]
[!=, n, ., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {]
[., getNext, (, ), !=, n, ., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (]
[., getFirstChild, (, ), ., getNext, (, ), !=, n, ., getLastChild, (, ), ), {, return, n, ;, }]
[), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, int, op]
[., getLastChild, (, ), ), {, return, n, ;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n]
[;, }, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, int, op, =, NodeUtil, ., getOpFromAssignmentOp]
[), {, return, n, ;, }, int, op, =, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =, IR]
[), ), {, return, n, ;, }, int, op, =, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =]
[;, }, int, op, =, NodeUtil, ., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =, IR, ., assign, (, left]
[;, Node, replacement, =, IR, ., assign, (, left, ., detachFromParent, (, ), ,, new, Node, (, op, ,, left]
[., getOpFromAssignmentOp, (, n, ), ;, Node, replacement, =, IR, ., assign, (, left, ., detachFromParent, (, ), ,, new]
[), ;, Node, replacement, =, IR, ., assign, (, left, ., detachFromParent, (, ), ,, new, Node, (, op, ,]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement]
[., assign, (, left, ., detachFromParent, (, ), ,, new, Node, (, op, ,, left, ., cloneTree, (, ), ,]
[,, new, Node, (, op, ,, left, ., cloneTree, (, ), ,, right, ., detachFromParent, (, ), ), ., srcref]
[., detachFromParent, (, ), ,, new, Node, (, op, ,, left, ., cloneTree, (, ), ,, right, ., detachFromParent, (]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
[., srcref, (, n, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;]
[,, left, ., cloneTree, (, ), ,, right, ., detachFromParent, (, ), ), ., srcref, (, n, ), ), ;]
[,, right, ., detachFromParent, (, ), ), ., srcref, (, n, ), ), ;, n, ., getParent, (, ), .]
[., cloneTree, (, ), ,, right, ., detachFromParent, (, ), ), ., srcref, (, n, ), ), ;, n, .]
[), ., srcref, (, n, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, )]
[., detachFromParent, (, ), ), ., srcref, (, n, ), ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;]
[;, reportCodeChange, (, ), ;, return, replacement, ;, }, private, Node, tryFoldAndOr, (, Node, n, ,, Node, left, ,, Node]
[., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, private, Node, tryFoldAndOr, (]
[., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }]
[,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, private, Node, tryFoldAndOr, (, Node, n, ,, Node]
[), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, private, Node, tryFoldAndOr, (, Node, n, ,, Node, left, ,]
[;, return, replacement, ;, }, private, Node, tryFoldAndOr, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node]
[;, }, private, Node, tryFoldAndOr, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, parent, =, n]
[;, Node, result, =, null, ;, int, type, =, n, ., getType, (, ), ;, TernaryValue, leftVal, =, NodeUtil, .]
[., getParent, (, ), ;, Node, result, =, null, ;, int, type, =, n, ., getType, (, ), ;, TernaryValue]
[;, int, type, =, n, ., getType, (, ), ;, TernaryValue, leftVal, =, NodeUtil, ., getImpureBooleanValue, (, left, ), ;]
[;, TernaryValue, leftVal, =, NodeUtil, ., getImpureBooleanValue, (, left, ), ;, if, (, leftVal, !=, TernaryValue, ., UNKNOWN, ), {]
[., getType, (, ), ;, TernaryValue, leftVal, =, NodeUtil, ., getImpureBooleanValue, (, left, ), ;, if, (, leftVal, !=, TernaryValue]
[;, if, (, leftVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;]
[., getImpureBooleanValue, (, left, ), ;, if, (, leftVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, .]
[), ;, if, (, leftVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, )]
[), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, .]
[!=, TernaryValue, ., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&]
[), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, .]
[., UNKNOWN, ), {, boolean, lval, =, leftVal, ., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==]
[;, if, (, lval, &&, type, ==, Token, ., OR, ||, !, lval, &&, type, ==, Token, ., AND, )]
[., toBoolean, (, true, ), ;, if, (, lval, &&, type, ==, Token, ., OR, ||, !, lval, &&, type]
[), ;, if, (, lval, &&, type, ==, Token, ., OR, ||, !, lval, &&, type, ==, Token, ., AND]
[), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =, right]
[||, !, lval, &&, type, ==, Token, ., AND, ), {, result, =, left, ;, }, else, if, (, !]
[&&, type, ==, Token, ., OR, ||, !, lval, &&, type, ==, Token, ., AND, ), {, result, =, left]
[||, !, lval, &&, type, ==, Token, ., AND, ), {, result, =, left, ;, }, else, if, (, !]
[==, Token, ., OR, ||, !, lval, &&, type, ==, Token, ., AND, ), {, result, =, left, ;, }]
[||, !, lval, &&, type, ==, Token, ., AND, ), {, result, =, left, ;, }, else, if, (, !]
[., OR, ||, !, lval, &&, type, ==, Token, ., AND, ), {, result, =, left, ;, }, else, if]
[), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =, right]
[&&, type, ==, Token, ., AND, ), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left]
[&&, type, ==, Token, ., AND, ), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left]
[), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =, right]
[==, Token, ., AND, ), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), )]
[), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =, right]
[., AND, ), {, result, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result]
[=, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =, right, ;, }, }]
[;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, result, =, right, ;, }, }, if, (]
[), {, result, =, right, ;, }, }, if, (, result, !=, null, ), {, n, ., removeChild, (, result]
[), {, result, =, right, ;, }, }, if, (, result, !=, null, ), {, n, ., removeChild, (, result]
[), ), {, result, =, right, ;, }, }, if, (, result, !=, null, ), {, n, ., removeChild, (]
[=, right, ;, }, }, if, (, result, !=, null, ), {, n, ., removeChild, (, result, ), ;, parent]
[;, }, }, if, (, result, !=, null, ), {, n, ., removeChild, (, result, ), ;, parent, ., replaceChild]
[), {, n, ., removeChild, (, result, ), ;, parent, ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (]
[!=, null, ), {, n, ., removeChild, (, result, ), ;, parent, ., replaceChild, (, n, ,, result, ), ;]
[), {, n, ., removeChild, (, result, ), ;, parent, ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (]
[;, parent, ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return, result, ;, }, else, {]
[., removeChild, (, result, ), ;, parent, ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return, result, ;, }, else]
[;, reportCodeChange, (, ), ;, return, result, ;, }, else, {, return, n, ;, }, }, private, Node, tryFoldChildAddString, (]
[., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return, result, ;, }, else, {, return, n]
[,, result, ), ;, reportCodeChange, (, ), ;, return, result, ;, }, else, {, return, n, ;, }, }, private]
[), ;, reportCodeChange, (, ), ;, return, result, ;, }, else, {, return, n, ;, }, }, private, Node, tryFoldChildAddString]
[;, return, result, ;, }, else, {, return, n, ;, }, }, private, Node, tryFoldChildAddString, (, Node, n, ,, Node]
[;, }, else, {, return, n, ;, }, }, private, Node, tryFoldChildAddString, (, Node, n, ,, Node, left, ,, Node]
[;, }, }, private, Node, tryFoldChildAddString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, NodeUtil]
[), {, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;]
[&&, left, ., isAdd, (, ), ), {, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =]
[., isLiteralValue, (, right, ,, false, ), &&, left, ., isAdd, (, ), ), {, Node, ll, =, left, .]
[,, false, ), &&, left, ., isAdd, (, ), ), {, Node, ll, =, left, ., getFirstChild, (, ), ;]
[), &&, left, ., isAdd, (, ), ), {, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr]
[), {, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;]
[., isAdd, (, ), ), {, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, .]
[;, Node, lr, =, ll, ., getNext, (, ), ;, if, (, lr, ., isString, (, ), ), {, String]
[., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;, if, (, lr, ., isString, (]
[;, if, (, lr, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, lr, ), ;]
[., getNext, (, ), ;, if, (, lr, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue]
[), {, String, leftString, =, NodeUtil, ., getStringValue, (, lr, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right]
[., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, lr, ), ;, String, rightString, =, NodeUtil]
[;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null]
[., getStringValue, (, lr, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=]
[), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=]
[;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;, String]
[., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, left, ., removeChild]
[), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;]
[), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (]
[&&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;]
[!=, null, &&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +]
[&&, rightString, !=, null, ), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;]
[), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (]
[!=, null, ), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;, n, .]
[), {, left, ., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (]
[;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, left, ,, ll, ), ;, n, ., replaceChild]
[., removeChild, (, ll, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, left, ,, ll]
[), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, left, ,, ll, ), ;, n, .]
[;, n, ., replaceChild, (, left, ,, ll, ), ;, n, ., replaceChild, (, right, ,, IR, ., string, (]
[+, rightString, ;, n, ., replaceChild, (, left, ,, ll, ), ;, n, ., replaceChild, (, right, ,, IR, .]
[;, n, ., replaceChild, (, left, ,, ll, ), ;, n, ., replaceChild, (, right, ,, IR, ., string, (]
[;, n, ., replaceChild, (, right, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return]
[., replaceChild, (, left, ,, ll, ), ;, n, ., replaceChild, (, right, ,, IR, ., string, (, result, )]
[,, ll, ), ;, n, ., replaceChild, (, right, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (]
[), ;, n, ., replaceChild, (, right, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;]
[;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false]
[., replaceChild, (, right, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;]
[,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if]
[), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if, (, NodeUtil, ., isLiteralValue, (, left, ,]
[., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if, (, NodeUtil]
[), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, if, (, NodeUtil, ., isLiteralValue, (, left]
[;, return, n, ;, }, }, }, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, right, .]
[;, }, }, }, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, right, ., isAdd, (, )]
[), {, Node, rl, =, right, ., getFirstChild, (, ), ;, Node, rr, =, right, ., getLastChild, (, ), ;]
[&&, right, ., isAdd, (, ), ), {, Node, rl, =, right, ., getFirstChild, (, ), ;, Node, rr, =]
[., isLiteralValue, (, left, ,, false, ), &&, right, ., isAdd, (, ), ), {, Node, rl, =, right, .]
[,, false, ), &&, right, ., isAdd, (, ), ), {, Node, rl, =, right, ., getFirstChild, (, ), ;]
[), &&, right, ., isAdd, (, ), ), {, Node, rl, =, right, ., getFirstChild, (, ), ;, Node, rr]
[), {, Node, rl, =, right, ., getFirstChild, (, ), ;, Node, rr, =, right, ., getLastChild, (, ), ;]
[., isAdd, (, ), ), {, Node, rl, =, right, ., getFirstChild, (, ), ;, Node, rr, =, right, .]
[;, Node, rr, =, right, ., getLastChild, (, ), ;, if, (, rl, ., isString, (, ), ), {, String]
[., getFirstChild, (, ), ;, Node, rr, =, right, ., getLastChild, (, ), ;, if, (, rl, ., isString, (]
[;, if, (, rl, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;]
[., getLastChild, (, ), ;, if, (, rl, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue]
[), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl]
[., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil]
[;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null]
[., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (, leftString, !=]
[), ;, String, rightString, =, NodeUtil, ., getStringValue, (, rl, ), ;, if, (, leftString, !=, null, &&, rightString, !=]
[;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;, String]
[., getStringValue, (, rl, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, right, ., removeChild]
[), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;]
[), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (]
[&&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;]
[!=, null, &&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +]
[&&, rightString, !=, null, ), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;]
[), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (]
[!=, null, ), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;, n, .]
[), {, right, ., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (]
[;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, right, ,, rr, ), ;, n, ., replaceChild]
[., removeChild, (, rr, ), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, right, ,, rr]
[), ;, String, result, =, leftString, +, rightString, ;, n, ., replaceChild, (, right, ,, rr, ), ;, n, .]
[;, n, ., replaceChild, (, right, ,, rr, ), ;, n, ., replaceChild, (, left, ,, IR, ., string, (]
[+, rightString, ;, n, ., replaceChild, (, right, ,, rr, ), ;, n, ., replaceChild, (, left, ,, IR, .]
[;, n, ., replaceChild, (, right, ,, rr, ), ;, n, ., replaceChild, (, left, ,, IR, ., string, (]
[;, n, ., replaceChild, (, left, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return]
[., replaceChild, (, right, ,, rr, ), ;, n, ., replaceChild, (, left, ,, IR, ., string, (, result, )]
[,, rr, ), ;, n, ., replaceChild, (, left, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (]
[), ;, n, ., replaceChild, (, left, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;]
[;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, return, n, ;, }, private, Node, tryFoldAddConstantString, (, Node]
[., replaceChild, (, left, ,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;]
[,, IR, ., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, return]
[), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, return, n, ;, }, private, Node, tryFoldAddConstantString, (]
[., string, (, result, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, return, n, ;]
[), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, return, n, ;, }, private, Node, tryFoldAddConstantString]
[;, return, n, ;, }, }, }, return, n, ;, }, private, Node, tryFoldAddConstantString, (, Node, n, ,, Node, left]
[;, }, }, }, return, n, ;, }, private, Node, tryFoldAddConstantString, (, Node, n, ,, Node, left, ,, Node, right]
[;, }, private, Node, tryFoldAddConstantString, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, left, .]
[), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right]
[||, right, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString]
[., isString, (, ), ||, right, ., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left]
[), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right]
[., isString, (, ), ), {, String, leftString, =, NodeUtil, ., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil]
[;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null]
[., getStringValue, (, left, ), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=]
[), ;, String, rightString, =, NodeUtil, ., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=]
[;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (, leftString]
[., getStringValue, (, right, ), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =]
[), ;, if, (, leftString, !=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (]
[), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;, n, ., getParent, (, ), .]
[&&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;, n, .]
[!=, null, &&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;]
[&&, rightString, !=, null, ), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;, n, .]
[), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;, n, ., getParent, (, ), .]
[!=, null, ), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;, n, ., getParent, (]
[), {, Node, newStringNode, =, IR, ., string, (, leftString, +, rightString, ), ;, n, ., getParent, (, ), .]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newStringNode, ), ;, reportCodeChange, (, ), ;, return, newStringNode]
[., string, (, leftString, +, rightString, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newStringNode, )]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newStringNode, ), ;, reportCodeChange, (, ), ;, return]
[+, rightString, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newStringNode, ), ;, reportCodeChange, (, )]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newStringNode, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, newStringNode, ;, }, }, return, n, ;, }, private, Node, tryFoldArithmeticOp, (, Node, n]
[., replaceChild, (, n, ,, newStringNode, ), ;, reportCodeChange, (, ), ;, return, newStringNode, ;, }, }, return, n, ;]
[., getParent, (, ), ., replaceChild, (, n, ,, newStringNode, ), ;, reportCodeChange, (, ), ;, return, newStringNode, ;, }]
[,, newStringNode, ), ;, reportCodeChange, (, ), ;, return, newStringNode, ;, }, }, return, n, ;, }, private, Node, tryFoldArithmeticOp]
[), ;, reportCodeChange, (, ), ;, return, newStringNode, ;, }, }, return, n, ;, }, private, Node, tryFoldArithmeticOp, (, Node]
[;, return, newStringNode, ;, }, }, return, n, ;, }, private, Node, tryFoldArithmeticOp, (, Node, n, ,, Node, left, ,]
[;, }, }, return, n, ;, }, private, Node, tryFoldArithmeticOp, (, Node, n, ,, Node, left, ,, Node, right, )]
[;, }, private, Node, tryFoldArithmeticOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, result, =, performArithmeticOp]
[;, if, (, result, !=, null, ), {, result, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, )]
[,, left, ,, right, ), ;, if, (, result, !=, null, ), {, result, ., copyInformationFromForTree, (, n, ), ;]
[., getType, (, ), ,, left, ,, right, ), ;, if, (, result, !=, null, ), {, result, ., copyInformationFromForTree]
[,, right, ), ;, if, (, result, !=, null, ), {, result, ., copyInformationFromForTree, (, n, ), ;, n, .]
[), ;, if, (, result, !=, null, ), {, result, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (]
[), {, result, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, result]
[!=, null, ), {, result, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n]
[), {, result, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, result]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return, result]
[., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, result, ), ;, reportCodeChange]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, result, ;, }, return, n, ;, }, private, Node, performArithmeticOp, (, int, opType, ,]
[., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return, result, ;, }, return, n, ;, }]
[., getParent, (, ), ., replaceChild, (, n, ,, result, ), ;, reportCodeChange, (, ), ;, return, result, ;, }]
[,, result, ), ;, reportCodeChange, (, ), ;, return, result, ;, }, return, n, ;, }, private, Node, performArithmeticOp, (]
[), ;, reportCodeChange, (, ), ;, return, result, ;, }, return, n, ;, }, private, Node, performArithmeticOp, (, int, opType]
[;, return, result, ;, }, return, n, ;, }, private, Node, performArithmeticOp, (, int, opType, ,, Node, left, ,, Node]
[;, }, return, n, ;, }, private, Node, performArithmeticOp, (, int, opType, ,, Node, left, ,, Node, right, ), {]
[;, }, private, Node, performArithmeticOp, (, int, opType, ,, Node, left, ,, Node, right, ), {, if, (, opType, ==]
[), {, return, null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, ), ;, if]
[&&, (, NodeUtil, ., mayBeString, (, left, ,, false, ), ||, NodeUtil, ., mayBeString, (, right, ,, false, ), )]
[==, Token, ., ADD, &&, (, NodeUtil, ., mayBeString, (, left, ,, false, ), ||, NodeUtil, ., mayBeString, (, right]
[&&, (, NodeUtil, ., mayBeString, (, left, ,, false, ), ||, NodeUtil, ., mayBeString, (, right, ,, false, ), )]
[., ADD, &&, (, NodeUtil, ., mayBeString, (, left, ,, false, ), ||, NodeUtil, ., mayBeString, (, right, ,, false]
[), {, return, null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, ), ;, if]
[), ), {, return, null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, ), ;]
[||, NodeUtil, ., mayBeString, (, right, ,, false, ), ), ), {, return, null, ;, }, double, result, ;, Double]
[., mayBeString, (, left, ,, false, ), ||, NodeUtil, ., mayBeString, (, right, ,, false, ), ), ), {, return]
[,, false, ), ||, NodeUtil, ., mayBeString, (, right, ,, false, ), ), ), {, return, null, ;, }, double]
[), ||, NodeUtil, ., mayBeString, (, right, ,, false, ), ), ), {, return, null, ;, }, double, result, ;]
[), ), {, return, null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, ), ;]
[., mayBeString, (, right, ,, false, ), ), ), {, return, null, ;, }, double, result, ;, Double, lValObj, =]
[,, false, ), ), ), {, return, null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (]
[), ), ), {, return, null, ;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, )]
[;, }, double, result, ;, Double, lValObj, =, NodeUtil, ., getNumberValue, (, left, ), ;, if, (, lValObj, ==, null]
[;, if, (, lValObj, ==, null, ), {, return, null, ;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (, right]
[., getNumberValue, (, left, ), ;, if, (, lValObj, ==, null, ), {, return, null, ;, }, Double, rValObj, =]
[), ;, if, (, lValObj, ==, null, ), {, return, null, ;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (]
[), {, return, null, ;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rValObj, ==]
[==, null, ), {, return, null, ;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[), {, return, null, ;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rValObj, ==]
[;, }, Double, rValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rValObj, ==, null, ), {, return]
[;, if, (, rValObj, ==, null, ), {, return, null, ;, }, double, lval, =, lValObj, ;, double, rval, =]
[., getNumberValue, (, right, ), ;, if, (, rValObj, ==, null, ), {, return, null, ;, }, double, lval, =]
[), ;, if, (, rValObj, ==, null, ), {, return, null, ;, }, double, lval, =, lValObj, ;, double, rval]
[), {, return, null, ;, }, double, lval, =, lValObj, ;, double, rval, =, rValObj, ;, switch, (, opType, )]
[==, null, ), {, return, null, ;, }, double, lval, =, lValObj, ;, double, rval, =, rValObj, ;, switch, (]
[), {, return, null, ;, }, double, lval, =, lValObj, ;, double, rval, =, rValObj, ;, switch, (, opType, )]
[;, }, double, lval, =, lValObj, ;, double, rval, =, rValObj, ;, switch, (, opType, ), {, case, Token, .]
[;, double, rval, =, rValObj, ;, switch, (, opType, ), {, case, Token, ., BITAND, :, result, =, ScriptRuntime, .]
[;, switch, (, opType, ), {, case, Token, ., BITAND, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), &]
[), {, case, Token, ., BITAND, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), &, ScriptRuntime, ., toInt32, (]
[:, result, =, ScriptRuntime, ., toInt32, (, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case]
[., BITAND, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break]
[=, ScriptRuntime, ., toInt32, (, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, .]
[;, break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32]
[&, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, ., toInt32]
[., toInt32, (, lval, ), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITOR, :]
[), &, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, .]
[;, break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32]
[., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, ., toInt32, (, lval]
[), ;, break, ;, case, Token, ., BITOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), |, ScriptRuntime, .]
[:, result, =, ScriptRuntime, ., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case]
[., BITOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break]
[=, ScriptRuntime, ., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, .]
[;, break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32]
[|, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, ., toInt32]
[., toInt32, (, lval, ), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITXOR, :]
[), |, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, .]
[;, break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32]
[., toInt32, (, rval, ), ;, break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, ., toInt32, (, lval]
[), ;, break, ;, case, Token, ., BITXOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^, ScriptRuntime, .]
[:, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case]
[., BITXOR, :, result, =, ScriptRuntime, ., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break]
[=, ScriptRuntime, ., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, .]
[;, break, ;, case, Token, ., ADD, :, result, =, lval, +, rval, ;, break, ;, case, Token, ., SUB]
[^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., ADD, :, result, =, lval, +, rval]
[., toInt32, (, lval, ), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., ADD, :]
[), ^, ScriptRuntime, ., toInt32, (, rval, ), ;, break, ;, case, Token, ., ADD, :, result, =, lval, +]
[;, break, ;, case, Token, ., ADD, :, result, =, lval, +, rval, ;, break, ;, case, Token, ., SUB]
[., toInt32, (, rval, ), ;, break, ;, case, Token, ., ADD, :, result, =, lval, +, rval, ;, break]
[), ;, break, ;, case, Token, ., ADD, :, result, =, lval, +, rval, ;, break, ;, case, Token, .]
[:, result, =, lval, +, rval, ;, break, ;, case, Token, ., SUB, :, result, =, lval, -, rval, ;]
[., ADD, :, result, =, lval, +, rval, ;, break, ;, case, Token, ., SUB, :, result, =, lval, -]
[=, lval, +, rval, ;, break, ;, case, Token, ., SUB, :, result, =, lval, -, rval, ;, break, ;]
[;, break, ;, case, Token, ., SUB, :, result, =, lval, -, rval, ;, break, ;, case, Token, ., MUL]
[+, rval, ;, break, ;, case, Token, ., SUB, :, result, =, lval, -, rval, ;, break, ;, case, Token]
[;, break, ;, case, Token, ., SUB, :, result, =, lval, -, rval, ;, break, ;, case, Token, ., MUL]
[:, result, =, lval, -, rval, ;, break, ;, case, Token, ., MUL, :, result, =, lval, *, rval, ;]
[., SUB, :, result, =, lval, -, rval, ;, break, ;, case, Token, ., MUL, :, result, =, lval, *]
[=, lval, -, rval, ;, break, ;, case, Token, ., MUL, :, result, =, lval, *, rval, ;, break, ;]
[;, break, ;, case, Token, ., MUL, :, result, =, lval, *, rval, ;, break, ;, case, Token, ., MOD]
[-, rval, ;, break, ;, case, Token, ., MUL, :, result, =, lval, *, rval, ;, break, ;, case, Token]
[;, break, ;, case, Token, ., MUL, :, result, =, lval, *, rval, ;, break, ;, case, Token, ., MOD]
[:, result, =, lval, *, rval, ;, break, ;, case, Token, ., MOD, :, if, (, rval, ==, 0, )]
[., MUL, :, result, =, lval, *, rval, ;, break, ;, case, Token, ., MOD, :, if, (, rval, ==]
[=, lval, *, rval, ;, break, ;, case, Token, ., MOD, :, if, (, rval, ==, 0, ), {, return]
[;, break, ;, case, Token, ., MOD, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result]
[*, rval, ;, break, ;, case, Token, ., MOD, :, if, (, rval, ==, 0, ), {, return, null, ;]
[;, break, ;, case, Token, ., MOD, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result]
[:, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =, lval, %, rval, ;, break, ;]
[., MOD, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =, lval, %, rval, ;]
[), {, return, null, ;, }, result, =, lval, %, rval, ;, break, ;, case, Token, ., DIV, :, if]
[==, 0, ), {, return, null, ;, }, result, =, lval, %, rval, ;, break, ;, case, Token, ., DIV]
[), {, return, null, ;, }, result, =, lval, %, rval, ;, break, ;, case, Token, ., DIV, :, if]
[;, }, result, =, lval, %, rval, ;, break, ;, case, Token, ., DIV, :, if, (, rval, ==, 0]
[=, lval, %, rval, ;, break, ;, case, Token, ., DIV, :, if, (, rval, ==, 0, ), {, return]
[;, break, ;, case, Token, ., DIV, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result]
[%, rval, ;, break, ;, case, Token, ., DIV, :, if, (, rval, ==, 0, ), {, return, null, ;]
[;, break, ;, case, Token, ., DIV, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result]
[:, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =, lval, /, rval, ;, break, ;]
[., DIV, :, if, (, rval, ==, 0, ), {, return, null, ;, }, result, =, lval, /, rval, ;]
[), {, return, null, ;, }, result, =, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (]
[==, 0, ), {, return, null, ;, }, result, =, lval, /, rval, ;, break, ;, default, :, throw, new]
[), {, return, null, ;, }, result, =, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (]
[;, }, result, =, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }]
[=, lval, /, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (]
[;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (, String, ., valueOf, (]
[/, rval, ;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (, String, .]
[;, break, ;, default, :, throw, new, Error, (, "Unexpected arithmetic operator", ), ;, }, if, (, (, String, ., valueOf, (]
[;, }, if, (, (, String, ., valueOf, (, result, ), ., length, (, ), <=, String, ., valueOf, (]
[), ;, }, if, (, (, String, ., valueOf, (, result, ), ., length, (, ), <=, String, ., valueOf]
[), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;, }, return, null, ;, }, private, Node, tryFoldLeftChildOp]
[||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;, }, return]
[||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result]
[||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, )]
[), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY]
[&&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==]
[<=, String, ., valueOf, (, lval, ), ., length, (, ), +, String, ., valueOf, (, rval, ), ., length]
[., length, (, ), <=, String, ., valueOf, (, lval, ), ., length, (, ), +, String, ., valueOf, (]
[., valueOf, (, result, ), ., length, (, ), <=, String, ., valueOf, (, lval, ), ., length, (, )]
[), ., length, (, ), <=, String, ., valueOf, (, lval, ), ., length, (, ), +, String, ., valueOf]
[&&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==]
[+, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||]
[+, String, ., valueOf, (, rval, ), ., length, (, ), +, 1, &&, Math, ., abs, (, result, )]
[., length, (, ), +, String, ., valueOf, (, rval, ), ., length, (, ), +, 1, &&, Math, .]
[., valueOf, (, lval, ), ., length, (, ), +, String, ., valueOf, (, rval, ), ., length, (, )]
[), ., length, (, ), +, String, ., valueOf, (, rval, ), ., length, (, ), +, 1, &&, Math]
[+, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||]
[., length, (, ), +, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN]
[., valueOf, (, rval, ), ., length, (, ), +, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER]
[), ., length, (, ), +, 1, &&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, .]
[&&, Math, ., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==]
[), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY]
[<=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double]
[., abs, (, result, ), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, .]
[), <=, MAX_FOLD_NUMBER, ), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==]
[), ||, Double, ., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY]
[||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result]
[., isNaN, (, result, ), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return]
[), ||, result, ==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (]
[||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;, }, return]
[==, Double, ., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result, ,, null]
[||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;, }, return]
[., POSITIVE_INFINITY, ||, result, ==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;]
[), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;, }, return, null, ;, }, private, Node, tryFoldLeftChildOp]
[==, Double, ., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;, }, return, null, ;]
[), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;, }, return, null, ;, }, private, Node, tryFoldLeftChildOp]
[., NEGATIVE_INFINITY, ), {, return, NodeUtil, ., numberNode, (, result, ,, null, ), ;, }, return, null, ;, }, private]
[;, }, return, null, ;, }, private, Node, tryFoldLeftChildOp, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[., numberNode, (, result, ,, null, ), ;, }, return, null, ;, }, private, Node, tryFoldLeftChildOp, (, Node, n, ,]
[,, null, ), ;, }, return, null, ;, }, private, Node, tryFoldLeftChildOp, (, Node, n, ,, Node, left, ,, Node]
[), ;, }, return, null, ;, }, private, Node, tryFoldLeftChildOp, (, Node, n, ,, Node, left, ,, Node, right, )]
[;, }, private, Node, tryFoldLeftChildOp, (, Node, n, ,, Node, left, ,, Node, right, ), {, int, opType, =, n]
[;, Preconditions, ., checkState, (, (, NodeUtil, ., isAssociative, (, opType, ), &&, NodeUtil, ., isCommutative, (, opType, ), )]
[., getType, (, ), ;, Preconditions, ., checkState, (, (, NodeUtil, ., isAssociative, (, opType, ), &&, NodeUtil, ., isCommutative]
[;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||, !, NodeUtil, ., mayBeString, (, n, ), )]
[., checkState, (, (, NodeUtil, ., isAssociative, (, opType, ), &&, NodeUtil, ., isCommutative, (, opType, ), ), ||, n]
[), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||, !, NodeUtil, ., mayBeString, (, n, )]
[||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||, !]
[), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||]
[&&, NodeUtil, ., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (]
[., isAssociative, (, opType, ), &&, NodeUtil, ., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), )]
[), &&, NodeUtil, ., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState]
[), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||]
[., isCommutative, (, opType, ), ), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !, n]
[), ), ||, n, ., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, )]
[), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||, !, NodeUtil, ., mayBeString, (, n, )]
[., isAdd, (, ), ), ;, Preconditions, ., checkState, (, !, n, ., isAdd, (, ), ||, !, NodeUtil, .]
[;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&, left, ., getType]
[., checkState, (, !, n, ., isAdd, (, ), ||, !, NodeUtil, ., mayBeString, (, n, ), ), ;, Double]
[), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&, left, .]
[||, !, NodeUtil, ., mayBeString, (, n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;]
[||, !, NodeUtil, ., mayBeString, (, n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;]
[., isAdd, (, ), ||, !, NodeUtil, ., mayBeString, (, n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue]
[), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&, left, .]
[), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&, left, .]
[., mayBeString, (, n, ), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj]
[), ), ;, Double, rightValObj, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&, left]
[;, if, (, rightValObj, !=, null, &&, left, ., getType, (, ), ==, opType, ), {, Preconditions, ., checkState, (]
[., getNumberValue, (, right, ), ;, if, (, rightValObj, !=, null, &&, left, ., getType, (, ), ==, opType, )]
[), ;, if, (, rightValObj, !=, null, &&, left, ., getType, (, ), ==, opType, ), {, Preconditions, ., checkState]
[), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==, 2, ), ;, Node, ll, =, left, .]
[&&, left, ., getType, (, ), ==, opType, ), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==]
[!=, null, &&, left, ., getType, (, ), ==, opType, ), {, Preconditions, ., checkState, (, left, ., getChildCount, (]
[&&, left, ., getType, (, ), ==, opType, ), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==]
[), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==, 2, ), ;, Node, ll, =, left, .]
[==, opType, ), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==, 2, ), ;, Node, ll, =]
[., getType, (, ), ==, opType, ), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==, 2, )]
[), {, Preconditions, ., checkState, (, left, ., getChildCount, (, ), ==, 2, ), ;, Node, ll, =, left, .]
[;, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;, Node]
[., checkState, (, left, ., getChildCount, (, ), ==, 2, ), ;, Node, ll, =, left, ., getFirstChild, (, )]
[), ;, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;]
[==, 2, ), ;, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (]
[., getChildCount, (, ), ==, 2, ), ;, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =]
[), ;, Node, ll, =, left, ., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;]
[;, Node, lr, =, ll, ., getNext, (, ), ;, Node, valueToCombine, =, ll, ;, Node, replacement, =, performArithmeticOp, (]
[., getFirstChild, (, ), ;, Node, lr, =, ll, ., getNext, (, ), ;, Node, valueToCombine, =, ll, ;, Node]
[;, Node, valueToCombine, =, ll, ;, Node, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, if, (]
[., getNext, (, ), ;, Node, valueToCombine, =, ll, ;, Node, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right]
[;, Node, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, if, (, replacement, ==, null, ), {]
[;, if, (, replacement, ==, null, ), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,]
[,, valueToCombine, ,, right, ), ;, if, (, replacement, ==, null, ), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp]
[,, right, ), ;, if, (, replacement, ==, null, ), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType]
[), ;, if, (, replacement, ==, null, ), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine]
[), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (]
[==, null, ), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }]
[), {, valueToCombine, =, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (]
[=, lr, ;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (, replacement, !=, null]
[;, replacement, =, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (, replacement, !=, null, ), {]
[=, performArithmeticOp, (, opType, ,, valueToCombine, ,, right, ), ;, }, if, (, replacement, !=, null, ), {, left, .]
[;, }, if, (, replacement, !=, null, ), {, left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (]
[,, valueToCombine, ,, right, ), ;, }, if, (, replacement, !=, null, ), {, left, ., removeChild, (, valueToCombine, )]
[,, right, ), ;, }, if, (, replacement, !=, null, ), {, left, ., removeChild, (, valueToCombine, ), ;, n]
[), ;, }, if, (, replacement, !=, null, ), {, left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild]
[), {, left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, )]
[!=, null, ), {, left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (, left, ,, left, ., removeFirstChild]
[), {, left, ., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, )]
[;, n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (, right, )]
[., removeChild, (, valueToCombine, ), ;, n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, ), ), ;, replacement]
[), ;, n, ., replaceChild, (, left, ,, left, ., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (, right]
[;, replacement, ., copyInformationFromForTree, (, right, ), ;, n, ., replaceChild, (, right, ,, replacement, ), ;, reportCodeChange, (, )]
[., replaceChild, (, left, ,, left, ., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (, right, ), ;, n]
[,, left, ., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (, right, ), ;, n, ., replaceChild, (, right]
[), ;, replacement, ., copyInformationFromForTree, (, right, ), ;, n, ., replaceChild, (, right, ,, replacement, ), ;, reportCodeChange, (]
[., removeFirstChild, (, ), ), ;, replacement, ., copyInformationFromForTree, (, right, ), ;, n, ., replaceChild, (, right, ,, replacement]
[;, n, ., replaceChild, (, right, ,, replacement, ), ;, reportCodeChange, (, ), ;, }, }, return, n, ;, }]
[., copyInformationFromForTree, (, right, ), ;, n, ., replaceChild, (, right, ,, replacement, ), ;, reportCodeChange, (, ), ;, }]
[), ;, n, ., replaceChild, (, right, ,, replacement, ), ;, reportCodeChange, (, ), ;, }, }, return, n, ;]
[;, reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, Node, tryFoldAdd, (, Node, node, ,, Node, left]
[., replaceChild, (, right, ,, replacement, ), ;, reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, Node]
[,, replacement, ), ;, reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, Node, tryFoldAdd, (, Node, node]
[), ;, reportCodeChange, (, ), ;, }, }, return, n, ;, }, private, Node, tryFoldAdd, (, Node, node, ,, Node]
[;, }, }, return, n, ;, }, private, Node, tryFoldAdd, (, Node, node, ,, Node, left, ,, Node, right, )]
[;, }, private, Node, tryFoldAdd, (, Node, node, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, if, (, NodeUtil, ., mayBeString, (, node, ,, true, ), ), {, if, (, NodeUtil, ., isLiteralValue, (, left]
[., checkArgument, (, node, ., isAdd, (, ), ), ;, if, (, NodeUtil, ., mayBeString, (, node, ,, true, )]
[), ;, if, (, NodeUtil, ., mayBeString, (, node, ,, true, ), ), {, if, (, NodeUtil, ., isLiteralValue, (]
[., isAdd, (, ), ), ;, if, (, NodeUtil, ., mayBeString, (, node, ,, true, ), ), {, if, (]
[), {, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, NodeUtil, ., isLiteralValue, (, right, ,, false]
[., mayBeString, (, node, ,, true, ), ), {, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&]
[,, true, ), ), {, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, NodeUtil, ., isLiteralValue, (]
[), ), {, if, (, NodeUtil, ., isLiteralValue, (, left, ,, false, ), &&, NodeUtil, ., isLiteralValue, (, right, ,]
[), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right, ), ;, }, else, {, return, tryFoldChildAddString, (, node, ,]
[&&, NodeUtil, ., isLiteralValue, (, right, ,, false, ), ), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right, )]
[., isLiteralValue, (, left, ,, false, ), &&, NodeUtil, ., isLiteralValue, (, right, ,, false, ), ), {, return, tryFoldAddConstantString]
[,, false, ), &&, NodeUtil, ., isLiteralValue, (, right, ,, false, ), ), {, return, tryFoldAddConstantString, (, node, ,, left]
[), &&, NodeUtil, ., isLiteralValue, (, right, ,, false, ), ), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right]
[), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right, ), ;, }, else, {, return, tryFoldChildAddString, (, node, ,]
[., isLiteralValue, (, right, ,, false, ), ), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right, ), ;, }]
[,, false, ), ), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right, ), ;, }, else, {, return, tryFoldChildAddString]
[), ), {, return, tryFoldAddConstantString, (, node, ,, left, ,, right, ), ;, }, else, {, return, tryFoldChildAddString, (, node]
[;, }, else, {, return, tryFoldChildAddString, (, node, ,, left, ,, right, ), ;, }, }, else, {, Node, result]
[,, left, ,, right, ), ;, }, else, {, return, tryFoldChildAddString, (, node, ,, left, ,, right, ), ;, }]
[,, right, ), ;, }, else, {, return, tryFoldChildAddString, (, node, ,, left, ,, right, ), ;, }, }, else]
[), ;, }, else, {, return, tryFoldChildAddString, (, node, ,, left, ,, right, ), ;, }, }, else, {, Node]
[;, }, }, else, {, Node, result, =, tryFoldArithmeticOp, (, node, ,, left, ,, right, ), ;, if, (, result]
[,, left, ,, right, ), ;, }, }, else, {, Node, result, =, tryFoldArithmeticOp, (, node, ,, left, ,, right]
[,, right, ), ;, }, }, else, {, Node, result, =, tryFoldArithmeticOp, (, node, ,, left, ,, right, ), ;]
[), ;, }, }, else, {, Node, result, =, tryFoldArithmeticOp, (, node, ,, left, ,, right, ), ;, if, (]
[;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, node, ,, left, ,, right]
[,, left, ,, right, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (]
[,, right, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, node, ,]
[), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, node, ,, left, ,]
[), {, return, result, ;, }, return, tryFoldLeftChildOp, (, node, ,, left, ,, right, ), ;, }, }, private, Node]
[!=, node, ), {, return, result, ;, }, return, tryFoldLeftChildOp, (, node, ,, left, ,, right, ), ;, }, }]
[), {, return, result, ;, }, return, tryFoldLeftChildOp, (, node, ,, left, ,, right, ), ;, }, }, private, Node]
[;, }, return, tryFoldLeftChildOp, (, node, ,, left, ,, right, ), ;, }, }, private, Node, tryFoldShift, (, Node, n]
[;, }, }, private, Node, tryFoldShift, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (, left]
[,, left, ,, right, ), ;, }, }, private, Node, tryFoldShift, (, Node, n, ,, Node, left, ,, Node, right]
[,, right, ), ;, }, }, private, Node, tryFoldShift, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[), ;, }, }, private, Node, tryFoldShift, (, Node, n, ,, Node, left, ,, Node, right, ), {, if, (]
[), {, double, result, ;, double, lval, =, left, ., getDouble, (, ), ;, double, rval, =, right, ., getDouble]
[&&, right, ., isNumber, (, ), ), {, double, result, ;, double, lval, =, left, ., getDouble, (, ), ;]
[., isNumber, (, ), &&, right, ., isNumber, (, ), ), {, double, result, ;, double, lval, =, left, .]
[), {, double, result, ;, double, lval, =, left, ., getDouble, (, ), ;, double, rval, =, right, ., getDouble]
[., isNumber, (, ), ), {, double, result, ;, double, lval, =, left, ., getDouble, (, ), ;, double, rval]
[;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !, (, lval, >=, Integer, ., MIN_VALUE, &&]
[., getDouble, (, ), ;, double, rval, =, right, ., getDouble, (, ), ;, if, (, !, (, lval, >=]
[;, if, (, !, (, lval, >=, Integer, ., MIN_VALUE, &&, lval, <=, Integer, ., MAX_VALUE, ), ), {, report]
[., getDouble, (, ), ;, if, (, !, (, lval, >=, Integer, ., MIN_VALUE, &&, lval, <=, Integer, ., MAX_VALUE]
[), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=, 0]
[), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=, 0]
[), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=]
[&&, lval, <=, Integer, ., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }]
[>=, Integer, ., MIN_VALUE, &&, lval, <=, Integer, ., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;]
[&&, lval, <=, Integer, ., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }]
[., MIN_VALUE, &&, lval, <=, Integer, ., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n]
[), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=]
[<=, Integer, ., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (]
[), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=]
[., MAX_VALUE, ), ), {, report, (, BITWISE_OPERAND_OUT_OF_RANGE, ,, left, ), ;, return, n, ;, }, if, (, !, (]
[;, return, n, ;, }, if, (, !, (, rval, >=, 0, &&, rval, <, 32, ), ), {, report]
[,, left, ), ;, return, n, ;, }, if, (, !, (, rval, >=, 0, &&, rval, <, 32, )]
[), ;, return, n, ;, }, if, (, !, (, rval, >=, 0, &&, rval, <, 32, ), ), {]
[;, }, if, (, !, (, rval, >=, 0, &&, rval, <, 32, ), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,]
[), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, ), lval]
[), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, ), lval]
[), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, )]
[&&, rval, <, 32, ), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt]
[>=, 0, &&, rval, <, 32, ), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }]
[&&, rval, <, 32, ), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt]
[), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, )]
[<, 32, ), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =, (]
[), ), {, report, (, SHIFT_AMOUNT_OUT_OF_BOUNDS, ,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, )]
[;, return, n, ;, }, int, lvalInt, =, (, int, ), lval, ;, if, (, lvalInt, !=, lval, ), {]
[,, right, ), ;, return, n, ;, }, int, lvalInt, =, (, int, ), lval, ;, if, (, lvalInt, !=]
[), ;, return, n, ;, }, int, lvalInt, =, (, int, ), lval, ;, if, (, lvalInt, !=, lval, )]
[;, }, int, lvalInt, =, (, int, ), lval, ;, if, (, lvalInt, !=, lval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND]
[;, if, (, lvalInt, !=, lval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, int]
[;, if, (, lvalInt, !=, lval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, int]
[), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, int, rvalInt, =, (, int, ), rval]
[!=, lval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, int, rvalInt, =, (, int]
[), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, left, ), ;, return, n, ;, }, int, rvalInt, =, (, int, ), rval]
[;, return, n, ;, }, int, rvalInt, =, (, int, ), rval, ;, if, (, rvalInt, !=, rval, ), {]
[,, left, ), ;, return, n, ;, }, int, rvalInt, =, (, int, ), rval, ;, if, (, rvalInt, !=]
[), ;, return, n, ;, }, int, rvalInt, =, (, int, ), rval, ;, if, (, rvalInt, !=, rval, )]
[;, }, int, rvalInt, =, (, int, ), rval, ;, if, (, rvalInt, !=, rval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND]
[;, if, (, rvalInt, !=, rval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return, n, ;, }, switch]
[;, if, (, rvalInt, !=, rval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return, n, ;, }, switch]
[), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return, n, ;, }, switch, (, n, ., getType, (, )]
[!=, rval, ), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return, n, ;, }, switch, (, n, ., getType]
[), {, report, (, FRACTIONAL_BITWISE_OPERAND, ,, right, ), ;, return, n, ;, }, switch, (, n, ., getType, (, )]
[;, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., LSH, :, result]
[,, right, ), ;, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, .]
[), ;, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., LSH, :]
[;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., LSH, :, result, =, lvalInt, <<]
[), {, case, Token, ., LSH, :, result, =, lvalInt, <<, rvalInt, ;, break, ;, case, Token, ., RSH, :]
[., getType, (, ), ), {, case, Token, ., LSH, :, result, =, lvalInt, <<, rvalInt, ;, break, ;, case]
[:, result, =, lvalInt, <<, rvalInt, ;, break, ;, case, Token, ., RSH, :, result, =, lvalInt, >, >, rvalInt]
[., LSH, :, result, =, lvalInt, <<, rvalInt, ;, break, ;, case, Token, ., RSH, :, result, =, lvalInt, >]
[=, lvalInt, <<, rvalInt, ;, break, ;, case, Token, ., RSH, :, result, =, lvalInt, >, >, rvalInt, ;, break]
[;, break, ;, case, Token, ., RSH, :, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case, Token, .]
[<<, rvalInt, ;, break, ;, case, Token, ., RSH, :, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case]
[;, break, ;, case, Token, ., RSH, :, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case, Token, .]
[:, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &]
[., RSH, :, result, =, lvalInt, >, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =]
[=, lvalInt, >, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;]
[;, break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;, result, =, lvalLong, >, >]
[>, >, rvalInt, ;, break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;, result, =]
[;, break, ;, case, Token, ., URSH, :, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;, result, =, lvalLong, >, >]
[:, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :]
[., URSH, :, long, lvalLong, =, lvalInt, &, 0xffffffffL, ;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;]
[;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +, Token]
[&, 0xffffffffL, ;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: "]
[;, result, =, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +, Token]
[=, lvalLong, >, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +, Token, ., name]
[;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +, Token, ., name, (, n, ., getType, (, )]
[>, >, >, rvalInt, ;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +, Token, ., name, (, n]
[;, break, ;, default, :, throw, new, AssertionError, (, "Unknown shift operator: ", +, Token, ., name, (, n, ., getType, (, )]
[;, }, Node, newNumber, =, IR, ., number, (, result, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ;, }, Node, newNumber, =, IR, ., number, (, result, ), ;, n, ., getParent, (, ), ., replaceChild]
[+, Token, ., name, (, n, ., getType, (, ), ), ), ;, }, Node, newNumber, =, IR, ., number]
[), ;, }, Node, newNumber, =, IR, ., number, (, result, ), ;, n, ., getParent, (, ), ., replaceChild]
[., name, (, n, ., getType, (, ), ), ), ;, }, Node, newNumber, =, IR, ., number, (, result]
[), ), ;, }, Node, newNumber, =, IR, ., number, (, result, ), ;, n, ., getParent, (, ), .]
[., getType, (, ), ), ), ;, }, Node, newNumber, =, IR, ., number, (, result, ), ;, n, .]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNumber, ), ;, reportCodeChange, (, ), ;, return, newNumber]
[., number, (, result, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNumber, ), ;, reportCodeChange]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNumber, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, newNumber, ;, }, return, n, ;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node]
[., replaceChild, (, n, ,, newNumber, ), ;, reportCodeChange, (, ), ;, return, newNumber, ;, }, return, n, ;, }]
[., getParent, (, ), ., replaceChild, (, n, ,, newNumber, ), ;, reportCodeChange, (, ), ;, return, newNumber, ;, }]
[,, newNumber, ), ;, reportCodeChange, (, ), ;, return, newNumber, ;, }, return, n, ;, }, @, SuppressWarnings, (, "fallthrough"]
[), ;, reportCodeChange, (, ), ;, return, newNumber, ;, }, return, n, ;, }, @, SuppressWarnings, (, "fallthrough", ), private]
[;, return, newNumber, ;, }, return, n, ;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryFoldComparison, (, Node, n]
[;, }, return, n, ;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryFoldComparison, (, Node, n, ,, Node, left]
[;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryFoldComparison, (, Node, n, ,, Node, left, ,, Node, right, )]
[private, Node, tryFoldComparison, (, Node, n, ,, Node, left, ,, Node, right, ), {, TernaryValue, result, =, evaluateComparison, (, n]
[), private, Node, tryFoldComparison, (, Node, n, ,, Node, left, ,, Node, right, ), {, TernaryValue, result, =, evaluateComparison, (]
[;, if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode]
[,, left, ,, right, ), ;, if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node]
[., getType, (, ), ,, left, ,, right, ), ;, if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return]
[,, right, ), ;, if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =]
[), ;, if, (, result, ==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =, NodeUtil, .]
[), {, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (, result, ., toBoolean, (, true, ), )]
[==, TernaryValue, ., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (, result, ., toBoolean]
[), {, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (, result, ., toBoolean, (, true, ), )]
[., UNKNOWN, ), {, return, n, ;, }, Node, newNode, =, NodeUtil, ., booleanNode, (, result, ., toBoolean, (, true]
[;, }, Node, newNode, =, NodeUtil, ., booleanNode, (, result, ., toBoolean, (, true, ), ), ;, n, ., getParent]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode]
[., booleanNode, (, result, ., toBoolean, (, true, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return]
[., toBoolean, (, true, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;]
[), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;]
[;, reportCodeChange, (, ), ;, return, newNode, ;, }, static, TernaryValue, evaluateComparison, (, int, op, ,, Node, left, ,, Node]
[., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, static, TernaryValue, evaluateComparison, (]
[., getParent, (, ), ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }]
[,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, static, TernaryValue, evaluateComparison, (, int, op, ,, Node]
[), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, static, TernaryValue, evaluateComparison, (, int, op, ,, Node, left, ,]
[;, return, newNode, ;, }, static, TernaryValue, evaluateComparison, (, int, op, ,, Node, left, ,, Node, right, ), {, boolean]
[;, }, static, TernaryValue, evaluateComparison, (, int, op, ,, Node, left, ,, Node, right, ), {, boolean, leftLiteral, =, NodeUtil]
[;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral]
[., isLiteralValue, (, left, ,, true, ), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;]
[,, true, ), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral]
[), ;, boolean, rightLiteral, =, NodeUtil, ., isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||, !]
[;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&, op, !=]
[., isLiteralValue, (, right, ,, true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op]
[,, true, ), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op, !=, Token, ., GT]
[), ;, if, (, !, leftLiteral, ||, !, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&, op]
[), {, if, (, op, !=, Token, ., GT, &&, op, !=, Token, ., LT, ), {, return, TernaryValue, .]
[||, !, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&, op, !=, Token, ., LT, ), {]
[||, !, rightLiteral, ), {, if, (, op, !=, Token, ., GT, &&, op, !=, Token, ., LT, ), {]
[), {, if, (, op, !=, Token, ., GT, &&, op, !=, Token, ., LT, ), {, return, TernaryValue, .]
[), {, if, (, op, !=, Token, ., GT, &&, op, !=, Token, ., LT, ), {, return, TernaryValue, .]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (, right, ), &&, rightLiteral]
[&&, op, !=, Token, ., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, .]
[!=, Token, ., GT, &&, op, !=, Token, ., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean]
[&&, op, !=, Token, ., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, .]
[., GT, &&, op, !=, Token, ., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (, right, ), &&, rightLiteral]
[!=, Token, ., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (, right, ), &&, rightLiteral]
[., LT, ), {, return, TernaryValue, ., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (, right, )]
[;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (, right, ), &&, rightLiteral, ;, boolean, nullRight, =, right, .]
[., UNKNOWN, ;, }, }, boolean, undefinedRight, =, NodeUtil, ., isUndefined, (, right, ), &&, rightLiteral, ;, boolean, nullRight, =]
[;, boolean, nullRight, =, right, ., isNull, (, ), ;, int, lhType, =, getNormalizedNodeType, (, left, ), ;, int, rhType]
[&&, rightLiteral, ;, boolean, nullRight, =, right, ., isNull, (, ), ;, int, lhType, =, getNormalizedNodeType, (, left, ), ;]
[., isUndefined, (, right, ), &&, rightLiteral, ;, boolean, nullRight, =, right, ., isNull, (, ), ;, int, lhType, =]
[), &&, rightLiteral, ;, boolean, nullRight, =, right, ., isNull, (, ), ;, int, lhType, =, getNormalizedNodeType, (, left, )]
[;, boolean, nullRight, =, right, ., isNull, (, ), ;, int, lhType, =, getNormalizedNodeType, (, left, ), ;, int, rhType]
[;, int, lhType, =, getNormalizedNodeType, (, left, ), ;, int, rhType, =, getNormalizedNodeType, (, right, ), ;, switch, (, lhType]
[., isNull, (, ), ;, int, lhType, =, getNormalizedNodeType, (, left, ), ;, int, rhType, =, getNormalizedNodeType, (, right, )]
[;, int, rhType, =, getNormalizedNodeType, (, right, ), ;, switch, (, lhType, ), {, case, Token, ., VOID, :, if]
[), ;, int, rhType, =, getNormalizedNodeType, (, right, ), ;, switch, (, lhType, ), {, case, Token, ., VOID, :]
[;, switch, (, lhType, ), {, case, Token, ., VOID, :, if, (, !, leftLiteral, ), {, return, TernaryValue, .]
[), ;, switch, (, lhType, ), {, case, Token, ., VOID, :, if, (, !, leftLiteral, ), {, return, TernaryValue]
[), {, case, Token, ., VOID, :, if, (, !, leftLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else]
[:, if, (, !, leftLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, if, (, !, rightLiteral, ), {]
[., VOID, :, if, (, !, leftLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, if, (, !, rightLiteral]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, else, if, (, !, rightLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, else, if, (, !, rightLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;]
[;, }, else, if, (, !, rightLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, TernaryValue, .]
[., UNKNOWN, ;, }, else, if, (, !, rightLiteral, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op]
[;, }, else, {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, case, Token]
[., UNKNOWN, ;, }, else, {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }]
[;, }, case, Token, ., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, .]
[., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, case, Token, ., NULL, :, if, (, rightLiteral]
[), ;, }, case, Token, ., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue]
[,, op, ), ), ;, }, case, Token, ., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (, op, ), )]
[), ), ;, }, case, Token, ., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return]
[:, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,]
[., NULL, :, if, (, rightLiteral, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,, op, ), ), ;, }, case, Token, ., TRUE]
[&&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,, op, ), ), ;]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,, op, ), ), ;, }, case, Token, ., TRUE]
[), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, right, ,, op, ), ), ;, }, case, Token, .]
[;, }, case, Token, ., TRUE, :, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return, TernaryValue, .]
[., forBoolean, (, compareToNull, (, right, ,, op, ), ), ;, }, case, Token, ., TRUE, :, case, Token, .]
[), ;, }, case, Token, ., TRUE, :, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return, TernaryValue]
[,, op, ), ), ;, }, case, Token, ., TRUE, :, case, Token, ., FALSE, :, if, (, undefinedRight, )]
[), ), ;, }, case, Token, ., TRUE, :, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return]
[:, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[., TRUE, :, case, Token, ., FALSE, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[:, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }]
[., FALSE, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), )]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rhType, !=]
[;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&, rhType, !=, Token, .]
[., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&]
[), ;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&, rhType, !=, Token]
[,, op, ), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&]
[), ), ;, }, if, (, rhType, !=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&, rhType, !=]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token]
[&&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[&&, rhType, !=, Token, ., FALSE, &&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }]
[!=, Token, ., TRUE, &&, rhType, !=, Token, ., FALSE, &&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue]
[&&, rhType, !=, Token, ., FALSE, &&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }]
[., TRUE, &&, rhType, !=, Token, ., FALSE, &&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN]
[&&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[!=, Token, ., FALSE, &&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (]
[&&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[., FALSE, &&, rhType, !=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, )]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token]
[!=, Token, ., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, .]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token]
[., NULL, ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :]
[;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, .]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return]
[), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., forBoolean, (, lhType, ==, rhType]
[:, case, Token, ., EQ, :, return, TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case, Token, ., SHNE]
[., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case, Token]
[:, return, TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case, Token, ., SHNE, :, case, Token, ., NE]
[., EQ, :, return, TernaryValue, ., forBoolean, (, lhType, ==, rhType, ), ;, case, Token, ., SHNE, :, case, Token]
[;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType, )]
[., forBoolean, (, lhType, ==, rhType, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue]
[), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType]
[==, rhType, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType]
[), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType]
[:, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case, Token, ., GE]
[., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case, Token]
[:, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case, Token, ., GE, :, case, Token, ., LE]
[., NE, :, return, TernaryValue, ., forBoolean, (, lhType, !=, rhType, ), ;, case, Token, ., GE, :, case, Token]
[;, case, Token, ., GE, :, case, Token, ., LE, :, case, Token, ., GT, :, case, Token, ., LT]
[., forBoolean, (, lhType, !=, rhType, ), ;, case, Token, ., GE, :, case, Token, ., LE, :, case, Token]
[), ;, case, Token, ., GE, :, case, Token, ., LE, :, case, Token, ., GT, :, case, Token, .]
[!=, rhType, ), ;, case, Token, ., GE, :, case, Token, ., LE, :, case, Token, ., GT, :, case]
[), ;, case, Token, ., GE, :, case, Token, ., LE, :, case, Token, ., GT, :, case, Token, .]
[:, case, Token, ., LE, :, case, Token, ., GT, :, case, Token, ., LT, :, return, compareAsNumbers, (, op]
[., GE, :, case, Token, ., LE, :, case, Token, ., GT, :, case, Token, ., LT, :, return, compareAsNumbers]
[:, case, Token, ., GT, :, case, Token, ., LT, :, return, compareAsNumbers, (, op, ,, left, ,, right, )]
[., LE, :, case, Token, ., GT, :, case, Token, ., LT, :, return, compareAsNumbers, (, op, ,, left, ,]
[:, case, Token, ., LT, :, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, }, return, TernaryValue, .]
[., GT, :, case, Token, ., LT, :, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, }, return]
[:, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, .]
[., LT, :, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., THIS, :, if, (, !, right, ., isThis, (, )]
[,, left, ,, right, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., THIS, :, if, (, !]
[,, right, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., THIS, :, if, (, !, right, .]
[), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., THIS, :, if, (, !, right, ., isThis, (]
[;, case, Token, ., THIS, :, if, (, !, right, ., isThis, (, ), ), {, return, TernaryValue, ., UNKNOWN]
[., UNKNOWN, ;, case, Token, ., THIS, :, if, (, !, right, ., isThis, (, ), ), {, return, TernaryValue]
[:, if, (, !, right, ., isThis, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op]
[., THIS, :, if, (, !, right, ., isThis, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token]
[., isThis, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, .]
[;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, .]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return]
[), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., TRUE, ;, case, Token, .]
[:, case, Token, ., EQ, :, return, TernaryValue, ., TRUE, ;, case, Token, ., SHNE, :, case, Token, ., NE]
[., SHEQ, :, case, Token, ., EQ, :, return, TernaryValue, ., TRUE, ;, case, Token, ., SHNE, :, case, Token]
[:, return, TernaryValue, ., TRUE, ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., FALSE]
[., EQ, :, return, TernaryValue, ., TRUE, ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue]
[;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, .]
[., TRUE, ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., FALSE, ;, }, return]
[:, case, Token, ., NE, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, .]
[., SHNE, :, case, Token, ., NE, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[:, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., STRING, :, if, (, undefinedRight]
[., NE, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., STRING, :, if]
[;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., STRING, :, if, (, undefinedRight, ), {, return, TernaryValue, .]
[., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., STRING, :, if, (, undefinedRight, ), {, return]
[;, case, Token, ., STRING, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[., UNKNOWN, ;, case, Token, ., STRING, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[:, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }]
[., STRING, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), )]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&]
[;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left]
[., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, )]
[), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean]
[), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, .]
[&&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, .]
[), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token]
[;, }, if, (, Token, ., STRING, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;]
[., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, ., STRING, !=, right, .]
[), ;, }, if, (, Token, ., STRING, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN]
[,, op, ), ), ;, }, if, (, Token, ., STRING, !=, right, ., getType, (, ), ), {, return]
[), ), ;, }, if, (, Token, ., STRING, !=, right, ., getType, (, ), ), {, return, TernaryValue, .]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token]
[!=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case]
[., STRING, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, )]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token]
[., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, .]
[;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, areStringsEqual, (]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return]
[), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, return, areStringsEqual, (, left, ., getString, (, )]
[:, case, Token, ., EQ, :, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString, (, )]
[., SHEQ, :, case, Token, ., EQ, :, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString]
[:, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString, (, ), ), ;, case, Token, .]
[., EQ, :, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString, (, ), ), ;, case]
[;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, areStringsEqual, (, left, ., getString, (, ), ,]
[,, right, ., getString, (, ), ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, areStringsEqual]
[., getString, (, ), ,, right, ., getString, (, ), ), ;, case, Token, ., SHNE, :, case, Token, .]
[), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, areStringsEqual, (, left, ., getString, (, )]
[., getString, (, ), ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, return, areStringsEqual, (, left]
[:, case, Token, ., NE, :, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString, (, )]
[., SHNE, :, case, Token, ., NE, :, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString]
[:, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString, (, ), ), ., not, (, )]
[., NE, :, return, areStringsEqual, (, left, ., getString, (, ), ,, right, ., getString, (, ), ), ., not]
[;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NUMBER, :, if, (, undefinedRight, ), {, return, TernaryValue, .]
[., not, (, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NUMBER, :, if, (, undefinedRight, )]
[,, right, ., getString, (, ), ), ., not, (, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token]
[., getString, (, ), ,, right, ., getString, (, ), ), ., not, (, ), ;, }, return, TernaryValue, .]
[), ., not, (, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NUMBER, :, if, (, undefinedRight]
[., getString, (, ), ), ., not, (, ), ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NUMBER]
[;, case, Token, ., NUMBER, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[., UNKNOWN, ;, case, Token, ., NUMBER, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[:, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }]
[., NUMBER, :, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), )]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&]
[;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left]
[., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, )]
[), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean]
[), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, .]
[&&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, .]
[), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token]
[;, }, if, (, Token, ., NUMBER, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;]
[., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, if, (, Token, ., NUMBER, !=, right, .]
[), ;, }, if, (, Token, ., NUMBER, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN]
[,, op, ), ), ;, }, if, (, Token, ., NUMBER, !=, right, ., getType, (, ), ), {, return]
[), ), ;, }, if, (, Token, ., NUMBER, !=, right, ., getType, (, ), ), {, return, TernaryValue, .]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, case, Token]
[!=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left]
[., NUMBER, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (, op]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, case, Token]
[., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left, ,, right]
[;, }, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, case, Token, ., NAME, :, if, (, leftLiteral]
[., UNKNOWN, ;, }, return, compareAsNumbers, (, op, ,, left, ,, right, ), ;, case, Token, ., NAME, :, if]
[;, case, Token, ., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[,, left, ,, right, ), ;, case, Token, ., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return, TernaryValue]
[,, right, ), ;, case, Token, ., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return, TernaryValue, ., forBoolean]
[), ;, case, Token, ., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined]
[:, if, (, leftLiteral, &&, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), )]
[., NAME, :, if, (, leftLiteral, &&, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rightLiteral, )]
[&&, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rightLiteral, )]
[;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =, (, left, ., getString, (, ), ., equals, (, "undefined"]
[., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =]
[), ;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =, (, left, ., getString, (, ), ., equals, (]
[,, op, ), ), ;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =, (, left, ., getString, (, )]
[), ), ;, }, if, (, rightLiteral, ), {, boolean, undefinedLeft, =, (, left, ., getString, (, ), ., equals]
[), {, boolean, undefinedLeft, =, (, left, ., getString, (, ), ., equals, (, "undefined", ), ), ;, if, (]
[;, if, (, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }]
[), ;, if, (, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;]
[., equals, (, "undefined", ), ), ;, if, (, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right]
[., getString, (, ), ., equals, (, "undefined", ), ), ;, if, (, undefinedLeft, ), {, return, TernaryValue, ., forBoolean]
[), ), ;, if, (, undefinedLeft, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), )]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, if, (, leftLiteral, &&]
[;, }, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull]
[., forBoolean, (, compareToUndefined, (, right, ,, op, ), ), ;, }, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (]
[), ;, }, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (]
[,, op, ), ), ;, }, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue]
[), ), ;, }, if, (, leftLiteral, &&, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, if, (, Token]
[&&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;]
[&&, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, )]
[&&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, if, (, Token]
[), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, if, (]
[;, }, }, if, (, Token, ., NAME, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN]
[., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, if, (, Token, ., NAME, !=, right]
[), ;, }, }, if, (, Token, ., NAME, !=, right, ., getType, (, ), ), {, return, TernaryValue, .]
[,, op, ), ), ;, }, }, if, (, Token, ., NAME, !=, right, ., getType, (, ), ), {]
[), ), ;, }, }, if, (, Token, ., NAME, !=, right, ., getType, (, ), ), {, return, TernaryValue]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, String, ln, =, left, ., getString, (, ), ;, String, rn, =]
[!=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, String, ln, =, left, ., getString]
[., NAME, !=, right, ., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, String, ln, =, left]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, String, ln, =, left, ., getString, (, ), ;, String, rn, =]
[., getType, (, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, String, ln, =, left, ., getString, (, )]
[;, }, String, ln, =, left, ., getString, (, ), ;, String, rn, =, right, ., getString, (, ), ;]
[., UNKNOWN, ;, }, String, ln, =, left, ., getString, (, ), ;, String, rn, =, right, ., getString, (]
[;, String, rn, =, right, ., getString, (, ), ;, if, (, !, ln, ., equals, (, rn, ), )]
[., getString, (, ), ;, String, rn, =, right, ., getString, (, ), ;, if, (, !, ln, ., equals]
[;, if, (, !, ln, ., equals, (, rn, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (]
[., getString, (, ), ;, if, (, !, ln, ., equals, (, rn, ), ), {, return, TernaryValue, ., UNKNOWN]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., LT, :, case, Token]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., LT, :, case, Token]
[., equals, (, rn, ), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token]
[), ), {, return, TernaryValue, ., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., LT, :, case]
[;, }, switch, (, op, ), {, case, Token, ., LT, :, case, Token, ., GT, :, return, TernaryValue, .]
[., UNKNOWN, ;, }, switch, (, op, ), {, case, Token, ., LT, :, case, Token, ., GT, :, return]
[), {, case, Token, ., LT, :, case, Token, ., GT, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue]
[:, case, Token, ., GT, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, .]
[., LT, :, case, Token, ., GT, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case]
[:, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NEG, :, if, (, leftLiteral]
[., GT, :, return, TernaryValue, ., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NEG, :, if]
[;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NEG, :, if, (, leftLiteral, ), {, if, (, undefinedRight]
[., FALSE, ;, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., NEG, :, if, (, leftLiteral, ), {, if]
[;, case, Token, ., NEG, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean]
[., UNKNOWN, ;, case, Token, ., NEG, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue]
[:, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[., NEG, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&]
[;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left]
[., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, )]
[), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean]
[), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, .]
[&&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, .]
[), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue]
[;, }, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case, Token]
[., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case, Token]
[), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case]
[,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case, Token, .]
[), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :]
[;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., FUNCTION]
[., UNKNOWN, ;, case, Token, ., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token]
[:, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., FUNCTION, :, if, (, leftLiteral, )]
[., ARRAYLIT, :, case, Token, ., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., FUNCTION, :, if, (]
[:, case, Token, ., REGEXP, :, case, Token, ., FUNCTION, :, if, (, leftLiteral, ), {, if, (, undefinedRight, )]
[., OBJECTLIT, :, case, Token, ., REGEXP, :, case, Token, ., FUNCTION, :, if, (, leftLiteral, ), {, if, (]
[:, case, Token, ., FUNCTION, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean]
[., REGEXP, :, case, Token, ., FUNCTION, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue]
[:, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,]
[., FUNCTION, :, if, (, leftLiteral, ), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (]
[), {, if, (, undefinedRight, ), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;]
[), {, return, TernaryValue, ., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&]
[;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left]
[., forBoolean, (, compareToUndefined, (, left, ,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, )]
[), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (]
[,, op, ), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean]
[), ), ;, }, if, (, nullRight, &&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, .]
[&&, isEqualityOp, (, op, ), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;]
[), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, .]
[), ), {, return, TernaryValue, ., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue]
[;, }, }, return, TernaryValue, ., UNKNOWN, ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, TernaryValue]
[., forBoolean, (, compareToNull, (, left, ,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, default, :]
[), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static]
[,, op, ), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }]
[), ), ;, }, }, return, TernaryValue, ., UNKNOWN, ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private]
[;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, TernaryValue, areStringsEqual, (, String, a, ,, String, b]
[., UNKNOWN, ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, TernaryValue, areStringsEqual, (, String, a, ,]
[;, }, }, private, static, TernaryValue, areStringsEqual, (, String, a, ,, String, b, ), {, if, (, a, ., indexOf]
[., UNKNOWN, ;, }, }, private, static, TernaryValue, areStringsEqual, (, String, a, ,, String, b, ), {, if, (, a]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, ), ?, TernaryValue, .]
[||, b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {]
[!=, -, 1, ||, b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;]
[., indexOf, (, '\u000B', ), !=, -, 1, ||, b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {]
[), !=, -, 1, ||, b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN]
[||, b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {]
[||, b, ., indexOf, (, '\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, ), ?, TernaryValue, .]
[!=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, )]
[., indexOf, (, '\u000B', ), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a]
[), !=, -, 1, ), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, ), ?, TernaryValue, .]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, ), ?, TernaryValue, .]
[;, }, else, {, return, a, ., equals, (, b, ), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;]
[., UNKNOWN, ;, }, else, {, return, a, ., equals, (, b, ), ?, TernaryValue, ., TRUE, :, TernaryValue, .]
[;, }, }, private, static, int, getNormalizedNodeType, (, Node, n, ), {, int, type, =, n, ., getType, (, )]
[?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, private, static, int, getNormalizedNodeType, (, Node, n, ), {]
[., equals, (, b, ), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, private, static, int, getNormalizedNodeType]
[), ?, TernaryValue, ., TRUE, :, TernaryValue, ., FALSE, ;, }, }, private, static, int, getNormalizedNodeType, (, Node, n, )]
[:, TernaryValue, ., FALSE, ;, }, }, private, static, int, getNormalizedNodeType, (, Node, n, ), {, int, type, =, n]
[., TRUE, :, TernaryValue, ., FALSE, ;, }, }, private, static, int, getNormalizedNodeType, (, Node, n, ), {, int, type]
[;, }, }, private, static, int, getNormalizedNodeType, (, Node, n, ), {, int, type, =, n, ., getType, (, )]
[., FALSE, ;, }, }, private, static, int, getNormalizedNodeType, (, Node, n, ), {, int, type, =, n, ., getType]
[;, if, (, type, ==, Token, ., NOT, ), {, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;]
[., getType, (, ), ;, if, (, type, ==, Token, ., NOT, ), {, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue]
[), {, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, switch, (, value, ), {, case, TRUE, :]
[==, Token, ., NOT, ), {, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, switch, (, value, )]
[), {, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, switch, (, value, ), {, case, TRUE, :]
[., NOT, ), {, TernaryValue, value, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, switch, (, value, ), {, case]
[;, switch, (, value, ), {, case, TRUE, :, return, Token, ., TRUE, ;, case, FALSE, :, return, Token, .]
[., getPureBooleanValue, (, n, ), ;, switch, (, value, ), {, case, TRUE, :, return, Token, ., TRUE, ;, case]
[), ;, switch, (, value, ), {, case, TRUE, :, return, Token, ., TRUE, ;, case, FALSE, :, return, Token]
[), {, case, TRUE, :, return, Token, ., TRUE, ;, case, FALSE, :, return, Token, ., FALSE, ;, case, UNKNOWN]
[:, return, Token, ., TRUE, ;, case, FALSE, :, return, Token, ., FALSE, ;, case, UNKNOWN, :, return, type, ;]
[;, case, FALSE, :, return, Token, ., FALSE, ;, case, UNKNOWN, :, return, type, ;, }, }, return, type, ;]
[., TRUE, ;, case, FALSE, :, return, Token, ., FALSE, ;, case, UNKNOWN, :, return, type, ;, }, }, return]
[:, return, Token, ., FALSE, ;, case, UNKNOWN, :, return, type, ;, }, }, return, type, ;, }, private, static]
[;, case, UNKNOWN, :, return, type, ;, }, }, return, type, ;, }, private, static, TernaryValue, compareAsNumbers, (, int, op]
[., FALSE, ;, case, UNKNOWN, :, return, type, ;, }, }, return, type, ;, }, private, static, TernaryValue, compareAsNumbers, (]
[:, return, type, ;, }, }, return, type, ;, }, private, static, TernaryValue, compareAsNumbers, (, int, op, ,, Node, left]
[;, }, }, return, type, ;, }, private, static, TernaryValue, compareAsNumbers, (, int, op, ,, Node, left, ,, Node, right]
[;, }, private, static, TernaryValue, compareAsNumbers, (, int, op, ,, Node, left, ,, Node, right, ), {, Double, leftValue, =]
[;, if, (, leftValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, ., getNumberValue]
[., getNumberValue, (, left, ), ;, if, (, leftValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, Double]
[), ;, if, (, leftValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, .]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (]
[;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValue, ==, null, ), {, return]
[., UNKNOWN, ;, }, Double, rightValue, =, NodeUtil, ., getNumberValue, (, right, ), ;, if, (, rightValue, ==, null, )]
[;, if, (, rightValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, double, lv, =, leftValue, ;, double]
[., getNumberValue, (, right, ), ;, if, (, rightValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, double]
[), ;, if, (, rightValue, ==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, double, lv, =, leftValue, ;]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, double, lv, =, leftValue, ;, double, rv, =, rightValue, ;, switch, (]
[==, null, ), {, return, TernaryValue, ., UNKNOWN, ;, }, double, lv, =, leftValue, ;, double, rv, =, rightValue, ;]
[), {, return, TernaryValue, ., UNKNOWN, ;, }, double, lv, =, leftValue, ;, double, rv, =, rightValue, ;, switch, (]
[;, }, double, lv, =, leftValue, ;, double, rv, =, rightValue, ;, switch, (, op, ), {, case, Token, .]
[., UNKNOWN, ;, }, double, lv, =, leftValue, ;, double, rv, =, rightValue, ;, switch, (, op, ), {, case]
[;, double, rv, =, rightValue, ;, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ]
[;, switch, (, op, ), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, Preconditions, ., checkState, (]
[), {, case, Token, ., SHEQ, :, case, Token, ., EQ, :, Preconditions, ., checkState, (, left, ., isNumber, (]
[:, case, Token, ., EQ, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (]
[., SHEQ, :, case, Token, ., EQ, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, .]
[:, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue]
[., EQ, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;]
[;, return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case, Token, ., NE]
[., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean]
[), ;, return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case, Token, .]
[&&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case, Token]
[., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, ==, rv]
[), ;, return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case, Token, .]
[., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, ==, rv, ), ;, case, Token, ., SHNE]
[;, case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (, left, ., isNumber, (, )]
[., forBoolean, (, lv, ==, rv, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, .]
[), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (, left, ., isNumber, (]
[==, rv, ), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (, left, .]
[), ;, case, Token, ., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (, left, ., isNumber, (]
[:, case, Token, ., NE, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (]
[., SHNE, :, case, Token, ., NE, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, .]
[:, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue]
[., NE, :, Preconditions, ., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;]
[;, return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean]
[., checkState, (, left, ., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean]
[), ;, return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, .]
[&&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case, Token]
[., isNumber, (, ), &&, right, ., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, !=, rv]
[), ;, return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, .]
[., isNumber, (, ), ), ;, return, TernaryValue, ., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE]
[;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case, Token, ., LT]
[., forBoolean, (, lv, !=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=]
[), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case, Token, .]
[!=, rv, ), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case]
[), ;, case, Token, ., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case, Token, .]
[:, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean]
[., LE, :, return, TernaryValue, ., forBoolean, (, lv, <=, rv, ), ;, case, Token, ., LT, :, return, TernaryValue]
[;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case, Token, ., GE]
[., forBoolean, (, lv, <=, rv, ), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <]
[), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case, Token, .]
[<=, rv, ), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case]
[), ;, case, Token, ., LT, :, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case, Token, .]
[:, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean]
[., LT, :, return, TernaryValue, ., forBoolean, (, lv, <, rv, ), ;, case, Token, ., GE, :, return, TernaryValue]
[;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case, Token, ., GT]
[., forBoolean, (, lv, <, rv, ), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=]
[), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case, Token, .]
[<, rv, ), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case]
[), ;, case, Token, ., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case, Token, .]
[:, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean]
[., GE, :, return, TernaryValue, ., forBoolean, (, lv, >=, rv, ), ;, case, Token, ., GT, :, return, TernaryValue]
[;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (, lv, >, rv, ), ;, default, :, return, TernaryValue]
[., forBoolean, (, lv, >=, rv, ), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (, lv, >]
[), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (, lv, >, rv, ), ;, default, :, return]
[>=, rv, ), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (, lv, >, rv, ), ;, default]
[), ;, case, Token, ., GT, :, return, TernaryValue, ., forBoolean, (, lv, >, rv, ), ;, default, :, return]
[:, return, TernaryValue, ., forBoolean, (, lv, >, rv, ), ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }]
[., GT, :, return, TernaryValue, ., forBoolean, (, lv, >, rv, ), ;, default, :, return, TernaryValue, ., UNKNOWN, ;]
[;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, boolean, compareToUndefined, (, Node, value, ,, int, op]
[., forBoolean, (, lv, >, rv, ), ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, boolean]
[), ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, boolean, compareToUndefined, (, Node, value, ,, int]
[>, rv, ), ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, boolean, compareToUndefined, (, Node, value]
[), ;, default, :, return, TernaryValue, ., UNKNOWN, ;, }, }, private, static, boolean, compareToUndefined, (, Node, value, ,, int]
[;, }, }, private, static, boolean, compareToUndefined, (, Node, value, ,, int, op, ), {, Preconditions, ., checkState, (, NodeUtil]
[., UNKNOWN, ;, }, }, private, static, boolean, compareToUndefined, (, Node, value, ,, int, op, ), {, Preconditions, ., checkState]
[;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token, ., NULL, ==, value]
[., checkState, (, NodeUtil, ., isLiteralValue, (, value, ,, true, ), ), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (]
[), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token, ., NULL, ==]
[., isLiteralValue, (, value, ,, true, ), ), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean]
[,, true, ), ), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token]
[), ), ;, boolean, valueUndefined, =, NodeUtil, ., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token, ., NULL]
[;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined]
[., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), )]
[), ;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =]
[;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent]
[), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return]
[==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {]
[., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op]
[), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return]
[., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token]
[;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return]
[||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE]
[;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return]
[), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case]
[:, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined]
[., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :]
[;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case, Token]
[:, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !]
[., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :]
[;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !, valueUndefined, ;, case, Token]
[;, case, Token, ., SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !, valueUndefined, ;, case, Token]
[:, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !, valueUndefined, ;, case, Token, ., LT, :, case, Token]
[., SHEQ, :, return, valueUndefined, ;, case, Token, ., SHNE, :, return, !, valueUndefined, ;, case, Token, ., LT, :]
[;, case, Token, ., SHNE, :, return, !, valueUndefined, ;, case, Token, ., LT, :, case, Token, ., GT, :]
[:, return, !, valueUndefined, ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :]
[., SHNE, :, return, !, valueUndefined, ;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, .]
[;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE]
[;, case, Token, ., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE]
[:, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, return, false, ;, default]
[., LT, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, return, false]
[:, case, Token, ., LE, :, case, Token, ., GE, :, return, false, ;, default, :, throw, new, IllegalStateException, (]
[., GT, :, case, Token, ., LE, :, case, Token, ., GE, :, return, false, ;, default, :, throw, new]
[:, case, Token, ., GE, :, return, false, ;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }]
[., LE, :, case, Token, ., GE, :, return, false, ;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;]
[:, return, false, ;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, static, boolean, isEqualityOp, (]
[., GE, :, return, false, ;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, static, boolean]
[;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, static, boolean, isEqualityOp, (, int, op, )]
[;, }, }, private, static, boolean, isEqualityOp, (, int, op, ), {, switch, (, op, ), {, case, Token, .]
[), ;, }, }, private, static, boolean, isEqualityOp, (, int, op, ), {, switch, (, op, ), {, case, Token]
[), {, case, Token, ., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, .]
[:, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, true, ;, }]
[., EQ, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, true]
[:, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, true, ;, }, return, false, ;, }, private]
[., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, return, true, ;, }, return, false, ;]
[:, case, Token, ., SHNE, :, return, true, ;, }, return, false, ;, }, private, static, boolean, compareToNull, (, Node]
[., SHEQ, :, case, Token, ., SHNE, :, return, true, ;, }, return, false, ;, }, private, static, boolean, compareToNull]
[:, return, true, ;, }, return, false, ;, }, private, static, boolean, compareToNull, (, Node, value, ,, int, op, )]
[., SHNE, :, return, true, ;, }, return, false, ;, }, private, static, boolean, compareToNull, (, Node, value, ,, int]
[;, }, return, false, ;, }, private, static, boolean, compareToNull, (, Node, value, ,, int, op, ), {, boolean, valueUndefined]
[;, }, private, static, boolean, compareToNull, (, Node, value, ,, int, op, ), {, boolean, valueUndefined, =, NodeUtil, ., isUndefined]
[;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined]
[., isUndefined, (, value, ), ;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), )]
[), ;, boolean, valueNull, =, (, Token, ., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =]
[;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent]
[), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return]
[==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {]
[., NULL, ==, value, ., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op]
[), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return]
[., getType, (, ), ), ;, boolean, equivalent, =, valueUndefined, ||, valueNull, ;, switch, (, op, ), {, case, Token]
[;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return]
[||, valueNull, ;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE]
[;, switch, (, op, ), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return]
[), {, case, Token, ., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case]
[:, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueNull]
[., EQ, :, return, equivalent, ;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :]
[;, case, Token, ., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueNull, ;, case, Token]
[:, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueNull, ;, case, Token, ., SHNE, :, return, !]
[., NE, :, return, !, equivalent, ;, case, Token, ., SHEQ, :, return, valueNull, ;, case, Token, ., SHNE, :]
[;, case, Token, ., SHEQ, :, return, valueNull, ;, case, Token, ., SHNE, :, return, !, valueNull, ;, default, :]
[;, case, Token, ., SHEQ, :, return, valueNull, ;, case, Token, ., SHNE, :, return, !, valueNull, ;, default, :]
[:, return, valueNull, ;, case, Token, ., SHNE, :, return, !, valueNull, ;, default, :, throw, new, IllegalStateException, (, "unexpected."]
[., SHEQ, :, return, valueNull, ;, case, Token, ., SHNE, :, return, !, valueNull, ;, default, :, throw, new, IllegalStateException]
[;, case, Token, ., SHNE, :, return, !, valueNull, ;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }]
[:, return, !, valueNull, ;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, Node, tryFoldCtorCall, (]
[., SHNE, :, return, !, valueNull, ;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, Node]
[;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, Node, tryFoldCtorCall, (, Node, n, ), {]
[;, default, :, throw, new, IllegalStateException, (, "unexpected.", ), ;, }, }, private, Node, tryFoldCtorCall, (, Node, n, ), {]
[;, }, }, private, Node, tryFoldCtorCall, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isNew, (, )]
[), ;, }, }, private, Node, tryFoldCtorCall, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isNew, (]
[;, if, (, inForcedStringContext, (, n, ), ), {, return, tryFoldInForcedStringContext, (, n, ), ;, }, return, n, ;, }]
[., checkArgument, (, n, ., isNew, (, ), ), ;, if, (, inForcedStringContext, (, n, ), ), {, return, tryFoldInForcedStringContext]
[), ;, if, (, inForcedStringContext, (, n, ), ), {, return, tryFoldInForcedStringContext, (, n, ), ;, }, return, n, ;]
[., isNew, (, ), ), ;, if, (, inForcedStringContext, (, n, ), ), {, return, tryFoldInForcedStringContext, (, n, ), ;]
[), {, return, tryFoldInForcedStringContext, (, n, ), ;, }, return, n, ;, }, private, boolean, inForcedStringContext, (, Node, n, )]
[), ), {, return, tryFoldInForcedStringContext, (, n, ), ;, }, return, n, ;, }, private, boolean, inForcedStringContext, (, Node, n]
[;, }, return, n, ;, }, private, boolean, inForcedStringContext, (, Node, n, ), {, if, (, n, ., getParent, (]
[), ;, }, return, n, ;, }, private, boolean, inForcedStringContext, (, Node, n, ), {, if, (, n, ., getParent]
[;, }, private, boolean, inForcedStringContext, (, Node, n, ), {, if, (, n, ., getParent, (, ), ., isGetElem, (]
[), {, return, true, ;, }, if, (, n, ., getParent, (, ), ., isAdd, (, ), ), {, return]
[&&, n, ., getParent, (, ), ., getLastChild, (, ), ==, n, ), {, return, true, ;, }, if, (]
[., isGetElem, (, ), &&, n, ., getParent, (, ), ., getLastChild, (, ), ==, n, ), {, return, true]
[., getParent, (, ), ., isGetElem, (, ), &&, n, ., getParent, (, ), ., getLastChild, (, ), ==, n]
[), {, return, true, ;, }, if, (, n, ., getParent, (, ), ., isAdd, (, ), ), {, return]
[==, n, ), {, return, true, ;, }, if, (, n, ., getParent, (, ), ., isAdd, (, ), )]
[., getLastChild, (, ), ==, n, ), {, return, true, ;, }, if, (, n, ., getParent, (, ), .]
[., getParent, (, ), ., getLastChild, (, ), ==, n, ), {, return, true, ;, }, if, (, n, .]
[), {, return, true, ;, }, if, (, n, ., getParent, (, ), ., isAdd, (, ), ), {, return]
[;, }, if, (, n, ., getParent, (, ), ., isAdd, (, ), ), {, return, true, ;, }, return]
[), {, return, true, ;, }, return, false, ;, }, private, Node, tryFoldInForcedStringContext, (, Node, n, ), {, Preconditions, .]
[., isAdd, (, ), ), {, return, true, ;, }, return, false, ;, }, private, Node, tryFoldInForcedStringContext, (, Node, n]
[., getParent, (, ), ., isAdd, (, ), ), {, return, true, ;, }, return, false, ;, }, private, Node]
[;, }, return, false, ;, }, private, Node, tryFoldInForcedStringContext, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, .]
[;, }, private, Node, tryFoldInForcedStringContext, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isNew, (, ), )]
[;, Node, objectType, =, n, ., getFirstChild, (, ), ;, if, (, !, objectType, ., isName, (, ), ), {]
[., checkArgument, (, n, ., isNew, (, ), ), ;, Node, objectType, =, n, ., getFirstChild, (, ), ;, if]
[), ;, Node, objectType, =, n, ., getFirstChild, (, ), ;, if, (, !, objectType, ., isName, (, ), )]
[., isNew, (, ), ), ;, Node, objectType, =, n, ., getFirstChild, (, ), ;, if, (, !, objectType, .]
[;, if, (, !, objectType, ., isName, (, ), ), {, return, n, ;, }, if, (, objectType, ., getString]
[., getFirstChild, (, ), ;, if, (, !, objectType, ., isName, (, ), ), {, return, n, ;, }, if]
[), {, return, n, ;, }, if, (, objectType, ., getString, (, ), ., equals, (, "String", ), ), {]
[), {, return, n, ;, }, if, (, objectType, ., getString, (, ), ., equals, (, "String", ), ), {]
[., isName, (, ), ), {, return, n, ;, }, if, (, objectType, ., getString, (, ), ., equals, (]
[;, }, if, (, objectType, ., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =, objectType]
[), {, Node, value, =, objectType, ., getNext, (, ), ;, String, stringValue, =, null, ;, if, (, value, ==]
[., equals, (, "String", ), ), {, Node, value, =, objectType, ., getNext, (, ), ;, String, stringValue, =, null]
[., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =, objectType, ., getNext, (, ), ;]
[), ), {, Node, value, =, objectType, ., getNext, (, ), ;, String, stringValue, =, null, ;, if, (, value]
[;, String, stringValue, =, null, ;, if, (, value, ==, null, ), {, stringValue, =, "", ;, }, else, {]
[., getNext, (, ), ;, String, stringValue, =, null, ;, if, (, value, ==, null, ), {, stringValue, =, ""]
[;, if, (, value, ==, null, ), {, stringValue, =, "", ;, }, else, {, if, (, !, NodeUtil, .]
[), {, stringValue, =, "", ;, }, else, {, if, (, !, NodeUtil, ., isImmutableValue, (, value, ), ), {]
[==, null, ), {, stringValue, =, "", ;, }, else, {, if, (, !, NodeUtil, ., isImmutableValue, (, value, )]
[), {, stringValue, =, "", ;, }, else, {, if, (, !, NodeUtil, ., isImmutableValue, (, value, ), ), {]
[=, "", ;, }, else, {, if, (, !, NodeUtil, ., isImmutableValue, (, value, ), ), {, return, n, ;]
[;, }, else, {, if, (, !, NodeUtil, ., isImmutableValue, (, value, ), ), {, return, n, ;, }, stringValue]
[), {, return, n, ;, }, stringValue, =, NodeUtil, ., getStringValue, (, value, ), ;, }, if, (, stringValue, ==]
[), {, return, n, ;, }, stringValue, =, NodeUtil, ., getStringValue, (, value, ), ;, }, if, (, stringValue, ==]
[., isImmutableValue, (, value, ), ), {, return, n, ;, }, stringValue, =, NodeUtil, ., getStringValue, (, value, ), ;]
[), ), {, return, n, ;, }, stringValue, =, NodeUtil, ., getStringValue, (, value, ), ;, }, if, (, stringValue]
[;, }, stringValue, =, NodeUtil, ., getStringValue, (, value, ), ;, }, if, (, stringValue, ==, null, ), {, return]
[=, NodeUtil, ., getStringValue, (, value, ), ;, }, if, (, stringValue, ==, null, ), {, return, n, ;, }]
[;, }, if, (, stringValue, ==, null, ), {, return, n, ;, }, Node, parent, =, n, ., getParent, (]
[., getStringValue, (, value, ), ;, }, if, (, stringValue, ==, null, ), {, return, n, ;, }, Node, parent]
[), ;, }, if, (, stringValue, ==, null, ), {, return, n, ;, }, Node, parent, =, n, ., getParent]
[), {, return, n, ;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, newString, =, IR, .]
[==, null, ), {, return, n, ;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, newString, =]
[), {, return, n, ;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, newString, =, IR, .]
[;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, newString, =, IR, ., string, (, stringValue, )]
[;, Node, newString, =, IR, ., string, (, stringValue, ), ;, parent, ., replaceChild, (, n, ,, newString, ), ;]
[., getParent, (, ), ;, Node, newString, =, IR, ., string, (, stringValue, ), ;, parent, ., replaceChild, (, n]
[;, parent, ., replaceChild, (, n, ,, newString, ), ;, newString, ., copyInformationFrom, (, parent, ), ;, reportCodeChange, (, )]
[., string, (, stringValue, ), ;, parent, ., replaceChild, (, n, ,, newString, ), ;, newString, ., copyInformationFrom, (, parent]
[), ;, parent, ., replaceChild, (, n, ,, newString, ), ;, newString, ., copyInformationFrom, (, parent, ), ;, reportCodeChange, (]
[;, newString, ., copyInformationFrom, (, parent, ), ;, reportCodeChange, (, ), ;, return, newString, ;, }, return, n, ;, }]
[., replaceChild, (, n, ,, newString, ), ;, newString, ., copyInformationFrom, (, parent, ), ;, reportCodeChange, (, ), ;, return]
[,, newString, ), ;, newString, ., copyInformationFrom, (, parent, ), ;, reportCodeChange, (, ), ;, return, newString, ;, }, return]
[), ;, newString, ., copyInformationFrom, (, parent, ), ;, reportCodeChange, (, ), ;, return, newString, ;, }, return, n, ;]
[;, reportCodeChange, (, ), ;, return, newString, ;, }, return, n, ;, }, private, Node, tryFoldGetElem, (, Node, n, ,]
[., copyInformationFrom, (, parent, ), ;, reportCodeChange, (, ), ;, return, newString, ;, }, return, n, ;, }, private, Node]
[), ;, reportCodeChange, (, ), ;, return, newString, ;, }, return, n, ;, }, private, Node, tryFoldGetElem, (, Node, n]
[;, return, newString, ;, }, return, n, ;, }, private, Node, tryFoldGetElem, (, Node, n, ,, Node, left, ,, Node]
[;, }, return, n, ;, }, private, Node, tryFoldGetElem, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[;, }, private, Node, tryFoldGetElem, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;]
[., checkArgument, (, n, ., isGetElem, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return]
[), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, )]
[., isGetElem, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,]
[), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (, left, ., isArrayLit, (, )]
[., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (, left]
[;, }, if, (, left, ., isArrayLit, (, ), ), {, return, tryFoldArrayAccess, (, n, ,, left, ,, right, )]
[,, left, ,, right, ), ;, }, if, (, left, ., isArrayLit, (, ), ), {, return, tryFoldArrayAccess, (, n]
[,, right, ), ;, }, if, (, left, ., isArrayLit, (, ), ), {, return, tryFoldArrayAccess, (, n, ,, left]
[), ;, }, if, (, left, ., isArrayLit, (, ), ), {, return, tryFoldArrayAccess, (, n, ,, left, ,, right]
[), {, return, tryFoldArrayAccess, (, n, ,, left, ,, right, ), ;, }, return, n, ;, }, private, Node, tryFoldGetProp]
[., isArrayLit, (, ), ), {, return, tryFoldArrayAccess, (, n, ,, left, ,, right, ), ;, }, return, n, ;]
[;, }, return, n, ;, }, private, Node, tryFoldGetProp, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[,, left, ,, right, ), ;, }, return, n, ;, }, private, Node, tryFoldGetProp, (, Node, n, ,, Node, left]
[,, right, ), ;, }, return, n, ;, }, private, Node, tryFoldGetProp, (, Node, n, ,, Node, left, ,, Node]
[), ;, }, return, n, ;, }, private, Node, tryFoldGetProp, (, Node, n, ,, Node, left, ,, Node, right, )]
[;, }, private, Node, tryFoldGetProp, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;]
[., checkArgument, (, n, ., isGetProp, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return]
[), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, )]
[., isGetProp, (, ), ), ;, if, (, left, ., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,]
[), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (, right, ., isString, (, )]
[., isObjectLit, (, ), ), {, return, tryFoldObjectPropAccess, (, n, ,, left, ,, right, ), ;, }, if, (, right]
[;, }, if, (, right, ., isString, (, ), &&, right, ., getString, (, ), ., equals, (, "length", )]
[,, left, ,, right, ), ;, }, if, (, right, ., isString, (, ), &&, right, ., getString, (, )]
[,, right, ), ;, }, if, (, right, ., isString, (, ), &&, right, ., getString, (, ), ., equals]
[), ;, }, if, (, right, ., isString, (, ), &&, right, ., getString, (, ), ., equals, (, "length"]
[), {, int, knownLength, =, -, 1, ;, switch, (, left, ., getType, (, ), ), {, case, Token, .]
[&&, right, ., getString, (, ), ., equals, (, "length", ), ), {, int, knownLength, =, -, 1, ;, switch]
[., isString, (, ), &&, right, ., getString, (, ), ., equals, (, "length", ), ), {, int, knownLength, =]
[), {, int, knownLength, =, -, 1, ;, switch, (, left, ., getType, (, ), ), {, case, Token, .]
[., equals, (, "length", ), ), {, int, knownLength, =, -, 1, ;, switch, (, left, ., getType, (, )]
[., getString, (, ), ., equals, (, "length", ), ), {, int, knownLength, =, -, 1, ;, switch, (, left]
[), ), {, int, knownLength, =, -, 1, ;, switch, (, left, ., getType, (, ), ), {, case, Token]
[;, switch, (, left, ., getType, (, ), ), {, case, Token, ., ARRAYLIT, :, if, (, mayHaveSideEffects, (, left]
[;, switch, (, left, ., getType, (, ), ), {, case, Token, ., ARRAYLIT, :, if, (, mayHaveSideEffects, (, left]
[), {, case, Token, ., ARRAYLIT, :, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, knownLength]
[., getType, (, ), ), {, case, Token, ., ARRAYLIT, :, if, (, mayHaveSideEffects, (, left, ), ), {, return]
[:, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, knownLength, =, left, ., getChildCount, (, )]
[., ARRAYLIT, :, if, (, mayHaveSideEffects, (, left, ), ), {, return, n, ;, }, knownLength, =, left, ., getChildCount]
[), {, return, n, ;, }, knownLength, =, left, ., getChildCount, (, ), ;, break, ;, case, Token, ., STRING]
[), ), {, return, n, ;, }, knownLength, =, left, ., getChildCount, (, ), ;, break, ;, case, Token, .]
[;, }, knownLength, =, left, ., getChildCount, (, ), ;, break, ;, case, Token, ., STRING, :, knownLength, =, left]
[=, left, ., getChildCount, (, ), ;, break, ;, case, Token, ., STRING, :, knownLength, =, left, ., getString, (]
[;, break, ;, case, Token, ., STRING, :, knownLength, =, left, ., getString, (, ), ., length, (, ), ;]
[., getChildCount, (, ), ;, break, ;, case, Token, ., STRING, :, knownLength, =, left, ., getString, (, ), .]
[:, knownLength, =, left, ., getString, (, ), ., length, (, ), ;, break, ;, default, :, return, n, ;]
[., STRING, :, knownLength, =, left, ., getString, (, ), ., length, (, ), ;, break, ;, default, :, return]
[=, left, ., getString, (, ), ., length, (, ), ;, break, ;, default, :, return, n, ;, }, Preconditions]
[;, break, ;, default, :, return, n, ;, }, Preconditions, ., checkState, (, knownLength, !=, -, 1, ), ;, Node]
[., length, (, ), ;, break, ;, default, :, return, n, ;, }, Preconditions, ., checkState, (, knownLength, !=, -]
[., getString, (, ), ., length, (, ), ;, break, ;, default, :, return, n, ;, }, Preconditions, ., checkState]
[;, }, Preconditions, ., checkState, (, knownLength, !=, -, 1, ), ;, Node, lengthNode, =, IR, ., number, (, knownLength]
[;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;, n, ., getParent, (, ), ., replaceChild, (, n]
[., checkState, (, knownLength, !=, -, 1, ), ;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;, n]
[), ;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[!=, -, 1, ), ;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;, n, ., getParent, (, )]
[), ;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ;, Node, lengthNode, =, IR, ., number, (, knownLength, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[;, n, ., getParent, (, ), ., replaceChild, (, n, ,, lengthNode, ), ;, reportCodeChange, (, ), ;, return, lengthNode]
[., number, (, knownLength, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, lengthNode, ), ;, reportCodeChange]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, lengthNode, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, lengthNode, ;, }, return, n, ;, }, private, boolean, isAssignmentTarget, (, Node, n, )]
[., replaceChild, (, n, ,, lengthNode, ), ;, reportCodeChange, (, ), ;, return, lengthNode, ;, }, return, n, ;, }]
[., getParent, (, ), ., replaceChild, (, n, ,, lengthNode, ), ;, reportCodeChange, (, ), ;, return, lengthNode, ;, }]
[,, lengthNode, ), ;, reportCodeChange, (, ), ;, return, lengthNode, ;, }, return, n, ;, }, private, boolean, isAssignmentTarget, (]
[), ;, reportCodeChange, (, ), ;, return, lengthNode, ;, }, return, n, ;, }, private, boolean, isAssignmentTarget, (, Node, n]
[;, return, lengthNode, ;, }, return, n, ;, }, private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =]
[;, }, return, n, ;, }, private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =, n, ., getParent]
[;, }, private, boolean, isAssignmentTarget, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if]
[;, if, (, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||]
[., getParent, (, ), ;, if, (, (, NodeUtil, ., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, )]
[), {, return, true, ;, }, return, false, ;, }, private, Node, tryFoldArrayAccess, (, Node, n, ,, Node, left, ,]
[||, parent, ., isDec, (, ), ), {, return, true, ;, }, return, false, ;, }, private, Node, tryFoldArrayAccess, (]
[||, parent, ., isInc, (, ), ||, parent, ., isDec, (, ), ), {, return, true, ;, }, return, false]
[), ||, parent, ., isInc, (, ), ||, parent, ., isDec, (, ), ), {, return, true, ;, }, return]
[&&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isInc, (, ), ||, parent, ., isDec, (]
[., isAssignmentOp, (, parent, ), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isInc, (, )]
[), &&, parent, ., getFirstChild, (, ), ==, n, ), ||, parent, ., isInc, (, ), ||, parent, ., isDec]
[), ||, parent, ., isInc, (, ), ||, parent, ., isDec, (, ), ), {, return, true, ;, }, return]
[==, n, ), ||, parent, ., isInc, (, ), ||, parent, ., isDec, (, ), ), {, return, true, ;]
[., getFirstChild, (, ), ==, n, ), ||, parent, ., isInc, (, ), ||, parent, ., isDec, (, ), )]
[), ||, parent, ., isInc, (, ), ||, parent, ., isDec, (, ), ), {, return, true, ;, }, return]
[||, parent, ., isDec, (, ), ), {, return, true, ;, }, return, false, ;, }, private, Node, tryFoldArrayAccess, (]
[., isInc, (, ), ||, parent, ., isDec, (, ), ), {, return, true, ;, }, return, false, ;, }]
[), {, return, true, ;, }, return, false, ;, }, private, Node, tryFoldArrayAccess, (, Node, n, ,, Node, left, ,]
[., isDec, (, ), ), {, return, true, ;, }, return, false, ;, }, private, Node, tryFoldArrayAccess, (, Node, n]
[;, }, return, false, ;, }, private, Node, tryFoldArrayAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {]
[;, }, private, Node, tryFoldArrayAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {, Node, parent, =, n]
[;, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, if, (, !, right, ., isNumber, (]
[., getParent, (, ), ;, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, if, (, !]
[), {, return, n, ;, }, if, (, !, right, ., isNumber, (, ), ), {, return, n, ;, }]
[), ), {, return, n, ;, }, if, (, !, right, ., isNumber, (, ), ), {, return, n, ;]
[;, }, if, (, !, right, ., isNumber, (, ), ), {, return, n, ;, }, double, index, =, right]
[), {, return, n, ;, }, double, index, =, right, ., getDouble, (, ), ;, int, intIndex, =, (, int]
[), {, return, n, ;, }, double, index, =, right, ., getDouble, (, ), ;, int, intIndex, =, (, int]
[., isNumber, (, ), ), {, return, n, ;, }, double, index, =, right, ., getDouble, (, ), ;, int]
[;, }, double, index, =, right, ., getDouble, (, ), ;, int, intIndex, =, (, int, ), index, ;, if]
[;, int, intIndex, =, (, int, ), index, ;, if, (, intIndex, !=, index, ), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,]
[., getDouble, (, ), ;, int, intIndex, =, (, int, ), index, ;, if, (, intIndex, !=, index, ), {]
[;, if, (, intIndex, !=, index, ), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if]
[;, if, (, intIndex, !=, index, ), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if]
[), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if, (, intIndex, <, 0, ), {]
[!=, index, ), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if, (, intIndex, <, 0]
[), {, report, (, INVALID_GETELEM_INDEX_ERROR, ,, right, ), ;, return, n, ;, }, if, (, intIndex, <, 0, ), {]
[;, return, n, ;, }, if, (, intIndex, <, 0, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return]
[,, right, ), ;, return, n, ;, }, if, (, intIndex, <, 0, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right]
[), ;, return, n, ;, }, if, (, intIndex, <, 0, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;]
[;, }, if, (, intIndex, <, 0, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }]
[), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, Node, current, =, left, ., getFirstChild, (]
[<, 0, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, Node, current, =, left, .]
[), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, Node, current, =, left, ., getFirstChild, (]
[;, return, n, ;, }, Node, current, =, left, ., getFirstChild, (, ), ;, Node, elem, =, null, ;, for]
[,, right, ), ;, return, n, ;, }, Node, current, =, left, ., getFirstChild, (, ), ;, Node, elem, =]
[), ;, return, n, ;, }, Node, current, =, left, ., getFirstChild, (, ), ;, Node, elem, =, null, ;]
[;, }, Node, current, =, left, ., getFirstChild, (, ), ;, Node, elem, =, null, ;, for, (, int, i]
[;, Node, elem, =, null, ;, for, (, int, i, =, 0, ;, current, !=, null, ;, i, ++, )]
[., getFirstChild, (, ), ;, Node, elem, =, null, ;, for, (, int, i, =, 0, ;, current, !=, null]
[;, for, (, int, i, =, 0, ;, current, !=, null, ;, i, ++, ), {, if, (, i, !=]
[;, current, !=, null, ;, i, ++, ), {, if, (, i, !=, intIndex, ), {, if, (, mayHaveSideEffects, (]
[;, i, ++, ), {, if, (, i, !=, intIndex, ), {, if, (, mayHaveSideEffects, (, current, ), ), {]
[!=, null, ;, i, ++, ), {, if, (, i, !=, intIndex, ), {, if, (, mayHaveSideEffects, (, current, )]
[;, i, ++, ), {, if, (, i, !=, intIndex, ), {, if, (, mayHaveSideEffects, (, current, ), ), {]
[), {, if, (, i, !=, intIndex, ), {, if, (, mayHaveSideEffects, (, current, ), ), {, return, n, ;]
[++, ), {, if, (, i, !=, intIndex, ), {, if, (, mayHaveSideEffects, (, current, ), ), {, return, n]
[), {, if, (, mayHaveSideEffects, (, current, ), ), {, return, n, ;, }, }, else, {, elem, =, current]
[!=, intIndex, ), {, if, (, mayHaveSideEffects, (, current, ), ), {, return, n, ;, }, }, else, {, elem]
[), {, if, (, mayHaveSideEffects, (, current, ), ), {, return, n, ;, }, }, else, {, elem, =, current]
[), {, return, n, ;, }, }, else, {, elem, =, current, ;, }, current, =, current, ., getNext, (]
[), ), {, return, n, ;, }, }, else, {, elem, =, current, ;, }, current, =, current, ., getNext]
[;, }, }, else, {, elem, =, current, ;, }, current, =, current, ., getNext, (, ), ;, }, if]
[=, current, ;, }, current, =, current, ., getNext, (, ), ;, }, if, (, elem, ==, null, ), {]
[;, }, current, =, current, ., getNext, (, ), ;, }, if, (, elem, ==, null, ), {, report, (]
[=, current, ., getNext, (, ), ;, }, if, (, elem, ==, null, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right]
[;, }, if, (, elem, ==, null, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }]
[., getNext, (, ), ;, }, if, (, elem, ==, null, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;]
[), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, if, (, elem, ., isEmpty, (, )]
[==, null, ), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, if, (, elem, ., isEmpty]
[), {, report, (, INDEX_OUT_OF_BOUNDS_ERROR, ,, right, ), ;, return, n, ;, }, if, (, elem, ., isEmpty, (, )]
[;, return, n, ;, }, if, (, elem, ., isEmpty, (, ), ), {, elem, =, NodeUtil, ., newUndefinedNode, (]
[,, right, ), ;, return, n, ;, }, if, (, elem, ., isEmpty, (, ), ), {, elem, =, NodeUtil]
[), ;, return, n, ;, }, if, (, elem, ., isEmpty, (, ), ), {, elem, =, NodeUtil, ., newUndefinedNode]
[;, }, if, (, elem, ., isEmpty, (, ), ), {, elem, =, NodeUtil, ., newUndefinedNode, (, elem, ), ;]
[), {, elem, =, NodeUtil, ., newUndefinedNode, (, elem, ), ;, }, else, {, left, ., removeChild, (, elem, )]
[., isEmpty, (, ), ), {, elem, =, NodeUtil, ., newUndefinedNode, (, elem, ), ;, }, else, {, left, .]
[=, NodeUtil, ., newUndefinedNode, (, elem, ), ;, }, else, {, left, ., removeChild, (, elem, ), ;, }, n]
[;, }, else, {, left, ., removeChild, (, elem, ), ;, }, n, ., getParent, (, ), ., replaceChild, (]
[., newUndefinedNode, (, elem, ), ;, }, else, {, left, ., removeChild, (, elem, ), ;, }, n, ., getParent]
[), ;, }, else, {, left, ., removeChild, (, elem, ), ;, }, n, ., getParent, (, ), ., replaceChild]
[;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, elem, ), ;, reportCodeChange, (, ), ;, return]
[., removeChild, (, elem, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, elem, ), ;]
[), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, elem, ), ;, reportCodeChange, (, ), ;]
[;, reportCodeChange, (, ), ;, return, elem, ;, }, private, Node, tryFoldObjectPropAccess, (, Node, n, ,, Node, left, ,, Node]
[., replaceChild, (, n, ,, elem, ), ;, reportCodeChange, (, ), ;, return, elem, ;, }, private, Node, tryFoldObjectPropAccess, (]
[., getParent, (, ), ., replaceChild, (, n, ,, elem, ), ;, reportCodeChange, (, ), ;, return, elem, ;, }]
[,, elem, ), ;, reportCodeChange, (, ), ;, return, elem, ;, }, private, Node, tryFoldObjectPropAccess, (, Node, n, ,, Node]
[), ;, reportCodeChange, (, ), ;, return, elem, ;, }, private, Node, tryFoldObjectPropAccess, (, Node, n, ,, Node, left, ,]
[;, return, elem, ;, }, private, Node, tryFoldObjectPropAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions]
[;, }, private, Node, tryFoldObjectPropAccess, (, Node, n, ,, Node, left, ,, Node, right, ), {, Preconditions, ., checkArgument, (]
[;, if, (, !, left, ., isObjectLit, (, ), ||, !, right, ., isString, (, ), ), {, return, n]
[., checkArgument, (, NodeUtil, ., isGet, (, n, ), ), ;, if, (, !, left, ., isObjectLit, (, ), ||]
[), ;, if, (, !, left, ., isObjectLit, (, ), ||, !, right, ., isString, (, ), ), {, return]
[., isGet, (, n, ), ), ;, if, (, !, left, ., isObjectLit, (, ), ||, !, right, ., isString]
[), ), ;, if, (, !, left, ., isObjectLit, (, ), ||, !, right, ., isString, (, ), ), {]
[), {, return, n, ;, }, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, Node, key]
[||, !, right, ., isString, (, ), ), {, return, n, ;, }, if, (, isAssignmentTarget, (, n, ), )]
[||, !, right, ., isString, (, ), ), {, return, n, ;, }, if, (, isAssignmentTarget, (, n, ), )]
[., isObjectLit, (, ), ||, !, right, ., isString, (, ), ), {, return, n, ;, }, if, (, isAssignmentTarget]
[), {, return, n, ;, }, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, Node, key]
[), {, return, n, ;, }, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, Node, key]
[., isString, (, ), ), {, return, n, ;, }, if, (, isAssignmentTarget, (, n, ), ), {, return, n]
[;, }, if, (, isAssignmentTarget, (, n, ), ), {, return, n, ;, }, Node, key, =, null, ;, Node]
[), {, return, n, ;, }, Node, key, =, null, ;, Node, value, =, null, ;, for, (, Node, c]
[), ), {, return, n, ;, }, Node, key, =, null, ;, Node, value, =, null, ;, for, (, Node]
[;, }, Node, key, =, null, ;, Node, value, =, null, ;, for, (, Node, c, =, left, ., getFirstChild]
[;, Node, value, =, null, ;, for, (, Node, c, =, left, ., getFirstChild, (, ), ;, c, !=, null]
[;, for, (, Node, c, =, left, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, .]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, c, ., getString, (]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, c, ., getString, (, ), ., equals, (]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, c, ., getString, (, ), .]
[;, c, =, c, ., getNext, (, ), ), {, if, (, c, ., getString, (, ), ., equals, (]
[=, c, ., getNext, (, ), ), {, if, (, c, ., getString, (, ), ., equals, (, right, .]
[), {, if, (, c, ., getString, (, ), ., equals, (, right, ., getString, (, ), ), ), {]
[., getNext, (, ), ), {, if, (, c, ., getString, (, ), ., equals, (, right, ., getString, (]
[), {, switch, (, c, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, continue, ;, case, Token]
[., equals, (, right, ., getString, (, ), ), ), {, switch, (, c, ., getType, (, ), ), {]
[., getString, (, ), ., equals, (, right, ., getString, (, ), ), ), {, switch, (, c, ., getType]
[), ), {, switch, (, c, ., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, continue, ;, case]
[., getString, (, ), ), ), {, switch, (, c, ., getType, (, ), ), {, case, Token, ., SETTER_DEF]
[), {, case, Token, ., SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if]
[., getType, (, ), ), {, case, Token, ., SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case, Token]
[:, continue, ;, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (, value, !=, null, &&, mayHaveSideEffects]
[., SETTER_DEF, :, continue, ;, case, Token, ., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (, value, !=, null]
[:, case, Token, ., STRING_KEY, :, if, (, value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {, return, n]
[., GETTER_DEF, :, case, Token, ., STRING_KEY, :, if, (, value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {]
[:, if, (, value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }, key, =, c]
[., STRING_KEY, :, if, (, value, !=, null, &&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }, key]
[), {, return, n, ;, }, key, =, c, ;, value, =, key, ., getFirstChild, (, ), ;, break, ;]
[&&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }, key, =, c, ;, value, =, key, ., getFirstChild]
[!=, null, &&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }, key, =, c, ;, value, =, key]
[&&, mayHaveSideEffects, (, value, ), ), {, return, n, ;, }, key, =, c, ;, value, =, key, ., getFirstChild]
[), {, return, n, ;, }, key, =, c, ;, value, =, key, ., getFirstChild, (, ), ;, break, ;]
[), ), {, return, n, ;, }, key, =, c, ;, value, =, key, ., getFirstChild, (, ), ;, break]
[;, }, key, =, c, ;, value, =, key, ., getFirstChild, (, ), ;, break, ;, default, :, throw, new]
[=, c, ;, value, =, key, ., getFirstChild, (, ), ;, break, ;, default, :, throw, new, IllegalStateException, (, )]
[;, value, =, key, ., getFirstChild, (, ), ;, break, ;, default, :, throw, new, IllegalStateException, (, ), ;, }]
[=, key, ., getFirstChild, (, ), ;, break, ;, default, :, throw, new, IllegalStateException, (, ), ;, }, }, else]
[;, break, ;, default, :, throw, new, IllegalStateException, (, ), ;, }, }, else, if, (, mayHaveSideEffects, (, c, .]
[., getFirstChild, (, ), ;, break, ;, default, :, throw, new, IllegalStateException, (, ), ;, }, }, else, if, (]
[;, }, }, else, if, (, mayHaveSideEffects, (, c, ., getFirstChild, (, ), ), ), {, return, n, ;, }]
[), {, return, n, ;, }, }, if, (, value, ==, null, ), {, return, n, ;, }, if, (]
[), ), {, return, n, ;, }, }, if, (, value, ==, null, ), {, return, n, ;, }, if]
[., getFirstChild, (, ), ), ), {, return, n, ;, }, }, if, (, value, ==, null, ), {, return]
[;, }, }, if, (, value, ==, null, ), {, return, n, ;, }, if, (, value, ., isFunction, (]
[), {, return, n, ;, }, if, (, value, ., isFunction, (, ), &&, NodeUtil, ., referencesThis, (, value, )]
[==, null, ), {, return, n, ;, }, if, (, value, ., isFunction, (, ), &&, NodeUtil, ., referencesThis, (]
[), {, return, n, ;, }, if, (, value, ., isFunction, (, ), &&, NodeUtil, ., referencesThis, (, value, )]
[;, }, if, (, value, ., isFunction, (, ), &&, NodeUtil, ., referencesThis, (, value, ), ), {, return, n]
[), {, return, n, ;, }, Node, replacement, =, value, ., detachFromParent, (, ), ;, if, (, key, ., isGetterDef]
[&&, NodeUtil, ., referencesThis, (, value, ), ), {, return, n, ;, }, Node, replacement, =, value, ., detachFromParent, (]
[., isFunction, (, ), &&, NodeUtil, ., referencesThis, (, value, ), ), {, return, n, ;, }, Node, replacement, =]
[), {, return, n, ;, }, Node, replacement, =, value, ., detachFromParent, (, ), ;, if, (, key, ., isGetterDef]
[., referencesThis, (, value, ), ), {, return, n, ;, }, Node, replacement, =, value, ., detachFromParent, (, ), ;]
[), ), {, return, n, ;, }, Node, replacement, =, value, ., detachFromParent, (, ), ;, if, (, key, .]
[;, }, Node, replacement, =, value, ., detachFromParent, (, ), ;, if, (, key, ., isGetterDef, (, ), ), {]
[;, if, (, key, ., isGetterDef, (, ), ), {, replacement, =, IR, ., call, (, replacement, ), ;, replacement]
[., detachFromParent, (, ), ;, if, (, key, ., isGetterDef, (, ), ), {, replacement, =, IR, ., call, (]
[), {, replacement, =, IR, ., call, (, replacement, ), ;, replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true]
[., isGetterDef, (, ), ), {, replacement, =, IR, ., call, (, replacement, ), ;, replacement, ., putBooleanProp, (, Node]
[=, IR, ., call, (, replacement, ), ;, replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }]
[;, replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, n, ., getParent, (, ), ., replaceChild]
[., call, (, replacement, ), ;, replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, n, .]
[), ;, replacement, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, n, ., getParent, (, ), .]
[;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
[., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n]
[,, true, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (]
[., FREE_CALL, ,, true, ), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;]
[), ;, }, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;]
[;, reportCodeChange, (, ), ;, return, n, ;, }, }]
[., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }]
[., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, n, ;, }]
[,, replacement, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }]
[), ;, reportCodeChange, (, ), ;, return, n, ;, }, }]
[;, return, n, ;, }, }]
[;, }, }]
