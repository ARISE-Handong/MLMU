[rhino, ., Node, ;, import, java, ., util, ., List, ;, class, AstParallelizer, {, public, static, final, String, TEMP_NAME, =]
[,, Predicate, <, Node, >, shouldTraverse, ,, Supplier, <, Node, >, placeHolderProvider, ,, Node, root, ,, boolean, includeRoot, ), {]
[,, Predicate, <, Node, >, shouldTraverse, ,, Supplier, <, Node, >, placeHolderProvider, ,, Node, root, ,, boolean, includeRoot, ), {]
[>, shouldTraverse, ,, Supplier, <, Node, >, placeHolderProvider, ,, Node, root, ,, boolean, includeRoot, ), {, this, ., shouldSplit, =]
[,, Supplier, <, Node, >, placeHolderProvider, ,, Node, root, ,, boolean, includeRoot, ), {, this, ., shouldSplit, =, shouldSplit, ;]
[,, Supplier, <, Node, >, placeHolderProvider, ,, Node, root, ,, boolean, includeRoot, ), {, this, ., shouldSplit, =, shouldSplit, ;]
[>, placeHolderProvider, ,, Node, root, ,, boolean, includeRoot, ), {, this, ., shouldSplit, =, shouldSplit, ;, this, ., placeHolderProvider, =]
[,, Node, root, ,, boolean, includeRoot, ), {, this, ., shouldSplit, =, shouldSplit, ;, this, ., placeHolderProvider, =, placeHolderProvider, ;]
[,, Node, root, ,, boolean, includeRoot, ), {, this, ., shouldSplit, =, shouldSplit, ;, this, ., placeHolderProvider, =, placeHolderProvider, ;]
[boolean, includeRoot, ), {, this, ., shouldSplit, =, shouldSplit, ;, this, ., placeHolderProvider, =, placeHolderProvider, ;, this, ., root, =]
[), {, this, ., shouldSplit, =, shouldSplit, ;, this, ., placeHolderProvider, =, placeHolderProvider, ;, this, ., root, =, root, ;]
[), {, this, ., shouldSplit, =, shouldSplit, ;, this, ., placeHolderProvider, =, placeHolderProvider, ;, this, ., root, =, root, ;]
[shouldSplit, =, shouldSplit, ;, this, ., placeHolderProvider, =, placeHolderProvider, ;, this, ., root, =, root, ;, this, ., includeRoot, =]
[shouldSplit, ;, this, ., placeHolderProvider, =, placeHolderProvider, ;, this, ., root, =, root, ;, this, ., includeRoot, =, includeRoot, ;]
[shouldSplit, ;, this, ., placeHolderProvider, =, placeHolderProvider, ;, this, ., root, =, root, ;, this, ., includeRoot, =, includeRoot, ;]
[placeHolderProvider, =, placeHolderProvider, ;, this, ., root, =, root, ;, this, ., includeRoot, =, includeRoot, ;, this, ., forest, =]
[placeHolderProvider, =, placeHolderProvider, ;, this, ., root, =, root, ;, this, ., includeRoot, =, includeRoot, ;, this, ., forest, =]
[root, =, root, ;, this, ., includeRoot, =, includeRoot, ;, this, ., forest, =, Lists, ., newLinkedList, (, ), ;]
[root, =, root, ;, this, ., includeRoot, =, includeRoot, ;, this, ., forest, =, Lists, ., newLinkedList, (, ), ;]
[this, ., includeRoot, =, includeRoot, ;, this, ., forest, =, Lists, ., newLinkedList, (, ), ;, this, ., detachPointList, =]
[this, ., includeRoot, =, includeRoot, ;, this, ., forest, =, Lists, ., newLinkedList, (, ), ;, this, ., detachPointList, =]
[;, }, public, static, AstParallelizer, createNewFunctionLevelAstParallelizer, (, Node, root, ,, boolean, globalPass, ), {, Predicate, <, Node, >, shouldSplit, =]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[Node, input, ), {, return, input, ., isFunction, (, ), ;, }, }, ;, Predicate, <, Node, >, shouldTraverse, =]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, ignored, ), {, return]
[public, boolean, apply, (, Node, ignored, ), {, return, true, ;, }, }, ;, Supplier, <, Node, >, placeHolders, =]
[>, placeHolders, =, new, Supplier, <, Node, >, (, ), {, @, Override, public, Node, get, (, ), {, return]
[>, placeHolders, =, new, Supplier, <, Node, >, (, ), {, @, Override, public, Node, get, (, ), {, return]
[Supplier, <, Node, >, (, ), {, @, Override, public, Node, get, (, ), {, return, IR, ., function, (]
[Supplier, <, Node, >, (, ), {, @, Override, public, Node, get, (, ), {, return, IR, ., function, (]
[(, ), {, @, Override, public, Node, get, (, ), {, return, IR, ., function, (, IR, ., name, (]
[@, Override, public, Node, get, (, ), {, return, IR, ., function, (, IR, ., name, (, TEMP_NAME, ), ,]
[@, Override, public, Node, get, (, ), {, return, IR, ., function, (, IR, ., name, (, TEMP_NAME, ), ,]
[), {, return, IR, ., function, (, IR, ., name, (, TEMP_NAME, ), ,, IR, ., paramList, (, ), ,]
[), {, return, IR, ., function, (, IR, ., name, (, TEMP_NAME, ), ,, IR, ., paramList, (, ), ,]
[TEMP_NAME, ), ,, IR, ., paramList, (, ), ,, IR, ., block, (, ), ), ;, }, }, ;, return]
[IR, ., paramList, (, ), ,, IR, ., block, (, ), ), ;, }, }, ;, return, new, AstParallelizer, (]
[paramList, (, ), ,, IR, ., block, (, ), ), ;, }, }, ;, return, new, AstParallelizer, (, shouldSplit, ,]
[), ,, IR, ., block, (, ), ), ;, }, }, ;, return, new, AstParallelizer, (, shouldSplit, ,, shouldTraverse, ,]
[IR, ., block, (, ), ), ;, }, }, ;, return, new, AstParallelizer, (, shouldSplit, ,, shouldTraverse, ,, placeHolders, ,]
[block, (, ), ), ;, }, }, ;, return, new, AstParallelizer, (, shouldSplit, ,, shouldTraverse, ,, placeHolders, ,, root, ,]
[,, globalPass, ), ;, }, public, static, AstParallelizer, createNewFileLevelAstParallelizer, (, Node, root, ), {, Predicate, <, Node, >, shouldSplit, =]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[(, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, input, ., getSourceFileName, (, ), !=]
[), {, return, input, ., getSourceFileName, (, ), !=, null, ;, }, }, ;, Supplier, <, Node, >, placeHolders, =]
[>, placeHolders, =, new, Supplier, <, Node, >, (, ), {, @, Override, public, Node, get, (, ), {, return]
[>, placeHolders, =, new, Supplier, <, Node, >, (, ), {, @, Override, public, Node, get, (, ), {, return]
[Supplier, <, Node, >, (, ), {, @, Override, public, Node, get, (, ), {, return, NodeUtil, ., newExpr, (]
[Supplier, <, Node, >, (, ), {, @, Override, public, Node, get, (, ), {, return, NodeUtil, ., newExpr, (]
[(, ), {, @, Override, public, Node, get, (, ), {, return, NodeUtil, ., newExpr, (, IR, ., string, (]
[., newExpr, (, IR, ., string, (, TEMP_NAME, ), ), ;, }, }, ;, Predicate, <, Node, >, shouldTraverse, =]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, n, ), {, return]
[Override, public, boolean, apply, (, Node, n, ), {, return, n, ., isBlock, (, ), ;, }, }, ;, return]
[apply, (, Node, n, ), {, return, n, ., isBlock, (, ), ;, }, }, ;, return, new, AstParallelizer, (]
[Node, n, ), {, return, n, ., isBlock, (, ), ;, }, }, ;, return, new, AstParallelizer, (, shouldSplit, ,]
[), {, return, n, ., isBlock, (, ), ;, }, }, ;, return, new, AstParallelizer, (, shouldSplit, ,, shouldTraverse, ,]
[return, n, ., isBlock, (, ), ;, }, }, ;, return, new, AstParallelizer, (, shouldSplit, ,, shouldTraverse, ,, placeHolders, ,]
[., isBlock, (, ), ;, }, }, ;, return, new, AstParallelizer, (, shouldSplit, ,, shouldTraverse, ,, placeHolders, ,, root, ,]
[root, ,, false, ), ;, }, private, void, recordSplitPoint, (, Node, placeHolder, ,, Node, before, ,, Node, original, ), {]
[root, ,, false, ), ;, }, private, void, recordSplitPoint, (, Node, placeHolder, ,, Node, before, ,, Node, original, ), {]
[;, }, private, void, recordSplitPoint, (, Node, placeHolder, ,, Node, before, ,, Node, original, ), {, detachPointList, ., add, (]
[void, recordSplitPoint, (, Node, placeHolder, ,, Node, before, ,, Node, original, ), {, detachPointList, ., add, (, new, DetachPoint, (]
[(, Node, placeHolder, ,, Node, before, ,, Node, original, ), {, detachPointList, ., add, (, new, DetachPoint, (, placeHolder, ,]
[placeHolder, ,, Node, before, ,, Node, original, ), {, detachPointList, ., add, (, new, DetachPoint, (, placeHolder, ,, before, ,]
[placeHolder, ,, before, ,, original, ), ), ;, }, public, List, <, Node, >, split, (, ), {, if, (]
[,, original, ), ), ;, }, public, List, <, Node, >, split, (, ), {, if, (, includeRoot, ), {]
[,, original, ), ), ;, }, public, List, <, Node, >, split, (, ), {, if, (, includeRoot, ), {]
[;, }, public, List, <, Node, >, split, (, ), {, if, (, includeRoot, ), {, forest, ., add, (]
[<, Node, >, split, (, ), {, if, (, includeRoot, ), {, forest, ., add, (, root, ), ;, }]
[>, split, (, ), {, if, (, includeRoot, ), {, forest, ., add, (, root, ), ;, }, split, (]
[{, if, (, includeRoot, ), {, forest, ., add, (, root, ), ;, }, split, (, root, ), ;, return]
[split, (, root, ), ;, return, forest, ;, }, private, void, split, (, Node, n, ), {, Node, c, =]
[split, (, root, ), ;, return, forest, ;, }, private, void, split, (, Node, n, ), {, Node, c, =]
[private, void, split, (, Node, n, ), {, Node, c, =, n, ., getFirstChild, (, ), ;, Node, before, =]
[Node, n, ), {, Node, c, =, n, ., getFirstChild, (, ), ;, Node, before, =, null, ;, while, (]
[Node, n, ), {, Node, c, =, n, ., getFirstChild, (, ), ;, Node, before, =, null, ;, while, (]
[), {, Node, c, =, n, ., getFirstChild, (, ), ;, Node, before, =, null, ;, while, (, c, !=]
[., getFirstChild, (, ), ;, Node, before, =, null, ;, while, (, c, !=, null, ), {, Node, next, =]
[., getFirstChild, (, ), ;, Node, before, =, null, ;, while, (, c, !=, null, ), {, Node, next, =]
[null, ;, while, (, c, !=, null, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (]
[null, ;, while, (, c, !=, null, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (]
[c, !=, null, ), {, Node, next, =, c, ., getNext, (, ), ;, if, (, shouldSplit, ., apply, (]
[=, c, ., getNext, (, ), ;, if, (, shouldSplit, ., apply, (, c, ), ), {, Node, placeHolder, =]
[=, c, ., getNext, (, ), ;, if, (, shouldSplit, ., apply, (, c, ), ), {, Node, placeHolder, =]
[(, shouldSplit, ., apply, (, c, ), ), {, Node, placeHolder, =, placeHolderProvider, ., get, (, ), ;, if, (]
[(, shouldSplit, ., apply, (, c, ), ), {, Node, placeHolder, =, placeHolderProvider, ., get, (, ), ;, if, (]
[., apply, (, c, ), ), {, Node, placeHolder, =, placeHolderProvider, ., get, (, ), ;, if, (, before, ==]
[c, ), ), {, Node, placeHolder, =, placeHolderProvider, ., get, (, ), ;, if, (, before, ==, null, ), {]
[c, ), ), {, Node, placeHolder, =, placeHolderProvider, ., get, (, ), ;, if, (, before, ==, null, ), {]
[Node, placeHolder, =, placeHolderProvider, ., get, (, ), ;, if, (, before, ==, null, ), {, forest, ., add, (]
[Node, placeHolder, =, placeHolderProvider, ., get, (, ), ;, if, (, before, ==, null, ), {, forest, ., add, (]
[), ;, if, (, before, ==, null, ), {, forest, ., add, (, n, ., removeFirstChild, (, ), ), ;]
[), ;, if, (, before, ==, null, ), {, forest, ., add, (, n, ., removeFirstChild, (, ), ), ;]
[before, ==, null, ), {, forest, ., add, (, n, ., removeFirstChild, (, ), ), ;, n, ., addChildToFront, (]
[., add, (, n, ., removeFirstChild, (, ), ), ;, n, ., addChildToFront, (, placeHolder, ), ;, }, else, {]
[., add, (, n, ., removeFirstChild, (, ), ), ;, n, ., addChildToFront, (, placeHolder, ), ;, }, else, {]
[., removeFirstChild, (, ), ), ;, n, ., addChildToFront, (, placeHolder, ), ;, }, else, {, n, ., addChildAfter, (]
[(, ), ), ;, n, ., addChildToFront, (, placeHolder, ), ;, }, else, {, n, ., addChildAfter, (, placeHolder, ,]
[;, n, ., addChildToFront, (, placeHolder, ), ;, }, else, {, n, ., addChildAfter, (, placeHolder, ,, c, ), ;]
[;, n, ., addChildToFront, (, placeHolder, ), ;, }, else, {, n, ., addChildAfter, (, placeHolder, ,, c, ), ;]
[(, placeHolder, ), ;, }, else, {, n, ., addChildAfter, (, placeHolder, ,, c, ), ;, n, ., removeChildAfter, (]
[;, }, else, {, n, ., addChildAfter, (, placeHolder, ,, c, ), ;, n, ., removeChildAfter, (, before, ), ;]
[;, }, else, {, n, ., addChildAfter, (, placeHolder, ,, c, ), ;, n, ., removeChildAfter, (, before, ), ;]
[n, ., addChildAfter, (, placeHolder, ,, c, ), ;, n, ., removeChildAfter, (, before, ), ;, forest, ., add, (]
[placeHolder, ,, c, ), ;, n, ., removeChildAfter, (, before, ), ;, forest, ., add, (, c, ), ;, }]
[c, ), ;, n, ., removeChildAfter, (, before, ), ;, forest, ., add, (, c, ), ;, }, recordSplitPoint, (]
[;, n, ., removeChildAfter, (, before, ), ;, forest, ., add, (, c, ), ;, }, recordSplitPoint, (, placeHolder, ,]
[., removeChildAfter, (, before, ), ;, forest, ., add, (, c, ), ;, }, recordSplitPoint, (, placeHolder, ,, before, ,]
[before, ), ;, forest, ., add, (, c, ), ;, }, recordSplitPoint, (, placeHolder, ,, before, ,, c, ), ;]
[;, forest, ., add, (, c, ), ;, }, recordSplitPoint, (, placeHolder, ,, before, ,, c, ), ;, before, =]
[c, ), ;, }, recordSplitPoint, (, placeHolder, ,, before, ,, c, ), ;, before, =, placeHolder, ;, }, else, {]
[;, }, recordSplitPoint, (, placeHolder, ,, before, ,, c, ), ;, before, =, placeHolder, ;, }, else, {, split, (]
[(, placeHolder, ,, before, ,, c, ), ;, before, =, placeHolder, ;, }, else, {, split, (, c, ), ;]
[,, before, ,, c, ), ;, before, =, placeHolder, ;, }, else, {, split, (, c, ), ;, before, =]
[c, ), ;, before, =, placeHolder, ;, }, else, {, split, (, c, ), ;, before, =, c, ;, }]
[;, before, =, placeHolder, ;, }, else, {, split, (, c, ), ;, before, =, c, ;, }, c, =]
[;, before, =, c, ;, }, c, =, next, ;, }, }, public, void, join, (, ), {, while, (]
[before, =, c, ;, }, c, =, next, ;, }, }, public, void, join, (, ), {, while, (, !]
[before, =, c, ;, }, c, =, next, ;, }, }, public, void, join, (, ), {, while, (, !]
[}, public, void, join, (, ), {, while, (, !, detachPointList, ., isEmpty, (, ), ), {, DetachPoint, entry, =]
[}, public, void, join, (, ), {, while, (, !, detachPointList, ., isEmpty, (, ), ), {, DetachPoint, entry, =]
[(, ), {, while, (, !, detachPointList, ., isEmpty, (, ), ), {, DetachPoint, entry, =, detachPointList, ., remove, (]
[(, ), {, while, (, !, detachPointList, ., isEmpty, (, ), ), {, DetachPoint, entry, =, detachPointList, ., remove, (]
[(, ), {, while, (, !, detachPointList, ., isEmpty, (, ), ), {, DetachPoint, entry, =, detachPointList, ., remove, (]
[detachPointList, ., isEmpty, (, ), ), {, DetachPoint, entry, =, detachPointList, ., remove, (, detachPointList, ., size, (, ), -]
[(, ), ), {, DetachPoint, entry, =, detachPointList, ., remove, (, detachPointList, ., size, (, ), -, 1, ), ;]
[(, ), ), {, DetachPoint, entry, =, detachPointList, ., remove, (, detachPointList, ., size, (, ), -, 1, ), ;]
[Node, before, ;, private, Node, original, ;, private, DetachPoint, (, Node, placeHolder, ,, Node, before, ,, Node, original, ), {]
[Node, before, ;, private, Node, original, ;, private, DetachPoint, (, Node, placeHolder, ,, Node, before, ,, Node, original, ), {]
[Node, original, ;, private, DetachPoint, (, Node, placeHolder, ,, Node, before, ,, Node, original, ), {, this, ., placeHolder, =]
[;, private, DetachPoint, (, Node, placeHolder, ,, Node, before, ,, Node, original, ), {, this, ., placeHolder, =, placeHolder, ;]
[;, private, DetachPoint, (, Node, placeHolder, ,, Node, before, ,, Node, original, ), {, this, ., placeHolder, =, placeHolder, ;]
[Node, placeHolder, ,, Node, before, ,, Node, original, ), {, this, ., placeHolder, =, placeHolder, ;, this, ., before, =]
[,, Node, before, ,, Node, original, ), {, this, ., placeHolder, =, placeHolder, ;, this, ., before, =, before, ;]
[,, Node, before, ,, Node, original, ), {, this, ., placeHolder, =, placeHolder, ;, this, ., before, =, before, ;]
[Node, original, ), {, this, ., placeHolder, =, placeHolder, ;, this, ., before, =, before, ;, this, ., original, =]
[., before, =, before, ;, this, ., original, =, original, ;, }, public, void, reattach, (, ), {, if, (]
[., before, =, before, ;, this, ., original, =, original, ;, }, public, void, reattach, (, ), {, if, (]
[., before, =, before, ;, this, ., original, =, original, ;, }, public, void, reattach, (, ), {, if, (]
[., original, =, original, ;, }, public, void, reattach, (, ), {, if, (, placeHolder, ., getParent, (, ), !=]
[}, public, void, reattach, (, ), {, if, (, placeHolder, ., getParent, (, ), !=, null, ), {, if, (]
[}, public, void, reattach, (, ), {, if, (, placeHolder, ., getParent, (, ), !=, null, ), {, if, (]
[void, reattach, (, ), {, if, (, placeHolder, ., getParent, (, ), !=, null, ), {, if, (, before, ==]
[), {, if, (, placeHolder, ., getParent, (, ), !=, null, ), {, if, (, before, ==, null, ), {]
[), {, if, (, placeHolder, ., getParent, (, ), !=, null, ), {, if, (, before, ==, null, ), {]
[), {, if, (, placeHolder, ., getParent, (, ), !=, null, ), {, if, (, before, ==, null, ), {]
[), !=, null, ), {, if, (, before, ==, null, ), {, placeHolder, ., getParent, (, ), ., addChildrenToFront, (]
[), {, if, (, before, ==, null, ), {, placeHolder, ., getParent, (, ), ., addChildrenToFront, (, original, ), ;]
[), {, if, (, before, ==, null, ), {, placeHolder, ., getParent, (, ), ., addChildrenToFront, (, original, ), ;]
[), {, if, (, before, ==, null, ), {, placeHolder, ., getParent, (, ), ., addChildrenToFront, (, original, ), ;]
[{, placeHolder, ., getParent, (, ), ., addChildrenToFront, (, original, ), ;, placeHolder, ., getParent, (, ), ., removeChildAfter, (]
[., addChildrenToFront, (, original, ), ;, placeHolder, ., getParent, (, ), ., removeChildAfter, (, original, ), ;, }, else, {]
[., addChildrenToFront, (, original, ), ;, placeHolder, ., getParent, (, ), ., removeChildAfter, (, original, ), ;, }, else, {]
[., addChildrenToFront, (, original, ), ;, placeHolder, ., getParent, (, ), ., removeChildAfter, (, original, ), ;, }, else, {]
[getParent, (, ), ., removeChildAfter, (, original, ), ;, }, else, {, placeHolder, ., getParent, (, ), ., addChildAfter, (]
[), ., removeChildAfter, (, original, ), ;, }, else, {, placeHolder, ., getParent, (, ), ., addChildAfter, (, original, ,]
[(, original, ), ;, }, else, {, placeHolder, ., getParent, (, ), ., addChildAfter, (, original, ,, before, ), ;]
[(, original, ), ;, }, else, {, placeHolder, ., getParent, (, ), ., addChildAfter, (, original, ,, before, ), ;]
[(, original, ), ;, }, else, {, placeHolder, ., getParent, (, ), ., addChildAfter, (, original, ,, before, ), ;]
[., getParent, (, ), ., addChildAfter, (, original, ,, before, ), ;, placeHolder, ., getParent, (, ), ., removeChildAfter, (]
