[., google, ., javascript, ., rhino, ., Token, ;, final, class, CheckSuspiciousCode, extends, AbstractPostOrderCallback, {, static, final, DiagnosticType, SUSPICIOUS_SEMICOLON, =]
[., google, ., javascript, ., rhino, ., Token, ;, final, class, CheckSuspiciousCode, extends, AbstractPostOrderCallback, {, static, final, DiagnosticType, SUSPICIOUS_SEMICOLON, =]
[., rhino, ., Token, ;, final, class, CheckSuspiciousCode, extends, AbstractPostOrderCallback, {, static, final, DiagnosticType, SUSPICIOUS_SEMICOLON, =, DiagnosticType, ., warning, (]
[., Token, ;, final, class, CheckSuspiciousCode, extends, AbstractPostOrderCallback, {, static, final, DiagnosticType, SUSPICIOUS_SEMICOLON, =, DiagnosticType, ., warning, (, "JSC_SUSPICIOUS_SEMICOLON", ,]
[{, static, final, DiagnosticType, SUSPICIOUS_SEMICOLON, =, DiagnosticType, ., warning, (, "JSC_SUSPICIOUS_SEMICOLON", ,, "If this if/for/while really shouldn't have a body, use {}", ), ;, static, final, DiagnosticType, SUSPICIOUS_COMPARISON_WITH_NAN, =]
[{, static, final, DiagnosticType, SUSPICIOUS_SEMICOLON, =, DiagnosticType, ., warning, (, "JSC_SUSPICIOUS_SEMICOLON", ,, "If this if/for/while really shouldn't have a body, use {}", ), ;, static, final, DiagnosticType, SUSPICIOUS_COMPARISON_WITH_NAN, =]
[SUSPICIOUS_SEMICOLON, =, DiagnosticType, ., warning, (, "JSC_SUSPICIOUS_SEMICOLON", ,, "If this if/for/while really shouldn't have a body, use {}", ), ;, static, final, DiagnosticType, SUSPICIOUS_COMPARISON_WITH_NAN, =, DiagnosticType, ., warning, (]
[DiagnosticType, ., warning, (, "JSC_SUSPICIOUS_SEMICOLON", ,, "If this if/for/while really shouldn't have a body, use {}", ), ;, static, final, DiagnosticType, SUSPICIOUS_COMPARISON_WITH_NAN, =, DiagnosticType, ., warning, (, "JSC_SUSPICIOUS_NAN", ,]
[(, ), {, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {]
[{, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, checkMissingSemicolon, (]
[@, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, checkMissingSemicolon, (, t, ,]
[void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, checkMissingSemicolon, (, t, ,, n, ), ;]
[(, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, checkMissingSemicolon, (, t, ,, n, ), ;, checkNaN, (]
[t, ,, Node, n, ,, Node, parent, ), {, checkMissingSemicolon, (, t, ,, n, ), ;, checkNaN, (, t, ,]
[(, t, ,, n, ), ;, }, private, void, checkMissingSemicolon, (, NodeTraversal, t, ,, Node, n, ), {, switch, (]
[(, t, ,, n, ), ;, }, private, void, checkMissingSemicolon, (, NodeTraversal, t, ,, Node, n, ), {, switch, (]
[void, checkMissingSemicolon, (, NodeTraversal, t, ,, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[void, checkMissingSemicolon, (, NodeTraversal, t, ,, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, Node, trueCase, =]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, Node, trueCase, =]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, Node, trueCase, =]
[), {, case, Token, ., IF, :, Node, trueCase, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;]
[case, Token, ., IF, :, Node, trueCase, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, reportIfWasEmpty, (]
[., IF, :, Node, trueCase, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, reportIfWasEmpty, (, t, ,]
[n, ., getFirstChild, (, ), ., getNext, (, ), ;, reportIfWasEmpty, (, t, ,, trueCase, ), ;, Node, elseCase, =]
[n, ., getFirstChild, (, ), ., getNext, (, ), ;, reportIfWasEmpty, (, t, ,, trueCase, ), ;, Node, elseCase, =]
[), ;, reportIfWasEmpty, (, t, ,, trueCase, ), ;, Node, elseCase, =, trueCase, ., getNext, (, ), ;, if, (]
[), ;, reportIfWasEmpty, (, t, ,, trueCase, ), ;, Node, elseCase, =, trueCase, ., getNext, (, ), ;, if, (]
[reportIfWasEmpty, (, t, ,, trueCase, ), ;, Node, elseCase, =, trueCase, ., getNext, (, ), ;, if, (, elseCase, !=]
[,, trueCase, ), ;, Node, elseCase, =, trueCase, ., getNext, (, ), ;, if, (, elseCase, !=, null, ), {]
[), ;, Node, elseCase, =, trueCase, ., getNext, (, ), ;, if, (, elseCase, !=, null, ), {, reportIfWasEmpty, (]
[Node, elseCase, =, trueCase, ., getNext, (, ), ;, if, (, elseCase, !=, null, ), {, reportIfWasEmpty, (, t, ,]
[), ;, if, (, elseCase, !=, null, ), {, reportIfWasEmpty, (, t, ,, elseCase, ), ;, }, break, ;, case]
[), ;, if, (, elseCase, !=, null, ), {, reportIfWasEmpty, (, t, ,, elseCase, ), ;, }, break, ;, case]
[!=, null, ), {, reportIfWasEmpty, (, t, ,, elseCase, ), ;, }, break, ;, case, Token, ., WHILE, :, case]
[!=, null, ), {, reportIfWasEmpty, (, t, ,, elseCase, ), ;, }, break, ;, case, Token, ., WHILE, :, case]
[reportIfWasEmpty, (, t, ,, elseCase, ), ;, }, break, ;, case, Token, ., WHILE, :, case, Token, ., FOR, :]
[t, ,, elseCase, ), ;, }, break, ;, case, Token, ., WHILE, :, case, Token, ., FOR, :, reportIfWasEmpty, (]
[elseCase, ), ;, }, break, ;, case, Token, ., WHILE, :, case, Token, ., FOR, :, reportIfWasEmpty, (, t, ,]
[elseCase, ), ;, }, break, ;, case, Token, ., WHILE, :, case, Token, ., FOR, :, reportIfWasEmpty, (, t, ,]
[break, ;, case, Token, ., WHILE, :, case, Token, ., FOR, :, reportIfWasEmpty, (, t, ,, NodeUtil, ., getLoopCodeBlock, (]
[(, n, ), ), ;, break, ;, }, }, private, void, reportIfWasEmpty, (, NodeTraversal, t, ,, Node, block, ), {]
[(, n, ), ), ;, break, ;, }, }, private, void, reportIfWasEmpty, (, NodeTraversal, t, ,, Node, block, ), {]
[;, break, ;, }, }, private, void, reportIfWasEmpty, (, NodeTraversal, t, ,, Node, block, ), {, Preconditions, ., checkState, (]
[;, break, ;, }, }, private, void, reportIfWasEmpty, (, NodeTraversal, t, ,, Node, block, ), {, Preconditions, ., checkState, (]
[NodeTraversal, t, ,, Node, block, ), {, Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, if, (]
[NodeTraversal, t, ,, Node, block, ), {, Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, if, (]
[t, ,, Node, block, ), {, Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, if, (, !]
[t, ,, Node, block, ), {, Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, if, (, !]
[Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, if, (, !, block, ., hasChildren, (, ), &&]
[Preconditions, ., checkState, (, block, ., isBlock, (, ), ), ;, if, (, !, block, ., hasChildren, (, ), &&]
[(, ), ), ;, if, (, !, block, ., hasChildren, (, ), &&, block, ., wasEmptyNode, (, ), ), {]
[(, ), ), ;, if, (, !, block, ., hasChildren, (, ), &&, block, ., wasEmptyNode, (, ), ), {]
[(, ), ), ;, if, (, !, block, ., hasChildren, (, ), &&, block, ., wasEmptyNode, (, ), ), {]
[., hasChildren, (, ), &&, block, ., wasEmptyNode, (, ), ), {, t, ., getCompiler, (, ), ., report, (]
[., hasChildren, (, ), &&, block, ., wasEmptyNode, (, ), ), {, t, ., getCompiler, (, ), ., report, (]
[&&, block, ., wasEmptyNode, (, ), ), {, t, ., getCompiler, (, ), ., report, (, t, ., makeError, (]
[., wasEmptyNode, (, ), ), {, t, ., getCompiler, (, ), ., report, (, t, ., makeError, (, block, ,]
[,, SUSPICIOUS_SEMICOLON, ), ), ;, }, }, private, void, checkNaN, (, NodeTraversal, t, ,, Node, n, ), {, switch, (]
[,, SUSPICIOUS_SEMICOLON, ), ), ;, }, }, private, void, checkNaN, (, NodeTraversal, t, ,, Node, n, ), {, switch, (]
[void, checkNaN, (, NodeTraversal, t, ,, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[void, checkNaN, (, NodeTraversal, t, ,, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[,, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., EQ, :, case]
[,, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., EQ, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., EQ, :, case, Token, ., GE, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., EQ, :, case, Token, ., GE, :, case]
[(, ), ), {, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case]
[(, ), ), {, case, Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case]
[Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[Token, ., EQ, :, case, Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case]
[Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LT, :, case]
[Token, ., GE, :, case, Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LT, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LT, :, case, Token, ., NE, :, case]
[Token, ., GT, :, case, Token, ., LE, :, case, Token, ., LT, :, case, Token, ., NE, :, case]
[Token, ., LE, :, case, Token, ., LT, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[Token, ., LE, :, case, Token, ., LT, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case]
[case, Token, ., LT, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :]
[., LT, :, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, reportIfNaN, (]
[:, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, reportIfNaN, (, t, ,]
[:, case, Token, ., NE, :, case, Token, ., SHEQ, :, case, Token, ., SHNE, :, reportIfNaN, (, t, ,]
[Token, ., SHEQ, :, case, Token, ., SHNE, :, reportIfNaN, (, t, ,, n, ., getFirstChild, (, ), ), ;]
[SHEQ, :, case, Token, ., SHNE, :, reportIfNaN, (, t, ,, n, ., getFirstChild, (, ), ), ;, reportIfNaN, (]
[case, Token, ., SHNE, :, reportIfNaN, (, t, ,, n, ., getFirstChild, (, ), ), ;, reportIfNaN, (, t, ,]
[case, Token, ., SHNE, :, reportIfNaN, (, t, ,, n, ., getFirstChild, (, ), ), ;, reportIfNaN, (, t, ,]
[getLastChild, (, ), ), ;, }, }, private, void, reportIfNaN, (, NodeTraversal, t, ,, Node, n, ), {, if, (]
[getLastChild, (, ), ), ;, }, }, private, void, reportIfNaN, (, NodeTraversal, t, ,, Node, n, ), {, if, (]
[;, }, }, private, void, reportIfNaN, (, NodeTraversal, t, ,, Node, n, ), {, if, (, NodeUtil, ., isNaN, (]
[void, reportIfNaN, (, NodeTraversal, t, ,, Node, n, ), {, if, (, NodeUtil, ., isNaN, (, n, ), ), {]
[void, reportIfNaN, (, NodeTraversal, t, ,, Node, n, ), {, if, (, NodeUtil, ., isNaN, (, n, ), ), {]
[void, reportIfNaN, (, NodeTraversal, t, ,, Node, n, ), {, if, (, NodeUtil, ., isNaN, (, n, ), ), {]
[), {, if, (, NodeUtil, ., isNaN, (, n, ), ), {, t, ., getCompiler, (, ), ., report, (]
[), {, if, (, NodeUtil, ., isNaN, (, n, ), ), {, t, ., getCompiler, (, ), ., report, (]
[NodeUtil, ., isNaN, (, n, ), ), {, t, ., getCompiler, (, ), ., report, (, t, ., makeError, (]
[NodeUtil, ., isNaN, (, n, ), ), {, t, ., getCompiler, (, ), ., report, (, t, ., makeError, (]
[), {, t, ., getCompiler, (, ), ., report, (, t, ., makeError, (, n, ., getParent, (, ), ,]
