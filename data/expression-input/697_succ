[;, Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler]
[., checkNotNull, (, compiler, ), ;, Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;]
[), ;, Preconditions, ., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =]
[;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;]
[., checkNotNull, (, safeNameIdSupplier, ), ;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler, ;, this]
[), ;, Preconditions, ., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier]
[;, this, ., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;, this, ., knownConstants, =, constNames, ;, }]
[., checkNotNull, (, constNames, ), ;, this, ., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;, this, .]
[), ;, this, ., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;, this, ., knownConstants, =, constNames, ;]
[=, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;, this, ., knownConstants, =, constNames, ;, }, private, static, final, int]
[., compiler, =, compiler, ;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;, this, ., knownConstants, =, constNames, ;, }, private, static]
[;, this, ., safeNameIdSupplier, =, safeNameIdSupplier, ;, this, ., knownConstants, =, constNames, ;, }, private, static, final, int, MAX_INTERATIONS, =]
[=, safeNameIdSupplier, ;, this, ., knownConstants, =, constNames, ;, }, private, static, final, int, MAX_INTERATIONS, =, 100, ;, void, maybeExposeExpression]
[., safeNameIdSupplier, =, safeNameIdSupplier, ;, this, ., knownConstants, =, constNames, ;, }, private, static, final, int, MAX_INTERATIONS, =, 100, ;]
[;, this, ., knownConstants, =, constNames, ;, }, private, static, final, int, MAX_INTERATIONS, =, 100, ;, void, maybeExposeExpression, (, Node]
[=, constNames, ;, }, private, static, final, int, MAX_INTERATIONS, =, 100, ;, void, maybeExposeExpression, (, Node, expression, ), {, int]
[., knownConstants, =, constNames, ;, }, private, static, final, int, MAX_INTERATIONS, =, 100, ;, void, maybeExposeExpression, (, Node, expression, )]
[;, }, private, static, final, int, MAX_INTERATIONS, =, 100, ;, void, maybeExposeExpression, (, Node, expression, ), {, int, i, =]
[;, void, maybeExposeExpression, (, Node, expression, ), {, int, i, =, 0, ;, while, (, DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression]
[;, while, (, DecompositionType, ., DECOMPOSABLE, ==, canExposeExpression, (, expression, ), ), {, exposeExpression, (, expression, ), ;, i, ++]
[), {, exposeExpression, (, expression, ), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException]
[==, canExposeExpression, (, expression, ), ), {, exposeExpression, (, expression, ), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS]
[., DECOMPOSABLE, ==, canExposeExpression, (, expression, ), ), {, exposeExpression, (, expression, ), ;, i, ++, ;, if, (, i]
[), {, exposeExpression, (, expression, ), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException]
[), ), {, exposeExpression, (, expression, ), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new]
[;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +, expression, ., toStringTree]
[), ;, i, ++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +, expression, .]
[;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +, expression, ., toStringTree, (, ), )]
[++, ;, if, (, i, >, MAX_INTERATIONS, ), {, throw, new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +, expression, ., toStringTree, (, )]
[), {, throw, new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +, expression, ., toStringTree, (, ), ), ;, }, }, }, void, exposeExpression]
[>, MAX_INTERATIONS, ), {, throw, new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +, expression, ., toStringTree, (, ), ), ;, }, }, }]
[), {, throw, new, IllegalStateException, (, "DecomposeExpression depth exceeded on :\n", +, expression, ., toStringTree, (, ), ), ;, }, }, }, void, exposeExpression]
[;, }, }, }, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;, Preconditions]
[), ;, }, }, }, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;]
[+, expression, ., toStringTree, (, ), ), ;, }, }, }, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot]
[), ;, }, }, }, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot, (, expression, ), ;]
[., toStringTree, (, ), ), ;, }, }, }, void, exposeExpression, (, Node, expression, ), {, Node, expressionRoot, =, findExpressionRoot]
[;, Preconditions, ., checkState, (, expressionRoot, !=, null, ), ;, exposeExpression, (, expressionRoot, ,, expression, ), ;, compiler, ., reportCodeChange]
[), ;, Preconditions, ., checkState, (, expressionRoot, !=, null, ), ;, exposeExpression, (, expressionRoot, ,, expression, ), ;, compiler, .]
[;, exposeExpression, (, expressionRoot, ,, expression, ), ;, compiler, ., reportCodeChange, (, ), ;, }, void, moveExpression, (, Node, expression]
[., checkState, (, expressionRoot, !=, null, ), ;, exposeExpression, (, expressionRoot, ,, expression, ), ;, compiler, ., reportCodeChange, (, )]
[), ;, exposeExpression, (, expressionRoot, ,, expression, ), ;, compiler, ., reportCodeChange, (, ), ;, }, void, moveExpression, (, Node]
[!=, null, ), ;, exposeExpression, (, expressionRoot, ,, expression, ), ;, compiler, ., reportCodeChange, (, ), ;, }, void, moveExpression]
[), ;, exposeExpression, (, expressionRoot, ,, expression, ), ;, compiler, ., reportCodeChange, (, ), ;, }, void, moveExpression, (, Node]
[;, compiler, ., reportCodeChange, (, ), ;, }, void, moveExpression, (, Node, expression, ), {, String, resultName, =, getResultValueName, (]
[,, expression, ), ;, compiler, ., reportCodeChange, (, ), ;, }, void, moveExpression, (, Node, expression, ), {, String, resultName]
[), ;, compiler, ., reportCodeChange, (, ), ;, }, void, moveExpression, (, Node, expression, ), {, String, resultName, =, getResultValueName]
[;, }, void, moveExpression, (, Node, expression, ), {, String, resultName, =, getResultValueName, (, ), ;, Node, injectionPoint, =, findInjectionPoint]
[., reportCodeChange, (, ), ;, }, void, moveExpression, (, Node, expression, ), {, String, resultName, =, getResultValueName, (, ), ;]
[;, Node, injectionPoint, =, findInjectionPoint, (, expression, ), ;, Preconditions, ., checkNotNull, (, injectionPoint, ), ;, Node, injectionPointParent, =, injectionPoint]
[;, Preconditions, ., checkNotNull, (, injectionPoint, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, ., checkNotNull]
[), ;, Preconditions, ., checkNotNull, (, injectionPoint, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, .]
[;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, injectionPointParent, ), ;, Preconditions, ., checkState]
[., checkNotNull, (, injectionPoint, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, injectionPointParent]
[), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, Preconditions, ., checkNotNull, (, injectionPointParent, ), ;, Preconditions, .]
[;, Preconditions, ., checkNotNull, (, injectionPointParent, ), ;, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), ), ;]
[., getParent, (, ), ;, Preconditions, ., checkNotNull, (, injectionPointParent, ), ;, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (]
[;, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent, =, expression, ., getParent, (]
[., checkNotNull, (, injectionPointParent, ), ;, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent]
[), ;, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent, =, expression, ., getParent]
[;, Node, expressionParent, =, expression, ., getParent, (, ), ;, expressionParent, ., replaceChild, (, expression, ,, IR, ., name, (]
[., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent, =, expression, ., getParent, (, ), ;]
[), ;, Node, expressionParent, =, expression, ., getParent, (, ), ;, expressionParent, ., replaceChild, (, expression, ,, IR, ., name]
[., isStatementBlock, (, injectionPointParent, ), ), ;, Node, expressionParent, =, expression, ., getParent, (, ), ;, expressionParent, ., replaceChild, (]
[), ), ;, Node, expressionParent, =, expression, ., getParent, (, ), ;, expressionParent, ., replaceChild, (, expression, ,, IR, .]
[;, expressionParent, ., replaceChild, (, expression, ,, IR, ., name, (, resultName, ), ), ;, Node, newExpressionRoot, =, NodeUtil, .]
[., getParent, (, ), ;, expressionParent, ., replaceChild, (, expression, ,, IR, ., name, (, resultName, ), ), ;, Node]
[;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;, injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,, injectionPoint]
[., replaceChild, (, expression, ,, IR, ., name, (, resultName, ), ), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (]
[,, IR, ., name, (, resultName, ), ), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, )]
[), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;, injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,]
[., name, (, resultName, ), ), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;, injectionPointParent]
[), ), ;, Node, newExpressionRoot, =, NodeUtil, ., newVarNode, (, resultName, ,, expression, ), ;, injectionPointParent, ., addChildBefore, (, newExpressionRoot]
[;, injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,, injectionPoint, ), ;, compiler, ., reportCodeChange, (, ), ;, }, private, void, exposeExpression]
[., newVarNode, (, resultName, ,, expression, ), ;, injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,, injectionPoint, ), ;, compiler, ., reportCodeChange]
[,, expression, ), ;, injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,, injectionPoint, ), ;, compiler, ., reportCodeChange, (, ), ;, }]
[), ;, injectionPointParent, ., addChildBefore, (, newExpressionRoot, ,, injectionPoint, ), ;, compiler, ., reportCodeChange, (, ), ;, }, private, void]
[;, compiler, ., reportCodeChange, (, ), ;, }, private, void, exposeExpression, (, Node, expressionRoot, ,, Node, subExpression, ), {, Node]
[., addChildBefore, (, newExpressionRoot, ,, injectionPoint, ), ;, compiler, ., reportCodeChange, (, ), ;, }, private, void, exposeExpression, (, Node]
[,, injectionPoint, ), ;, compiler, ., reportCodeChange, (, ), ;, }, private, void, exposeExpression, (, Node, expressionRoot, ,, Node, subExpression]
[), ;, compiler, ., reportCodeChange, (, ), ;, }, private, void, exposeExpression, (, Node, expressionRoot, ,, Node, subExpression, ), {]
[;, }, private, void, exposeExpression, (, Node, expressionRoot, ,, Node, subExpression, ), {, Node, nonconditionalExpr, =, findNonconditionalParent, (, subExpression, ,]
[., reportCodeChange, (, ), ;, }, private, void, exposeExpression, (, Node, expressionRoot, ,, Node, subExpression, ), {, Node, nonconditionalExpr, =]
[;, boolean, hasFollowingSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, nonconditionalExpr, ,, compiler, ), ;, Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr, )]
[,, expressionRoot, ), ;, boolean, hasFollowingSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, nonconditionalExpr, ,, compiler, ), ;, Node, exprInjectionPoint, =, findInjectionPoint]
[), ;, boolean, hasFollowingSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, nonconditionalExpr, ,, compiler, ), ;, Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr]
[;, Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;, state, ., sideEffects]
[., mayHaveSideEffects, (, nonconditionalExpr, ,, compiler, ), ;, Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =, new]
[,, compiler, ), ;, Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;]
[), ;, Node, exprInjectionPoint, =, findInjectionPoint, (, nonconditionalExpr, ), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;, state, .]
[;, DecompositionState, state, =, new, DecompositionState, (, ), ;, state, ., sideEffects, =, hasFollowingSideEffects, ;, state, ., extractBeforeStatement, =, exprInjectionPoint]
[), ;, DecompositionState, state, =, new, DecompositionState, (, ), ;, state, ., sideEffects, =, hasFollowingSideEffects, ;, state, ., extractBeforeStatement, =]
[;, state, ., sideEffects, =, hasFollowingSideEffects, ;, state, ., extractBeforeStatement, =, exprInjectionPoint, ;, for, (, Node, grandchild, =, null, ,]
[=, hasFollowingSideEffects, ;, state, ., extractBeforeStatement, =, exprInjectionPoint, ;, for, (, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,]
[., sideEffects, =, hasFollowingSideEffects, ;, state, ., extractBeforeStatement, =, exprInjectionPoint, ;, for, (, Node, grandchild, =, null, ,, child, =]
[;, state, ., extractBeforeStatement, =, exprInjectionPoint, ;, for, (, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =]
[=, exprInjectionPoint, ;, for, (, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =, child, ., getParent, (]
[., extractBeforeStatement, =, exprInjectionPoint, ;, for, (, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =, child, .]
[;, for, (, Node, grandchild, =, null, ,, child, =, nonconditionalExpr, ,, parent, =, child, ., getParent, (, ), ;]
[,, child, =, nonconditionalExpr, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, grandchild, =, child]
[,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, grandchild, =, child, ,, child, =, parent]
[;, parent, !=, expressionRoot, ;, grandchild, =, child, ,, child, =, parent, ,, parent, =, child, ., getParent, (, )]
[., getParent, (, ), ;, parent, !=, expressionRoot, ;, grandchild, =, child, ,, child, =, parent, ,, parent, =, child]
[;, grandchild, =, child, ,, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, int, parentType]
[!=, expressionRoot, ;, grandchild, =, child, ,, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {]
[;, grandchild, =, child, ,, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, int, parentType]
[=, child, ,, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, int, parentType, =, parent]
[,, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, int, parentType, =, parent, ., getType]
[=, parent, ,, parent, =, child, ., getParent, (, ), ), {, int, parentType, =, parent, ., getType, (, )]
[,, parent, =, child, ., getParent, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, Preconditions]
[=, child, ., getParent, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState]
[), {, int, parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (, !, isConditionalOp, (, parent, )]
[., getParent, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, Preconditions, ., checkState, (, !]
[;, Preconditions, ., checkState, (, !, isConditionalOp, (, parent, ), ||, child, ==, parent, ., getFirstChild, (, ), ), ;]
[., getType, (, ), ;, Preconditions, ., checkState, (, !, isConditionalOp, (, parent, ), ||, child, ==, parent, ., getFirstChild]
[;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects, )]
[., checkState, (, !, isConditionalOp, (, parent, ), ||, child, ==, parent, ., getFirstChild, (, ), ), ;, if, (]
[), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects]
[||, child, ==, parent, ., getFirstChild, (, ), ), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if]
[||, child, ==, parent, ., getFirstChild, (, ), ), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if]
[), ||, child, ==, parent, ., getFirstChild, (, ), ), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {]
[), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects]
[==, parent, ., getFirstChild, (, ), ), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (, isSafeAssign]
[), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects]
[., getFirstChild, (, ), ), ;, if, (, parentType, ==, Token, ., ASSIGN, ), {, if, (, isSafeAssign, (, parent]
[), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects, ), ), {, }, else, {, Node, left, =]
[==, Token, ., ASSIGN, ), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects, ), ), {, }, else]
[), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects, ), ), {, }, else, {, Node, left, =]
[., ASSIGN, ), {, if, (, isSafeAssign, (, parent, ,, state, ., sideEffects, ), ), {, }, else, {, Node]
[), {, }, else, {, Node, left, =, parent, ., getFirstChild, (, ), ;, int, type, =, left, ., getType]
[,, state, ., sideEffects, ), ), {, }, else, {, Node, left, =, parent, ., getFirstChild, (, ), ;, int]
[), ), {, }, else, {, Node, left, =, parent, ., getFirstChild, (, ), ;, int, type, =, left, .]
[., sideEffects, ), ), {, }, else, {, Node, left, =, parent, ., getFirstChild, (, ), ;, int, type, =]
[;, int, type, =, left, ., getType, (, ), ;, if, (, left, !=, child, ), {, Preconditions, ., checkState]
[., getFirstChild, (, ), ;, int, type, =, left, ., getType, (, ), ;, if, (, left, !=, child, )]
[;, if, (, left, !=, child, ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;]
[., getType, (, ), ;, if, (, left, !=, child, ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (]
[), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;, if, (, type, ==, Token, .]
[!=, child, ), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;, if, (, type, ==]
[), {, Preconditions, ., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;, if, (, type, ==, Token, .]
[;, if, (, type, ==, Token, ., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,]
[., checkState, (, NodeUtil, ., isGet, (, left, ), ), ;, if, (, type, ==, Token, ., GETELEM, ), {]
[), ;, if, (, type, ==, Token, ., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null]
[., isGet, (, left, ), ), ;, if, (, type, ==, Token, ., GETELEM, ), {, decomposeSubExpressions, (, left, .]
[), ), ;, if, (, type, ==, Token, ., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,]
[), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,, state, ), ;, }, decomposeSubExpressions, (, left, .]
[==, Token, ., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,, state, ), ;, }]
[), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,, state, ), ;, }, decomposeSubExpressions, (, left, .]
[., GETELEM, ), {, decomposeSubExpressions, (, left, ., getLastChild, (, ), ,, null, ,, state, ), ;, }, decomposeSubExpressions, (]
[;, }, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null, ,, state, ), ;, }, }, }, else, if]
[,, null, ,, state, ), ;, }, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null, ,, state, ), ;]
[., getLastChild, (, ), ,, null, ,, state, ), ;, }, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null]
[,, state, ), ;, }, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null, ,, state, ), ;, }, }]
[), ;, }, decomposeSubExpressions, (, left, ., getFirstChild, (, ), ,, null, ,, state, ), ;, }, }, }, else]
[;, }, }, }, else, if, (, parentType, ==, Token, ., CALL, &&, NodeUtil, ., isGet, (, parent, ., getFirstChild]
[,, null, ,, state, ), ;, }, }, }, else, if, (, parentType, ==, Token, ., CALL, &&, NodeUtil, .]
[., getFirstChild, (, ), ,, null, ,, state, ), ;, }, }, }, else, if, (, parentType, ==, Token, .]
[,, state, ), ;, }, }, }, else, if, (, parentType, ==, Token, ., CALL, &&, NodeUtil, ., isGet, (]
[), ;, }, }, }, else, if, (, parentType, ==, Token, ., CALL, &&, NodeUtil, ., isGet, (, parent, .]
[), {, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child]
[&&, NodeUtil, ., isGet, (, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =, parent, ., getFirstChild, (]
[==, Token, ., CALL, &&, NodeUtil, ., isGet, (, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =]
[&&, NodeUtil, ., isGet, (, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =, parent, ., getFirstChild, (]
[., CALL, &&, NodeUtil, ., isGet, (, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =, parent, .]
[), {, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child]
[., isGet, (, parent, ., getFirstChild, (, ), ), ), {, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;]
[), ), {, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,]
[., getFirstChild, (, ), ), ), {, Node, functionExpression, =, parent, ., getFirstChild, (, ), ;, decomposeSubExpressions, (, functionExpression, .]
[;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,]
[., getFirstChild, (, ), ;, decomposeSubExpressions, (, functionExpression, ., getNext, (, ), ,, child, ,, state, ), ;, if, (]
[;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild, )]
[,, child, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild]
[., getNext, (, ), ,, child, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, )]
[,, state, ), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild, (, )]
[), ;, if, (, isExpressionTreeUnsafe, (, functionExpression, ,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild]
[), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true, ;, Node]
[&&, functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", )]
[,, state, ., sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing]
[), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed."]
[., sideEffects, ), &&, functionExpression, ., getFirstChild, (, ), !=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, )]
[), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true, ;, Node]
[!=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true]
[., getFirstChild, (, ), !=, grandchild, ), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state]
[), {, Preconditions, ., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true, ;, Node]
[;, state, ., sideEffects, =, true, ;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =, replacement]
[., checkState, (, allowObjectCallDecomposing, (, ), ,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true, ;, Node, replacement, =, rewriteCallExpression]
[,, "Object method calls can not be decomposed.", ), ;, state, ., sideEffects, =, true, ;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;]
[), ;, state, ., sideEffects, =, true, ;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =]
[=, true, ;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =, replacement, ;, }, }, else]
[., sideEffects, =, true, ;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =, replacement, ;, }]
[;, Node, replacement, =, rewriteCallExpression, (, parent, ,, state, ), ;, parent, =, replacement, ;, }, }, else, if, (]
[;, parent, =, replacement, ;, }, }, else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (, parent]
[,, state, ), ;, parent, =, replacement, ;, }, }, else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {]
[), ;, parent, =, replacement, ;, }, }, else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (]
[=, replacement, ;, }, }, else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild]
[;, }, }, else, if, (, parentType, ==, Token, ., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, )]
[), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, else, {, decomposeSubExpressions, (]
[==, Token, ., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }]
[), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, else, {, decomposeSubExpressions, (]
[., OBJECTLIT, ), {, decomposeObjectLiteralKeys, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, else, {]
[;, }, else, {, decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, }, if]
[,, child, ,, state, ), ;, }, else, {, decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,, child, ,, state]
[., getFirstChild, (, ), ,, child, ,, state, ), ;, }, else, {, decomposeSubExpressions, (, parent, ., getFirstChild, (, )]
[,, state, ), ;, }, else, {, decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;]
[), ;, }, else, {, decomposeSubExpressions, (, parent, ., getFirstChild, (, ), ,, child, ,, state, ), ;, }, }]
[;, }, }, if, (, nonconditionalExpr, ==, subExpression, ), {, }, else, {, Node, parent, =, nonconditionalExpr, ., getParent, (]
[,, child, ,, state, ), ;, }, }, if, (, nonconditionalExpr, ==, subExpression, ), {, }, else, {, Node, parent]
[., getFirstChild, (, ), ,, child, ,, state, ), ;, }, }, if, (, nonconditionalExpr, ==, subExpression, ), {, }]
[,, state, ), ;, }, }, if, (, nonconditionalExpr, ==, subExpression, ), {, }, else, {, Node, parent, =, nonconditionalExpr]
[), ;, }, }, if, (, nonconditionalExpr, ==, subExpression, ), {, }, else, {, Node, parent, =, nonconditionalExpr, ., getParent]
[), {, }, else, {, Node, parent, =, nonconditionalExpr, ., getParent, (, ), ;, boolean, needResult, =, !, parent, .]
[==, subExpression, ), {, }, else, {, Node, parent, =, nonconditionalExpr, ., getParent, (, ), ;, boolean, needResult, =, !]
[), {, }, else, {, Node, parent, =, nonconditionalExpr, ., getParent, (, ), ;, boolean, needResult, =, !, parent, .]
[;, boolean, needResult, =, !, parent, ., isExprResult, (, ), ;, Node, extractedConditional, =, extractConditional, (, nonconditionalExpr, ,, exprInjectionPoint, ,]
[., getParent, (, ), ;, boolean, needResult, =, !, parent, ., isExprResult, (, ), ;, Node, extractedConditional, =, extractConditional, (]
[;, Node, extractedConditional, =, extractConditional, (, nonconditionalExpr, ,, exprInjectionPoint, ,, needResult, ), ;, }, }, private, static, boolean, allowObjectCallDecomposing, (]
[;, Node, extractedConditional, =, extractConditional, (, nonconditionalExpr, ,, exprInjectionPoint, ,, needResult, ), ;, }, }, private, static, boolean, allowObjectCallDecomposing, (]
[., isExprResult, (, ), ;, Node, extractedConditional, =, extractConditional, (, nonconditionalExpr, ,, exprInjectionPoint, ,, needResult, ), ;, }, }, private]
[;, }, }, private, static, boolean, allowObjectCallDecomposing, (, ), {, return, false, ;, }, private, boolean, maybeExternMethod, (, Node, node]
[,, exprInjectionPoint, ,, needResult, ), ;, }, }, private, static, boolean, allowObjectCallDecomposing, (, ), {, return, false, ;, }, private]
[,, needResult, ), ;, }, }, private, static, boolean, allowObjectCallDecomposing, (, ), {, return, false, ;, }, private, boolean, maybeExternMethod]
[), ;, }, }, private, static, boolean, allowObjectCallDecomposing, (, ), {, return, false, ;, }, private, boolean, maybeExternMethod, (, Node]
[;, }, private, boolean, maybeExternMethod, (, Node, node, ), {, return, true, ;, }, private, static, Node, findNonconditionalParent, (, Node]
[;, }, private, static, Node, findNonconditionalParent, (, Node, subExpression, ,, Node, expressionRoot, ), {, Node, result, =, subExpression, ;, for]
[;, for, (, Node, child, =, subExpression, ,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;]
[,, parent, =, child, ., getParent, (, ), ;, parent, !=, expressionRoot, ;, child, =, parent, ,, parent, =, child]
[;, parent, !=, expressionRoot, ;, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, if, (]
[., getParent, (, ), ;, parent, !=, expressionRoot, ;, child, =, parent, ,, parent, =, child, ., getParent, (, )]
[;, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, )]
[!=, expressionRoot, ;, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (]
[;, child, =, parent, ,, parent, =, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, )]
[=, parent, ,, parent, =, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, ), ), {]
[,, parent, =, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, ), ), {, if, (]
[=, child, ., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=]
[), {, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=, parent, ., getFirstChild, (, ), )]
[., getParent, (, ), ), {, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=, parent, .]
[), {, if, (, child, !=, parent, ., getFirstChild, (, ), ), {, result, =, parent, ;, }, }, }]
[), ), {, if, (, child, !=, parent, ., getFirstChild, (, ), ), {, result, =, parent, ;, }, }]
[), {, result, =, parent, ;, }, }, }, return, result, ;, }, private, static, class, DecompositionState, {, boolean, sideEffects]
[!=, parent, ., getFirstChild, (, ), ), {, result, =, parent, ;, }, }, }, return, result, ;, }, private]
[), {, result, =, parent, ;, }, }, }, return, result, ;, }, private, static, class, DecompositionState, {, boolean, sideEffects]
[., getFirstChild, (, ), ), {, result, =, parent, ;, }, }, }, return, result, ;, }, private, static, class]
[=, parent, ;, }, }, }, return, result, ;, }, private, static, class, DecompositionState, {, boolean, sideEffects, ;, Node, extractBeforeStatement]
[;, }, }, }, return, result, ;, }, private, static, class, DecompositionState, {, boolean, sideEffects, ;, Node, extractBeforeStatement, ;, }]
[;, }, private, static, class, DecompositionState, {, boolean, sideEffects, ;, Node, extractBeforeStatement, ;, }, private, void, decomposeObjectLiteralKeys, (, Node, key]
[), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state, ), ;, decomposeSubExpressions, (]
[||, key, ==, stopNode, ), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state]
[==, null, ||, key, ==, stopNode, ), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode]
[||, key, ==, stopNode, ), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state]
[), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state, ), ;, decomposeSubExpressions, (]
[==, stopNode, ), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state, ), ;]
[), {, return, ;, }, decomposeObjectLiteralKeys, (, key, ., getNext, (, ), ,, stopNode, ,, state, ), ;, decomposeSubExpressions, (]
[;, decomposeSubExpressions, (, key, ., getFirstChild, (, ), ,, stopNode, ,, state, ), ;, }, private, void, decomposeSubExpressions, (, Node]
[,, stopNode, ,, state, ), ;, decomposeSubExpressions, (, key, ., getFirstChild, (, ), ,, stopNode, ,, state, ), ;, }]
[., getNext, (, ), ,, stopNode, ,, state, ), ;, decomposeSubExpressions, (, key, ., getFirstChild, (, ), ,, stopNode, ,]
[,, state, ), ;, decomposeSubExpressions, (, key, ., getFirstChild, (, ), ,, stopNode, ,, state, ), ;, }, private, void]
[), ;, decomposeSubExpressions, (, key, ., getFirstChild, (, ), ,, stopNode, ,, state, ), ;, }, private, void, decomposeSubExpressions, (]
[;, }, private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, n, ==]
[,, stopNode, ,, state, ), ;, }, private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, )]
[., getFirstChild, (, ), ,, stopNode, ,, state, ), ;, }, private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode]
[,, state, ), ;, }, private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if]
[), ;, }, private, void, decomposeSubExpressions, (, Node, n, ,, Node, stopNode, ,, DecompositionState, state, ), {, if, (, n]
[), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (]
[||, n, ==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,]
[==, null, ||, n, ==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (]
[||, n, ==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,]
[), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (]
[==, stopNode, ), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,, n, .]
[), {, return, ;, }, Preconditions, ., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (]
[;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n, ,]
[., checkState, (, !, NodeUtil, ., isObjectLitKey, (, n, ,, n, ., getParent, (, ), ), ), ;, decomposeSubExpressions, (]
[), ;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n]
[), ;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n]
[., isObjectLitKey, (, n, ,, n, ., getParent, (, ), ), ), ;, decomposeSubExpressions, (, n, ., getNext, (, )]
[,, n, ., getParent, (, ), ), ), ;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state]
[), ), ;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (]
[., getParent, (, ), ), ), ;, decomposeSubExpressions, (, n, ., getNext, (, ), ,, stopNode, ,, state, ), ;]
[;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {, state, ., sideEffects, =, true, ;, state]
[,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {, state, .]
[., getNext, (, ), ,, stopNode, ,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, )]
[,, state, ), ;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {, state, ., sideEffects, =]
[), ;, if, (, isExpressionTreeUnsafe, (, n, ,, state, ., sideEffects, ), ), {, state, ., sideEffects, =, true, ;]
[), {, state, ., sideEffects, =, true, ;, state, ., extractBeforeStatement, =, extractExpression, (, n, ,, state, ., extractBeforeStatement, )]
[,, state, ., sideEffects, ), ), {, state, ., sideEffects, =, true, ;, state, ., extractBeforeStatement, =, extractExpression, (, n]
[), ), {, state, ., sideEffects, =, true, ;, state, ., extractBeforeStatement, =, extractExpression, (, n, ,, state, ., extractBeforeStatement]
[., sideEffects, ), ), {, state, ., sideEffects, =, true, ;, state, ., extractBeforeStatement, =, extractExpression, (, n, ,, state]
[=, true, ;, state, ., extractBeforeStatement, =, extractExpression, (, n, ,, state, ., extractBeforeStatement, ), ;, }, }, private, Node]
[., sideEffects, =, true, ;, state, ., extractBeforeStatement, =, extractExpression, (, n, ,, state, ., extractBeforeStatement, ), ;, }, }]
[;, state, ., extractBeforeStatement, =, extractExpression, (, n, ,, state, ., extractBeforeStatement, ), ;, }, }, private, Node, extractConditional, (]
[=, extractExpression, (, n, ,, state, ., extractBeforeStatement, ), ;, }, }, private, Node, extractConditional, (, Node, expr, ,, Node]
[., extractBeforeStatement, =, extractExpression, (, n, ,, state, ., extractBeforeStatement, ), ;, }, }, private, Node, extractConditional, (, Node, expr]
[;, }, }, private, Node, extractConditional, (, Node, expr, ,, Node, injectionPoint, ,, boolean, needResult, ), {, Node, parent, =]
[,, state, ., extractBeforeStatement, ), ;, }, }, private, Node, extractConditional, (, Node, expr, ,, Node, injectionPoint, ,, boolean, needResult]
[), ;, }, }, private, Node, extractConditional, (, Node, expr, ,, Node, injectionPoint, ,, boolean, needResult, ), {, Node, parent]
[., extractBeforeStatement, ), ;, }, }, private, Node, extractConditional, (, Node, expr, ,, Node, injectionPoint, ,, boolean, needResult, ), {]
[;, String, tempName, =, getTempValueName, (, ), ;, Node, first, =, expr, ., getFirstChild, (, ), ;, Node, second, =]
[., getParent, (, ), ;, String, tempName, =, getTempValueName, (, ), ;, Node, first, =, expr, ., getFirstChild, (, )]
[;, Node, first, =, expr, ., getFirstChild, (, ), ;, Node, second, =, first, ., getNext, (, ), ;, Node]
[;, Node, second, =, first, ., getNext, (, ), ;, Node, last, =, expr, ., getLastChild, (, ), ;, expr]
[., getFirstChild, (, ), ;, Node, second, =, first, ., getNext, (, ), ;, Node, last, =, expr, ., getLastChild]
[;, Node, last, =, expr, ., getLastChild, (, ), ;, expr, ., detachChildren, (, ), ;, Node, cond, =, null]
[., getNext, (, ), ;, Node, last, =, expr, ., getLastChild, (, ), ;, expr, ., detachChildren, (, ), ;]
[;, expr, ., detachChildren, (, ), ;, Node, cond, =, null, ;, Node, trueExpr, =, IR, ., block, (, )]
[., getLastChild, (, ), ;, expr, ., detachChildren, (, ), ;, Node, cond, =, null, ;, Node, trueExpr, =, IR]
[;, Node, cond, =, null, ;, Node, trueExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;]
[., detachChildren, (, ), ;, Node, cond, =, null, ;, Node, trueExpr, =, IR, ., block, (, ), ., srcref]
[;, Node, trueExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;, Node, falseExpr, =, IR, .]
[;, Node, falseExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;, switch, (, expr, ., getType]
[., srcref, (, expr, ), ;, Node, falseExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;]
[., block, (, ), ., srcref, (, expr, ), ;, Node, falseExpr, =, IR, ., block, (, ), ., srcref]
[), ;, Node, falseExpr, =, IR, ., block, (, ), ., srcref, (, expr, ), ;, switch, (, expr, .]
[;, switch, (, expr, ., getType, (, ), ), {, case, Token, ., HOOK, :, cond, =, first, ;, trueExpr]
[., srcref, (, expr, ), ;, switch, (, expr, ., getType, (, ), ), {, case, Token, ., HOOK, :]
[., block, (, ), ., srcref, (, expr, ), ;, switch, (, expr, ., getType, (, ), ), {, case]
[), ;, switch, (, expr, ., getType, (, ), ), {, case, Token, ., HOOK, :, cond, =, first, ;]
[), {, case, Token, ., HOOK, :, cond, =, first, ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression]
[., getType, (, ), ), {, case, Token, ., HOOK, :, cond, =, first, ;, trueExpr, ., addChildToFront, (, NodeUtil]
[:, cond, =, first, ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName]
[., HOOK, :, cond, =, first, ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult]
[=, first, ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), )]
[;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), ), ), ;]
[;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;]
[., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), ), ), ;, falseExpr, .]
[), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), )]
[., newExpr, (, buildResultExpression, (, second, ,, needResult, ,, tempName, ), ), ), ;, falseExpr, ., addChildToFront, (, NodeUtil, .]
[), ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), )]
[,, needResult, ,, tempName, ), ), ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,]
[,, tempName, ), ), ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,]
[), ), ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, )]
[;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, trueExpr]
[., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;]
[), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;]
[., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., AND]
[), ), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, )]
[,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first]
[,, tempName, ), ), ), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult]
[), ), ), ;, break, ;, case, Token, ., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName]
[:, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (]
[., AND, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (, NodeUtil, .]
[=, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (]
[;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;]
[,, needResult, ,, tempName, ), ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,]
[,, tempName, ), ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, )]
[), ;, trueExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), )]
[;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, falseExpr]
[., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;]
[), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;]
[., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., OR]
[), ), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, )]
[,, needResult, ,, tempName, ), ), ), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first]
[,, tempName, ), ), ), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult]
[), ), ), ;, break, ;, case, Token, ., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName]
[:, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (]
[., OR, :, cond, =, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (, NodeUtil, .]
[=, buildResultExpression, (, first, ,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (]
[;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;]
[,, needResult, ,, tempName, ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,]
[,, tempName, ), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, )]
[), ;, falseExpr, ., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), )]
[;, break, ;, default, :, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode, ;, if, (, falseExpr, .]
[., addChildToFront, (, NodeUtil, ., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;]
[), ;, break, ;, default, :, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode, ;, if, (, falseExpr]
[., newExpr, (, buildResultExpression, (, last, ,, needResult, ,, tempName, ), ), ), ;, break, ;, default, :, throw, new]
[), ), ;, break, ;, default, :, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode, ;, if, (]
[,, needResult, ,, tempName, ), ), ), ;, break, ;, default, :, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }]
[,, tempName, ), ), ), ;, break, ;, default, :, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode]
[), ), ), ;, break, ;, default, :, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, Node, ifNode, ;, if]
[;, }, Node, ifNode, ;, if, (, falseExpr, ., hasChildren, (, ), ), {, ifNode, =, IR, ., ifNode, (]
[), ;, }, Node, ifNode, ;, if, (, falseExpr, ., hasChildren, (, ), ), {, ifNode, =, IR, ., ifNode]
[), {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =]
[., hasChildren, (, ), ), {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ,, falseExpr, ), ;, }]
[=, IR, ., ifNode, (, cond, ,, trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =, IR, ., ifNode]
[;, }, else, {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom, (]
[., ifNode, (, cond, ,, trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =, IR, ., ifNode, (, cond]
[,, trueExpr, ,, falseExpr, ), ;, }, else, {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ), ;]
[,, falseExpr, ), ;, }, else, {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ), ;, }, ifNode]
[), ;, }, else, {, ifNode, =, IR, ., ifNode, (, cond, ,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom]
[=, IR, ., ifNode, (, cond, ,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (]
[;, }, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (, needResult, ), {, Node, tempVarNode, =, NodeUtil, ., newVarNode]
[., ifNode, (, cond, ,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (, needResult, )]
[,, trueExpr, ), ;, }, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (, needResult, ), {, Node, tempVarNode, =]
[), ;, }, ifNode, ., copyInformationFrom, (, expr, ), ;, if, (, needResult, ), {, Node, tempVarNode, =, NodeUtil, .]
[;, if, (, needResult, ), {, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, null, ), ., copyInformationFromForTree, (]
[., copyInformationFrom, (, expr, ), ;, if, (, needResult, ), {, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,]
[), ;, if, (, needResult, ), {, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, null, ), ., copyInformationFromForTree]
[), {, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, null, ), ., copyInformationFromForTree, (, expr, ), ;, Node]
[;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, injectionPointParent]
[., copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode]
[., newVarNode, (, tempName, ,, null, ), ., copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (]
[,, null, ), ., copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, .]
[), ., copyInformationFromForTree, (, expr, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (]
[), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;]
[;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node]
[., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, injectionPointParent, ., addChildAfter, (, ifNode, ,]
[;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ;]
[., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =]
[,, injectionPoint, ), ;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (]
[), ;, injectionPointParent, ., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, )]
[;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ;, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;]
[., addChildAfter, (, ifNode, ,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ;, parent, .]
[,, tempVarNode, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ;, parent, ., replaceChild, (, expr, ,]
[), ;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ;, parent, ., replaceChild, (, expr, ,, replacementValueNode, )]
[;, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, }, else, {, Preconditions, ., checkArgument, (, parent, ., isExprResult]
[., name, (, tempName, ), ;, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, }, else, {, Preconditions, .]
[), ;, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, }, else, {, Preconditions, ., checkArgument, (, parent, .]
[;, }, else, {, Preconditions, ., checkArgument, (, parent, ., isExprResult, (, ), ), ;, Node, gramps, =, parent, .]
[., replaceChild, (, expr, ,, replacementValueNode, ), ;, }, else, {, Preconditions, ., checkArgument, (, parent, ., isExprResult, (, )]
[,, replacementValueNode, ), ;, }, else, {, Preconditions, ., checkArgument, (, parent, ., isExprResult, (, ), ), ;, Node, gramps]
[), ;, }, else, {, Preconditions, ., checkArgument, (, parent, ., isExprResult, (, ), ), ;, Node, gramps, =, parent]
[;, Node, gramps, =, parent, ., getParent, (, ), ;, gramps, ., replaceChild, (, parent, ,, ifNode, ), ;, }]
[., checkArgument, (, parent, ., isExprResult, (, ), ), ;, Node, gramps, =, parent, ., getParent, (, ), ;, gramps]
[), ;, Node, gramps, =, parent, ., getParent, (, ), ;, gramps, ., replaceChild, (, parent, ,, ifNode, ), ;]
[., isExprResult, (, ), ), ;, Node, gramps, =, parent, ., getParent, (, ), ;, gramps, ., replaceChild, (, parent]
[;, gramps, ., replaceChild, (, parent, ,, ifNode, ), ;, }, return, ifNode, ;, }, private, static, Node, buildResultExpression, (]
[., getParent, (, ), ;, gramps, ., replaceChild, (, parent, ,, ifNode, ), ;, }, return, ifNode, ;, }, private]
[;, }, return, ifNode, ;, }, private, static, Node, buildResultExpression, (, Node, expr, ,, boolean, needResult, ,, String, tempName, )]
[., replaceChild, (, parent, ,, ifNode, ), ;, }, return, ifNode, ;, }, private, static, Node, buildResultExpression, (, Node, expr]
[,, ifNode, ), ;, }, return, ifNode, ;, }, private, static, Node, buildResultExpression, (, Node, expr, ,, boolean, needResult, ,]
[), ;, }, return, ifNode, ;, }, private, static, Node, buildResultExpression, (, Node, expr, ,, boolean, needResult, ,, String, tempName]
[;, }, private, static, Node, buildResultExpression, (, Node, expr, ,, boolean, needResult, ,, String, tempName, ), {, if, (, needResult]
[), {, return, IR, ., assign, (, IR, ., name, (, tempName, ), ,, expr, ), ., srcrefTree, (, expr]
[;, }, else, {, return, expr, ;, }, }, private, boolean, isConstantName, (, Node, n, ,, Set, <, String, >]
[., srcrefTree, (, expr, ), ;, }, else, {, return, expr, ;, }, }, private, boolean, isConstantName, (, Node, n]
[., assign, (, IR, ., name, (, tempName, ), ,, expr, ), ., srcrefTree, (, expr, ), ;, }, else]
[,, expr, ), ., srcrefTree, (, expr, ), ;, }, else, {, return, expr, ;, }, }, private, boolean, isConstantName]
[., name, (, tempName, ), ,, expr, ), ., srcrefTree, (, expr, ), ;, }, else, {, return, expr, ;]
[), ,, expr, ), ., srcrefTree, (, expr, ), ;, }, else, {, return, expr, ;, }, }, private, boolean]
[), ., srcrefTree, (, expr, ), ;, }, else, {, return, expr, ;, }, }, private, boolean, isConstantName, (, Node]
[), ;, }, else, {, return, expr, ;, }, }, private, boolean, isConstantName, (, Node, n, ,, Set, <, String]
[;, }, }, private, boolean, isConstantName, (, Node, n, ,, Set, <, String, >, knownConstants, ), {, return, n, .]
[;, }, private, Node, extractExpression, (, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =, expr, ., getParent, (]
[&&, (, NodeUtil, ., isConstantName, (, n, ), ||, knownConstants, ., contains, (, n, ., getString, (, ), ), )]
[., isName, (, ), &&, (, NodeUtil, ., isConstantName, (, n, ), ||, knownConstants, ., contains, (, n, ., getString]
[;, }, private, Node, extractExpression, (, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =, expr, ., getParent, (]
[), ;, }, private, Node, extractExpression, (, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =, expr, ., getParent]
[||, knownConstants, ., contains, (, n, ., getString, (, ), ), ), ;, }, private, Node, extractExpression, (, Node, expr]
[., isConstantName, (, n, ), ||, knownConstants, ., contains, (, n, ., getString, (, ), ), ), ;, }, private]
[), ||, knownConstants, ., contains, (, n, ., getString, (, ), ), ), ;, }, private, Node, extractExpression, (, Node]
[), ;, }, private, Node, extractExpression, (, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =, expr, ., getParent]
[., contains, (, n, ., getString, (, ), ), ), ;, }, private, Node, extractExpression, (, Node, expr, ,, Node]
[), ), ;, }, private, Node, extractExpression, (, Node, expr, ,, Node, injectionPoint, ), {, Node, parent, =, expr, .]
[., getString, (, ), ), ), ;, }, private, Node, extractExpression, (, Node, expr, ,, Node, injectionPoint, ), {, Node]
[;, boolean, isLhsOfAssignOp, =, NodeUtil, ., isAssignmentOp, (, parent, ), &&, !, parent, ., isAssign, (, ), &&, parent, .]
[., getParent, (, ), ;, boolean, isLhsOfAssignOp, =, NodeUtil, ., isAssignmentOp, (, parent, ), &&, !, parent, ., isAssign, (]
[;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, ., isGet, (, expr, ), ), {, for, (]
[&&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, .]
[&&, !, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null]
[., isAssignmentOp, (, parent, ), &&, !, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, expr]
[), &&, !, parent, ., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =]
[&&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, .]
[&&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, .]
[., isAssign, (, ), &&, parent, ., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (]
[;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, ., isGet, (, expr, ), ), {, for, (]
[==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, ., isGet, (, expr, ), ), {]
[., getFirstChild, (, ), ==, expr, ;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, ., isGet, (]
[;, Node, firstExtractedNode, =, null, ;, if, (, isLhsOfAssignOp, &&, NodeUtil, ., isGet, (, expr, ), ), {, for, (]
[;, if, (, isLhsOfAssignOp, &&, NodeUtil, ., isGet, (, expr, ), ), {, for, (, Node, n, :, expr, .]
[), {, for, (, Node, n, :, expr, ., children, (, ), ), {, if, (, !, n, ., isString]
[&&, NodeUtil, ., isGet, (, expr, ), ), {, for, (, Node, n, :, expr, ., children, (, ), )]
[), {, for, (, Node, n, :, expr, ., children, (, ), ), {, if, (, !, n, ., isString]
[., isGet, (, expr, ), ), {, for, (, Node, n, :, expr, ., children, (, ), ), {, if]
[), ), {, for, (, Node, n, :, expr, ., children, (, ), ), {, if, (, !, n, .]
[), {, if, (, !, n, ., isString, (, ), &&, !, isConstantName, (, n, ,, knownConstants, ), ), {]
[., children, (, ), ), {, if, (, !, n, ., isString, (, ), &&, !, isConstantName, (, n, ,]
[), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode]
[&&, !, isConstantName, (, n, ,, knownConstants, ), ), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;]
[&&, !, isConstantName, (, n, ,, knownConstants, ), ), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;]
[., isString, (, ), &&, !, isConstantName, (, n, ,, knownConstants, ), ), {, Node, extractedNode, =, extractExpression, (, n]
[), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode]
[), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode]
[,, knownConstants, ), ), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null]
[), ), {, Node, extractedNode, =, extractExpression, (, n, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {]
[;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String, tempName, =, getTempConstantValueName]
[,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String]
[), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String, tempName, =]
[), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String, tempName, =, getTempConstantValueName, (, ), ;, Node, replacementValueNode, =]
[==, null, ), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String, tempName, =, getTempConstantValueName, (, ), ;, Node]
[), {, firstExtractedNode, =, extractedNode, ;, }, }, }, }, String, tempName, =, getTempConstantValueName, (, ), ;, Node, replacementValueNode, =]
[=, extractedNode, ;, }, }, }, }, String, tempName, =, getTempConstantValueName, (, ), ;, Node, replacementValueNode, =, IR, ., name]
[;, }, }, }, }, String, tempName, =, getTempConstantValueName, (, ), ;, Node, replacementValueNode, =, IR, ., name, (, tempName]
[;, Node, replacementValueNode, =, IR, ., name, (, tempName, ), ., srcref, (, expr, ), ;, Node, tempNameValue, ;, if]
[;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (, expr, ., isName, (, ), ||, NodeUtil]
[., srcref, (, expr, ), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (, expr, .]
[., name, (, tempName, ), ., srcref, (, expr, ), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions]
[), ., srcref, (, expr, ), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (, expr]
[), ;, Node, tempNameValue, ;, if, (, isLhsOfAssignOp, ), {, Preconditions, ., checkState, (, expr, ., isName, (, ), ||]
[), {, Preconditions, ., checkState, (, expr, ., isName, (, ), ||, NodeUtil, ., isGet, (, expr, ), ), ;]
[;, Node, opNode, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent, ), ;]
[., checkState, (, expr, ., isName, (, ), ||, NodeUtil, ., isGet, (, expr, ), ), ;, Node, opNode, =]
[), ;, Node, opNode, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent, )]
[||, NodeUtil, ., isGet, (, expr, ), ), ;, Node, opNode, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent]
[., isName, (, ), ||, NodeUtil, ., isGet, (, expr, ), ), ;, Node, opNode, =, new, Node, (, NodeUtil]
[), ;, Node, opNode, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent, )]
[., isGet, (, expr, ), ), ;, Node, opNode, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), )]
[), ), ;, Node, opNode, =, new, Node, (, NodeUtil, ., getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent]
[;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;, parent, ., setType, (, Token, ., ASSIGN, ), ;, parent]
[., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;, parent, ., setType, (, Token]
[), ., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;, parent, ., setType, (]
[., getOpFromAssignmentOp, (, parent, ), ), ., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =, parent, ., getLastChild, (, )]
[), ), ., copyInformationFrom, (, parent, ), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;, parent, ., setType]
[), ;, Node, rightOperand, =, parent, ., getLastChild, (, ), ;, parent, ., setType, (, Token, ., ASSIGN, ), ;]
[;, parent, ., setType, (, Token, ., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode]
[., getLastChild, (, ), ;, parent, ., setType, (, Token, ., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,]
[;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack]
[., setType, (, Token, ., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront]
[), ;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, .]
[., ASSIGN, ), ;, parent, ., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;]
[;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =, expr, ., cloneTree]
[., replaceChild, (, rightOperand, ,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack, (, rightOperand]
[,, opNode, ), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =]
[), ;, opNode, ., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =, expr, .]
[;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {, parent]
[., addChildToFront, (, replacementValueNode, ), ;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =, expr, ., cloneTree, (, )]
[), ;, opNode, ., addChildToBack, (, rightOperand, ), ;, tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {]
[;, tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {, parent, ., replaceChild, (, expr, ,, replacementValueNode, )]
[., addChildToBack, (, rightOperand, ), ;, tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {, parent, ., replaceChild]
[), ;, tempNameValue, =, expr, ., cloneTree, (, ), ;, }, else, {, parent, ., replaceChild, (, expr, ,, replacementValueNode]
[=, expr, ., cloneTree, (, ), ;, }, else, {, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, tempNameValue]
[;, }, else, {, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, tempNameValue, =, expr, ;, }, Node, tempVarNode]
[., cloneTree, (, ), ;, }, else, {, parent, ., replaceChild, (, expr, ,, replacementValueNode, ), ;, tempNameValue, =, expr]
[;, tempNameValue, =, expr, ;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, ), ;, Node, injectionPointParent]
[., replaceChild, (, expr, ,, replacementValueNode, ), ;, tempNameValue, =, expr, ;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (]
[,, replacementValueNode, ), ;, tempNameValue, =, expr, ;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, )]
[), ;, tempNameValue, =, expr, ;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, ), ;, Node]
[=, expr, ;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, ), ;, Node, injectionPointParent, =, injectionPoint]
[;, }, Node, tempVarNode, =, NodeUtil, ., newVarNode, (, tempName, ,, tempNameValue, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent]
[;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if]
[., newVarNode, (, tempName, ,, tempNameValue, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore]
[,, tempNameValue, ), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint]
[), ;, Node, injectionPointParent, =, injectionPoint, ., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;]
[;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, tempVarNode]
[., getParent, (, ), ;, injectionPointParent, ., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, )]
[;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, tempVarNode, ;, }, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression]
[., addChildBefore, (, tempVarNode, ,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, tempVarNode, ;, }]
[,, injectionPoint, ), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, tempVarNode, ;, }, return, firstExtractedNode, ;, }]
[), ;, if, (, firstExtractedNode, ==, null, ), {, firstExtractedNode, =, tempVarNode, ;, }, return, firstExtractedNode, ;, }, private, Node]
[), {, firstExtractedNode, =, tempVarNode, ;, }, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression, (, Node, call, ,, DecompositionState, state]
[==, null, ), {, firstExtractedNode, =, tempVarNode, ;, }, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression, (, Node, call, ,]
[), {, firstExtractedNode, =, tempVarNode, ;, }, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression, (, Node, call, ,, DecompositionState, state]
[=, tempVarNode, ;, }, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression, (, Node, call, ,, DecompositionState, state, ), {, Preconditions]
[;, }, return, firstExtractedNode, ;, }, private, Node, rewriteCallExpression, (, Node, call, ,, DecompositionState, state, ), {, Preconditions, ., checkArgument]
[;, }, private, Node, rewriteCallExpression, (, Node, call, ,, DecompositionState, state, ), {, Preconditions, ., checkArgument, (, call, ., isCall]
[;, Node, first, =, call, ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, first, )]
[., checkArgument, (, call, ., isCall, (, ), ), ;, Node, first, =, call, ., getFirstChild, (, ), ;, Preconditions]
[), ;, Node, first, =, call, ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, first]
[., isCall, (, ), ), ;, Node, first, =, call, ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil]
[;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, first, ), ), ;, Node, getVarNode, =, extractExpression, (, first, ,]
[., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, first, ), ), ;, Node, getVarNode, =]
[;, Node, getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, getVarNode, ;, Node]
[., checkArgument, (, NodeUtil, ., isGet, (, first, ), ), ;, Node, getVarNode, =, extractExpression, (, first, ,, state, .]
[), ;, Node, getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, getVarNode, ;]
[., isGet, (, first, ), ), ;, Node, getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;, state]
[), ), ;, Node, getVarNode, =, extractExpression, (, first, ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, getVarNode]
[;, state, ., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, ), ;]
[,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, )]
[), ;, state, ., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, )]
[., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild]
[=, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (]
[., extractBeforeStatement, =, getVarNode, ;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, Preconditions, .]
[;, Node, getExprNode, =, getVarNode, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, .]
[;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, getExprNode, ), ), ;, Node, thisVarNode, =, extractExpression, (, getExprNode, .]
[., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, getExprNode, ), ), ;, Node, thisVarNode, =]
[., getFirstChild, (, ), ., getFirstChild, (, ), ;, Preconditions, ., checkArgument, (, NodeUtil, ., isGet, (, getExprNode, ), )]
[;, Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (, ), ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement]
[., checkArgument, (, NodeUtil, ., isGet, (, getExprNode, ), ), ;, Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (]
[), ;, Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (, ), ,, state, ., extractBeforeStatement, ), ;, state, .]
[., isGet, (, getExprNode, ), ), ;, Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (, ), ,, state, .]
[), ), ;, Node, thisVarNode, =, extractExpression, (, getExprNode, ., getFirstChild, (, ), ,, state, ., extractBeforeStatement, ), ;, state]
[;, state, ., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode]
[,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =, thisVarNode, ., getFirstChild, (, )]
[., getFirstChild, (, ), ,, state, ., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =, thisVarNode]
[), ;, state, ., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =]
[., extractBeforeStatement, ), ;, state, ., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node]
[=, thisVarNode, ;, Node, thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode, ., getFirstChild, (, )]
[., extractBeforeStatement, =, thisVarNode, ;, Node, thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode, ., getFirstChild]
[;, Node, thisNameNode, =, thisVarNode, ., getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node]
[;, Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node, newCall, =, IR, ., call, (, IR, ., getprop]
[., getFirstChild, (, ), ;, Node, functionNameNode, =, getVarNode, ., getFirstChild, (, ), ;, Node, newCall, =, IR, ., call]
[;, Node, newCall, =, IR, ., call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,, IR, .]
[., getFirstChild, (, ), ;, Node, newCall, =, IR, ., call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (]
[;, call, ., removeFirstChild, (, ), ;, if, (, call, ., hasChildren, (, ), ), {, newCall, ., addChildrenToBack, (]
[., srcref, (, call, ), ;, call, ., removeFirstChild, (, ), ;, if, (, call, ., hasChildren, (, ), )]
[., call, (, IR, ., getprop, (, functionNameNode, ., cloneNode, (, ), ,, IR, ., string, (, "call", ), )]
[,, thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, ), ;, call, ., removeFirstChild, (, ), ;, if]
[., getprop, (, functionNameNode, ., cloneNode, (, ), ,, IR, ., string, (, "call", ), ), ,, thisNameNode, ., cloneNode]
[,, IR, ., string, (, "call", ), ), ,, thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, )]
[., cloneNode, (, ), ,, IR, ., string, (, "call", ), ), ,, thisNameNode, ., cloneNode, (, ), ), .]
[), ,, thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, ), ;, call, ., removeFirstChild, (, ), ;]
[., string, (, "call", ), ), ,, thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, ), ;, call]
[), ), ,, thisNameNode, ., cloneNode, (, ), ), ., srcref, (, call, ), ;, call, ., removeFirstChild, (, )]
[), ., srcref, (, call, ), ;, call, ., removeFirstChild, (, ), ;, if, (, call, ., hasChildren, (, )]
[., cloneNode, (, ), ), ., srcref, (, call, ), ;, call, ., removeFirstChild, (, ), ;, if, (, call]
[), ;, call, ., removeFirstChild, (, ), ;, if, (, call, ., hasChildren, (, ), ), {, newCall, ., addChildrenToBack]
[;, if, (, call, ., hasChildren, (, ), ), {, newCall, ., addChildrenToBack, (, call, ., removeChildren, (, ), )]
[., removeFirstChild, (, ), ;, if, (, call, ., hasChildren, (, ), ), {, newCall, ., addChildrenToBack, (, call, .]
[), {, newCall, ., addChildrenToBack, (, call, ., removeChildren, (, ), ), ;, }, Node, callParent, =, call, ., getParent]
[., hasChildren, (, ), ), {, newCall, ., addChildrenToBack, (, call, ., removeChildren, (, ), ), ;, }, Node, callParent]
[;, }, Node, callParent, =, call, ., getParent, (, ), ;, callParent, ., replaceChild, (, call, ,, newCall, ), ;]
[., addChildrenToBack, (, call, ., removeChildren, (, ), ), ;, }, Node, callParent, =, call, ., getParent, (, ), ;]
[), ;, }, Node, callParent, =, call, ., getParent, (, ), ;, callParent, ., replaceChild, (, call, ,, newCall, )]
[., removeChildren, (, ), ), ;, }, Node, callParent, =, call, ., getParent, (, ), ;, callParent, ., replaceChild, (]
[;, callParent, ., replaceChild, (, call, ,, newCall, ), ;, return, newCall, ;, }, private, String, tempNamePrefix, =, "JSCompiler_temp", ;]
[., getParent, (, ), ;, callParent, ., replaceChild, (, call, ,, newCall, ), ;, return, newCall, ;, }, private, String]
[;, return, newCall, ;, }, private, String, tempNamePrefix, =, "JSCompiler_temp", ;, private, String, resultNamePrefix, =, "JSCompiler_inline_result", ;, @, VisibleForTesting, public]
[., replaceChild, (, call, ,, newCall, ), ;, return, newCall, ;, }, private, String, tempNamePrefix, =, "JSCompiler_temp", ;, private, String]
[,, newCall, ), ;, return, newCall, ;, }, private, String, tempNamePrefix, =, "JSCompiler_temp", ;, private, String, resultNamePrefix, =, "JSCompiler_inline_result", ;]
[), ;, return, newCall, ;, }, private, String, tempNamePrefix, =, "JSCompiler_temp", ;, private, String, resultNamePrefix, =, "JSCompiler_inline_result", ;, @, VisibleForTesting]
[;, }, private, String, tempNamePrefix, =, "JSCompiler_temp", ;, private, String, resultNamePrefix, =, "JSCompiler_inline_result", ;, @, VisibleForTesting, public, void, setTempNamePrefix, (]
[;, private, String, resultNamePrefix, =, "JSCompiler_inline_result", ;, @, VisibleForTesting, public, void, setTempNamePrefix, (, String, prefix, ), {, this, ., tempNamePrefix]
[;, @, VisibleForTesting, public, void, setTempNamePrefix, (, String, prefix, ), {, this, ., tempNamePrefix, =, prefix, ;, }, private, String]
[=, prefix, ;, }, private, String, getTempValueName, (, ), {, return, tempNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get]
[., tempNamePrefix, =, prefix, ;, }, private, String, getTempValueName, (, ), {, return, tempNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier]
[;, }, private, String, getTempValueName, (, ), {, return, tempNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, )]
[;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix, ), {, this, ., resultNamePrefix, =, prefix, ;, }, private]
[+, safeNameIdSupplier, ., get, (, ), ;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix, ), {, this, .]
[+, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix]
[+, safeNameIdSupplier, ., get, (, ), ;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix, ), {, this, .]
[., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix, ), {]
[;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix, ), {, this, ., resultNamePrefix, =, prefix, ;, }, private]
[., get, (, ), ;, }, @, VisibleForTesting, public, void, setResultNamePrefix, (, String, prefix, ), {, this, ., resultNamePrefix, =]
[=, prefix, ;, }, private, String, getResultValueName, (, ), {, return, resultNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get]
[., resultNamePrefix, =, prefix, ;, }, private, String, getResultValueName, (, ), {, return, resultNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier]
[;, }, private, String, getResultValueName, (, ), {, return, resultNamePrefix, +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, )]
[;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier]
[+, safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +, "_const"]
[+, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name]
[+, safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +, "_const"]
[., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix]
[;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier]
[., get, (, ), ;, }, private, String, getTempConstantValueName, (, ), {, String, name, =, tempNamePrefix, +, "_const", +, ContextualRenamer]
[;, this, ., knownConstants, ., add, (, name, ), ;, return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression]
[+, safeNameIdSupplier, ., get, (, ), ;, this, ., knownConstants, ., add, (, name, ), ;, return, name, ;, }]
[+, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, this, ., knownConstants, ., add, (, name, ), ;]
[+, "_const", +, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, this, ., knownConstants, ., add, (, name]
[+, ContextualRenamer, ., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, this, ., knownConstants, ., add, (, name, ), ;]
[+, safeNameIdSupplier, ., get, (, ), ;, this, ., knownConstants, ., add, (, name, ), ;, return, name, ;, }]
[., UNIQUE_ID_SEPARATOR, +, safeNameIdSupplier, ., get, (, ), ;, this, ., knownConstants, ., add, (, name, ), ;, return, name]
[;, this, ., knownConstants, ., add, (, name, ), ;, return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression]
[., get, (, ), ;, this, ., knownConstants, ., add, (, name, ), ;, return, name, ;, }, static, Node]
[;, return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, )]
[., add, (, name, ), ;, return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression, ), {, Node, expressionRoot]
[., knownConstants, ., add, (, name, ), ;, return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression, ), {]
[), ;, return, name, ;, }, static, Node, findInjectionPoint, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression]
[;, }, static, Node, findInjectionPoint, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, Preconditions, .]
[;, Preconditions, ., checkNotNull, (, expressionRoot, ), ;, Node, injectionPoint, =, expressionRoot, ;, Node, parent, =, injectionPoint, ., getParent, (]
[), ;, Preconditions, ., checkNotNull, (, expressionRoot, ), ;, Node, injectionPoint, =, expressionRoot, ;, Node, parent, =, injectionPoint, ., getParent]
[;, Node, injectionPoint, =, expressionRoot, ;, Node, parent, =, injectionPoint, ., getParent, (, ), ;, while, (, parent, ., isLabel]
[., checkNotNull, (, expressionRoot, ), ;, Node, injectionPoint, =, expressionRoot, ;, Node, parent, =, injectionPoint, ., getParent, (, ), ;]
[), ;, Node, injectionPoint, =, expressionRoot, ;, Node, parent, =, injectionPoint, ., getParent, (, ), ;, while, (, parent, .]
[;, Node, parent, =, injectionPoint, ., getParent, (, ), ;, while, (, parent, ., isLabel, (, ), ), {, injectionPoint]
[;, while, (, parent, ., isLabel, (, ), ), {, injectionPoint, =, parent, ;, parent, =, injectionPoint, ., getParent, (]
[., getParent, (, ), ;, while, (, parent, ., isLabel, (, ), ), {, injectionPoint, =, parent, ;, parent, =]
[), {, injectionPoint, =, parent, ;, parent, =, injectionPoint, ., getParent, (, ), ;, }, Preconditions, ., checkState, (, NodeUtil]
[., isLabel, (, ), ), {, injectionPoint, =, parent, ;, parent, =, injectionPoint, ., getParent, (, ), ;, }, Preconditions]
[=, parent, ;, parent, =, injectionPoint, ., getParent, (, ), ;, }, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (]
[;, parent, =, injectionPoint, ., getParent, (, ), ;, }, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPoint, .]
[=, injectionPoint, ., getParent, (, ), ;, }, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPoint, ., getParent, (]
[;, }, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPoint, ., getParent, (, ), ), ), ;, return, injectionPoint]
[., getParent, (, ), ;, }, Preconditions, ., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPoint, ., getParent, (, ), )]
[;, return, injectionPoint, ;, }, private, static, boolean, isConditionalOp, (, Node, n, ), {, switch, (, n, ., getType, (]
[., checkState, (, NodeUtil, ., isStatementBlock, (, injectionPoint, ., getParent, (, ), ), ), ;, return, injectionPoint, ;, }, private]
[), ;, return, injectionPoint, ;, }, private, static, boolean, isConditionalOp, (, Node, n, ), {, switch, (, n, ., getType]
[., isStatementBlock, (, injectionPoint, ., getParent, (, ), ), ), ;, return, injectionPoint, ;, }, private, static, boolean, isConditionalOp, (]
[), ), ;, return, injectionPoint, ;, }, private, static, boolean, isConditionalOp, (, Node, n, ), {, switch, (, n, .]
[., getParent, (, ), ), ), ;, return, injectionPoint, ;, }, private, static, boolean, isConditionalOp, (, Node, n, ), {]
[;, }, private, static, boolean, isConditionalOp, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {]
[), {, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, true, ;]
[., getType, (, ), ), {, case, Token, ., HOOK, :, case, Token, ., AND, :, case, Token, ., OR]
[:, case, Token, ., AND, :, case, Token, ., OR, :, return, true, ;, default, :, return, false, ;, }]
[., HOOK, :, case, Token, ., AND, :, case, Token, ., OR, :, return, true, ;, default, :, return, false]
[:, case, Token, ., OR, :, return, true, ;, default, :, return, false, ;, }, }, static, Node, findExpressionRoot, (]
[., AND, :, case, Token, ., OR, :, return, true, ;, default, :, return, false, ;, }, }, static, Node]
[:, return, true, ;, default, :, return, false, ;, }, }, static, Node, findExpressionRoot, (, Node, subExpression, ), {, Node]
[., OR, :, return, true, ;, default, :, return, false, ;, }, }, static, Node, findExpressionRoot, (, Node, subExpression, )]
[;, default, :, return, false, ;, }, }, static, Node, findExpressionRoot, (, Node, subExpression, ), {, Node, child, =, subExpression]
[;, }, }, static, Node, findExpressionRoot, (, Node, subExpression, ), {, Node, child, =, subExpression, ;, for, (, Node, parent]
[;, for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, int, parentType, =, parent, ., getType, (]
[), {, int, parentType, =, parent, ., getType, (, ), ;, switch, (, parentType, ), {, case, Token, ., EXPR_RESULT]
[., getAncestors, (, ), ), {, int, parentType, =, parent, ., getType, (, ), ;, switch, (, parentType, ), {]
[;, switch, (, parentType, ), {, case, Token, ., EXPR_RESULT, :, case, Token, ., IF, :, case, Token, ., SWITCH]
[., getType, (, ), ;, switch, (, parentType, ), {, case, Token, ., EXPR_RESULT, :, case, Token, ., IF, :]
[), {, case, Token, ., EXPR_RESULT, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, .]
[:, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR]
[., EXPR_RESULT, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token]
[:, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR, :, Preconditions, ., checkState, (]
[., IF, :, case, Token, ., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR, :, Preconditions, .]
[:, case, Token, ., RETURN, :, case, Token, ., VAR, :, Preconditions, ., checkState, (, child, ==, parent, ., getFirstChild]
[., SWITCH, :, case, Token, ., RETURN, :, case, Token, ., VAR, :, Preconditions, ., checkState, (, child, ==, parent]
[:, case, Token, ., VAR, :, Preconditions, ., checkState, (, child, ==, parent, ., getFirstChild, (, ), ), ;, return]
[., RETURN, :, case, Token, ., VAR, :, Preconditions, ., checkState, (, child, ==, parent, ., getFirstChild, (, ), )]
[:, Preconditions, ., checkState, (, child, ==, parent, ., getFirstChild, (, ), ), ;, return, parent, ;, case, Token, .]
[., VAR, :, Preconditions, ., checkState, (, child, ==, parent, ., getFirstChild, (, ), ), ;, return, parent, ;, case]
[;, return, parent, ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, case]
[., checkState, (, child, ==, parent, ., getFirstChild, (, ), ), ;, return, parent, ;, case, Token, ., SCRIPT, :]
[), ;, return, parent, ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :]
[==, parent, ., getFirstChild, (, ), ), ;, return, parent, ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK]
[), ;, return, parent, ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :]
[., getFirstChild, (, ), ), ;, return, parent, ;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case]
[;, case, Token, ., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, case, Token, ., CASE]
[:, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE]
[., SCRIPT, :, case, Token, ., BLOCK, :, case, Token, ., LABEL, :, case, Token, ., CASE, :, case, Token]
[:, case, Token, ., LABEL, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, null, ;, }]
[., BLOCK, :, case, Token, ., LABEL, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, null]
[:, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, null, ;, }, child, =, parent, ;, }]
[., LABEL, :, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, return, null, ;, }, child, =, parent]
[:, case, Token, ., DEFAULT_CASE, :, return, null, ;, }, child, =, parent, ;, }, throw, new, IllegalStateException, (, "Unexpected AST structure."]
[., CASE, :, case, Token, ., DEFAULT_CASE, :, return, null, ;, }, child, =, parent, ;, }, throw, new, IllegalStateException]
[:, return, null, ;, }, child, =, parent, ;, }, throw, new, IllegalStateException, (, "Unexpected AST structure.", ), ;, }, DecompositionType, canExposeExpression]
[., DEFAULT_CASE, :, return, null, ;, }, child, =, parent, ;, }, throw, new, IllegalStateException, (, "Unexpected AST structure.", ), ;, }]
[;, }, child, =, parent, ;, }, throw, new, IllegalStateException, (, "Unexpected AST structure.", ), ;, }, DecompositionType, canExposeExpression, (, Node, subExpression]
[=, parent, ;, }, throw, new, IllegalStateException, (, "Unexpected AST structure.", ), ;, }, DecompositionType, canExposeExpression, (, Node, subExpression, ), {, Node]
[;, }, throw, new, IllegalStateException, (, "Unexpected AST structure.", ), ;, }, DecompositionType, canExposeExpression, (, Node, subExpression, ), {, Node, expressionRoot, =]
[;, }, DecompositionType, canExposeExpression, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, if, (, expressionRoot]
[), ;, }, DecompositionType, canExposeExpression, (, Node, subExpression, ), {, Node, expressionRoot, =, findExpressionRoot, (, subExpression, ), ;, if, (]
[;, if, (, expressionRoot, !=, null, ), {, return, isSubexpressionMovable, (, expressionRoot, ,, subExpression, ), ;, }, return, DecompositionType, .]
[), ;, if, (, expressionRoot, !=, null, ), {, return, isSubexpressionMovable, (, expressionRoot, ,, subExpression, ), ;, }, return, DecompositionType]
[), {, return, isSubexpressionMovable, (, expressionRoot, ,, subExpression, ), ;, }, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, private, DecompositionType, isSubexpressionMovable]
[!=, null, ), {, return, isSubexpressionMovable, (, expressionRoot, ,, subExpression, ), ;, }, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, private]
[), {, return, isSubexpressionMovable, (, expressionRoot, ,, subExpression, ), ;, }, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, private, DecompositionType, isSubexpressionMovable]
[;, }, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, private, DecompositionType, isSubexpressionMovable, (, Node, expressionRoot, ,, Node, subExpression, ), {, boolean]
[,, subExpression, ), ;, }, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, private, DecompositionType, isSubexpressionMovable, (, Node, expressionRoot, ,, Node, subExpression]
[), ;, }, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, private, DecompositionType, isSubexpressionMovable, (, Node, expressionRoot, ,, Node, subExpression, ), {]
[;, }, private, DecompositionType, isSubexpressionMovable, (, Node, expressionRoot, ,, Node, subExpression, ), {, boolean, requiresDecomposition, =, false, ;, boolean, seenSideEffects]
[., UNDECOMPOSABLE, ;, }, private, DecompositionType, isSubexpressionMovable, (, Node, expressionRoot, ,, Node, subExpression, ), {, boolean, requiresDecomposition, =, false, ;]
[;, boolean, seenSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, subExpression, ,, compiler, ), ;, Node, child, =, subExpression, ;, for, (]
[;, Node, child, =, subExpression, ;, for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, if, (]
[., mayHaveSideEffects, (, subExpression, ,, compiler, ), ;, Node, child, =, subExpression, ;, for, (, Node, parent, :, child, .]
[,, compiler, ), ;, Node, child, =, subExpression, ;, for, (, Node, parent, :, child, ., getAncestors, (, ), )]
[), ;, Node, child, =, subExpression, ;, for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, if]
[;, for, (, Node, parent, :, child, ., getAncestors, (, ), ), {, if, (, parent, ==, expressionRoot, ), {]
[), {, if, (, parent, ==, expressionRoot, ), {, return, requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;]
[., getAncestors, (, ), ), {, if, (, parent, ==, expressionRoot, ), {, return, requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :]
[), {, return, requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;, }, int, parentType, =, parent, ., getType]
[==, expressionRoot, ), {, return, requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;, }, int, parentType, =, parent]
[), {, return, requiresDecomposition, ?, DecompositionType, ., DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;, }, int, parentType, =, parent, ., getType]
[;, }, int, parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp, (, parent, ), ), {, if]
[?, DecompositionType, ., DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;, }, int, parentType, =, parent, ., getType, (, ), ;, if]
[:, DecompositionType, ., MOVABLE, ;, }, int, parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp, (, parent]
[., DECOMPOSABLE, :, DecompositionType, ., MOVABLE, ;, }, int, parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp]
[;, }, int, parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp, (, parent, ), ), {, if]
[., MOVABLE, ;, }, int, parentType, =, parent, ., getType, (, ), ;, if, (, isConditionalOp, (, parent, ), )]
[;, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=, parent, ., getFirstChild, (, ), ), {]
[., getType, (, ), ;, if, (, isConditionalOp, (, parent, ), ), {, if, (, child, !=, parent, ., getFirstChild]
[), {, if, (, child, !=, parent, ., getFirstChild, (, ), ), {, requiresDecomposition, =, true, ;, }, }, else]
[), ), {, if, (, child, !=, parent, ., getFirstChild, (, ), ), {, requiresDecomposition, =, true, ;, }, }]
[), {, requiresDecomposition, =, true, ;, }, }, else, {, if, (, isSafeAssign, (, parent, ,, seenSideEffects, ), ), {]
[!=, parent, ., getFirstChild, (, ), ), {, requiresDecomposition, =, true, ;, }, }, else, {, if, (, isSafeAssign, (]
[), {, requiresDecomposition, =, true, ;, }, }, else, {, if, (, isSafeAssign, (, parent, ,, seenSideEffects, ), ), {]
[., getFirstChild, (, ), ), {, requiresDecomposition, =, true, ;, }, }, else, {, if, (, isSafeAssign, (, parent, ,]
[=, true, ;, }, }, else, {, if, (, isSafeAssign, (, parent, ,, seenSideEffects, ), ), {, }, else, {]
[;, }, }, else, {, if, (, isSafeAssign, (, parent, ,, seenSideEffects, ), ), {, }, else, {, for, (]
[), {, }, else, {, for, (, Node, n, :, parent, ., children, (, ), ), {, if, (, n]
[,, seenSideEffects, ), ), {, }, else, {, for, (, Node, n, :, parent, ., children, (, ), ), {]
[), ), {, }, else, {, for, (, Node, n, :, parent, ., children, (, ), ), {, if, (]
[), {, if, (, n, ==, child, ), {, break, ;, }, if, (, isExpressionTreeUnsafe, (, n, ,, seenSideEffects, )]
[., children, (, ), ), {, if, (, n, ==, child, ), {, break, ;, }, if, (, isExpressionTreeUnsafe, (]
[), {, break, ;, }, if, (, isExpressionTreeUnsafe, (, n, ,, seenSideEffects, ), ), {, seenSideEffects, =, true, ;, requiresDecomposition]
[==, child, ), {, break, ;, }, if, (, isExpressionTreeUnsafe, (, n, ,, seenSideEffects, ), ), {, seenSideEffects, =, true]
[), {, break, ;, }, if, (, isExpressionTreeUnsafe, (, n, ,, seenSideEffects, ), ), {, seenSideEffects, =, true, ;, requiresDecomposition]
[), {, seenSideEffects, =, true, ;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (, )]
[,, seenSideEffects, ), ), {, seenSideEffects, =, true, ;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, .]
[), ), {, seenSideEffects, =, true, ;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (]
[=, true, ;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (]
[;, requiresDecomposition, =, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (, requiresDecomposition, &&]
[=, true, ;, }, }, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (, requiresDecomposition, &&, parent, .]
[;, }, }, Node, first, =, parent, ., getFirstChild, (, ), ;, if, (, requiresDecomposition, &&, parent, ., isCall, (]
[;, if, (, requiresDecomposition, &&, parent, ., isCall, (, ), &&, NodeUtil, ., isGet, (, first, ), ), {, if]
[., getFirstChild, (, ), ;, if, (, requiresDecomposition, &&, parent, ., isCall, (, ), &&, NodeUtil, ., isGet, (, first]
[), {, if, (, maybeExternMethod, (, first, ), ), {, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, else, {, return, DecompositionType]
[&&, NodeUtil, ., isGet, (, first, ), ), {, if, (, maybeExternMethod, (, first, ), ), {, return, DecompositionType, .]
[&&, parent, ., isCall, (, ), &&, NodeUtil, ., isGet, (, first, ), ), {, if, (, maybeExternMethod, (, first]
[&&, NodeUtil, ., isGet, (, first, ), ), {, if, (, maybeExternMethod, (, first, ), ), {, return, DecompositionType, .]
[., isCall, (, ), &&, NodeUtil, ., isGet, (, first, ), ), {, if, (, maybeExternMethod, (, first, ), )]
[), {, if, (, maybeExternMethod, (, first, ), ), {, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, else, {, return, DecompositionType]
[., isGet, (, first, ), ), {, if, (, maybeExternMethod, (, first, ), ), {, return, DecompositionType, ., UNDECOMPOSABLE, ;]
[), ), {, if, (, maybeExternMethod, (, first, ), ), {, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, else, {, return]
[), {, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, else, {, return, DecompositionType, ., DECOMPOSABLE, ;, }, }, }, }, child]
[), ), {, return, DecompositionType, ., UNDECOMPOSABLE, ;, }, else, {, return, DecompositionType, ., DECOMPOSABLE, ;, }, }, }, }]
[;, }, else, {, return, DecompositionType, ., DECOMPOSABLE, ;, }, }, }, }, child, =, parent, ;, }, throw, new]
[., UNDECOMPOSABLE, ;, }, else, {, return, DecompositionType, ., DECOMPOSABLE, ;, }, }, }, }, child, =, parent, ;, }]
[;, }, }, }, }, child, =, parent, ;, }, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, private, boolean]
[., DECOMPOSABLE, ;, }, }, }, }, child, =, parent, ;, }, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }]
[=, parent, ;, }, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, private, boolean, isSafeAssign, (, Node, n, ,, boolean]
[;, }, throw, new, IllegalStateException, (, "Unexpected.", ), ;, }, private, boolean, isSafeAssign, (, Node, n, ,, boolean, seenSideEffects, )]
[;, }, private, boolean, isSafeAssign, (, Node, n, ,, boolean, seenSideEffects, ), {, if, (, n, ., isAssign, (, )]
[), ;, }, private, boolean, isSafeAssign, (, Node, n, ,, boolean, seenSideEffects, ), {, if, (, n, ., isAssign, (]
[), {, Node, lhs, =, n, ., getFirstChild, (, ), ;, switch, (, lhs, ., getType, (, ), ), {]
[., isAssign, (, ), ), {, Node, lhs, =, n, ., getFirstChild, (, ), ;, switch, (, lhs, ., getType]
[;, switch, (, lhs, ., getType, (, ), ), {, case, Token, ., NAME, :, return, true, ;, case, Token]
[., getFirstChild, (, ), ;, switch, (, lhs, ., getType, (, ), ), {, case, Token, ., NAME, :, return]
[), {, case, Token, ., NAME, :, return, true, ;, case, Token, ., GETPROP, :, return, !, isExpressionTreeUnsafe, (, lhs]
[., getType, (, ), ), {, case, Token, ., NAME, :, return, true, ;, case, Token, ., GETPROP, :, return]
[:, return, true, ;, case, Token, ., GETPROP, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects]
[., NAME, :, return, true, ;, case, Token, ., GETPROP, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, )]
[;, case, Token, ., GETPROP, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case]
[:, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case, Token, ., GETELEM, :, return]
[., GETPROP, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), ;, case, Token, ., GETELEM]
[;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&, !]
[;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&, !]
[,, seenSideEffects, ), ;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects]
[., getFirstChild, (, ), ,, seenSideEffects, ), ;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild]
[), ;, case, Token, ., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&]
[:, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&, !, isExpressionTreeUnsafe, (, lhs, ., getLastChild]
[., GETELEM, :, return, !, isExpressionTreeUnsafe, (, lhs, ., getFirstChild, (, ), ,, seenSideEffects, ), &&, !, isExpressionTreeUnsafe, (, lhs]
[;, }, }, return, false, ;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (]
[&&, !, isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,, seenSideEffects, ), ;, }, }, return, false, ;, }, private]
[&&, !, isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,, seenSideEffects, ), ;, }, }, return, false, ;, }, private]
[,, seenSideEffects, ), &&, !, isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,, seenSideEffects, ), ;, }, }, return, false]
[., getFirstChild, (, ), ,, seenSideEffects, ), &&, !, isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,, seenSideEffects, ), ;]
[), &&, !, isExpressionTreeUnsafe, (, lhs, ., getLastChild, (, ), ,, seenSideEffects, ), ;, }, }, return, false, ;, }]
[;, }, }, return, false, ;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (]
[;, }, }, return, false, ;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (]
[,, seenSideEffects, ), ;, }, }, return, false, ;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, )]
[., getLastChild, (, ), ,, seenSideEffects, ), ;, }, }, return, false, ;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n]
[), ;, }, }, return, false, ;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, ), {, if]
[;, }, private, boolean, isExpressionTreeUnsafe, (, Node, n, ,, boolean, followingSideEffectsExist, ), {, if, (, followingSideEffectsExist, ), {, return, NodeUtil]
[), {, return, NodeUtil, ., canBeSideEffected, (, n, ,, this, ., knownConstants, ), ;, }, else, {, return, NodeUtil, .]
[;, }, else, {, return, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ;, }, }, }]
[., canBeSideEffected, (, n, ,, this, ., knownConstants, ), ;, }, else, {, return, NodeUtil, ., mayHaveSideEffects, (, n, ,]
[,, this, ., knownConstants, ), ;, }, else, {, return, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ;, }]
[), ;, }, else, {, return, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ;, }, }, }]
[., knownConstants, ), ;, }, else, {, return, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ;, }, }, }]
[;, }, }, }]
[., mayHaveSideEffects, (, n, ,, compiler, ), ;, }, }, }]
[,, compiler, ), ;, }, }, }]
[), ;, }, }, }]
