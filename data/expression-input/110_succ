[), {, fuseIntoOneStatement, (, n, ), ;, reportCodeChange, (, ), ;, }, return, n, ;, }, private, boolean, canFuseIntoOneStatement, (]
[&&, canFuseIntoOneStatement, (, n, ), ), {, fuseIntoOneStatement, (, n, ), ;, reportCodeChange, (, ), ;, }, return, n, ;]
[&&, canFuseIntoOneStatement, (, n, ), ), {, fuseIntoOneStatement, (, n, ), ;, reportCodeChange, (, ), ;, }, return, n, ;]
[., isFunction, (, ), &&, canFuseIntoOneStatement, (, n, ), ), {, fuseIntoOneStatement, (, n, ), ;, reportCodeChange, (, ), ;]
[., getParent, (, ), ., isFunction, (, ), &&, canFuseIntoOneStatement, (, n, ), ), {, fuseIntoOneStatement, (, n, ), ;]
[), {, fuseIntoOneStatement, (, n, ), ;, reportCodeChange, (, ), ;, }, return, n, ;, }, private, boolean, canFuseIntoOneStatement, (]
[), ), {, fuseIntoOneStatement, (, n, ), ;, reportCodeChange, (, ), ;, }, return, n, ;, }, private, boolean, canFuseIntoOneStatement]
[;, reportCodeChange, (, ), ;, }, return, n, ;, }, private, boolean, canFuseIntoOneStatement, (, Node, block, ), {, if, (]
[), ;, reportCodeChange, (, ), ;, }, return, n, ;, }, private, boolean, canFuseIntoOneStatement, (, Node, block, ), {, if]
[;, }, return, n, ;, }, private, boolean, canFuseIntoOneStatement, (, Node, block, ), {, if, (, !, block, ., isBlock]
[;, }, private, boolean, canFuseIntoOneStatement, (, Node, block, ), {, if, (, !, block, ., isBlock, (, ), ), {]
[), {, return, false, ;, }, if, (, !, block, ., hasChildren, (, ), ||, block, ., hasOneChild, (, )]
[), {, return, false, ;, }, if, (, !, block, ., hasChildren, (, ), ||, block, ., hasOneChild, (, )]
[., isBlock, (, ), ), {, return, false, ;, }, if, (, !, block, ., hasChildren, (, ), ||, block]
[;, }, if, (, !, block, ., hasChildren, (, ), ||, block, ., hasOneChild, (, ), ), {, return, false]
[), {, return, false, ;, }, Node, last, =, block, ., getLastChild, (, ), ;, for, (, Node, c, =]
[||, block, ., hasOneChild, (, ), ), {, return, false, ;, }, Node, last, =, block, ., getLastChild, (, )]
[||, block, ., hasOneChild, (, ), ), {, return, false, ;, }, Node, last, =, block, ., getLastChild, (, )]
[., hasChildren, (, ), ||, block, ., hasOneChild, (, ), ), {, return, false, ;, }, Node, last, =, block]
[), {, return, false, ;, }, Node, last, =, block, ., getLastChild, (, ), ;, for, (, Node, c, =]
[., hasOneChild, (, ), ), {, return, false, ;, }, Node, last, =, block, ., getLastChild, (, ), ;, for]
[;, }, Node, last, =, block, ., getLastChild, (, ), ;, for, (, Node, c, =, block, ., getFirstChild, (]
[;, for, (, Node, c, =, block, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, .]
[., getLastChild, (, ), ;, for, (, Node, c, =, block, ., getFirstChild, (, ), ;, c, !=, null, ;]
[;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !, c, ., isExprResult]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, !, c, ., isExprResult, (, ), &&, c]
[!=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !, c, ., isExprResult, (, )]
[;, c, =, c, ., getNext, (, ), ), {, if, (, !, c, ., isExprResult, (, ), &&, c]
[=, c, ., getNext, (, ), ), {, if, (, !, c, ., isExprResult, (, ), &&, c, !=, last]
[), {, if, (, !, c, ., isExprResult, (, ), &&, c, !=, last, ), {, return, false, ;, }]
[., getNext, (, ), ), {, if, (, !, c, ., isExprResult, (, ), &&, c, !=, last, ), {]
[), {, return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF]
[&&, c, !=, last, ), {, return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {]
[&&, c, !=, last, ), {, return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {]
[., isExprResult, (, ), &&, c, !=, last, ), {, return, false, ;, }, }, switch, (, last, ., getType]
[), {, return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF]
[!=, last, ), {, return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {, case, Token]
[), {, return, false, ;, }, }, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF]
[;, }, }, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, .]
[), {, case, Token, ., IF, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., THROW, :, case, Token, ., SWITCH]
[:, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, return, true, ;, case]
[., IF, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, return, true]
[:, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, return, true, ;, case, Token, ., RETURN, :, return]
[., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, return, true, ;, case, Token, ., RETURN]
[:, case, Token, ., EXPR_RESULT, :, return, true, ;, case, Token, ., RETURN, :, return, last, ., hasChildren, (, )]
[., SWITCH, :, case, Token, ., EXPR_RESULT, :, return, true, ;, case, Token, ., RETURN, :, return, last, ., hasChildren]
[:, return, true, ;, case, Token, ., RETURN, :, return, last, ., hasChildren, (, ), ;, case, Token, ., FOR]
[., EXPR_RESULT, :, return, true, ;, case, Token, ., RETURN, :, return, last, ., hasChildren, (, ), ;, case, Token]
[;, case, Token, ., RETURN, :, return, last, ., hasChildren, (, ), ;, case, Token, ., FOR, :, return, NodeUtil]
[:, return, last, ., hasChildren, (, ), ;, case, Token, ., FOR, :, return, NodeUtil, ., isForIn, (, last, )]
[., RETURN, :, return, last, ., hasChildren, (, ), ;, case, Token, ., FOR, :, return, NodeUtil, ., isForIn, (]
[;, case, Token, ., FOR, :, return, NodeUtil, ., isForIn, (, last, ), &&, !, mayHaveSideEffects, (, last, ., getFirstChild]
[., hasChildren, (, ), ;, case, Token, ., FOR, :, return, NodeUtil, ., isForIn, (, last, ), &&, !, mayHaveSideEffects]
[:, return, NodeUtil, ., isForIn, (, last, ), &&, !, mayHaveSideEffects, (, last, ., getFirstChild, (, ), ), ;, }]
[., FOR, :, return, NodeUtil, ., isForIn, (, last, ), &&, !, mayHaveSideEffects, (, last, ., getFirstChild, (, ), )]
[;, }, return, false, ;, }, private, void, fuseIntoOneStatement, (, Node, block, ), {, Node, cur, =, block, ., removeFirstChild]
[&&, !, mayHaveSideEffects, (, last, ., getFirstChild, (, ), ), ;, }, return, false, ;, }, private, void, fuseIntoOneStatement, (]
[., isForIn, (, last, ), &&, !, mayHaveSideEffects, (, last, ., getFirstChild, (, ), ), ;, }, return, false, ;]
[), &&, !, mayHaveSideEffects, (, last, ., getFirstChild, (, ), ), ;, }, return, false, ;, }, private, void, fuseIntoOneStatement]
[;, }, return, false, ;, }, private, void, fuseIntoOneStatement, (, Node, block, ), {, Node, cur, =, block, ., removeFirstChild]
[;, }, return, false, ;, }, private, void, fuseIntoOneStatement, (, Node, block, ), {, Node, cur, =, block, ., removeFirstChild]
[), ;, }, return, false, ;, }, private, void, fuseIntoOneStatement, (, Node, block, ), {, Node, cur, =, block, .]
[., getFirstChild, (, ), ), ;, }, return, false, ;, }, private, void, fuseIntoOneStatement, (, Node, block, ), {, Node]
[;, }, private, void, fuseIntoOneStatement, (, Node, block, ), {, Node, cur, =, block, ., removeFirstChild, (, ), ;, Node]
[;, Node, commaTree, =, cur, ., removeFirstChild, (, ), ;, while, (, block, ., hasMoreThanOneChild, (, ), ), {, Node]
[., removeFirstChild, (, ), ;, Node, commaTree, =, cur, ., removeFirstChild, (, ), ;, while, (, block, ., hasMoreThanOneChild, (]
[;, while, (, block, ., hasMoreThanOneChild, (, ), ), {, Node, next, =, block, ., removeFirstChild, (, ), ., removeFirstChild]
[., removeFirstChild, (, ), ;, while, (, block, ., hasMoreThanOneChild, (, ), ), {, Node, next, =, block, ., removeFirstChild]
[), {, Node, next, =, block, ., removeFirstChild, (, ), ., removeFirstChild, (, ), ;, commaTree, =, fuseExpressionIntoExpression, (, commaTree]
[., hasMoreThanOneChild, (, ), ), {, Node, next, =, block, ., removeFirstChild, (, ), ., removeFirstChild, (, ), ;, commaTree]
[;, commaTree, =, fuseExpressionIntoExpression, (, commaTree, ,, next, ), ;, }, Preconditions, ., checkState, (, block, ., hasOneChild, (, )]
[., removeFirstChild, (, ), ;, commaTree, =, fuseExpressionIntoExpression, (, commaTree, ,, next, ), ;, }, Preconditions, ., checkState, (, block]
[., removeFirstChild, (, ), ., removeFirstChild, (, ), ;, commaTree, =, fuseExpressionIntoExpression, (, commaTree, ,, next, ), ;, }, Preconditions]
[=, fuseExpressionIntoExpression, (, commaTree, ,, next, ), ;, }, Preconditions, ., checkState, (, block, ., hasOneChild, (, ), ), ;]
[;, }, Preconditions, ., checkState, (, block, ., hasOneChild, (, ), ), ;, Node, last, =, block, ., getLastChild, (]
[,, next, ), ;, }, Preconditions, ., checkState, (, block, ., hasOneChild, (, ), ), ;, Node, last, =, block]
[), ;, }, Preconditions, ., checkState, (, block, ., hasOneChild, (, ), ), ;, Node, last, =, block, ., getLastChild]
[;, Node, last, =, block, ., getLastChild, (, ), ;, switch, (, last, ., getType, (, ), ), {, case]
[., checkState, (, block, ., hasOneChild, (, ), ), ;, Node, last, =, block, ., getLastChild, (, ), ;, switch]
[), ;, Node, last, =, block, ., getLastChild, (, ), ;, switch, (, last, ., getType, (, ), ), {]
[., hasOneChild, (, ), ), ;, Node, last, =, block, ., getLastChild, (, ), ;, switch, (, last, ., getType]
[;, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., RETURN, :]
[., getLastChild, (, ), ;, switch, (, last, ., getType, (, ), ), {, case, Token, ., IF, :, case]
[), {, case, Token, ., IF, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, case, Token, .]
[., getType, (, ), ), {, case, Token, ., IF, :, case, Token, ., RETURN, :, case, Token, ., THROW]
[:, case, Token, ., RETURN, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT]
[., IF, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token]
[:, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,]
[., RETURN, :, case, Token, ., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (]
[:, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;]
[., THROW, :, case, Token, ., SWITCH, :, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;]
[:, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;, case, Token, ., FOR, :]
[., SWITCH, :, case, Token, ., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;, case, Token, .]
[:, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn]
[., EXPR_RESULT, :, fuseExpresssonIntoFirstChild, (, commaTree, ,, last, ), ;, return, ;, case, Token, ., FOR, :, if, (, NodeUtil]
[;, return, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, last, ), ), {, fuseExpresssonIntoSecondChild, (]
[,, last, ), ;, return, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, last, ), )]
[), ;, return, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, last, ), ), {, fuseExpresssonIntoSecondChild]
[:, if, (, NodeUtil, ., isForIn, (, last, ), ), {, fuseExpresssonIntoSecondChild, (, commaTree, ,, last, ), ;, }, return]
[., FOR, :, if, (, NodeUtil, ., isForIn, (, last, ), ), {, fuseExpresssonIntoSecondChild, (, commaTree, ,, last, ), ;]
[), {, fuseExpresssonIntoSecondChild, (, commaTree, ,, last, ), ;, }, return, ;, default, :, throw, new, IllegalStateException, (, "Statement fusion missing.", )]
[., isForIn, (, last, ), ), {, fuseExpresssonIntoSecondChild, (, commaTree, ,, last, ), ;, }, return, ;, default, :, throw]
[), ), {, fuseExpresssonIntoSecondChild, (, commaTree, ,, last, ), ;, }, return, ;, default, :, throw, new, IllegalStateException, (, "Statement fusion missing."]
[;, }, return, ;, default, :, throw, new, IllegalStateException, (, "Statement fusion missing.", ), ;, }, }, private, static, Node, fuseExpressionIntoExpression, (]
[,, last, ), ;, }, return, ;, default, :, throw, new, IllegalStateException, (, "Statement fusion missing.", ), ;, }, }, private, static]
[), ;, }, return, ;, default, :, throw, new, IllegalStateException, (, "Statement fusion missing.", ), ;, }, }, private, static, Node, fuseExpressionIntoExpression]
[;, }, }, private, static, Node, fuseExpressionIntoExpression, (, Node, exp1, ,, Node, exp2, ), {, Node, comma, =, new, Node]
[), ;, }, }, private, static, Node, fuseExpressionIntoExpression, (, Node, exp1, ,, Node, exp2, ), {, Node, comma, =, new]
[;, comma, ., copyInformationFrom, (, exp2, ), ;, if, (, exp2, ., isComma, (, ), ), {, Node, leftMostChild, =]
[,, exp1, ), ;, comma, ., copyInformationFrom, (, exp2, ), ;, if, (, exp2, ., isComma, (, ), ), {]
[., COMMA, ,, exp1, ), ;, comma, ., copyInformationFrom, (, exp2, ), ;, if, (, exp2, ., isComma, (, )]
[), ;, comma, ., copyInformationFrom, (, exp2, ), ;, if, (, exp2, ., isComma, (, ), ), {, Node, leftMostChild]
[;, if, (, exp2, ., isComma, (, ), ), {, Node, leftMostChild, =, exp2, ;, while, (, leftMostChild, ., isComma]
[., copyInformationFrom, (, exp2, ), ;, if, (, exp2, ., isComma, (, ), ), {, Node, leftMostChild, =, exp2, ;]
[), ;, if, (, exp2, ., isComma, (, ), ), {, Node, leftMostChild, =, exp2, ;, while, (, leftMostChild, .]
[), {, Node, leftMostChild, =, exp2, ;, while, (, leftMostChild, ., isComma, (, ), ), {, leftMostChild, =, leftMostChild, .]
[., isComma, (, ), ), {, Node, leftMostChild, =, exp2, ;, while, (, leftMostChild, ., isComma, (, ), ), {]
[;, while, (, leftMostChild, ., isComma, (, ), ), {, leftMostChild, =, leftMostChild, ., getFirstChild, (, ), ;, }, Node]
[), {, leftMostChild, =, leftMostChild, ., getFirstChild, (, ), ;, }, Node, parent, =, leftMostChild, ., getParent, (, ), ;]
[., isComma, (, ), ), {, leftMostChild, =, leftMostChild, ., getFirstChild, (, ), ;, }, Node, parent, =, leftMostChild, .]
[=, leftMostChild, ., getFirstChild, (, ), ;, }, Node, parent, =, leftMostChild, ., getParent, (, ), ;, comma, ., addChildToBack]
[;, }, Node, parent, =, leftMostChild, ., getParent, (, ), ;, comma, ., addChildToBack, (, leftMostChild, ., detachFromParent, (, )]
[., getFirstChild, (, ), ;, }, Node, parent, =, leftMostChild, ., getParent, (, ), ;, comma, ., addChildToBack, (, leftMostChild]
[;, comma, ., addChildToBack, (, leftMostChild, ., detachFromParent, (, ), ), ;, parent, ., addChildToFront, (, comma, ), ;, return]
[., getParent, (, ), ;, comma, ., addChildToBack, (, leftMostChild, ., detachFromParent, (, ), ), ;, parent, ., addChildToFront, (]
[;, parent, ., addChildToFront, (, comma, ), ;, return, exp2, ;, }, else, {, comma, ., addChildToBack, (, exp2, )]
[., addChildToBack, (, leftMostChild, ., detachFromParent, (, ), ), ;, parent, ., addChildToFront, (, comma, ), ;, return, exp2, ;]
[), ;, parent, ., addChildToFront, (, comma, ), ;, return, exp2, ;, }, else, {, comma, ., addChildToBack, (, exp2]
[., detachFromParent, (, ), ), ;, parent, ., addChildToFront, (, comma, ), ;, return, exp2, ;, }, else, {, comma]
[;, return, exp2, ;, }, else, {, comma, ., addChildToBack, (, exp2, ), ;, return, comma, ;, }, }, private]
[., addChildToFront, (, comma, ), ;, return, exp2, ;, }, else, {, comma, ., addChildToBack, (, exp2, ), ;, return]
[), ;, return, exp2, ;, }, else, {, comma, ., addChildToBack, (, exp2, ), ;, return, comma, ;, }, }]
[;, }, else, {, comma, ., addChildToBack, (, exp2, ), ;, return, comma, ;, }, }, private, static, void, fuseExpresssonIntoFirstChild]
[;, return, comma, ;, }, }, private, static, void, fuseExpresssonIntoFirstChild, (, Node, exp, ,, Node, stmt, ), {, Node, val]
[., addChildToBack, (, exp2, ), ;, return, comma, ;, }, }, private, static, void, fuseExpresssonIntoFirstChild, (, Node, exp, ,, Node]
[), ;, return, comma, ;, }, }, private, static, void, fuseExpresssonIntoFirstChild, (, Node, exp, ,, Node, stmt, ), {, Node]
[;, }, }, private, static, void, fuseExpresssonIntoFirstChild, (, Node, exp, ,, Node, stmt, ), {, Node, val, =, stmt, .]
[;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;, stmt, ., addChildToFront, (, comma, ), ;, }, private]
[., removeFirstChild, (, ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;, stmt, ., addChildToFront, (, comma]
[;, stmt, ., addChildToFront, (, comma, ), ;, }, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,, Node, stmt, )]
[,, val, ), ;, stmt, ., addChildToFront, (, comma, ), ;, }, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,]
[), ;, stmt, ., addChildToFront, (, comma, ), ;, }, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,, Node, stmt]
[;, }, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,, Node, stmt, ), {, Node, val, =, stmt, ., removeChildAfter]
[., addChildToFront, (, comma, ), ;, }, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,, Node, stmt, ), {, Node]
[), ;, }, private, static, void, fuseExpresssonIntoSecondChild, (, Node, exp, ,, Node, stmt, ), {, Node, val, =, stmt, .]
[;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;, stmt, ., addChildAfter, (, comma, ,, stmt, ., getFirstChild]
[., removeChildAfter, (, stmt, ., getFirstChild, (, ), ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;]
[), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;, stmt, ., addChildAfter, (, comma, ,, stmt, .]
[., getFirstChild, (, ), ), ;, Node, comma, =, fuseExpressionIntoExpression, (, exp, ,, val, ), ;, stmt, ., addChildAfter, (]
[;, stmt, ., addChildAfter, (, comma, ,, stmt, ., getFirstChild, (, ), ), ;, }, }]
[,, val, ), ;, stmt, ., addChildAfter, (, comma, ,, stmt, ., getFirstChild, (, ), ), ;, }, }]
[), ;, stmt, ., addChildAfter, (, comma, ,, stmt, ., getFirstChild, (, ), ), ;, }, }]
[;, }, }]
[., addChildAfter, (, comma, ,, stmt, ., getFirstChild, (, ), ), ;, }, }]
[,, stmt, ., getFirstChild, (, ), ), ;, }, }]
[), ;, }, }]
[., getFirstChild, (, ), ), ;, }, }]
