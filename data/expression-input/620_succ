[;, private, final, AbstractCompiler, compiler, ;, private, final, boolean, removeNoOpStatements, ;, UnreachableCodeElimination, (, AbstractCompiler, compiler, ,, boolean, removeNoOpStatements, ), {]
[., getLogger, (, UnreachableCodeElimination, ., class, ., getName, (, ), ), ;, private, final, AbstractCompiler, compiler, ;, private, final, boolean]
[), ;, private, final, AbstractCompiler, compiler, ;, private, final, boolean, removeNoOpStatements, ;, UnreachableCodeElimination, (, AbstractCompiler, compiler, ,, boolean, removeNoOpStatements, )]
[., getName, (, ), ), ;, private, final, AbstractCompiler, compiler, ;, private, final, boolean, removeNoOpStatements, ;, UnreachableCodeElimination, (, AbstractCompiler, compiler]
[=, compiler, ;, this, ., removeNoOpStatements, =, removeNoOpStatements, ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {]
[., compiler, =, compiler, ;, this, ., removeNoOpStatements, =, removeNoOpStatements, ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t]
[;, this, ., removeNoOpStatements, =, removeNoOpStatements, ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, Scope, scope]
[=, removeNoOpStatements, ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, Scope, scope, =, t, ., getScope]
[., removeNoOpStatements, =, removeNoOpStatements, ;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, Scope, scope, =, t]
[;, }, @, Override, public, void, exitScope, (, NodeTraversal, t, ), {, Scope, scope, =, t, ., getScope, (, )]
[;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (, compiler, ,, false, ,, false, ), ;, cfa, ., process, (, null, ,]
[., getScope, (, ), ;, ControlFlowAnalysis, cfa, =, new, ControlFlowAnalysis, (, compiler, ,, false, ,, false, ), ;, cfa, .]
[;, cfa, ., process, (, null, ,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node, >, cfg, =]
[,, false, ,, false, ), ;, cfa, ., process, (, null, ,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph]
[,, false, ), ;, cfa, ., process, (, null, ,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node]
[), ;, cfa, ., process, (, null, ,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node, >, cfg]
[;, ControlFlowGraph, <, Node, >, cfg, =, cfa, ., getCfg, (, ), ;, new, GraphReachability, <, Node, ,, ControlFlowGraph, .]
[., process, (, null, ,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node, >, cfg, =, cfa, .]
[,, scope, ., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node, >, cfg, =, cfa, ., getCfg, (, ), ;]
[), ;, ControlFlowGraph, <, Node, >, cfg, =, cfa, ., getCfg, (, ), ;, new, GraphReachability, <, Node, ,, ControlFlowGraph]
[., getRootNode, (, ), ), ;, ControlFlowGraph, <, Node, >, cfg, =, cfa, ., getCfg, (, ), ;, new, GraphReachability]
[;, new, GraphReachability, <, Node, ,, ControlFlowGraph, ., Branch, >, (, cfg, ), ., compute, (, cfg, ., getEntry, (]
[., getCfg, (, ), ;, new, GraphReachability, <, Node, ,, ControlFlowGraph, ., Branch, >, (, cfg, ), ., compute, (]
[;, Node, root, =, scope, ., getRootNode, (, ), ;, if, (, scope, ., isLocal, (, ), ), {, root]
[., compute, (, cfg, ., getEntry, (, ), ., getValue, (, ), ), ;, Node, root, =, scope, ., getRootNode]
[), ., compute, (, cfg, ., getEntry, (, ), ., getValue, (, ), ), ;, Node, root, =, scope, .]
[), ;, Node, root, =, scope, ., getRootNode, (, ), ;, if, (, scope, ., isLocal, (, ), ), {]
[., getValue, (, ), ), ;, Node, root, =, scope, ., getRootNode, (, ), ;, if, (, scope, ., isLocal]
[., getEntry, (, ), ., getValue, (, ), ), ;, Node, root, =, scope, ., getRootNode, (, ), ;, if]
[;, if, (, scope, ., isLocal, (, ), ), {, root, =, root, ., getLastChild, (, ), ;, }, NodeTraversal]
[., getRootNode, (, ), ;, if, (, scope, ., isLocal, (, ), ), {, root, =, root, ., getLastChild, (]
[), {, root, =, root, ., getLastChild, (, ), ;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new]
[., isLocal, (, ), ), {, root, =, root, ., getLastChild, (, ), ;, }, NodeTraversal, ., traverse, (, compiler]
[=, root, ., getLastChild, (, ), ;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, EliminationPass, (, cfg]
[;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, EliminationPass, (, cfg, ), ), ;, }, @, Override]
[., getLastChild, (, ), ;, }, NodeTraversal, ., traverse, (, compiler, ,, root, ,, new, EliminationPass, (, cfg, ), )]
[;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, NodeTraversal, ., traverse, (, compiler]
[., traverse, (, compiler, ,, root, ,, new, EliminationPass, (, cfg, ), ), ;, }, @, Override, public, void, process]
[,, root, ,, new, EliminationPass, (, cfg, ), ), ;, }, @, Override, public, void, process, (, Node, externs, ,]
[,, new, EliminationPass, (, cfg, ), ), ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root]
[), ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, NodeTraversal, ., traverse, (]
[), ), ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, NodeTraversal, ., traverse]
[;, }, private, class, EliminationPass, extends, AbstractShallowCallback, {, private, final, ControlFlowGraph, <, Node, >, cfg, ;, private, EliminationPass, (, ControlFlowGraph]
[., traverse, (, compiler, ,, root, ,, this, ), ;, }, private, class, EliminationPass, extends, AbstractShallowCallback, {, private, final, ControlFlowGraph]
[,, root, ,, this, ), ;, }, private, class, EliminationPass, extends, AbstractShallowCallback, {, private, final, ControlFlowGraph, <, Node, >, cfg]
[,, this, ), ;, }, private, class, EliminationPass, extends, AbstractShallowCallback, {, private, final, ControlFlowGraph, <, Node, >, cfg, ;, private]
[), ;, }, private, class, EliminationPass, extends, AbstractShallowCallback, {, private, final, ControlFlowGraph, <, Node, >, cfg, ;, private, EliminationPass, (]
[=, cfg, ;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {]
[., cfg, =, cfg, ;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[), {, return, ;, }, if, (, n, ., isFunction, (, ), ||, n, ., isScript, (, ), ), {]
[==, null, ), {, return, ;, }, if, (, n, ., isFunction, (, ), ||, n, ., isScript, (, )]
[), {, return, ;, }, if, (, n, ., isFunction, (, ), ||, n, ., isScript, (, ), ), {]
[), {, return, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;]
[||, n, ., isScript, (, ), ), {, return, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg]
[., isFunction, (, ), ||, n, ., isScript, (, ), ), {, return, ;, }, DiGraphNode, <, Node, ,, Branch]
[), {, return, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;]
[., isScript, (, ), ), {, return, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode]
[;, if, (, gNode, ==, null, ), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability]
[., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==, null, ), {, return, ;, }, if, (, gNode, .]
[), ;, if, (, gNode, ==, null, ), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=]
[), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&]
[==, null, ), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (]
[), {, return, ;, }, if, (, gNode, ., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&]
[), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }, @, SuppressWarnings, (, "fallthrough"]
[||, (, removeNoOpStatements, &&, !, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {, removeDeadExprStatementSafely, (, n, )]
[!=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&, !, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {]
[., getAnnotation, (, ), !=, GraphReachability, ., REACHABLE, ||, (, removeNoOpStatements, &&, !, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler]
[||, (, removeNoOpStatements, &&, !, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {, removeDeadExprStatementSafely, (, n, )]
[., REACHABLE, ||, (, removeNoOpStatements, &&, !, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {, removeDeadExprStatementSafely, (]
[), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }, @, SuppressWarnings, (, "fallthrough"]
[), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }, @, SuppressWarnings, (]
[&&, !, NodeUtil, ., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;]
[), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }, @, SuppressWarnings, (]
[), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }, @, SuppressWarnings, (]
[., mayHaveSideEffects, (, n, ,, compiler, ), ), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (]
[,, compiler, ), ), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }]
[), ), ), {, removeDeadExprStatementSafely, (, n, ), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }, @, SuppressWarnings]
[;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryRemoveUnconditionalBranching, (, Node]
[), ;, return, ;, }, tryRemoveUnconditionalBranching, (, n, ), ;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryRemoveUnconditionalBranching, (]
[;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryRemoveUnconditionalBranching, (, Node, n, ), {, if, (, n, ==, null]
[), ;, }, @, SuppressWarnings, (, "fallthrough", ), private, Node, tryRemoveUnconditionalBranching, (, Node, n, ), {, if, (, n, ==]
[private, Node, tryRemoveUnconditionalBranching, (, Node, n, ), {, if, (, n, ==, null, ), {, return, n, ;, }, DiGraphNode]
[), private, Node, tryRemoveUnconditionalBranching, (, Node, n, ), {, if, (, n, ==, null, ), {, return, n, ;, }]
[), {, return, n, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, )]
[==, null, ), {, return, n, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (]
[), {, return, n, ;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, )]
[;, }, DiGraphNode, <, Node, ,, Branch, >, gNode, =, cfg, ., getDirectedGraphNode, (, n, ), ;, if, (, gNode]
[;, if, (, gNode, ==, null, ), {, return, n, ;, }, switch, (, n, ., getType, (, ), )]
[., getDirectedGraphNode, (, n, ), ;, if, (, gNode, ==, null, ), {, return, n, ;, }, switch, (, n]
[), ;, if, (, gNode, ==, null, ), {, return, n, ;, }, switch, (, n, ., getType, (, )]
[), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., RETURN, :]
[==, null, ), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, .]
[), {, return, n, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., RETURN, :]
[;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., RETURN, :, if, (, n, .]
[), {, case, Token, ., RETURN, :, if, (, n, ., hasChildren, (, ), ), {, break, ;, }, case]
[., getType, (, ), ), {, case, Token, ., RETURN, :, if, (, n, ., hasChildren, (, ), ), {]
[:, if, (, n, ., hasChildren, (, ), ), {, break, ;, }, case, Token, ., BREAK, :, case, Token]
[., RETURN, :, if, (, n, ., hasChildren, (, ), ), {, break, ;, }, case, Token, ., BREAK, :]
[), {, break, ;, }, case, Token, ., BREAK, :, case, Token, ., CONTINUE, :, List, <, DiGraphEdge, <, Node]
[., hasChildren, (, ), ), {, break, ;, }, case, Token, ., BREAK, :, case, Token, ., CONTINUE, :, List]
[:, case, Token, ., CONTINUE, :, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =, gNode, ., getOutEdges]
[., BREAK, :, case, Token, ., CONTINUE, :, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =, gNode]
[:, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =, gNode, ., getOutEdges, (, ), ;, if, (]
[., CONTINUE, :, List, <, DiGraphEdge, <, Node, ,, Branch, >, >, outEdges, =, gNode, ., getOutEdges, (, ), ;]
[;, if, (, outEdges, ., size, (, ), ==, 1, &&, (, n, ., getNext, (, ), ==, null, ||]
[., getOutEdges, (, ), ;, if, (, outEdges, ., size, (, ), ==, 1, &&, (, n, ., getNext, (]
[), {, Preconditions, ., checkState, (, outEdges, ., get, (, 0, ), ., getValue, (, ), ==, Branch, ., UNCOND]
[&&, (, n, ., getNext, (, ), ==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), )]
[==, 1, &&, (, n, ., getNext, (, ), ==, null, ||, n, ., getNext, (, ), ., isFunction, (]
[., size, (, ), ==, 1, &&, (, n, ., getNext, (, ), ==, null, ||, n, ., getNext, (]
[&&, (, n, ., getNext, (, ), ==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), )]
[), {, Preconditions, ., checkState, (, outEdges, ., get, (, 0, ), ., getValue, (, ), ==, Branch, ., UNCOND]
[), ), {, Preconditions, ., checkState, (, outEdges, ., get, (, 0, ), ., getValue, (, ), ==, Branch, .]
[||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions, ., checkState, (, outEdges, ., get]
[==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions, ., checkState, (, outEdges]
[., getNext, (, ), ==, null, ||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions]
[||, n, ., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions, ., checkState, (, outEdges, ., get]
[), ), {, Preconditions, ., checkState, (, outEdges, ., get, (, 0, ), ., getValue, (, ), ==, Branch, .]
[., isFunction, (, ), ), ), {, Preconditions, ., checkState, (, outEdges, ., get, (, 0, ), ., getValue, (]
[., getNext, (, ), ., isFunction, (, ), ), ), {, Preconditions, ., checkState, (, outEdges, ., get, (, 0]
[;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =, outEdges, ., get, (, 0, ), ., getDestination]
[., checkState, (, outEdges, ., get, (, 0, ), ., getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node]
[), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =, outEdges, ., get, (, 0, ), .]
[==, Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =, outEdges, ., get]
[., getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode]
[., get, (, 0, ), ., getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (]
[), ., getValue, (, ), ==, Branch, ., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node]
[), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =, outEdges, ., get, (, 0, ), .]
[., UNCOND, ), ;, Node, fallThrough, =, computeFollowing, (, n, ), ;, Node, nextCfgNode, =, outEdges, ., get, (, 0]
[;, Node, nextCfgNode, =, outEdges, ., get, (, 0, ), ., getDestination, (, ), ., getValue, (, ), ;, if]
[), ;, Node, nextCfgNode, =, outEdges, ., get, (, 0, ), ., getDestination, (, ), ., getValue, (, ), ;]
[;, if, (, nextCfgNode, ==, fallThrough, ), {, removeDeadExprStatementSafely, (, n, ), ;, return, fallThrough, ;, }, }, }, return]
[., getValue, (, ), ;, if, (, nextCfgNode, ==, fallThrough, ), {, removeDeadExprStatementSafely, (, n, ), ;, return, fallThrough, ;]
[., getDestination, (, ), ., getValue, (, ), ;, if, (, nextCfgNode, ==, fallThrough, ), {, removeDeadExprStatementSafely, (, n, )]
[., get, (, 0, ), ., getDestination, (, ), ., getValue, (, ), ;, if, (, nextCfgNode, ==, fallThrough, )]
[), ., getDestination, (, ), ., getValue, (, ), ;, if, (, nextCfgNode, ==, fallThrough, ), {, removeDeadExprStatementSafely, (, n]
[), {, removeDeadExprStatementSafely, (, n, ), ;, return, fallThrough, ;, }, }, }, return, n, ;, }, private, Node, computeFollowing]
[==, fallThrough, ), {, removeDeadExprStatementSafely, (, n, ), ;, return, fallThrough, ;, }, }, }, return, n, ;, }, private]
[), {, removeDeadExprStatementSafely, (, n, ), ;, return, fallThrough, ;, }, }, }, return, n, ;, }, private, Node, computeFollowing]
[;, return, fallThrough, ;, }, }, }, return, n, ;, }, private, Node, computeFollowing, (, Node, n, ), {, Node]
[), ;, return, fallThrough, ;, }, }, }, return, n, ;, }, private, Node, computeFollowing, (, Node, n, ), {]
[;, }, }, }, return, n, ;, }, private, Node, computeFollowing, (, Node, n, ), {, Node, next, =, ControlFlowAnalysis]
[;, }, private, Node, computeFollowing, (, Node, n, ), {, Node, next, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;]
[;, while, (, next, !=, null, &&, next, ., isBlock, (, ), ), {, if, (, next, ., hasChildren, (]
[., computeFollowNode, (, n, ), ;, while, (, next, !=, null, &&, next, ., isBlock, (, ), ), {, if]
[), ;, while, (, next, !=, null, &&, next, ., isBlock, (, ), ), {, if, (, next, ., hasChildren]
[), {, if, (, next, ., hasChildren, (, ), ), {, next, =, next, ., getFirstChild, (, ), ;, }]
[&&, next, ., isBlock, (, ), ), {, if, (, next, ., hasChildren, (, ), ), {, next, =, next]
[!=, null, &&, next, ., isBlock, (, ), ), {, if, (, next, ., hasChildren, (, ), ), {, next]
[&&, next, ., isBlock, (, ), ), {, if, (, next, ., hasChildren, (, ), ), {, next, =, next]
[), {, if, (, next, ., hasChildren, (, ), ), {, next, =, next, ., getFirstChild, (, ), ;, }]
[., isBlock, (, ), ), {, if, (, next, ., hasChildren, (, ), ), {, next, =, next, ., getFirstChild]
[), {, next, =, next, ., getFirstChild, (, ), ;, }, else, {, next, =, computeFollowing, (, next, ), ;]
[., hasChildren, (, ), ), {, next, =, next, ., getFirstChild, (, ), ;, }, else, {, next, =, computeFollowing]
[=, next, ., getFirstChild, (, ), ;, }, else, {, next, =, computeFollowing, (, next, ), ;, }, }, return]
[;, }, else, {, next, =, computeFollowing, (, next, ), ;, }, }, return, next, ;, }, private, void, removeDeadExprStatementSafely]
[., getFirstChild, (, ), ;, }, else, {, next, =, computeFollowing, (, next, ), ;, }, }, return, next, ;]
[=, computeFollowing, (, next, ), ;, }, }, return, next, ;, }, private, void, removeDeadExprStatementSafely, (, Node, n, ), {]
[;, }, }, return, next, ;, }, private, void, removeDeadExprStatementSafely, (, Node, n, ), {, Node, parent, =, n, .]
[), ;, }, }, return, next, ;, }, private, void, removeDeadExprStatementSafely, (, Node, n, ), {, Node, parent, =, n]
[;, }, private, void, removeDeadExprStatementSafely, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, if]
[;, if, (, n, ., isEmpty, (, ), ||, (, n, ., isBlock, (, ), &&, !, n, ., hasChildren]
[., getParent, (, ), ;, if, (, n, ., isEmpty, (, ), ||, (, n, ., isBlock, (, ), &&]
[), {, return, ;, }, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, ;, }, switch, (]
[||, (, n, ., isBlock, (, ), &&, !, n, ., hasChildren, (, ), ), ), {, return, ;, }]
[., isEmpty, (, ), ||, (, n, ., isBlock, (, ), &&, !, n, ., hasChildren, (, ), ), )]
[), {, return, ;, }, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, ;, }, switch, (]
[), ), {, return, ;, }, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, ;, }, switch]
[&&, !, n, ., hasChildren, (, ), ), ), {, return, ;, }, if, (, NodeUtil, ., isForIn, (, parent]
[., isBlock, (, ), &&, !, n, ., hasChildren, (, ), ), ), {, return, ;, }, if, (, NodeUtil]
[), ), {, return, ;, }, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, ;, }, switch]
[), ), {, return, ;, }, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, ;, }, switch]
[., hasChildren, (, ), ), ), {, return, ;, }, if, (, NodeUtil, ., isForIn, (, parent, ), ), {]
[), {, return, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., DO, :, return]
[., isForIn, (, parent, ), ), {, return, ;, }, switch, (, n, ., getType, (, ), ), {, case]
[), ), {, return, ;, }, switch, (, n, ., getType, (, ), ), {, case, Token, ., DO, :]
[), {, case, Token, ., DO, :, return, ;, case, Token, ., BLOCK, :, if, (, parent, ., isTry, (]
[., getType, (, ), ), {, case, Token, ., DO, :, return, ;, case, Token, ., BLOCK, :, if, (]
[:, return, ;, case, Token, ., BLOCK, :, if, (, parent, ., isTry, (, ), ), {, if, (, NodeUtil]
[., DO, :, return, ;, case, Token, ., BLOCK, :, if, (, parent, ., isTry, (, ), ), {, if]
[:, if, (, parent, ., isTry, (, ), ), {, if, (, NodeUtil, ., isTryCatchNodeContainer, (, n, ), ), {]
[., BLOCK, :, if, (, parent, ., isTry, (, ), ), {, if, (, NodeUtil, ., isTryCatchNodeContainer, (, n, )]
[), {, if, (, NodeUtil, ., isTryCatchNodeContainer, (, n, ), ), {, return, ;, }, }, break, ;, case, Token]
[., isTry, (, ), ), {, if, (, NodeUtil, ., isTryCatchNodeContainer, (, n, ), ), {, return, ;, }, }]
[), {, return, ;, }, }, break, ;, case, Token, ., CATCH, :, Node, tryNode, =, parent, ., getParent, (]
[., isTryCatchNodeContainer, (, n, ), ), {, return, ;, }, }, break, ;, case, Token, ., CATCH, :, Node, tryNode]
[), ), {, return, ;, }, }, break, ;, case, Token, ., CATCH, :, Node, tryNode, =, parent, ., getParent]
[:, Node, tryNode, =, parent, ., getParent, (, ), ;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }]
[., CATCH, :, Node, tryNode, =, parent, ., getParent, (, ), ;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break]
[;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (, n, ., isVar, (, ), &&, !]
[., getParent, (, ), ;, NodeUtil, ., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (, n, ., isVar]
[;, break, ;, }, if, (, n, ., isVar, (, ), &&, !, n, ., getFirstChild, (, ), ., hasChildren]
[., maybeAddFinally, (, tryNode, ), ;, break, ;, }, if, (, n, ., isVar, (, ), &&, !, n, .]
[), ;, break, ;, }, if, (, n, ., isVar, (, ), &&, !, n, ., getFirstChild, (, ), .]
[), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (]
[&&, !, n, ., getFirstChild, (, ), ., hasChildren, (, ), ), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (]
[., isVar, (, ), &&, !, n, ., getFirstChild, (, ), ., hasChildren, (, ), ), {, return, ;, }]
[), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (]
[), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (]
[., hasChildren, (, ), ), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;, compiler, ., reportCodeChange, (]
[., getFirstChild, (, ), ., hasChildren, (, ), ), {, return, ;, }, NodeUtil, ., redeclareVarsInsideBranch, (, n, ), ;]
[;, compiler, ., reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {, logger]
[., redeclareVarsInsideBranch, (, n, ), ;, compiler, ., reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (, Level, .]
[), ;, compiler, ., reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {]
[;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {, logger, ., fine, (, "Removing ", +, n]
[., reportCodeChange, (, ), ;, if, (, logger, ., isLoggable, (, Level, ., FINE, ), ), {, logger, ., fine]
[), {, logger, ., fine, (, "Removing ", +, n, ., toString, (, ), ), ;, }, NodeUtil, ., removeChild, (]
[., isLoggable, (, Level, ., FINE, ), ), {, logger, ., fine, (, "Removing ", +, n, ., toString, (, )]
[), ), {, logger, ., fine, (, "Removing ", +, n, ., toString, (, ), ), ;, }, NodeUtil, ., removeChild]
[., FINE, ), ), {, logger, ., fine, (, "Removing ", +, n, ., toString, (, ), ), ;, }, NodeUtil]
[;, }, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n, ), ;, }, }, @, Override, public]
[., fine, (, "Removing ", +, n, ., toString, (, ), ), ;, }, NodeUtil, ., removeChild, (, n, ., getParent]
[), ;, }, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n, ), ;, }, }, @, Override]
[+, n, ., toString, (, ), ), ;, }, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n]
[), ;, }, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n, ), ;, }, }, @, Override]
[., toString, (, ), ), ;, }, NodeUtil, ., removeChild, (, n, ., getParent, (, ), ,, n, ), ;]
[;, }, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, }]
[., removeChild, (, n, ., getParent, (, ), ,, n, ), ;, }, }, @, Override, public, void, visit, (]
[,, n, ), ;, }, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent]
[., getParent, (, ), ,, n, ), ;, }, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node]
[), ;, }, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {]
