[import, java, ., util, ., regex, ., Pattern, ;, class, PeepholeSubstituteAlternateSyntax, extends, AbstractPeepholeOptimization, {, private, static, final, int, AND_PRECEDENCE, =]
[import, java, ., util, ., regex, ., Pattern, ;, class, PeepholeSubstituteAlternateSyntax, extends, AbstractPeepholeOptimization, {, private, static, final, int, AND_PRECEDENCE, =]
[., regex, ., Pattern, ;, class, PeepholeSubstituteAlternateSyntax, extends, AbstractPeepholeOptimization, {, private, static, final, int, AND_PRECEDENCE, =, NodeUtil, ., precedence, (]
[., regex, ., Pattern, ;, class, PeepholeSubstituteAlternateSyntax, extends, AbstractPeepholeOptimization, {, private, static, final, int, AND_PRECEDENCE, =, NodeUtil, ., precedence, (]
[static, final, int, AND_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., AND, ), ;, private, static, final, int, OR_PRECEDENCE, =]
[static, final, int, AND_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., AND, ), ;, private, static, final, int, OR_PRECEDENCE, =]
[=, NodeUtil, ., precedence, (, Token, ., AND, ), ;, private, static, final, int, OR_PRECEDENCE, =, NodeUtil, ., precedence, (]
[=, NodeUtil, ., precedence, (, Token, ., AND, ), ;, private, static, final, int, OR_PRECEDENCE, =, NodeUtil, ., precedence, (]
[static, final, int, OR_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., OR, ), ;, private, static, final, int, NOT_PRECEDENCE, =]
[static, final, int, OR_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., OR, ), ;, private, static, final, int, NOT_PRECEDENCE, =]
[=, NodeUtil, ., precedence, (, Token, ., OR, ), ;, private, static, final, int, NOT_PRECEDENCE, =, NodeUtil, ., precedence, (]
[=, NodeUtil, ., precedence, (, Token, ., OR, ), ;, private, static, final, int, NOT_PRECEDENCE, =, NodeUtil, ., precedence, (]
[static, final, int, NOT_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., NOT, ), ;, private, static, final, CodeGenerator, REGEXP_ESCAPER, =]
[static, final, int, NOT_PRECEDENCE, =, NodeUtil, ., precedence, (, Token, ., NOT, ), ;, private, static, final, CodeGenerator, REGEXP_ESCAPER, =]
[=, NodeUtil, ., precedence, (, Token, ., NOT, ), ;, private, static, final, CodeGenerator, REGEXP_ESCAPER, =, CodeGenerator, ., forCostEstimation, (]
[CodeGenerator, REGEXP_ESCAPER, =, CodeGenerator, ., forCostEstimation, (, null, ), ;, private, final, boolean, late, ;, private, final, int, STRING_SPLIT_OVERHEAD, =]
[CodeGenerator, REGEXP_ESCAPER, =, CodeGenerator, ., forCostEstimation, (, null, ), ;, private, final, boolean, late, ;, private, final, int, STRING_SPLIT_OVERHEAD, =]
[final, boolean, late, ;, private, final, int, STRING_SPLIT_OVERHEAD, =, ".split('.')", ., length, (, ), ;, static, final, DiagnosticType, INVALID_REGULAR_EXPRESSION_FLAGS, =]
[final, boolean, late, ;, private, final, int, STRING_SPLIT_OVERHEAD, =, ".split('.')", ., length, (, ), ;, static, final, DiagnosticType, INVALID_REGULAR_EXPRESSION_FLAGS, =]
[private, final, int, STRING_SPLIT_OVERHEAD, =, ".split('.')", ., length, (, ), ;, static, final, DiagnosticType, INVALID_REGULAR_EXPRESSION_FLAGS, =, DiagnosticType, ., warning, (]
[int, STRING_SPLIT_OVERHEAD, =, ".split('.')", ., length, (, ), ;, static, final, DiagnosticType, INVALID_REGULAR_EXPRESSION_FLAGS, =, DiagnosticType, ., warning, (, "JSC_INVALID_REGULAR_EXPRESSION_FLAGS", ,]
[DiagnosticType, INVALID_REGULAR_EXPRESSION_FLAGS, =, DiagnosticType, ., warning, (, "JSC_INVALID_REGULAR_EXPRESSION_FLAGS", ,, "Invalid flags to RegExp constructor: {0}", ), ;, static, final, Predicate, <, Node, >, DONT_TRAVERSE_FUNCTIONS_PREDICATE, =]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, !]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, !]
[input, ), {, return, !, input, ., isFunction, (, ), ;, }, }, ;, PeepholeSubstituteAlternateSyntax, (, boolean, late, ), {]
[input, ), {, return, !, input, ., isFunction, (, ), ;, }, }, ;, PeepholeSubstituteAlternateSyntax, (, boolean, late, ), {]
[!, input, ., isFunction, (, ), ;, }, }, ;, PeepholeSubstituteAlternateSyntax, (, boolean, late, ), {, this, ., late, =]
[), ;, }, }, ;, PeepholeSubstituteAlternateSyntax, (, boolean, late, ), {, this, ., late, =, late, ;, }, @, Override]
[}, ;, PeepholeSubstituteAlternateSyntax, (, boolean, late, ), {, this, ., late, =, late, ;, }, @, Override, @, SuppressWarnings, (]
[late, ;, }, @, Override, @, SuppressWarnings, (, "fallthrough", ), public, Node, optimizeSubtree, (, Node, node, ), {, switch, (]
[late, ;, }, @, Override, @, SuppressWarnings, (, "fallthrough", ), public, Node, optimizeSubtree, (, Node, node, ), {, switch, (]
["fallthrough", ), public, Node, optimizeSubtree, (, Node, node, ), {, switch, (, node, ., getType, (, ), ), {, case]
["fallthrough", ), public, Node, optimizeSubtree, (, Node, node, ), {, switch, (, node, ., getType, (, ), ), {, case]
[), {, switch, (, node, ., getType, (, ), ), {, case, Token, ., RETURN, :, {, Node, result, =]
[switch, (, node, ., getType, (, ), ), {, case, Token, ., RETURN, :, {, Node, result, =, tryRemoveRedundantExit, (]
[(, ), ), {, case, Token, ., RETURN, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (]
[(, ), ), {, case, Token, ., RETURN, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (]
[), {, case, Token, ., RETURN, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=]
[., RETURN, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return]
[{, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;, }]
[result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, result, =]
[tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, result, =, tryReplaceExitWithBreak, (]
[if, (, result, !=, node, ), {, return, result, ;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;, if, (]
[if, (, result, !=, node, ), {, return, result, ;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;, if, (]
[result, !=, node, ), {, return, result, ;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;, if, (, result, !=]
[{, return, result, ;, }, result, =, tryReplaceExitWithBreak, (, node, ), ;, if, (, result, !=, node, ), {, return]
[}, result, =, tryReplaceExitWithBreak, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return]
[=, tryReplaceExitWithBreak, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReduceReturn, (]
[;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReduceReturn, (, node, ), ;, }, case]
[;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReduceReturn, (, node, ), ;, }, case]
[return, result, ;, }, return, tryReduceReturn, (, node, ), ;, }, case, Token, ., THROW, :, {, Node, result, =]
[;, }, return, tryReduceReturn, (, node, ), ;, }, case, Token, ., THROW, :, {, Node, result, =, tryRemoveRedundantExit, (]
[node, ), ;, }, case, Token, ., THROW, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (]
[node, ), ;, }, case, Token, ., THROW, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (]
[;, }, case, Token, ., THROW, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=]
[., THROW, :, {, Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return]
[Node, result, =, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return]
[=, tryRemoveRedundantExit, (, node, ), ;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReplaceExitWithBreak, (]
[;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case]
[;, if, (, result, !=, node, ), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case]
[!=, node, ), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case, Token, ., NOT, :]
[), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case, Token, ., NOT, :, tryMinimizeCondition, (]
[), {, return, result, ;, }, return, tryReplaceExitWithBreak, (, node, ), ;, }, case, Token, ., NOT, :, tryMinimizeCondition, (]
[(, node, ), ;, }, case, Token, ., NOT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return]
[), ;, }, case, Token, ., NOT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (]
[Token, ., NOT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (, node, ), ;, case]
[Token, ., NOT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (, node, ), ;, case]
[tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (, node, ), ;, case, Token, ., IF, :]
[node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (, node, ), ;, case, Token, ., IF, :, tryMinimizeCondition, (]
[node, ., getFirstChild, (, ), ), ;, return, tryMinimizeNot, (, node, ), ;, case, Token, ., IF, :, tryMinimizeCondition, (]
[tryMinimizeNot, (, node, ), ;, case, Token, ., IF, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return]
[node, ), ;, case, Token, ., IF, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (]
[Token, ., IF, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node, ), ;, case]
[Token, ., IF, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node, ), ;, case]
[tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node, ), ;, case, Token, ., EXPR_RESULT, :]
[node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node, ), ;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (]
[node, ., getFirstChild, (, ), ), ;, return, tryMinimizeIf, (, node, ), ;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (]
[tryMinimizeIf, (, node, ), ;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return]
[), ;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case]
[), ;, case, Token, ., EXPR_RESULT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case]
[., EXPR_RESULT, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., HOOK, :]
[:, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., HOOK, :, tryMinimizeCondition, (]
[:, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., HOOK, :, tryMinimizeCondition, (]
[), ;, return, node, ;, case, Token, ., HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return]
[node, ;, case, Token, ., HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case]
[node, ;, case, Token, ., HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case]
[HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., WHILE, :, case]
[HOOK, :, tryMinimizeCondition, (, node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., WHILE, :, case]
[node, ., getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., WHILE, :, case, Token, ., DO, :]
[getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, tryMinimizeCondition, (]
[getFirstChild, (, ), ), ;, return, node, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, tryMinimizeCondition, (]
[;, return, node, ;, case, Token, ., WHILE, :, case, Token, ., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (]
[Token, ., WHILE, :, case, Token, ., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return]
[:, case, Token, ., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return, node, ;, case]
[:, case, Token, ., DO, :, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return, node, ;, case]
[tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return, node, ;, case, Token, ., FOR, :, if, (]
[(, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return, node, ;, case, Token, ., FOR, :, if, (, !]
[(, NodeUtil, ., getConditionExpression, (, node, ), ), ;, return, node, ;, case, Token, ., FOR, :, if, (, !]
[(, node, ), ), ;, return, node, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (]
[;, return, node, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, ), ), {]
[node, ;, case, Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, ), ), {, tryJoinForCondition, (]
[Token, ., FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, ), ), {, tryJoinForCondition, (, node, ), ;]
[FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, ), ), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (]
[FOR, :, if, (, !, NodeUtil, ., isForIn, (, node, ), ), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (]
[!, NodeUtil, ., isForIn, (, node, ), ), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (]
[), ), {, tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return]
[tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return, node, ;, case]
[tryJoinForCondition, (, node, ), ;, tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return, node, ;, case]
[tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return, node, ;, case, Token, ., TRUE, :, case]
[tryMinimizeCondition, (, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, return, node, ;, case, Token, ., TRUE, :, case]
[(, node, ), ), ;, }, return, node, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return]
[), ), ;, }, return, node, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (]
[return, node, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (, node, ), ;, case]
[return, node, ;, case, Token, ., TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (, node, ), ;, case]
[Token, ., TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :]
[TRUE, :, case, Token, ., FALSE, :, return, reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :, node, =]
[case, Token, ., FALSE, :, return, reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :, node, =, tryFoldStandardConstructors, (]
[return, reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :, node, =, tryFoldStandardConstructors, (, node, ), ;, if, (]
[reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :, node, =, tryFoldStandardConstructors, (, node, ), ;, if, (, !]
[reduceTrueFalse, (, node, ), ;, case, Token, ., NEW, :, node, =, tryFoldStandardConstructors, (, node, ), ;, if, (, !]
[NEW, :, node, =, tryFoldStandardConstructors, (, node, ), ;, if, (, !, node, ., isCall, (, ), ), {, return]
[tryFoldStandardConstructors, (, node, ), ;, if, (, !, node, ., isCall, (, ), ), {, return, node, ;, }, case]
[tryFoldStandardConstructors, (, node, ), ;, if, (, !, node, ., isCall, (, ), ), {, return, node, ;, }, case]
[!, node, ., isCall, (, ), ), {, return, node, ;, }, case, Token, ., CALL, :, Node, result, =]
[., isCall, (, ), ), {, return, node, ;, }, case, Token, ., CALL, :, Node, result, =, tryFoldLiteralConstructor, (]
[{, return, node, ;, }, case, Token, ., CALL, :, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if, (]
[{, return, node, ;, }, case, Token, ., CALL, :, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if, (]
[node, ;, }, case, Token, ., CALL, :, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if, (, result, ==]
[case, Token, ., CALL, :, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if, (, result, ==, node, ), {]
[., CALL, :, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if, (, result, ==, node, ), {, result, =]
[:, Node, result, =, tryFoldLiteralConstructor, (, node, ), ;, if, (, result, ==, node, ), {, result, =, tryFoldSimpleFunctionCall, (]
[(, node, ), ;, if, (, result, ==, node, ), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (]
[(, node, ), ;, if, (, result, ==, node, ), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (]
[), ;, if, (, result, ==, node, ), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==]
[(, result, ==, node, ), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==, node, ), {]
[==, node, ), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==, node, ), {, result, =]
[), {, result, =, tryFoldSimpleFunctionCall, (, node, ), ;, if, (, result, ==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (]
[node, ), ;, if, (, result, ==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return]
[if, (, result, ==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result, ;, case]
[if, (, result, ==, node, ), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result, ;, case]
[), {, result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result, ;, case, Token, ., COMMA, :, return]
[result, =, tryFoldImmediateCallToBoundFunction, (, node, ), ;, }, }, return, result, ;, case, Token, ., COMMA, :, return, trySplitComma, (]
[node, ), ;, }, }, return, result, ;, case, Token, ., COMMA, :, return, trySplitComma, (, node, ), ;, case]
[node, ), ;, }, }, return, result, ;, case, Token, ., COMMA, :, return, trySplitComma, (, node, ), ;, case]
[return, result, ;, case, Token, ., COMMA, :, return, trySplitComma, (, node, ), ;, case, Token, ., NAME, :, return]
[;, case, Token, ., COMMA, :, return, trySplitComma, (, node, ), ;, case, Token, ., NAME, :, return, tryReplaceUndefined, (]
[COMMA, :, return, trySplitComma, (, node, ), ;, case, Token, ., NAME, :, return, tryReplaceUndefined, (, node, ), ;, case]
[COMMA, :, return, trySplitComma, (, node, ), ;, case, Token, ., NAME, :, return, tryReplaceUndefined, (, node, ), ;, case]
[node, ), ;, case, Token, ., NAME, :, return, tryReplaceUndefined, (, node, ), ;, case, Token, ., BLOCK, :, return]
[;, case, Token, ., NAME, :, return, tryReplaceUndefined, (, node, ), ;, case, Token, ., BLOCK, :, return, tryReplaceIf, (]
[NAME, :, return, tryReplaceUndefined, (, node, ), ;, case, Token, ., BLOCK, :, return, tryReplaceIf, (, node, ), ;, case]
[NAME, :, return, tryReplaceUndefined, (, node, ), ;, case, Token, ., BLOCK, :, return, tryReplaceIf, (, node, ), ;, case]
[node, ), ;, case, Token, ., BLOCK, :, return, tryReplaceIf, (, node, ), ;, case, Token, ., ARRAYLIT, :, return]
[;, case, Token, ., BLOCK, :, return, tryReplaceIf, (, node, ), ;, case, Token, ., ARRAYLIT, :, return, tryMinimizeArrayLiteral, (]
[return, tryReplaceIf, (, node, ), ;, case, Token, ., ARRAYLIT, :, return, tryMinimizeArrayLiteral, (, node, ), ;, default, :, return]
[node, ), ;, default, :, return, node, ;, }, }, private, void, tryJoinForCondition, (, Node, n, ), {, if, (]
[), ;, default, :, return, node, ;, }, }, private, void, tryJoinForCondition, (, Node, n, ), {, if, (, !]
[private, void, tryJoinForCondition, (, Node, n, ), {, if, (, !, late, ), {, return, ;, }, Node, block, =]
[private, void, tryJoinForCondition, (, Node, n, ), {, if, (, !, late, ), {, return, ;, }, Node, block, =]
[(, !, late, ), {, return, ;, }, Node, block, =, n, ., getLastChild, (, ), ;, Node, maybeIf, =]
[(, !, late, ), {, return, ;, }, Node, block, =, n, ., getLastChild, (, ), ;, Node, maybeIf, =]
[Node, block, =, n, ., getLastChild, (, ), ;, Node, maybeIf, =, block, ., getFirstChild, (, ), ;, if, (]
[Node, block, =, n, ., getLastChild, (, ), ;, Node, maybeIf, =, block, ., getFirstChild, (, ), ;, if, (]
[Node, block, =, n, ., getLastChild, (, ), ;, Node, maybeIf, =, block, ., getFirstChild, (, ), ;, if, (]
[=, n, ., getLastChild, (, ), ;, Node, maybeIf, =, block, ., getFirstChild, (, ), ;, if, (, maybeIf, !=]
[., getLastChild, (, ), ;, Node, maybeIf, =, block, ., getFirstChild, (, ), ;, if, (, maybeIf, !=, null, &&]
[., getLastChild, (, ), ;, Node, maybeIf, =, block, ., getFirstChild, (, ), ;, if, (, maybeIf, !=, null, &&]
[getFirstChild, (, ), ;, if, (, maybeIf, !=, null, &&, maybeIf, ., isIf, (, ), ), {, Node, maybeBreak, =]
[getFirstChild, (, ), ;, if, (, maybeIf, !=, null, &&, maybeIf, ., isIf, (, ), ), {, Node, maybeBreak, =]
[getFirstChild, (, ), ;, if, (, maybeIf, !=, null, &&, maybeIf, ., isIf, (, ), ), {, Node, maybeBreak, =]
[if, (, maybeIf, !=, null, &&, maybeIf, ., isIf, (, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (]
[(, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (]
[(, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (]
[(, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (]
[(, ), ), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (]
[), {, Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=]
[Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=, null, &&]
[Node, maybeBreak, =, maybeIf, ., getChildAtIndex, (, 1, ), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=, null, &&]
[(, 1, ), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&]
[1, ), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&, !]
[1, ), ., getFirstChild, (, ), ;, if, (, maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&, !]
[maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (]
[maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (]
[maybeBreak, !=, null, &&, maybeBreak, ., isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (]
[isBreak, (, ), &&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount, (, ), ==]
[&&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {]
[&&, !, maybeBreak, ., hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {]
[hasChildren, (, ), ), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {, block, ., replaceChild, (]
[), ), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {, block, ., replaceChild, (, maybeIf, ,]
[), ), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {, block, ., replaceChild, (, maybeIf, ,]
[), ), {, if, (, maybeIf, ., getChildCount, (, ), ==, 3, ), {, block, ., replaceChild, (, maybeIf, ,]
[block, ., replaceChild, (, maybeIf, ,, maybeIf, ., getLastChild, (, ), ., detachFromParent, (, ), ), ;, }, else, {]
[block, ., replaceChild, (, maybeIf, ,, maybeIf, ., getLastChild, (, ), ., detachFromParent, (, ), ), ;, }, else, {]
[), ., detachFromParent, (, ), ), ;, }, else, {, block, ., removeFirstChild, (, ), ;, }, Node, ifCondition, =]
[), ., detachFromParent, (, ), ), ;, }, else, {, block, ., removeFirstChild, (, ), ;, }, Node, ifCondition, =]
[{, block, ., removeFirstChild, (, ), ;, }, Node, ifCondition, =, maybeIf, ., removeFirstChild, (, ), ;, Node, fixedIfCondition, =]
[{, block, ., removeFirstChild, (, ), ;, }, Node, ifCondition, =, maybeIf, ., removeFirstChild, (, ), ;, Node, fixedIfCondition, =]
[{, block, ., removeFirstChild, (, ), ;, }, Node, ifCondition, =, maybeIf, ., removeFirstChild, (, ), ;, Node, fixedIfCondition, =]
[(, ), ;, }, Node, ifCondition, =, maybeIf, ., removeFirstChild, (, ), ;, Node, fixedIfCondition, =, IR, ., not, (]
[ifCondition, =, maybeIf, ., removeFirstChild, (, ), ;, Node, fixedIfCondition, =, IR, ., not, (, ifCondition, ), ., srcref, (]
[), ;, Node, fixedIfCondition, =, IR, ., not, (, ifCondition, ), ., srcref, (, ifCondition, ), ;, Node, forCondition, =]
[), ;, Node, fixedIfCondition, =, IR, ., not, (, ifCondition, ), ., srcref, (, ifCondition, ), ;, Node, forCondition, =]
[=, IR, ., not, (, ifCondition, ), ., srcref, (, ifCondition, ), ;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (]
[ifCondition, ), ., srcref, (, ifCondition, ), ;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (]
[ifCondition, ), ., srcref, (, ifCondition, ), ;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (]
[;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, forCondition, ., isEmpty, (, ), ), {]
[;, Node, forCondition, =, NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, forCondition, ., isEmpty, (, ), ), {]
[NodeUtil, ., getConditionExpression, (, n, ), ;, if, (, forCondition, ., isEmpty, (, ), ), {, n, ., replaceChild, (]
[getConditionExpression, (, n, ), ;, if, (, forCondition, ., isEmpty, (, ), ), {, n, ., replaceChild, (, forCondition, ,]
[isEmpty, (, ), ), {, n, ., replaceChild, (, forCondition, ,, fixedIfCondition, ), ;, }, else, {, Node, replacement, =]
[), {, n, ., replaceChild, (, forCondition, ,, fixedIfCondition, ), ;, }, else, {, Node, replacement, =, new, Node, (]
[), {, n, ., replaceChild, (, forCondition, ,, fixedIfCondition, ), ;, }, else, {, Node, replacement, =, new, Node, (]
[(, forCondition, ,, fixedIfCondition, ), ;, }, else, {, Node, replacement, =, new, Node, (, Token, ., AND, ), ;]
[(, forCondition, ,, fixedIfCondition, ), ;, }, else, {, Node, replacement, =, new, Node, (, Token, ., AND, ), ;]
[), ;, }, else, {, Node, replacement, =, new, Node, (, Token, ., AND, ), ;, n, ., replaceChild, (]
[}, else, {, Node, replacement, =, new, Node, (, Token, ., AND, ), ;, n, ., replaceChild, (, forCondition, ,]
[Node, replacement, =, new, Node, (, Token, ., AND, ), ;, n, ., replaceChild, (, forCondition, ,, replacement, ), ;]
[Node, replacement, =, new, Node, (, Token, ., AND, ), ;, n, ., replaceChild, (, forCondition, ,, replacement, ), ;]
[Node, (, Token, ., AND, ), ;, n, ., replaceChild, (, forCondition, ,, replacement, ), ;, replacement, ., addChildToBack, (]
[., AND, ), ;, n, ., replaceChild, (, forCondition, ,, replacement, ), ;, replacement, ., addChildToBack, (, forCondition, ), ;]
[., AND, ), ;, n, ., replaceChild, (, forCondition, ,, replacement, ), ;, replacement, ., addChildToBack, (, forCondition, ), ;]
[n, ., replaceChild, (, forCondition, ,, replacement, ), ;, replacement, ., addChildToBack, (, forCondition, ), ;, replacement, ., addChildToBack, (]
[forCondition, ,, replacement, ), ;, replacement, ., addChildToBack, (, forCondition, ), ;, replacement, ., addChildToBack, (, fixedIfCondition, ), ;, }]
[(, fixedIfCondition, ), ;, }, reportCodeChange, (, ), ;, }, }, }, private, Node, tryFoldSimpleFunctionCall, (, Node, n, ), {]
[(, fixedIfCondition, ), ;, }, reportCodeChange, (, ), ;, }, }, }, private, Node, tryFoldSimpleFunctionCall, (, Node, n, ), {]
[}, reportCodeChange, (, ), ;, }, }, }, private, Node, tryFoldSimpleFunctionCall, (, Node, n, ), {, Preconditions, ., checkState, (]
[}, reportCodeChange, (, ), ;, }, }, }, private, Node, tryFoldSimpleFunctionCall, (, Node, n, ), {, Preconditions, ., checkState, (]
[tryFoldSimpleFunctionCall, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =]
[tryFoldSimpleFunctionCall, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =]
[checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (]
[checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (]
[checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (]
[checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (]
[n, ., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (, callTarget, !=]
[isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (, callTarget, !=, null, &&]
[isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, if, (, callTarget, !=, null, &&]
[callTarget, =, n, ., getFirstChild, (, ), ;, if, (, callTarget, !=, null, &&, callTarget, ., isName, (, ), &&]
[callTarget, =, n, ., getFirstChild, (, ), ;, if, (, callTarget, !=, null, &&, callTarget, ., isName, (, ), &&]
[callTarget, =, n, ., getFirstChild, (, ), ;, if, (, callTarget, !=, null, &&, callTarget, ., isName, (, ), &&]
[if, (, callTarget, !=, null, &&, callTarget, ., isName, (, ), &&, callTarget, ., getString, (, ), ., equals, (]
[., isName, (, ), &&, callTarget, ., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =]
[., isName, (, ), &&, callTarget, ., getString, (, ), ., equals, (, "String", ), ), {, Node, value, =]
[(, ), ., equals, (, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (]
[(, ), ., equals, (, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (]
[(, ), ., equals, (, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (]
[(, ), ., equals, (, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (]
[., equals, (, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (, value, !=]
[(, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (, value, !=, null, &&]
[(, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (, value, !=, null, &&]
[(, "String", ), ), {, Node, value, =, callTarget, ., getNext, (, ), ;, if, (, value, !=, null, &&]
[value, =, callTarget, ., getNext, (, ), ;, if, (, value, !=, null, &&, value, ., getNext, (, ), ==]
[callTarget, ., getNext, (, ), ;, if, (, value, !=, null, &&, value, ., getNext, (, ), ==, null, &&]
[callTarget, ., getNext, (, ), ;, if, (, value, !=, null, &&, value, ., getNext, (, ), ==, null, &&]
[), ;, if, (, value, !=, null, &&, value, ., getNext, (, ), ==, null, &&, NodeUtil, ., isImmutableValue, (]
[&&, value, ., getNext, (, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =]
[&&, value, ., getNext, (, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =]
[(, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, ., add, (]
[(, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, ., add, (]
[(, ), ==, null, &&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, ., add, (]
[&&, NodeUtil, ., isImmutableValue, (, value, ), ), {, Node, addition, =, IR, ., add, (, IR, ., string, (]
[value, ), ), {, Node, addition, =, IR, ., add, (, IR, ., string, (, "", ), ., srcref, (]
[{, Node, addition, =, IR, ., add, (, IR, ., string, (, "", ), ., srcref, (, callTarget, ), ,]
[{, Node, addition, =, IR, ., add, (, IR, ., string, (, "", ), ., srcref, (, callTarget, ), ,]
[(, IR, ., string, (, "", ), ., srcref, (, callTarget, ), ,, value, ., detachFromParent, (, ), ), ;]
[(, IR, ., string, (, "", ), ., srcref, (, callTarget, ), ,, value, ., detachFromParent, (, ), ), ;]
[(, IR, ., string, (, "", ), ., srcref, (, callTarget, ), ,, value, ., detachFromParent, (, ), ), ;]
[srcref, (, callTarget, ), ,, value, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (]
[callTarget, ), ,, value, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[value, ., detachFromParent, (, ), ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, addition, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, addition, ), ;, reportCodeChange, (, ), ;, return]
[(, ), ., replaceChild, (, n, ,, addition, ), ;, reportCodeChange, (, ), ;, return, addition, ;, }, }, return]
[(, ), ;, return, addition, ;, }, }, return, n, ;, }, private, Node, tryFoldImmediateCallToBoundFunction, (, Node, n, ), {]
[(, ), ;, return, addition, ;, }, }, return, n, ;, }, private, Node, tryFoldImmediateCallToBoundFunction, (, Node, n, ), {]
[addition, ;, }, }, return, n, ;, }, private, Node, tryFoldImmediateCallToBoundFunction, (, Node, n, ), {, Preconditions, ., checkState, (]
[addition, ;, }, }, return, n, ;, }, private, Node, tryFoldImmediateCallToBoundFunction, (, Node, n, ), {, Preconditions, ., checkState, (]
[tryFoldImmediateCallToBoundFunction, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =]
[tryFoldImmediateCallToBoundFunction, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isCall, (, ), ), ;, Node, callTarget, =]
[(, n, ., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, Bind, bind, =]
[(, n, ., isCall, (, ), ), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, Bind, bind, =]
[), ;, Node, callTarget, =, n, ., getFirstChild, (, ), ;, Bind, bind, =, getCodingConvention, (, ), ., describeFunctionBind, (]
[Node, callTarget, =, n, ., getFirstChild, (, ), ;, Bind, bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,]
[getFirstChild, (, ), ;, Bind, bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,, false, ), ;, if, (]
[getFirstChild, (, ), ;, Bind, bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,, false, ), ;, if, (]
[), ;, Bind, bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,, false, ), ;, if, (, bind, !=]
[bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,, false, ), ;, if, (, bind, !=, null, ), {]
[bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,, false, ), ;, if, (, bind, !=, null, ), {]
[bind, =, getCodingConvention, (, ), ., describeFunctionBind, (, callTarget, ,, false, ), ;, if, (, bind, !=, null, ), {]
[callTarget, ,, false, ), ;, if, (, bind, !=, null, ), {, bind, ., target, ., detachFromParent, (, ), ;]
[callTarget, ,, false, ), ;, if, (, bind, !=, null, ), {, bind, ., target, ., detachFromParent, (, ), ;]
[;, if, (, bind, !=, null, ), {, bind, ., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (]
[(, bind, !=, null, ), {, bind, ., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,]
[(, bind, !=, null, ), {, bind, ., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,]
[{, bind, ., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,, bind, ., target, ), ;]
[., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,, bind, ., target, ), ;, callTarget, =]
[., target, ., detachFromParent, (, ), ;, n, ., replaceChild, (, callTarget, ,, bind, ., target, ), ;, callTarget, =]
[(, ), ;, n, ., replaceChild, (, callTarget, ,, bind, ., target, ), ;, callTarget, =, bind, ., target, ;]
[;, n, ., replaceChild, (, callTarget, ,, bind, ., target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (]
[;, n, ., replaceChild, (, callTarget, ,, bind, ., target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (]
[(, callTarget, ,, bind, ., target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,]
[target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (]
[target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (]
[target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (]
[target, ), ;, callTarget, =, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (]
[=, bind, ., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=]
[., target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=, null, &&]
[target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=, null, &&, !]
[target, ;, addParameterAfter, (, bind, ., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=, null, &&, !]
[bind, ., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (]
[bind, ., parameters, ,, callTarget, ), ;, if, (, bind, ., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (]
[bind, ., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), ), {, Node, newCallTarget, =]
[bind, ., thisValue, !=, null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), ), {, Node, newCallTarget, =]
[null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop, (]
[null, &&, !, NodeUtil, ., isUndefined, (, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop, (]
[(, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,]
[(, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,]
[(, bind, ., thisValue, ), ), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,]
[), ), {, Node, newCallTarget, =, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,, IR, ., string, (]
[=, IR, ., getprop, (, callTarget, ., cloneTree, (, ), ,, IR, ., string, (, "call", ), ., srcref, (]
[(, callTarget, ., cloneTree, (, ), ,, IR, ., string, (, "call", ), ., srcref, (, callTarget, ), ), ;]
[(, callTarget, ., cloneTree, (, ), ,, IR, ., string, (, "call", ), ., srcref, (, callTarget, ), ), ;]
[(, ), ,, IR, ., string, (, "call", ), ., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (]
[,, IR, ., string, (, "call", ), ., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,]
[string, (, "call", ), ., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;]
[string, (, "call", ), ., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;]
[., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (]
[., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (]
[., srcref, (, callTarget, ), ), ;, n, ., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (]
[., replaceChild, (, callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,]
[callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;]
[callTarget, ,, newCallTarget, ), ;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;]
[;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;, n, ., putBooleanProp, (]
[;, n, ., addChildAfter, (, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;, n, ., putBooleanProp, (]
[(, bind, ., thisValue, ., cloneTree, (, ), ,, newCallTarget, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,]
[(, ), ,, newCallTarget, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }, else, {]
[(, ), ,, newCallTarget, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }, else, {]
[), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }, else, {, n, ., putBooleanProp, (]
[), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }, else, {, n, ., putBooleanProp, (]
[putBooleanProp, (, Node, ., FREE_CALL, ,, false, ), ;, }, else, {, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,]
[FREE_CALL, ,, false, ), ;, }, else, {, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }]
[else, {, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, }, reportCodeChange, (, ), ;, }, return]
[), ;, }, return, n, ;, }, private, void, addParameterAfter, (, Node, parameterList, ,, Node, after, ), {, if, (]
[), ;, }, return, n, ;, }, private, void, addParameterAfter, (, Node, parameterList, ,, Node, after, ), {, if, (]
[}, return, n, ;, }, private, void, addParameterAfter, (, Node, parameterList, ,, Node, after, ), {, if, (, parameterList, !=]
[;, }, private, void, addParameterAfter, (, Node, parameterList, ,, Node, after, ), {, if, (, parameterList, !=, null, ), {]
[private, void, addParameterAfter, (, Node, parameterList, ,, Node, after, ), {, if, (, parameterList, !=, null, ), {, addParameterAfter, (]
[private, void, addParameterAfter, (, Node, parameterList, ,, Node, after, ), {, if, (, parameterList, !=, null, ), {, addParameterAfter, (]
[,, Node, after, ), {, if, (, parameterList, !=, null, ), {, addParameterAfter, (, parameterList, ., getNext, (, ), ,]
[), {, if, (, parameterList, !=, null, ), {, addParameterAfter, (, parameterList, ., getNext, (, ), ,, after, ), ;]
[), {, if, (, parameterList, !=, null, ), {, addParameterAfter, (, parameterList, ., getNext, (, ), ,, after, ), ;]
[), {, if, (, parameterList, !=, null, ), {, addParameterAfter, (, parameterList, ., getNext, (, ), ,, after, ), ;]
[{, addParameterAfter, (, parameterList, ., getNext, (, ), ,, after, ), ;, after, ., getParent, (, ), ., addChildAfter, (]
[{, addParameterAfter, (, parameterList, ., getNext, (, ), ,, after, ), ;, after, ., getParent, (, ), ., addChildAfter, (]
[(, ), ,, after, ), ;, after, ., getParent, (, ), ., addChildAfter, (, parameterList, ., cloneTree, (, ), ,]
[., cloneTree, (, ), ,, after, ), ;, }, }, private, Node, trySplitComma, (, Node, n, ), {, if, (]
[,, after, ), ;, }, }, private, Node, trySplitComma, (, Node, n, ), {, if, (, late, ), {, return]
[private, Node, trySplitComma, (, Node, n, ), {, if, (, late, ), {, return, n, ;, }, Node, parent, =]
[private, Node, trySplitComma, (, Node, n, ), {, if, (, late, ), {, return, n, ;, }, Node, parent, =]
[(, late, ), {, return, n, ;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, left, =]
[(, late, ), {, return, n, ;, }, Node, parent, =, n, ., getParent, (, ), ;, Node, left, =]
[parent, =, n, ., getParent, (, ), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =]
[parent, =, n, ., getParent, (, ), ;, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =]
[Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (]
[Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (]
[Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (]
[(, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, parent, ., isExprResult, (, ), &&]
[), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, parent, ., isExprResult, (, ), &&, !]
[), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, parent, ., isExprResult, (, ), &&, !]
[), ;, Node, right, =, n, ., getLastChild, (, ), ;, if, (, parent, ., isExprResult, (, ), &&, !]
[if, (, parent, ., isExprResult, (, ), &&, !, parent, ., getParent, (, ), ., isLabel, (, ), ), {]
[if, (, parent, ., isExprResult, (, ), &&, !, parent, ., getParent, (, ), ., isLabel, (, ), ), {]
[), &&, !, parent, ., getParent, (, ), ., isLabel, (, ), ), {, n, ., detachChildren, (, ), ;]
[), &&, !, parent, ., getParent, (, ), ., isLabel, (, ), ), {, n, ., detachChildren, (, ), ;]
[., getParent, (, ), ., isLabel, (, ), ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (]
[(, ), ., isLabel, (, ), ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,]
[), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =]
[), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =]
[detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =, IR, ., exprResult, (]
[;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;]
[;, parent, ., replaceChild, (, n, ,, left, ), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;]
[(, n, ,, left, ), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;, newStatement, ., copyInformationFrom, (]
[left, ), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;, newStatement, ., copyInformationFrom, (, n, ), ;]
[left, ), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;, newStatement, ., copyInformationFrom, (, n, ), ;]
[left, ), ;, Node, newStatement, =, IR, ., exprResult, (, right, ), ;, newStatement, ., copyInformationFrom, (, n, ), ;]
[exprResult, (, right, ), ;, newStatement, ., copyInformationFrom, (, n, ), ;, parent, ., getParent, (, ), ., addChildAfter, (]
[right, ), ;, newStatement, ., copyInformationFrom, (, n, ), ;, parent, ., getParent, (, ), ., addChildAfter, (, newStatement, ,]
[newStatement, ., copyInformationFrom, (, n, ), ;, parent, ., getParent, (, ), ., addChildAfter, (, newStatement, ,, parent, ), ;]
[), ;, parent, ., getParent, (, ), ., addChildAfter, (, newStatement, ,, parent, ), ;, reportCodeChange, (, ), ;, return]
[), ., addChildAfter, (, newStatement, ,, parent, ), ;, reportCodeChange, (, ), ;, return, left, ;, }, else, {, return]
[else, {, return, n, ;, }, }, private, Node, tryReplaceIf, (, Node, n, ), {, for, (, Node, child, =]
[else, {, return, n, ;, }, }, private, Node, tryReplaceIf, (, Node, n, ), {, for, (, Node, child, =]
[}, private, Node, tryReplaceIf, (, Node, n, ), {, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[}, private, Node, tryReplaceIf, (, Node, n, ), {, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[Node, tryReplaceIf, (, Node, n, ), {, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=]
[(, Node, n, ), {, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;]
[n, ), {, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[n, ), {, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[=, child, ., getNext, (, ), ), {, if, (, child, ., isIf, (, ), ), {, Node, cond, =]
[=, child, ., getNext, (, ), ), {, if, (, child, ., isIf, (, ), ), {, Node, cond, =]
[(, child, ., isIf, (, ), ), {, Node, cond, =, child, ., getFirstChild, (, ), ;, Node, thenBranch, =]
[(, child, ., isIf, (, ), ), {, Node, cond, =, child, ., getFirstChild, (, ), ;, Node, thenBranch, =]
[cond, =, child, ., getFirstChild, (, ), ;, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =]
[cond, =, child, ., getFirstChild, (, ), ;, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =]
[thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node, nextNode, =]
[thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node, nextNode, =]
[Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (]
[Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (]
[Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (]
[Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (]
[Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (]
[=, thenBranch, ., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (, nextNode, !=]
[., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (, nextNode, !=, null, &&]
[., getNext, (, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (, nextNode, !=, null, &&]
[(, ), ;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (, nextNode, !=, null, &&, elseBranch, ==]
[;, Node, nextNode, =, child, ., getNext, (, ), ;, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&]
[nextNode, =, child, ., getNext, (, ), ;, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (]
[., getNext, (, ), ;, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&]
[., getNext, (, ), ;, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&]
[&&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =]
[&&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =]
[&&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen, =]
[&&, nextNode, ., isIf, (, ), ), {, Node, nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen, =]
[nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen, =, nextCond, ., getNext, (, ), ;, Node, nextElse, =]
[nextCond, =, nextNode, ., getFirstChild, (, ), ;, Node, nextThen, =, nextCond, ., getNext, (, ), ;, Node, nextElse, =]
[Node, nextThen, =, nextCond, ., getNext, (, ), ;, Node, nextElse, =, nextThen, ., getNext, (, ), ;, if, (]
[Node, nextThen, =, nextCond, ., getNext, (, ), ;, Node, nextElse, =, nextThen, ., getNext, (, ), ;, if, (]
[., getNext, (, ), ;, Node, nextElse, =, nextThen, ., getNext, (, ), ;, if, (, thenBranch, ., isEquivalentToTyped, (]
[;, Node, nextElse, =, nextThen, ., getNext, (, ), ;, if, (, thenBranch, ., isEquivalentToTyped, (, nextThen, ), ), {]
[;, Node, nextElse, =, nextThen, ., getNext, (, ), ;, if, (, thenBranch, ., isEquivalentToTyped, (, nextThen, ), ), {]
[getNext, (, ), ;, if, (, thenBranch, ., isEquivalentToTyped, (, nextThen, ), ), {, child, ., detachFromParent, (, ), ;]
[getNext, (, ), ;, if, (, thenBranch, ., isEquivalentToTyped, (, nextThen, ), ), {, child, ., detachFromParent, (, ), ;]
[(, nextThen, ), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =]
[), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (]
[), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (]
[detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., OR, ,]
[;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., OR, ,, cond, ), ;]
[;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., OR, ,, cond, ), ;]
[(, ), ;, Node, newCond, =, new, Node, (, Token, ., OR, ,, cond, ), ;, nextNode, ., replaceChild, (]
[;, Node, newCond, =, new, Node, (, Token, ., OR, ,, cond, ), ;, nextNode, ., replaceChild, (, nextCond, ,]
[=, new, Node, (, Token, ., OR, ,, cond, ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;]
[=, new, Node, (, Token, ., OR, ,, cond, ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;]
[Token, ., OR, ,, cond, ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (]
[,, cond, ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;]
[nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (]
[nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (]
[nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (]
[newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=]
[;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null, &&]
[;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null, &&]
[(, nextCond, ), ;, reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null, &&, thenBranch, ., isEquivalentToTyped, (]
[reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null, &&, thenBranch, ., isEquivalentToTyped, (, nextElse, ), ), {]
[reportCodeChange, (, ), ;, }, else, if, (, nextElse, !=, null, &&, thenBranch, ., isEquivalentToTyped, (, nextElse, ), ), {]
[if, (, nextElse, !=, null, &&, thenBranch, ., isEquivalentToTyped, (, nextElse, ), ), {, child, ., detachFromParent, (, ), ;]
[if, (, nextElse, !=, null, &&, thenBranch, ., isEquivalentToTyped, (, nextElse, ), ), {, child, ., detachFromParent, (, ), ;]
[(, nextElse, ), ), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =]
[), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (]
[), {, child, ., detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (]
[detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., AND, ,]
[detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., AND, ,]
[detachFromParent, (, ), ;, child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., AND, ,]
[child, ., detachChildren, (, ), ;, Node, newCond, =, new, Node, (, Token, ., AND, ,, IR, ., not, (]
[;, Node, newCond, =, new, Node, (, Token, ., AND, ,, IR, ., not, (, cond, ), ., srcref, (]
[new, Node, (, Token, ., AND, ,, IR, ., not, (, cond, ), ., srcref, (, cond, ), ), ;]
[new, Node, (, Token, ., AND, ,, IR, ., not, (, cond, ), ., srcref, (, cond, ), ), ;]
[., AND, ,, IR, ., not, (, cond, ), ., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (]
[,, IR, ., not, (, cond, ), ., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (, nextCond, ,]
[not, (, cond, ), ., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;]
[not, (, cond, ), ., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;]
[., srcref, (, cond, ), ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (]
[cond, ), ), ;, nextNode, ., replaceChild, (, nextCond, ,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;]
[,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (]
[,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (]
[,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (]
[,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (]
[,, newCond, ), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (]
[), ;, newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=]
[newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=, null, &&]
[newCond, ., addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=, null, &&]
[addChildToBack, (, nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=, null, &&, elseBranch, ==]
[nextCond, ), ;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&]
[;, reportCodeChange, (, ), ;, }, }, else, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (]
[), ;, }, }, else, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&]
[}, }, else, if, (, nextNode, !=, null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (]
[null, &&, elseBranch, ==, null, &&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =]
[null, &&, isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (]
[isReturnBlock, (, thenBranch, ), &&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (]
[&&, isReturnExpression, (, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {]
[(, nextNode, ), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {, thenExpr, =]
[), ), {, Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {, thenExpr, =, getBlockReturnExpression, (]
[Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;]
[Node, thenExpr, =, null, ;, if, (, isReturnExpressBlock, (, thenBranch, ), ), {, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;]
[thenBranch, ), ), {, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, thenExpr, ., detachFromParent, (, ), ;, }, else, {]
[), {, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, thenExpr, ., detachFromParent, (, ), ;, }, else, {, thenExpr, =]
[), {, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, thenExpr, ., detachFromParent, (, ), ;, }, else, {, thenExpr, =]
[getBlockReturnExpression, (, thenBranch, ), ;, thenExpr, ., detachFromParent, (, ), ;, }, else, {, thenExpr, =, NodeUtil, ., newUndefinedNode, (]
[detachFromParent, (, ), ;, }, else, {, thenExpr, =, NodeUtil, ., newUndefinedNode, (, child, ), ;, }, Node, elseExpr, =]
[detachFromParent, (, ), ;, }, else, {, thenExpr, =, NodeUtil, ., newUndefinedNode, (, child, ), ;, }, Node, elseExpr, =]
[{, thenExpr, =, NodeUtil, ., newUndefinedNode, (, child, ), ;, }, Node, elseExpr, =, nextNode, ., getFirstChild, (, ), ;]
[{, thenExpr, =, NodeUtil, ., newUndefinedNode, (, child, ), ;, }, Node, elseExpr, =, nextNode, ., getFirstChild, (, ), ;]
[(, child, ), ;, }, Node, elseExpr, =, nextNode, ., getFirstChild, (, ), ;, cond, ., detachFromParent, (, ), ;]
[(, child, ), ;, }, Node, elseExpr, =, nextNode, ., getFirstChild, (, ), ;, cond, ., detachFromParent, (, ), ;]
[., getFirstChild, (, ), ;, cond, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =]
[., getFirstChild, (, ), ;, cond, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =]
[;, cond, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (]
[;, cond, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (]
[;, cond, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (]
[(, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (]
[;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,]
[., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,]
[Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (]
[., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, child, ), ), ;]
[., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, child, ), ), ;]
[., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, child, ), ), ;, n, ., replaceChild, (]
[(, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, child, ), ), ;, n, ., replaceChild, (, child, ,]
[thenExpr, ,, elseExpr, ), ., srcref, (, child, ), ), ;, n, ., replaceChild, (, child, ,, returnNode, ), ;]
[thenExpr, ,, elseExpr, ), ., srcref, (, child, ), ), ;, n, ., replaceChild, (, child, ,, returnNode, ), ;]
[., srcref, (, child, ), ), ;, n, ., replaceChild, (, child, ,, returnNode, ), ;, n, ., removeChild, (]
[child, ), ), ;, n, ., replaceChild, (, child, ,, returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;]
[child, ,, returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (]
[child, ,, returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (]
[child, ,, returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (]
[returnNode, ), ;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=]
[;, n, ., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=, null, &&]
[., removeChild, (, nextNode, ), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (]
[), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (, thenBranch, ), ), {]
[), ;, reportCodeChange, (, ), ;, }, else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (, thenBranch, ), ), {]
[), ;, }, else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (, thenBranch, ), ), {, child, ., removeChild, (]
[else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (, thenBranch, ), ), {, child, ., removeChild, (, elseBranch, ), ;]
[else, if, (, elseBranch, !=, null, &&, statementMustExitParent, (, thenBranch, ), ), {, child, ., removeChild, (, elseBranch, ), ;]
[!=, null, &&, statementMustExitParent, (, thenBranch, ), ), {, child, ., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (]
[&&, statementMustExitParent, (, thenBranch, ), ), {, child, ., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (, elseBranch, ,]
[thenBranch, ), ), {, child, ., removeChild, (, elseBranch, ), ;, n, ., addChildAfter, (, elseBranch, ,, child, ), ;]
[elseBranch, ), ;, n, ., addChildAfter, (, elseBranch, ,, child, ), ;, reportCodeChange, (, ), ;, }, }, }, return]
[(, ), ;, }, }, }, return, n, ;, }, private, boolean, statementMustExitParent, (, Node, n, ), {, switch, (]
[(, ), ;, }, }, }, return, n, ;, }, private, boolean, statementMustExitParent, (, Node, n, ), {, switch, (]
[;, }, private, boolean, statementMustExitParent, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[;, }, private, boolean, statementMustExitParent, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., THROW, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., THROW, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., THROW, :, case, Token, ., RETURN, :, return]
[., getType, (, ), ), {, case, Token, ., THROW, :, case, Token, ., RETURN, :, return, true, ;, case]
[., getType, (, ), ), {, case, Token, ., THROW, :, case, Token, ., RETURN, :, return, true, ;, case]
[case, Token, ., THROW, :, case, Token, ., RETURN, :, return, true, ;, case, Token, ., BLOCK, :, if, (]
[case, Token, ., THROW, :, case, Token, ., RETURN, :, return, true, ;, case, Token, ., BLOCK, :, if, (]
[return, true, ;, case, Token, ., BLOCK, :, if, (, n, ., hasChildren, (, ), ), {, Node, child, =]
[return, true, ;, case, Token, ., BLOCK, :, if, (, n, ., hasChildren, (, ), ), {, Node, child, =]
[:, if, (, n, ., hasChildren, (, ), ), {, Node, child, =, n, ., getLastChild, (, ), ;, return]
[(, n, ., hasChildren, (, ), ), {, Node, child, =, n, ., getLastChild, (, ), ;, return, statementMustExitParent, (]
[), ), {, Node, child, =, n, ., getLastChild, (, ), ;, return, statementMustExitParent, (, child, ), ;, }, return]
[Node, child, =, n, ., getLastChild, (, ), ;, return, statementMustExitParent, (, child, ), ;, }, return, false, ;, case]
[Node, child, =, n, ., getLastChild, (, ), ;, return, statementMustExitParent, (, child, ), ;, }, return, false, ;, case]
[), ;, return, statementMustExitParent, (, child, ), ;, }, return, false, ;, case, Token, ., FUNCTION, :, default, :, return]
[., FUNCTION, :, default, :, return, false, ;, }, }, private, Node, tryReplaceUndefined, (, Node, n, ), {, if, (]
[., FUNCTION, :, default, :, return, false, ;, }, }, private, Node, tryReplaceUndefined, (, Node, n, ), {, if, (]
[., FUNCTION, :, default, :, return, false, ;, }, }, private, Node, tryReplaceUndefined, (, Node, n, ), {, if, (]
[:, return, false, ;, }, }, private, Node, tryReplaceUndefined, (, Node, n, ), {, if, (, isASTNormalized, (, ), &&]
[:, return, false, ;, }, }, private, Node, tryReplaceUndefined, (, Node, n, ), {, if, (, isASTNormalized, (, ), &&]
[}, }, private, Node, tryReplaceUndefined, (, Node, n, ), {, if, (, isASTNormalized, (, ), &&, NodeUtil, ., isUndefined, (]
[Node, tryReplaceUndefined, (, Node, n, ), {, if, (, isASTNormalized, (, ), &&, NodeUtil, ., isUndefined, (, n, ), &&]
[tryReplaceUndefined, (, Node, n, ), {, if, (, isASTNormalized, (, ), &&, NodeUtil, ., isUndefined, (, n, ), &&, !]
[tryReplaceUndefined, (, Node, n, ), {, if, (, isASTNormalized, (, ), &&, NodeUtil, ., isUndefined, (, n, ), &&, !]
[), {, if, (, isASTNormalized, (, ), &&, NodeUtil, ., isUndefined, (, n, ), &&, !, NodeUtil, ., isLValue, (]
[&&, NodeUtil, ., isUndefined, (, n, ), &&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =]
[&&, NodeUtil, ., isUndefined, (, n, ), &&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =]
[(, n, ), &&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (]
[&&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;]
[&&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;]
[&&, !, NodeUtil, ., isLValue, (, n, ), ), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;]
[), {, Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[Node, replacement, =, NodeUtil, ., newUndefinedNode, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[NodeUtil, ., newUndefinedNode, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
[getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, return]
[;, return, replacement, ;, }, return, n, ;, }, private, Node, tryReduceReturn, (, Node, n, ), {, Node, result, =]
[;, return, replacement, ;, }, return, n, ;, }, private, Node, tryReduceReturn, (, Node, n, ), {, Node, result, =]
[}, private, Node, tryReduceReturn, (, Node, n, ), {, Node, result, =, n, ., getFirstChild, (, ), ;, if, (]
[}, private, Node, tryReduceReturn, (, Node, n, ), {, Node, result, =, n, ., getFirstChild, (, ), ;, if, (]
[Node, tryReduceReturn, (, Node, n, ), {, Node, result, =, n, ., getFirstChild, (, ), ;, if, (, result, !=]
[), {, Node, result, =, n, ., getFirstChild, (, ), ;, if, (, result, !=, null, ), {, switch, (]
[), {, Node, result, =, n, ., getFirstChild, (, ), ;, if, (, result, !=, null, ), {, switch, (]
[(, ), ;, if, (, result, !=, null, ), {, switch, (, result, ., getType, (, ), ), {, case]
[(, ), ;, if, (, result, !=, null, ), {, switch, (, result, ., getType, (, ), ), {, case]
[null, ), {, switch, (, result, ., getType, (, ), ), {, case, Token, ., VOID, :, Node, operand, =]
[null, ), {, switch, (, result, ., getType, (, ), ), {, case, Token, ., VOID, :, Node, operand, =]
[(, ), ), {, case, Token, ., VOID, :, Node, operand, =, result, ., getFirstChild, (, ), ;, if, (]
[), ), {, case, Token, ., VOID, :, Node, operand, =, result, ., getFirstChild, (, ), ;, if, (, !]
[{, case, Token, ., VOID, :, Node, operand, =, result, ., getFirstChild, (, ), ;, if, (, !, mayHaveSideEffects, (]
[VOID, :, Node, operand, =, result, ., getFirstChild, (, ), ;, if, (, !, mayHaveSideEffects, (, operand, ), ), {]
[VOID, :, Node, operand, =, result, ., getFirstChild, (, ), ;, if, (, !, mayHaveSideEffects, (, operand, ), ), {]
[., getFirstChild, (, ), ;, if, (, !, mayHaveSideEffects, (, operand, ), ), {, n, ., removeFirstChild, (, ), ;]
[mayHaveSideEffects, (, operand, ), ), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, case]
[mayHaveSideEffects, (, operand, ), ), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, case]
[., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, case, Token, ., NAME, :, String, name, =]
[., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, case, Token, ., NAME, :, String, name, =]
[;, }, break, ;, case, Token, ., NAME, :, String, name, =, result, ., getString, (, ), ;, if, (]
[;, }, break, ;, case, Token, ., NAME, :, String, name, =, result, ., getString, (, ), ;, if, (]
[case, Token, ., NAME, :, String, name, =, result, ., getString, (, ), ;, if, (, name, ., equals, (]
[:, String, name, =, result, ., getString, (, ), ;, if, (, name, ., equals, (, "undefined", ), ), {]
[:, String, name, =, result, ., getString, (, ), ;, if, (, name, ., equals, (, "undefined", ), ), {]
[getString, (, ), ;, if, (, name, ., equals, (, "undefined", ), ), {, n, ., removeFirstChild, (, ), ;]
["undefined", ), ), {, n, ., removeFirstChild, (, ), ;, reportCodeChange, (, ), ;, }, break, ;, }, }, return]
[}, break, ;, }, }, return, n, ;, }, private, Node, tryReplaceExitWithBreak, (, Node, n, ), {, Node, result, =]
[}, break, ;, }, }, return, n, ;, }, private, Node, tryReplaceExitWithBreak, (, Node, n, ), {, Node, result, =]
[private, Node, tryReplaceExitWithBreak, (, Node, n, ), {, Node, result, =, n, ., getFirstChild, (, ), ;, Node, breakTarget, =]
[n, ), {, Node, result, =, n, ., getFirstChild, (, ), ;, Node, breakTarget, =, n, ;, for, (, ;]
[), {, Node, result, =, n, ., getFirstChild, (, ), ;, Node, breakTarget, =, n, ;, for, (, ;, !]
[), {, Node, result, =, n, ., getFirstChild, (, ), ;, Node, breakTarget, =, n, ;, for, (, ;, !]
[=, n, ., getFirstChild, (, ), ;, Node, breakTarget, =, n, ;, for, (, ;, !, ControlFlowAnalysis, ., isBreakTarget, (]
[., getFirstChild, (, ), ;, Node, breakTarget, =, n, ;, for, (, ;, !, ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,]
[), ;, Node, breakTarget, =, n, ;, for, (, ;, !, ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, ), ;]
[Node, breakTarget, =, n, ;, for, (, ;, !, ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, ), ;, breakTarget, =]
[Node, breakTarget, =, n, ;, for, (, ;, !, ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, ), ;, breakTarget, =]
[ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, ), ;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (]
[ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, ), ;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (]
[ControlFlowAnalysis, ., isBreakTarget, (, breakTarget, ,, null, ), ;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (]
[null, ), ;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (, breakTarget, ., isFunction, (, ), ||]
[null, ), ;, breakTarget, =, breakTarget, ., getParent, (, ), ), {, if, (, breakTarget, ., isFunction, (, ), ||]
[(, ), ), {, if, (, breakTarget, ., isFunction, (, ), ||, breakTarget, ., isScript, (, ), ), {, return]
[., isFunction, (, ), ||, breakTarget, ., isScript, (, ), ), {, return, n, ;, }, }, Node, follow, =]
[., isFunction, (, ), ||, breakTarget, ., isScript, (, ), ), {, return, n, ;, }, }, Node, follow, =]
[||, breakTarget, ., isScript, (, ), ), {, return, n, ;, }, }, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (]
[), {, return, n, ;, }, }, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =]
[return, n, ;, }, }, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =, follow, ;]
[;, }, }, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =]
[}, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (]
[., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (]
[., computeFollowNode, (, breakTarget, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (]
[(, breakTarget, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=]
[prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (]
[=, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !]
[;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (]
[follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (, result, ), ), {, return]
[!=, follow, ), {, if, (, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (]
[!=, follow, ), {, if, (, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (]
[!=, follow, ), {, if, (, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (]
[), {, if, (, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (, follow, ==]
[if, (, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&]
[(, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (]
[(, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (]
[(, !, isPure, (, result, ), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (]
[), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||]
[), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||]
[return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||, result, !=]
[if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||, result, !=, null, ), ), {, return]
[&&, (, n, ., isThrow, (, ), ||, result, !=, null, ), ), {, return, n, ;, }, if, (]
[&&, (, n, ., isThrow, (, ), ||, result, !=, null, ), ), {, return, n, ;, }, if, (]
[&&, (, n, ., isThrow, (, ), ||, result, !=, null, ), ), {, return, n, ;, }, if, (]
[n, ., isThrow, (, ), ||, result, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==]
[isThrow, (, ), ||, result, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||]
[), ||, result, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (]
[result, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,]
[n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, Node, replacement, =]
[n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, Node, replacement, =]
[==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, Node, replacement, =, IR, ., breakNode, (, ), ;]
[==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, Node, replacement, =, IR, ., breakNode, (, ), ;]
[==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, Node, replacement, =, IR, ., breakNode, (, ), ;]
[), ), {, Node, replacement, =, IR, ., breakNode, (, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[{, Node, replacement, =, IR, ., breakNode, (, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[=, IR, ., breakNode, (, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;]
[=, IR, ., breakNode, (, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;]
[n, ., getParent, (, ), ., replaceChild, (, n, ,, replacement, ), ;, this, ., reportCodeChange, (, ), ;, return]
[), ., replaceChild, (, n, ,, replacement, ), ;, this, ., reportCodeChange, (, ), ;, return, replacement, ;, }, return]
[;, return, replacement, ;, }, return, n, ;, }, private, Node, tryRemoveRedundantExit, (, Node, n, ), {, Node, exitExpr, =]
[;, return, replacement, ;, }, return, n, ;, }, private, Node, tryRemoveRedundantExit, (, Node, n, ), {, Node, exitExpr, =]
[private, Node, tryRemoveRedundantExit, (, Node, n, ), {, Node, exitExpr, =, n, ., getFirstChild, (, ), ;, Node, follow, =]
[private, Node, tryRemoveRedundantExit, (, Node, n, ), {, Node, exitExpr, =, n, ., getFirstChild, (, ), ;, Node, follow, =]
[Node, n, ), {, Node, exitExpr, =, n, ., getFirstChild, (, ), ;, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (]
[=, n, ., getFirstChild, (, ), ;, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, Node, prefinallyFollows, =]
[., getFirstChild, (, ), ;, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, Node, prefinallyFollows, =, follow, ;]
[(, ), ;, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =]
[;, Node, follow, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (]
[., computeFollowNode, (, n, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (]
[., computeFollowNode, (, n, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (]
[(, n, ), ;, Node, prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=]
[prefinallyFollows, =, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (]
[=, follow, ;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !]
[;, follow, =, skipFinallyNodes, (, follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (]
[follow, ), ;, if, (, prefinallyFollows, !=, follow, ), {, if, (, !, isPure, (, exitExpr, ), ), {, return]
[!=, follow, ), {, if, (, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (]
[!=, follow, ), {, if, (, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (]
[!=, follow, ), {, if, (, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (]
[), {, if, (, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (, follow, ==]
[if, (, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&]
[(, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (]
[(, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (]
[(, !, isPure, (, exitExpr, ), ), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (]
[), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||]
[), {, return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||]
[return, n, ;, }, }, if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||, exitExpr, !=]
[if, (, follow, ==, null, &&, (, n, ., isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return]
[&&, (, n, ., isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (]
[&&, (, n, ., isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (]
[&&, (, n, ., isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (]
[n, ., isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==]
[isThrow, (, ), ||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||]
[), ||, exitExpr, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (]
[exitExpr, !=, null, ), ), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,]
[), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {]
[), {, return, n, ;, }, if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {]
[if, (, follow, ==, null, ||, areMatchingExits, (, n, ,, follow, ), ), {, n, ., detachFromParent, (, ), ;]
[||, areMatchingExits, (, n, ,, follow, ), ), {, n, ., detachFromParent, (, ), ;, reportCodeChange, (, ), ;, return]
[,, follow, ), ), {, n, ., detachFromParent, (, ), ;, reportCodeChange, (, ), ;, return, null, ;, }, return]
[reportCodeChange, (, ), ;, return, null, ;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return]
[reportCodeChange, (, ), ;, return, null, ;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return]
[reportCodeChange, (, ), ;, return, null, ;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return]
[), ;, return, null, ;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return, n, ==]
[return, null, ;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return, n, ==, null, ||]
[null, ;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return, n, ==, null, ||, (]
[null, ;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return, n, ==, null, ||, (]
[;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return, n, ==, null, ||, (, !]
[;, }, return, n, ;, }, boolean, isPure, (, Node, n, ), {, return, n, ==, null, ||, (, !]
[;, }, boolean, isPure, (, Node, n, ), {, return, n, ==, null, ||, (, !, NodeUtil, ., canBeSideEffected, (]
[isPure, (, Node, n, ), {, return, n, ==, null, ||, (, !, NodeUtil, ., canBeSideEffected, (, n, ), &&]
[(, Node, n, ), {, return, n, ==, null, ||, (, !, NodeUtil, ., canBeSideEffected, (, n, ), &&, !]
[n, ), {, return, n, ==, null, ||, (, !, NodeUtil, ., canBeSideEffected, (, n, ), &&, !, mayHaveSideEffects, (]
[n, ), &&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (]
[n, ), &&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (]
[n, ), &&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (]
[&&, !, mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=]
[mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&]
[mayHaveSideEffects, (, n, ), ), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&]
[), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (]
[), ;, }, Node, skipFinallyNodes, (, Node, n, ), {, while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (]
[Node, n, ), {, while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,]
[while, (, n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, ), ), {]
[n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, ), ), {, n, =]
[n, !=, null, &&, NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, ), ), {, n, =]
[NodeUtil, ., isTryFinallyNode, (, n, ., getParent, (, ), ,, n, ), ), {, n, =, ControlFlowAnalysis, ., computeFollowNode, (]
[., getParent, (, ), ,, n, ), ), {, n, =, ControlFlowAnalysis, ., computeFollowNode, (, n, ), ;, }, return]
[(, n, ), ;, }, return, n, ;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return]
[(, n, ), ;, }, return, n, ;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return]
[(, n, ), ;, }, return, n, ;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return]
[}, return, n, ;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (]
[;, }, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&]
[}, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&, (]
[}, boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&, (]
[boolean, areMatchingExits, (, Node, nodeThis, ,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&, (, !]
[(, Node, nodeThis, ,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&, (, !, isExceptionPossible, (]
[,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&, (, !, isExceptionPossible, (, nodeThis, ), ||]
[,, Node, nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&, (, !, isExceptionPossible, (, nodeThis, ), ||]
[nodeThat, ), {, return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&, (, !, isExceptionPossible, (, nodeThis, ), ||, getExceptionHandler, (]
[return, nodeThis, ., isEquivalentTo, (, nodeThat, ), &&, (, !, isExceptionPossible, (, nodeThis, ), ||, getExceptionHandler, (, nodeThis, ), ==]
[., isEquivalentTo, (, nodeThat, ), &&, (, !, isExceptionPossible, (, nodeThis, ), ||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (]
[||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {]
[||, getExceptionHandler, (, nodeThis, ), ==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {]
[), ==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (]
[), ==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (]
[), ==, getExceptionHandler, (, nodeThat, ), ), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (]
[), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||]
[), ;, }, boolean, isExceptionPossible, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||]
[), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||, n, ., isThrow, (, ), ), ;, return]
[), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||, n, ., isThrow, (, ), ), ;, return]
[), {, Preconditions, ., checkState, (, n, ., isReturn, (, ), ||, n, ., isThrow, (, ), ), ;, return]
[n, ., isReturn, (, ), ||, n, ., isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||]
[., isReturn, (, ), ||, n, ., isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||, (]
[., isReturn, (, ), ||, n, ., isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||, (]
[., isReturn, (, ), ||, n, ., isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||, (]
[., isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&]
[isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&, !]
[isThrow, (, ), ), ;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&, !]
[;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (]
[;, return, n, ., isThrow, (, ), ||, (, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (]
[), ||, (, n, ., hasChildren, (, ), &&, !, NodeUtil, ., isLiteralValue, (, n, ., getLastChild, (, ), ,]
[(, n, ., getLastChild, (, ), ,, true, ), ), ;, }, Node, getExceptionHandler, (, Node, n, ), {, return]
[(, n, ., getLastChild, (, ), ,, true, ), ), ;, }, Node, getExceptionHandler, (, Node, n, ), {, return]
[(, ), ,, true, ), ), ;, }, Node, getExceptionHandler, (, Node, n, ), {, return, ControlFlowAnalysis, ., getExceptionHandler, (]
[return, ControlFlowAnalysis, ., getExceptionHandler, (, n, ), ;, }, private, Node, tryMinimizeNot, (, Node, n, ), {, Node, parent, =]
[return, ControlFlowAnalysis, ., getExceptionHandler, (, n, ), ;, }, private, Node, tryMinimizeNot, (, Node, n, ), {, Node, parent, =]
[private, Node, tryMinimizeNot, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, notChild, =]
[private, Node, tryMinimizeNot, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, notChild, =]
[n, ., getParent, (, ), ;, Node, notChild, =, n, ., getFirstChild, (, ), ;, int, complementOperator, ;, switch, (]
[n, ., getParent, (, ), ;, Node, notChild, =, n, ., getFirstChild, (, ), ;, int, complementOperator, ;, switch, (]
[=, n, ., getFirstChild, (, ), ;, int, complementOperator, ;, switch, (, notChild, ., getType, (, ), ), {, case]
[=, n, ., getFirstChild, (, ), ;, int, complementOperator, ;, switch, (, notChild, ., getType, (, ), ), {, case]
[(, ), ;, int, complementOperator, ;, switch, (, notChild, ., getType, (, ), ), {, case, Token, ., EQ, :]
[;, int, complementOperator, ;, switch, (, notChild, ., getType, (, ), ), {, case, Token, ., EQ, :, complementOperator, =]
[;, int, complementOperator, ;, switch, (, notChild, ., getType, (, ), ), {, case, Token, ., EQ, :, complementOperator, =]
[., getType, (, ), ), {, case, Token, ., EQ, :, complementOperator, =, Token, ., NE, ;, break, ;, case]
[., getType, (, ), ), {, case, Token, ., EQ, :, complementOperator, =, Token, ., NE, ;, break, ;, case]
[), {, case, Token, ., EQ, :, complementOperator, =, Token, ., NE, ;, break, ;, case, Token, ., NE, :]
[case, Token, ., EQ, :, complementOperator, =, Token, ., NE, ;, break, ;, case, Token, ., NE, :, complementOperator, =]
[case, Token, ., EQ, :, complementOperator, =, Token, ., NE, ;, break, ;, case, Token, ., NE, :, complementOperator, =]
[Token, ., NE, ;, break, ;, case, Token, ., NE, :, complementOperator, =, Token, ., EQ, ;, break, ;, case]
[Token, ., NE, ;, break, ;, case, Token, ., NE, :, complementOperator, =, Token, ., EQ, ;, break, ;, case]
[break, ;, case, Token, ., NE, :, complementOperator, =, Token, ., EQ, ;, break, ;, case, Token, ., SHEQ, :]
[case, Token, ., NE, :, complementOperator, =, Token, ., EQ, ;, break, ;, case, Token, ., SHEQ, :, complementOperator, =]
[case, Token, ., NE, :, complementOperator, =, Token, ., EQ, ;, break, ;, case, Token, ., SHEQ, :, complementOperator, =]
[Token, ., EQ, ;, break, ;, case, Token, ., SHEQ, :, complementOperator, =, Token, ., SHNE, ;, break, ;, case]
[Token, ., EQ, ;, break, ;, case, Token, ., SHEQ, :, complementOperator, =, Token, ., SHNE, ;, break, ;, case]
[break, ;, case, Token, ., SHEQ, :, complementOperator, =, Token, ., SHNE, ;, break, ;, case, Token, ., SHNE, :]
[case, Token, ., SHEQ, :, complementOperator, =, Token, ., SHNE, ;, break, ;, case, Token, ., SHNE, :, complementOperator, =]
[case, Token, ., SHEQ, :, complementOperator, =, Token, ., SHNE, ;, break, ;, case, Token, ., SHNE, :, complementOperator, =]
[SHNE, ;, break, ;, case, Token, ., SHNE, :, complementOperator, =, Token, ., SHEQ, ;, break, ;, default, :, return]
[., SHNE, :, complementOperator, =, Token, ., SHEQ, ;, break, ;, default, :, return, n, ;, }, Node, newOperator, =]
[., SHNE, :, complementOperator, =, Token, ., SHEQ, ;, break, ;, default, :, return, n, ;, }, Node, newOperator, =]
[., SHEQ, ;, break, ;, default, :, return, n, ;, }, Node, newOperator, =, n, ., removeFirstChild, (, ), ;]
[., SHEQ, ;, break, ;, default, :, return, n, ;, }, Node, newOperator, =, n, ., removeFirstChild, (, ), ;]
[;, default, :, return, n, ;, }, Node, newOperator, =, n, ., removeFirstChild, (, ), ;, newOperator, ., setType, (]
[return, n, ;, }, Node, newOperator, =, n, ., removeFirstChild, (, ), ;, newOperator, ., setType, (, complementOperator, ), ;]
[return, n, ;, }, Node, newOperator, =, n, ., removeFirstChild, (, ), ;, newOperator, ., setType, (, complementOperator, ), ;]
[Node, newOperator, =, n, ., removeFirstChild, (, ), ;, newOperator, ., setType, (, complementOperator, ), ;, parent, ., replaceChild, (]
[=, n, ., removeFirstChild, (, ), ;, newOperator, ., setType, (, complementOperator, ), ;, parent, ., replaceChild, (, n, ,]
[removeFirstChild, (, ), ;, newOperator, ., setType, (, complementOperator, ), ;, parent, ., replaceChild, (, n, ,, newOperator, ), ;]
[., setType, (, complementOperator, ), ;, parent, ., replaceChild, (, n, ,, newOperator, ), ;, reportCodeChange, (, ), ;, return]
[;, reportCodeChange, (, ), ;, return, newOperator, ;, }, private, Node, tryMinimizeIf, (, Node, n, ), {, Node, parent, =]
[;, reportCodeChange, (, ), ;, return, newOperator, ;, }, private, Node, tryMinimizeIf, (, Node, n, ), {, Node, parent, =]
[private, Node, tryMinimizeIf, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, cond, =]
[private, Node, tryMinimizeIf, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, cond, =]
[Node, parent, =, n, ., getParent, (, ), ;, Node, cond, =, n, ., getFirstChild, (, ), ;, if, (]
[Node, parent, =, n, ., getParent, (, ), ;, Node, cond, =, n, ., getFirstChild, (, ), ;, if, (]
[., getParent, (, ), ;, Node, cond, =, n, ., getFirstChild, (, ), ;, if, (, NodeUtil, ., isLiteralValue, (]
[(, ), ;, Node, cond, =, n, ., getFirstChild, (, ), ;, if, (, NodeUtil, ., isLiteralValue, (, cond, ,]
[=, n, ., getFirstChild, (, ), ;, if, (, NodeUtil, ., isLiteralValue, (, cond, ,, true, ), ), {, return]
[;, if, (, NodeUtil, ., isLiteralValue, (, cond, ,, true, ), ), {, return, n, ;, }, Node, thenBranch, =]
[;, if, (, NodeUtil, ., isLiteralValue, (, cond, ,, true, ), ), {, return, n, ;, }, Node, thenBranch, =]
[true, ), ), {, return, n, ;, }, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =]
[true, ), ), {, return, n, ;, }, Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =]
[Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (]
[Node, thenBranch, =, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (]
[=, cond, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, elseBranch, ==]
[), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, elseBranch, ==, null, ), {, if, (]
[Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, elseBranch, ==, null, ), {, if, (, isFoldableExpressBlock, (]
[), ;, if, (, elseBranch, ==, null, ), {, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =]
[if, (, elseBranch, ==, null, ), {, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =, getBlockExpression, (]
[), {, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (]
[), {, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (]
[{, if, (, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (, !]
[(, isFoldableExpressBlock, (, thenBranch, ), ), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (, !, late, &&]
[(, thenBranch, ), ), {, Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (, !, late, &&, isPropertyAssignmentInExpression, (]
[Node, expr, =, getBlockExpression, (, thenBranch, ), ;, if, (, !, late, &&, isPropertyAssignmentInExpression, (, expr, ), ), {, return]
[thenBranch, ), ;, if, (, !, late, &&, isPropertyAssignmentInExpression, (, expr, ), ), {, return, n, ;, }, if, (]
[thenBranch, ), ;, if, (, !, late, &&, isPropertyAssignmentInExpression, (, expr, ), ), {, return, n, ;, }, if, (]
[(, expr, ), ), {, return, n, ;, }, if, (, cond, ., isNot, (, ), ), {, if, (]
[(, expr, ), ), {, return, n, ;, }, if, (, cond, ., isNot, (, ), ), {, if, (]
[), ), {, return, n, ;, }, if, (, cond, ., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (]
[{, return, n, ;, }, if, (, cond, ., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (, cond, ,]
[;, }, if, (, cond, ., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, ), &&]
[if, (, cond, ., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (]
[if, (, cond, ., isNot, (, ), ), {, if, (, isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (]
[), ), {, if, (, isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,]
[isLowerPrecedenceInExpression, (, cond, ,, OR_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return]
[&&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return, n, ;, }, Node, or, =]
[&&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return, n, ;, }, Node, or, =]
[&&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return, n, ;, }, Node, or, =]
[., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return, n, ;, }, Node, or, =, IR, ., or, (]
[., getFirstChild, (, ), ,, OR_PRECEDENCE, ), ), {, return, n, ;, }, Node, or, =, IR, ., or, (]
[), ), {, return, n, ;, }, Node, or, =, IR, ., or, (, cond, ., removeFirstChild, (, ), ,]
[), ), {, return, n, ;, }, Node, or, =, IR, ., or, (, cond, ., removeFirstChild, (, ), ,]
[=, IR, ., or, (, cond, ., removeFirstChild, (, ), ,, expr, ., removeFirstChild, (, ), ), ., srcref, (]
[., removeFirstChild, (, ), ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =]
[., removeFirstChild, (, ), ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =]
[,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (]
[removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, ), ;]
[removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, ), ;]
[., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, ), ;, parent, ., replaceChild, (]
[(, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, ), ;, parent, ., replaceChild, (, n, ,]
[;, Node, newExpr, =, NodeUtil, ., newExpr, (, or, ), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;]
[., newExpr, (, or, ), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return]
[;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (]
[;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (]
[., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (]
[(, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,]
[newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&]
[;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (]
[;, reportCodeChange, (, ), ;, return, newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (]
[newExpr, ;, }, if, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,]
[isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE, ), ), {, return]
[,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }]
[,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }]
[isLowerPrecedenceInExpression, (, expr, ., getFirstChild, (, ), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }, n, ., removeChild, (]
[), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =]
[), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =]
[), ,, AND_PRECEDENCE, ), ), {, return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =]
[), {, return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =, IR, ., and, (]
[return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =, IR, ., and, (, cond, ,]
[return, n, ;, }, n, ., removeChild, (, cond, ), ;, Node, and, =, IR, ., and, (, cond, ,]
[), ;, Node, and, =, IR, ., and, (, cond, ,, expr, ., removeFirstChild, (, ), ), ., srcref, (]
[., and, (, cond, ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =]
[., and, (, cond, ,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =]
[,, expr, ., removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (]
[removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, ), ;]
[removeFirstChild, (, ), ), ., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, ), ;]
[., srcref, (, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, ), ;, parent, ., replaceChild, (]
[(, n, ), ;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, ), ;, parent, ., replaceChild, (, n, ,]
[;, Node, newExpr, =, NodeUtil, ., newExpr, (, and, ), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;]
[., newExpr, (, and, ), ;, parent, ., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return]
[., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (]
[., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (]
[., replaceChild, (, n, ,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (]
[,, newExpr, ), ;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (, NodeUtil, ., isStatementBlock, (]
[;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (, NodeUtil, ., isStatementBlock, (, thenBranch, ), &&]
[;, reportCodeChange, (, ), ;, return, newExpr, ;, }, else, {, if, (, NodeUtil, ., isStatementBlock, (, thenBranch, ), &&]
[{, if, (, NodeUtil, ., isStatementBlock, (, thenBranch, ), &&, thenBranch, ., hasOneChild, (, ), ), {, Node, innerIf, =]
[{, if, (, NodeUtil, ., isStatementBlock, (, thenBranch, ), &&, thenBranch, ., hasOneChild, (, ), ), {, Node, innerIf, =]
[), &&, thenBranch, ., hasOneChild, (, ), ), {, Node, innerIf, =, thenBranch, ., getFirstChild, (, ), ;, if, (]
[), &&, thenBranch, ., hasOneChild, (, ), ), {, Node, innerIf, =, thenBranch, ., getFirstChild, (, ), ;, if, (]
[innerIf, =, thenBranch, ., getFirstChild, (, ), ;, if, (, innerIf, ., isIf, (, ), ), {, Node, innerCond, =]
[innerIf, =, thenBranch, ., getFirstChild, (, ), ;, if, (, innerIf, ., isIf, (, ), ), {, Node, innerCond, =]
[(, innerIf, ., isIf, (, ), ), {, Node, innerCond, =, innerIf, ., getFirstChild, (, ), ;, Node, innerThenBranch, =]
[(, innerIf, ., isIf, (, ), ), {, Node, innerCond, =, innerIf, ., getFirstChild, (, ), ;, Node, innerThenBranch, =]
[innerCond, =, innerIf, ., getFirstChild, (, ), ;, Node, innerThenBranch, =, innerCond, ., getNext, (, ), ;, Node, innerElseBranch, =]
[innerCond, =, innerIf, ., getFirstChild, (, ), ;, Node, innerThenBranch, =, innerCond, ., getNext, (, ), ;, Node, innerElseBranch, =]
[Node, innerThenBranch, =, innerCond, ., getNext, (, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (]
[Node, innerThenBranch, =, innerCond, ., getNext, (, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (]
[Node, innerThenBranch, =, innerCond, ., getNext, (, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (]
[=, innerCond, ., getNext, (, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (, innerElseBranch, ==]
[., getNext, (, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&]
[getNext, (, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&, !]
[(, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&, !, (]
[(, ), ;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&, !, (]
[;, Node, innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&, !, (, isLowerPrecedenceInExpression, (]
[innerElseBranch, =, innerThenBranch, ., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,]
[., getNext, (, ), ;, if, (, innerElseBranch, ==, null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&]
[(, ), ;, if, (, innerElseBranch, ==, null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (]
[;, if, (, innerElseBranch, ==, null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,]
[null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {]
[null, &&, !, (, isLowerPrecedenceInExpression, (, cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {]
[cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;]
[cond, ,, AND_PRECEDENCE, ), &&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;]
[&&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (]
[&&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (]
[&&, isLowerPrecedenceInExpression, (, innerCond, ,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (]
[,, AND_PRECEDENCE, ), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (]
[), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (, cond, ,]
[), ), ), {, n, ., detachChildren, (, ), ;, n, ., addChildToBack, (, IR, ., and, (, cond, ,]
[;, n, ., addChildToBack, (, IR, ., and, (, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (]
[(, IR, ., and, (, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ), ;]
[(, IR, ., and, (, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ), ;]
[(, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ), ;, n, ., addChildrenToBack, (]
[(, cond, ,, innerCond, ., detachFromParent, (, ), ), ., srcref, (, cond, ), ), ;, n, ., addChildrenToBack, (]
[), ), ., srcref, (, cond, ), ), ;, n, ., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (, ), ), ;]
[cond, ), ), ;, n, ., addChildrenToBack, (, innerThenBranch, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return]
[(, innerThenBranch, ., detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, }, return]
[detachFromParent, (, ), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, }, return, n, ;, }]
[), ), ;, reportCodeChange, (, ), ;, return, n, ;, }, }, }, }, return, n, ;, }, tryRemoveRepeatedStatements, (]
[), ;, return, n, ;, }, }, }, }, return, n, ;, }, tryRemoveRepeatedStatements, (, n, ), ;, if, (]
[), ;, return, n, ;, }, }, }, }, return, n, ;, }, tryRemoveRepeatedStatements, (, n, ), ;, if, (]
[), ;, return, n, ;, }, }, }, }, return, n, ;, }, tryRemoveRepeatedStatements, (, n, ), ;, if, (]
[}, }, }, return, n, ;, }, tryRemoveRepeatedStatements, (, n, ), ;, if, (, cond, ., isNot, (, ), &&]
[}, }, return, n, ;, }, tryRemoveRepeatedStatements, (, n, ), ;, if, (, cond, ., isNot, (, ), &&, !]
[return, n, ;, }, tryRemoveRepeatedStatements, (, n, ), ;, if, (, cond, ., isNot, (, ), &&, !, consumesDanglingElse, (]
[tryRemoveRepeatedStatements, (, n, ), ;, if, (, cond, ., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, ), ), {]
[tryRemoveRepeatedStatements, (, n, ), ;, if, (, cond, ., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, ), ), {]
[;, if, (, cond, ., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, ), ), {, n, ., replaceChild, (]
[(, cond, ., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, ), ), {, n, ., replaceChild, (, cond, ,]
[(, cond, ., isNot, (, ), &&, !, consumesDanglingElse, (, elseBranch, ), ), {, n, ., replaceChild, (, cond, ,]
[!, consumesDanglingElse, (, elseBranch, ), ), {, n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;]
[!, consumesDanglingElse, (, elseBranch, ), ), {, n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;]
[), ), {, n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (]
[n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch, ), ;]
[n, ., replaceChild, (, cond, ,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch, ), ;]
[cond, ,, cond, ., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch, ), ;, n, ., addChildToBack, (]
[., removeFirstChild, (, ), ), ;, n, ., removeChild, (, thenBranch, ), ;, n, ., addChildToBack, (, thenBranch, ), ;]
[;, n, ., removeChild, (, thenBranch, ), ;, n, ., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return]
[thenBranch, ), ;, n, ., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, if, (]
[thenBranch, ), ;, n, ., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, if, (]
[;, n, ., addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, if, (, isReturnExpressBlock, (]
[addChildToBack, (, thenBranch, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, if, (, isReturnExpressBlock, (, thenBranch, ), &&]
[thenBranch, ), ;, reportCodeChange, (, ), ;, return, n, ;, }, if, (, isReturnExpressBlock, (, thenBranch, ), &&, isReturnExpressBlock, (]
[return, n, ;, }, if, (, isReturnExpressBlock, (, thenBranch, ), &&, isReturnExpressBlock, (, elseBranch, ), ), {, Node, thenExpr, =]
[;, }, if, (, isReturnExpressBlock, (, thenBranch, ), &&, isReturnExpressBlock, (, elseBranch, ), ), {, Node, thenExpr, =, getBlockReturnExpression, (]
[thenBranch, ), &&, isReturnExpressBlock, (, elseBranch, ), ), {, Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =]
[&&, isReturnExpressBlock, (, elseBranch, ), ), {, Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (]
[elseBranch, ), ), {, Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;]
[elseBranch, ), ), {, Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;]
[Node, thenExpr, =, getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n, ., removeChild, (]
[getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n, ., removeChild, (, cond, ), ;]
[getBlockReturnExpression, (, thenBranch, ), ;, Node, elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n, ., removeChild, (, cond, ), ;]
[elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n, ., removeChild, (, cond, ), ;, thenExpr, ., detachFromParent, (, ), ;]
[elseExpr, =, getBlockReturnExpression, (, elseBranch, ), ;, n, ., removeChild, (, cond, ), ;, thenExpr, ., detachFromParent, (, ), ;]
[removeChild, (, cond, ), ;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =]
[removeChild, (, cond, ), ;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =]
[;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (]
[;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (]
[;, thenExpr, ., detachFromParent, (, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (]
[(, ), ;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (]
[;, elseExpr, ., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,]
[., detachFromParent, (, ), ;, Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,]
[Node, returnNode, =, IR, ., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (]
[., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ), ;]
[., returnNode, (, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ), ;]
[., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (]
[(, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,]
[thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, returnNode, ), ;]
[srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange, (, ), ;, return]
[parent, ., replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange, (, ), ;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock, =]
[replaceChild, (, n, ,, returnNode, ), ;, reportCodeChange, (, ), ;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (]
[;, reportCodeChange, (, ), ;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;, boolean, elseBranchIsExpressionBlock, =]
[(, ), ;, return, returnNode, ;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (]
[;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, ), ;, if, (]
[;, }, boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, ), ;, if, (]
[boolean, thenBranchIsExpressionBlock, =, isFoldableExpressBlock, (, thenBranch, ), ;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, ), ;, if, (, thenBranchIsExpressionBlock, &&]
[), ;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, ), ;, if, (, thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =]
[), ;, boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, ), ;, if, (, thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =]
[boolean, elseBranchIsExpressionBlock, =, isFoldableExpressBlock, (, elseBranch, ), ;, if, (, thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =, getBlockExpression, (]
[thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, elseOp, =]
[thenBranchIsExpressionBlock, &&, elseBranchIsExpressionBlock, ), {, Node, thenOp, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, elseOp, =]
[elseBranchIsExpressionBlock, ), {, Node, thenOp, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, elseOp, =, getBlockExpression, (]
[), ., getFirstChild, (, ), ;, Node, elseOp, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, if, (]
[), ., getFirstChild, (, ), ;, Node, elseOp, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, if, (]
[), ., getFirstChild, (, ), ;, Node, elseOp, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, if, (]
[Node, elseOp, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, if, (, thenOp, ., getType, (, ), ==]
[Node, elseOp, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, if, (, thenOp, ., getType, (, ), ==]
[(, ), ;, if, (, thenOp, ., getType, (, ), ==, elseOp, ., getType, (, ), ), {, if, (]
[(, ), ;, if, (, thenOp, ., getType, (, ), ==, elseOp, ., getType, (, ), ), {, if, (]
[(, thenOp, ., getType, (, ), ==, elseOp, ., getType, (, ), ), {, if, (, NodeUtil, ., isAssignmentOp, (]
[elseOp, ., getType, (, ), ), {, if, (, NodeUtil, ., isAssignmentOp, (, thenOp, ), ), {, Node, lhs, =]
[elseOp, ., getType, (, ), ), {, if, (, NodeUtil, ., isAssignmentOp, (, thenOp, ), ), {, Node, lhs, =]
[(, NodeUtil, ., isAssignmentOp, (, thenOp, ), ), {, Node, lhs, =, thenOp, ., getFirstChild, (, ), ;, if, (]
[(, NodeUtil, ., isAssignmentOp, (, thenOp, ), ), {, Node, lhs, =, thenOp, ., getFirstChild, (, ), ;, if, (]
[., isAssignmentOp, (, thenOp, ), ), {, Node, lhs, =, thenOp, ., getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (]
[(, thenOp, ), ), {, Node, lhs, =, thenOp, ., getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (, lhs, ,]
[(, thenOp, ), ), {, Node, lhs, =, thenOp, ., getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (, lhs, ,]
[=, thenOp, ., getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild, (, ), ), &&]
[thenOp, ., getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild, (, ), ), &&, !]
[getFirstChild, (, ), ;, if, (, areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild, (, ), ), &&, !, mayEffectMutableState, (]
[if, (, areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild, (, ), ), &&, !, mayEffectMutableState, (, lhs, ), ), {]
[if, (, areNodesEqualForInlining, (, lhs, ,, elseOp, ., getFirstChild, (, ), ), &&, !, mayEffectMutableState, (, lhs, ), ), {]
[lhs, ,, elseOp, ., getFirstChild, (, ), ), &&, !, mayEffectMutableState, (, lhs, ), ), {, n, ., removeChild, (]
[), ), &&, !, mayEffectMutableState, (, lhs, ), ), {, n, ., removeChild, (, cond, ), ;, Node, assignName, =]
[), ), &&, !, mayEffectMutableState, (, lhs, ), ), {, n, ., removeChild, (, cond, ), ;, Node, assignName, =]
[{, n, ., removeChild, (, cond, ), ;, Node, assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr, =]
[{, n, ., removeChild, (, cond, ), ;, Node, assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr, =]
[assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr, =, thenOp, ., removeFirstChild, (, ), ;, Node, elseExpr, =]
[assignName, =, thenOp, ., removeFirstChild, (, ), ;, Node, thenExpr, =, thenOp, ., removeFirstChild, (, ), ;, Node, elseExpr, =]
[), ;, Node, thenExpr, =, thenOp, ., removeFirstChild, (, ), ;, Node, elseExpr, =, elseOp, ., getLastChild, (, ), ;]
[), ;, Node, thenExpr, =, thenOp, ., removeFirstChild, (, ), ;, Node, elseExpr, =, elseOp, ., getLastChild, (, ), ;]
[=, thenOp, ., removeFirstChild, (, ), ;, Node, elseExpr, =, elseOp, ., getLastChild, (, ), ;, elseOp, ., removeChild, (]
[;, Node, elseExpr, =, elseOp, ., getLastChild, (, ), ;, elseOp, ., removeChild, (, elseExpr, ), ;, Node, hookNode, =]
[;, Node, elseExpr, =, elseOp, ., getLastChild, (, ), ;, elseOp, ., removeChild, (, elseExpr, ), ;, Node, hookNode, =]
[;, Node, elseExpr, =, elseOp, ., getLastChild, (, ), ;, elseOp, ., removeChild, (, elseExpr, ), ;, Node, hookNode, =]
[elseOp, ., getLastChild, (, ), ;, elseOp, ., removeChild, (, elseExpr, ), ;, Node, hookNode, =, IR, ., hook, (]
[getLastChild, (, ), ;, elseOp, ., removeChild, (, elseExpr, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,]
[), ;, elseOp, ., removeChild, (, elseExpr, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,]
[(, elseExpr, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (]
[=, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, Node, assign, =]
[=, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, Node, assign, =]
[hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, Node, assign, =, new, Node, (]
[hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, Node, assign, =, new, Node, (]
[elseExpr, ), ., srcref, (, n, ), ;, Node, assign, =, new, Node, (, thenOp, ., getType, (, ), ,]
[., srcref, (, n, ), ;, Node, assign, =, new, Node, (, thenOp, ., getType, (, ), ,, assignName, ,]
[;, Node, assign, =, new, Node, (, thenOp, ., getType, (, ), ,, assignName, ,, hookNode, ), ., srcref, (]
[(, thenOp, ., getType, (, ), ,, assignName, ,, hookNode, ), ., srcref, (, thenOp, ), ;, Node, expr, =]
[(, thenOp, ., getType, (, ), ,, assignName, ,, hookNode, ), ., srcref, (, thenOp, ), ;, Node, expr, =]
[(, ), ,, assignName, ,, hookNode, ), ., srcref, (, thenOp, ), ;, Node, expr, =, NodeUtil, ., newExpr, (]
[assignName, ,, hookNode, ), ., srcref, (, thenOp, ), ;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;]
[assignName, ,, hookNode, ), ., srcref, (, thenOp, ), ;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;]
[., srcref, (, thenOp, ), ;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;, parent, ., replaceChild, (]
[(, thenOp, ), ;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;, parent, ., replaceChild, (, n, ,]
[;, Node, expr, =, NodeUtil, ., newExpr, (, assign, ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;]
[., newExpr, (, assign, ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return]
[;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }]
[;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }]
[(, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }, n, ., removeChild, (]
[expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }, n, ., removeChild, (, cond, ), ;]
[expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, }, }, n, ., removeChild, (, cond, ), ;]
[;, return, expr, ;, }, }, }, n, ., removeChild, (, cond, ), ;, thenOp, ., detachFromParent, (, ), ;]
[;, return, expr, ;, }, }, }, n, ., removeChild, (, cond, ), ;, thenOp, ., detachFromParent, (, ), ;]
[removeChild, (, cond, ), ;, thenOp, ., detachFromParent, (, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =]
[removeChild, (, cond, ), ;, thenOp, ., detachFromParent, (, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =]
[;, thenOp, ., detachFromParent, (, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (]
[;, thenOp, ., detachFromParent, (, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (]
[;, thenOp, ., detachFromParent, (, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (]
[(, ), ;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (, IR, ., hook, (]
[;, elseOp, ., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (, IR, ., hook, (, cond, ,]
[., detachFromParent, (, ), ;, Node, expr, =, IR, ., exprResult, (, IR, ., hook, (, cond, ,, thenOp, ,]
[Node, expr, =, IR, ., exprResult, (, IR, ., hook, (, cond, ,, thenOp, ,, elseOp, ), ., srcref, (]
[., exprResult, (, IR, ., hook, (, cond, ,, thenOp, ,, elseOp, ), ., srcref, (, n, ), ), ;]
[., exprResult, (, IR, ., hook, (, cond, ,, thenOp, ,, elseOp, ), ., srcref, (, n, ), ), ;]
[., hook, (, cond, ,, thenOp, ,, elseOp, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (]
[(, cond, ,, thenOp, ,, elseOp, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,]
[thenOp, ,, elseOp, ), ., srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;]
[srcref, (, n, ), ), ;, parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return]
[parent, ., replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, boolean, thenBranchIsVar, =]
[replaceChild, (, n, ,, expr, ), ;, reportCodeChange, (, ), ;, return, expr, ;, }, boolean, thenBranchIsVar, =, isVarBlock, (]
[;, reportCodeChange, (, ), ;, return, expr, ;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =]
[(, ), ;, return, expr, ;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (]
[;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (]
[;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (]
[;, }, boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (]
[boolean, thenBranchIsVar, =, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (, thenBranchIsVar, &&]
[=, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (, thenBranchIsVar, &&, elseBranchIsExpressionBlock, &&]
[=, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (, thenBranchIsVar, &&, elseBranchIsExpressionBlock, &&]
[=, isVarBlock, (, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (, thenBranchIsVar, &&, elseBranchIsExpressionBlock, &&]
[(, thenBranch, ), ;, boolean, elseBranchIsVar, =, isVarBlock, (, elseBranch, ), ;, if, (, thenBranchIsVar, &&, elseBranchIsExpressionBlock, &&, getBlockExpression, (]
[&&, elseBranchIsExpressionBlock, &&, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =]
[&&, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (]
[getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, thenBranch, ), ;, Node, elseAssign, =]
[getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, thenBranch, ), ;, Node, elseAssign, =]
[), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, thenBranch, ), ;, Node, elseAssign, =, getBlockExpression, (]
[getBlockVar, (, thenBranch, ), ;, Node, elseAssign, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, Node, name1, =]
[getBlockVar, (, thenBranch, ), ;, Node, elseAssign, =, getBlockExpression, (, elseBranch, ), ., getFirstChild, (, ), ;, Node, name1, =]
[(, elseBranch, ), ., getFirstChild, (, ), ;, Node, name1, =, var, ., getFirstChild, (, ), ;, Node, maybeName2, =]
[(, elseBranch, ), ., getFirstChild, (, ), ;, Node, name1, =, var, ., getFirstChild, (, ), ;, Node, maybeName2, =]
[Node, name1, =, var, ., getFirstChild, (, ), ;, Node, maybeName2, =, elseAssign, ., getFirstChild, (, ), ;, if, (]
[Node, name1, =, var, ., getFirstChild, (, ), ;, Node, maybeName2, =, elseAssign, ., getFirstChild, (, ), ;, if, (]
[Node, name1, =, var, ., getFirstChild, (, ), ;, Node, maybeName2, =, elseAssign, ., getFirstChild, (, ), ;, if, (]
[Node, name1, =, var, ., getFirstChild, (, ), ;, Node, maybeName2, =, elseAssign, ., getFirstChild, (, ), ;, if, (]
[(, ), ;, Node, maybeName2, =, elseAssign, ., getFirstChild, (, ), ;, if, (, name1, ., hasChildren, (, ), &&]
[(, ), ;, Node, maybeName2, =, elseAssign, ., getFirstChild, (, ), ;, if, (, name1, ., hasChildren, (, ), &&]
[elseAssign, ., getFirstChild, (, ), ;, if, (, name1, ., hasChildren, (, ), &&, maybeName2, ., isName, (, ), &&]
[elseAssign, ., getFirstChild, (, ), ;, if, (, name1, ., hasChildren, (, ), &&, maybeName2, ., isName, (, ), &&]
[elseAssign, ., getFirstChild, (, ), ;, if, (, name1, ., hasChildren, (, ), &&, maybeName2, ., isName, (, ), &&]
[name1, ., hasChildren, (, ), &&, maybeName2, ., isName, (, ), &&, name1, ., getString, (, ), ., equals, (]
[name1, ., hasChildren, (, ), &&, maybeName2, ., isName, (, ), &&, name1, ., getString, (, ), ., equals, (]
[&&, name1, ., getString, (, ), ., equals, (, maybeName2, ., getString, (, ), ), ), {, Node, thenExpr, =]
[&&, name1, ., getString, (, ), ., equals, (, maybeName2, ., getString, (, ), ), ), {, Node, thenExpr, =]
[maybeName2, ., getString, (, ), ), ), {, Node, thenExpr, =, name1, ., removeChildren, (, ), ;, Node, elseExpr, =]
[maybeName2, ., getString, (, ), ), ), {, Node, thenExpr, =, name1, ., removeChildren, (, ), ;, Node, elseExpr, =]
[maybeName2, ., getString, (, ), ), ), {, Node, thenExpr, =, name1, ., removeChildren, (, ), ;, Node, elseExpr, =]
[=, name1, ., removeChildren, (, ), ;, Node, elseExpr, =, elseAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;]
[=, name1, ., removeChildren, (, ), ;, Node, elseExpr, =, elseAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;]
[=, elseAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =]
[=, elseAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =]
[=, elseAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =]
[(, ), ., detachFromParent, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (]
[., detachFromParent, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,]
[(, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,]
[detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (]
[;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;]
[;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;]
[hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;]
[hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;]
[thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (]
[), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;]
[), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;]
[n, ), ;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (]
[;, var, ., detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,]
[detachFromParent, (, ), ;, name1, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, ), ;]
[., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return]
[., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (]
[., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (]
[., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (]
[(, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (, elseBranchIsVar, &&]
[,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (, elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&]
[,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (, elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&]
[,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (, elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&]
[), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, else, if, (, elseBranchIsVar, &&, thenBranchIsExpressionBlock, &&, getBlockExpression, (]
[&&, thenBranchIsExpressionBlock, &&, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =]
[&&, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (]
[getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, elseBranch, ), ;, Node, thenAssign, =]
[getFirstChild, (, ), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, elseBranch, ), ;, Node, thenAssign, =]
[), ., isAssign, (, ), ), {, Node, var, =, getBlockVar, (, elseBranch, ), ;, Node, thenAssign, =, getBlockExpression, (]
[getBlockVar, (, elseBranch, ), ;, Node, thenAssign, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, maybeName1, =]
[getBlockVar, (, elseBranch, ), ;, Node, thenAssign, =, getBlockExpression, (, thenBranch, ), ., getFirstChild, (, ), ;, Node, maybeName1, =]
[(, thenBranch, ), ., getFirstChild, (, ), ;, Node, maybeName1, =, thenAssign, ., getFirstChild, (, ), ;, Node, name2, =]
[(, thenBranch, ), ., getFirstChild, (, ), ;, Node, maybeName1, =, thenAssign, ., getFirstChild, (, ), ;, Node, name2, =]
[Node, maybeName1, =, thenAssign, ., getFirstChild, (, ), ;, Node, name2, =, var, ., getFirstChild, (, ), ;, if, (]
[Node, maybeName1, =, thenAssign, ., getFirstChild, (, ), ;, Node, name2, =, var, ., getFirstChild, (, ), ;, if, (]
[Node, maybeName1, =, thenAssign, ., getFirstChild, (, ), ;, Node, name2, =, var, ., getFirstChild, (, ), ;, if, (]
[Node, maybeName1, =, thenAssign, ., getFirstChild, (, ), ;, Node, name2, =, var, ., getFirstChild, (, ), ;, if, (]
[(, ), ;, Node, name2, =, var, ., getFirstChild, (, ), ;, if, (, name2, ., hasChildren, (, ), &&]
[(, ), ;, Node, name2, =, var, ., getFirstChild, (, ), ;, if, (, name2, ., hasChildren, (, ), &&]
[var, ., getFirstChild, (, ), ;, if, (, name2, ., hasChildren, (, ), &&, maybeName1, ., isName, (, ), &&]
[var, ., getFirstChild, (, ), ;, if, (, name2, ., hasChildren, (, ), &&, maybeName1, ., isName, (, ), &&]
[var, ., getFirstChild, (, ), ;, if, (, name2, ., hasChildren, (, ), &&, maybeName1, ., isName, (, ), &&]
[name2, ., hasChildren, (, ), &&, maybeName1, ., isName, (, ), &&, maybeName1, ., getString, (, ), ., equals, (]
[name2, ., hasChildren, (, ), &&, maybeName1, ., isName, (, ), &&, maybeName1, ., getString, (, ), ., equals, (]
[&&, maybeName1, ., getString, (, ), ., equals, (, name2, ., getString, (, ), ), ), {, Node, thenExpr, =]
[&&, maybeName1, ., getString, (, ), ., equals, (, name2, ., getString, (, ), ), ), {, Node, thenExpr, =]
[&&, maybeName1, ., getString, (, ), ., equals, (, name2, ., getString, (, ), ), ), {, Node, thenExpr, =]
[), ), ), {, Node, thenExpr, =, thenAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, Node, elseExpr, =]
[), ), ), {, Node, thenExpr, =, thenAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, Node, elseExpr, =]
[=, thenAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, Node, elseExpr, =, name2, ., removeChildren, (, ), ;]
[=, thenAssign, ., getLastChild, (, ), ., detachFromParent, (, ), ;, Node, elseExpr, =, name2, ., removeChildren, (, ), ;]
[), ;, Node, elseExpr, =, name2, ., removeChildren, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =]
[), ;, Node, elseExpr, =, name2, ., removeChildren, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =]
[), ;, Node, elseExpr, =, name2, ., removeChildren, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =]
[=, name2, ., removeChildren, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (]
[., removeChildren, (, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,]
[(, ), ;, cond, ., detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,]
[detachFromParent, (, ), ;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (]
[;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;]
[;, Node, hookNode, =, IR, ., hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;]
[hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;]
[hook, (, cond, ,, thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;]
[thenExpr, ,, elseExpr, ), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (]
[), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;]
[), ., srcref, (, n, ), ;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;]
[n, ), ;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (]
[;, var, ., detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,]
[detachFromParent, (, ), ;, name2, ., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, ), ;]
[., addChildrenToBack, (, hookNode, ), ;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return]
[;, parent, ., replaceChild, (, n, ,, var, ), ;, reportCodeChange, (, ), ;, return, var, ;, }, }, return]
[(, ), ;, return, var, ;, }, }, return, n, ;, }, private, void, tryRemoveRepeatedStatements, (, Node, n, ), {]
[(, ), ;, return, var, ;, }, }, return, n, ;, }, private, void, tryRemoveRepeatedStatements, (, Node, n, ), {]
[var, ;, }, }, return, n, ;, }, private, void, tryRemoveRepeatedStatements, (, Node, n, ), {, Preconditions, ., checkState, (]
[var, ;, }, }, return, n, ;, }, private, void, tryRemoveRepeatedStatements, (, Node, n, ), {, Preconditions, ., checkState, (]
[tryRemoveRepeatedStatements, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isIf, (, ), ), ;, Node, parent, =]
[tryRemoveRepeatedStatements, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isIf, (, ), ), ;, Node, parent, =]
[checkState, (, n, ., isIf, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (]
[(, n, ., isIf, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, !]
[(, n, ., isIf, (, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, !]
[(, ), ), ;, Node, parent, =, n, ., getParent, (, ), ;, if, (, !, NodeUtil, ., isStatementBlock, (]
[(, ), ;, if, (, !, NodeUtil, ., isStatementBlock, (, parent, ), ), {, return, ;, }, Node, cond, =]
[(, ), ;, if, (, !, NodeUtil, ., isStatementBlock, (, parent, ), ), {, return, ;, }, Node, cond, =]
[(, parent, ), ), {, return, ;, }, Node, cond, =, n, ., getFirstChild, (, ), ;, Node, trueBranch, =]
[(, parent, ), ), {, return, ;, }, Node, cond, =, n, ., getFirstChild, (, ), ;, Node, trueBranch, =]
[cond, =, n, ., getFirstChild, (, ), ;, Node, trueBranch, =, cond, ., getNext, (, ), ;, Node, falseBranch, =]
[cond, =, n, ., getFirstChild, (, ), ;, Node, trueBranch, =, cond, ., getNext, (, ), ;, Node, falseBranch, =]
[), ;, Node, trueBranch, =, cond, ., getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;]
[), ;, Node, trueBranch, =, cond, ., getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;]
[=, cond, ., getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Preconditions, ., checkNotNull, (]
[getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Preconditions, ., checkNotNull, (, trueBranch, ), ;]
[getNext, (, ), ;, Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Preconditions, ., checkNotNull, (, trueBranch, ), ;]
[Node, falseBranch, =, trueBranch, ., getNext, (, ), ;, Preconditions, ., checkNotNull, (, trueBranch, ), ;, Preconditions, ., checkNotNull, (]
[getNext, (, ), ;, Preconditions, ., checkNotNull, (, trueBranch, ), ;, Preconditions, ., checkNotNull, (, falseBranch, ), ;, while, (]
[checkNotNull, (, trueBranch, ), ;, Preconditions, ., checkNotNull, (, falseBranch, ), ;, while, (, true, ), {, Node, lastTrue, =]
[checkNotNull, (, trueBranch, ), ;, Preconditions, ., checkNotNull, (, falseBranch, ), ;, while, (, true, ), {, Node, lastTrue, =]
[falseBranch, ), ;, while, (, true, ), {, Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =]
[falseBranch, ), ;, while, (, true, ), {, Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =]
[Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (]
[Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (]
[Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (]
[Node, lastTrue, =, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (]
[=, trueBranch, ., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (, lastTrue, ==]
[., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||]
[., getLastChild, (, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||]
[(, ), ;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||, lastFalse, ==]
[;, Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||, lastFalse, ==, null, ||]
[Node, lastFalse, =, falseBranch, ., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||, lastFalse, ==, null, ||, !]
[=, falseBranch, ., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (]
[., getLastChild, (, ), ;, if, (, lastTrue, ==, null, ||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,]
[lastTrue, ==, null, ||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }]
[lastTrue, ==, null, ||, lastFalse, ==, null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }]
[null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;]
[null, ||, !, areNodesEqualForInlining, (, lastTrue, ,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;]
[,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;]
[,, lastFalse, ), ), {, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;]
[{, break, ;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;, parent, ., addChildAfter, (]
[;, }, lastTrue, ., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;, parent, ., addChildAfter, (, lastTrue, ,]
[., detachFromParent, (, ), ;, lastFalse, ., detachFromParent, (, ), ;, parent, ., addChildAfter, (, lastTrue, ,, n, ), ;]
[,, n, ), ;, reportCodeChange, (, ), ;, }, }, private, boolean, isFoldableExpressBlock, (, Node, n, ), {, if, (]
[,, n, ), ;, reportCodeChange, (, ), ;, }, }, private, boolean, isFoldableExpressBlock, (, Node, n, ), {, if, (]
[}, private, boolean, isFoldableExpressBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if, (]
[}, private, boolean, isFoldableExpressBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if, (]
[(, n, ., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, maybeExpr, =]
[(, n, ., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, maybeExpr, =]
[if, (, n, ., hasOneChild, (, ), ), {, Node, maybeExpr, =, n, ., getFirstChild, (, ), ;, if, (]
[if, (, n, ., hasOneChild, (, ), ), {, Node, maybeExpr, =, n, ., getFirstChild, (, ), ;, if, (]
[Node, maybeExpr, =, n, ., getFirstChild, (, ), ;, if, (, maybeExpr, ., isExprResult, (, ), ), {, if, (]
[Node, maybeExpr, =, n, ., getFirstChild, (, ), ;, if, (, maybeExpr, ., isExprResult, (, ), ), {, if, (]
[Node, maybeExpr, =, n, ., getFirstChild, (, ), ;, if, (, maybeExpr, ., isExprResult, (, ), ), {, if, (]
[(, ), ), {, if, (, maybeExpr, ., getFirstChild, (, ), ., isCall, (, ), ), {, Node, calledFn, =]
[(, ), ), {, if, (, maybeExpr, ., getFirstChild, (, ), ., isCall, (, ), ), {, Node, calledFn, =]
[(, ), ), {, if, (, maybeExpr, ., getFirstChild, (, ), ., isCall, (, ), ), {, Node, calledFn, =]
[isCall, (, ), ), {, Node, calledFn, =, maybeExpr, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, if, (]
[isCall, (, ), ), {, Node, calledFn, =, maybeExpr, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, if, (]
[maybeExpr, ., getFirstChild, (, ), ., getFirstChild, (, ), ;, if, (, calledFn, ., isGetElem, (, ), ), {, return]
[getFirstChild, (, ), ;, if, (, calledFn, ., isGetElem, (, ), ), {, return, false, ;, }, else, if, (]
[getFirstChild, (, ), ;, if, (, calledFn, ., isGetElem, (, ), ), {, return, false, ;, }, else, if, (]
[getFirstChild, (, ), ;, if, (, calledFn, ., isGetElem, (, ), ), {, return, false, ;, }, else, if, (]
[calledFn, ., isGetElem, (, ), ), {, return, false, ;, }, else, if, (, calledFn, ., isGetProp, (, ), &&]
[calledFn, ., isGetElem, (, ), ), {, return, false, ;, }, else, if, (, calledFn, ., isGetProp, (, ), &&]
[calledFn, ., isGetElem, (, ), ), {, return, false, ;, }, else, if, (, calledFn, ., isGetProp, (, ), &&]
[calledFn, ., isGetElem, (, ), ), {, return, false, ;, }, else, if, (, calledFn, ., isGetProp, (, ), &&]
[if, (, calledFn, ., isGetProp, (, ), &&, calledFn, ., getLastChild, (, ), ., getString, (, ), ., startsWith, (]
[(, ), &&, calledFn, ., getLastChild, (, ), ., getString, (, ), ., startsWith, (, "on", ), ), {, return]
[getLastChild, (, ), ., getString, (, ), ., startsWith, (, "on", ), ), {, return, false, ;, }, }, return]
[getString, (, ), ., startsWith, (, "on", ), ), {, return, false, ;, }, }, return, true, ;, }, return]
[(, "on", ), ), {, return, false, ;, }, }, return, true, ;, }, return, false, ;, }, }, return]
[true, ;, }, return, false, ;, }, }, return, false, ;, }, private, Node, getBlockExpression, (, Node, n, ), {]
[true, ;, }, return, false, ;, }, }, return, false, ;, }, private, Node, getBlockExpression, (, Node, n, ), {]
[false, ;, }, }, return, false, ;, }, private, Node, getBlockExpression, (, Node, n, ), {, Preconditions, ., checkState, (]
[}, }, return, false, ;, }, private, Node, getBlockExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isFoldableExpressBlock, (]
[}, private, Node, getBlockExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isFoldableExpressBlock, (, n, ), ), ;, return]
[}, private, Node, getBlockExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isFoldableExpressBlock, (, n, ), ), ;, return]
[), ;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, isReturnBlock, (, Node, n, ), {, if, (]
[), ;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, isReturnBlock, (, Node, n, ), {, if, (]
[}, private, boolean, isReturnBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if, (]
[}, private, boolean, isReturnBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if, (]
[(, n, ., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =]
[(, n, ., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =]
[{, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;, return]
[{, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;, return]
[{, Node, first, =, n, ., getFirstChild, (, ), ;, return, first, ., isReturn, (, ), ;, }, }, return]
[isReturn, (, ), ;, }, }, return, false, ;, }, private, boolean, isReturnExpressBlock, (, Node, n, ), {, if, (]
[isReturn, (, ), ;, }, }, return, false, ;, }, private, boolean, isReturnExpressBlock, (, Node, n, ), {, if, (]
[}, private, boolean, isReturnExpressBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if, (]
[}, private, boolean, isReturnExpressBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if, (]
[(, n, ., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =]
[(, n, ., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =]
[if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;, if, (]
[if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;, if, (]
[{, Node, first, =, n, ., getFirstChild, (, ), ;, if, (, first, ., isReturn, (, ), ), {, return]
[{, Node, first, =, n, ., getFirstChild, (, ), ;, if, (, first, ., isReturn, (, ), ), {, return]
[if, (, first, ., isReturn, (, ), ), {, return, first, ., hasOneChild, (, ), ;, }, }, }, return]
[(, ), ;, }, }, }, return, false, ;, }, private, boolean, isReturnExpression, (, Node, n, ), {, if, (]
[(, ), ;, }, }, }, return, false, ;, }, private, boolean, isReturnExpression, (, Node, n, ), {, if, (]
[;, }, private, boolean, isReturnExpression, (, Node, n, ), {, if, (, n, ., isReturn, (, ), ), {, return]
[;, }, private, boolean, isReturnExpression, (, Node, n, ), {, if, (, n, ., isReturn, (, ), ), {, return]
[), {, if, (, n, ., isReturn, (, ), ), {, return, n, ., hasOneChild, (, ), ;, }, return]
[return, n, ., hasOneChild, (, ), ;, }, return, false, ;, }, private, Node, getBlockReturnExpression, (, Node, n, ), {]
[return, n, ., hasOneChild, (, ), ;, }, return, false, ;, }, private, Node, getBlockReturnExpression, (, Node, n, ), {]
[(, ), ;, }, return, false, ;, }, private, Node, getBlockReturnExpression, (, Node, n, ), {, Preconditions, ., checkState, (]
[;, }, return, false, ;, }, private, Node, getBlockReturnExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isReturnExpressBlock, (]
[}, private, Node, getBlockReturnExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isReturnExpressBlock, (, n, ), ), ;, return]
[}, private, Node, getBlockReturnExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isReturnExpressBlock, (, n, ), ), ;, return]
[}, private, Node, getBlockReturnExpression, (, Node, n, ), {, Preconditions, ., checkState, (, isReturnExpressBlock, (, n, ), ), ;, return]
[., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, private, boolean, isVarBlock, (, Node, n, ), {, if, (]
[., getFirstChild, (, ), ., getFirstChild, (, ), ;, }, private, boolean, isVarBlock, (, Node, n, ), {, if, (]
[}, private, boolean, isVarBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if, (]
[}, private, boolean, isVarBlock, (, Node, n, ), {, if, (, n, ., isBlock, (, ), ), {, if, (]
[(, n, ., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =]
[(, n, ., isBlock, (, ), ), {, if, (, n, ., hasOneChild, (, ), ), {, Node, first, =]
[if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;, if, (]
[if, (, n, ., hasOneChild, (, ), ), {, Node, first, =, n, ., getFirstChild, (, ), ;, if, (]
[{, Node, first, =, n, ., getFirstChild, (, ), ;, if, (, first, ., isVar, (, ), ), {, return]
[{, Node, first, =, n, ., getFirstChild, (, ), ;, if, (, first, ., isVar, (, ), ), {, return]
[if, (, first, ., isVar, (, ), ), {, return, first, ., hasOneChild, (, ), ;, }, }, }, return]
[., hasOneChild, (, ), ;, }, }, }, return, false, ;, }, private, Node, getBlockVar, (, Node, n, ), {]
[., hasOneChild, (, ), ;, }, }, }, return, false, ;, }, private, Node, getBlockVar, (, Node, n, ), {]
[;, }, }, }, return, false, ;, }, private, Node, getBlockVar, (, Node, n, ), {, Preconditions, ., checkState, (]
[}, }, return, false, ;, }, private, Node, getBlockVar, (, Node, n, ), {, Preconditions, ., checkState, (, isVarBlock, (]
[}, private, Node, getBlockVar, (, Node, n, ), {, Preconditions, ., checkState, (, isVarBlock, (, n, ), ), ;, return]
[}, private, Node, getBlockVar, (, Node, n, ), {, Preconditions, ., checkState, (, isVarBlock, (, n, ), ), ;, return]
[), ;, return, n, ., getFirstChild, (, ), ;, }, private, boolean, consumesDanglingElse, (, Node, n, ), {, while, (]
[getFirstChild, (, ), ;, }, private, boolean, consumesDanglingElse, (, Node, n, ), {, while, (, true, ), {, switch, (]
[getFirstChild, (, ), ;, }, private, boolean, consumesDanglingElse, (, Node, n, ), {, while, (, true, ), {, switch, (]
[(, Node, n, ), {, while, (, true, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, while, (, true, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, true, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, if, (]
[(, true, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, if, (]
[(, true, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, if, (]
[n, ., getType, (, ), ), {, case, Token, ., IF, :, if, (, n, ., getChildCount, (, ), <]
[), ), {, case, Token, ., IF, :, if, (, n, ., getChildCount, (, ), <, 3, ), {, return]
[case, Token, ., IF, :, if, (, n, ., getChildCount, (, ), <, 3, ), {, return, true, ;, }]
[., IF, :, if, (, n, ., getChildCount, (, ), <, 3, ), {, return, true, ;, }, n, =]
[., IF, :, if, (, n, ., getChildCount, (, ), <, 3, ), {, return, true, ;, }, n, =]
[), <, 3, ), {, return, true, ;, }, n, =, n, ., getLastChild, (, ), ;, continue, ;, case]
[), <, 3, ), {, return, true, ;, }, n, =, n, ., getLastChild, (, ), ;, continue, ;, case]
[return, true, ;, }, n, =, n, ., getLastChild, (, ), ;, continue, ;, case, Token, ., WITH, :, case]
[return, true, ;, }, n, =, n, ., getLastChild, (, ), ;, continue, ;, case, Token, ., WITH, :, case]
[=, n, ., getLastChild, (, ), ;, continue, ;, case, Token, ., WITH, :, case, Token, ., WHILE, :, case]
[=, n, ., getLastChild, (, ), ;, continue, ;, case, Token, ., WITH, :, case, Token, ., WHILE, :, case]
[(, ), ;, continue, ;, case, Token, ., WITH, :, case, Token, ., WHILE, :, case, Token, ., FOR, :]
[;, continue, ;, case, Token, ., WITH, :, case, Token, ., WHILE, :, case, Token, ., FOR, :, n, =]
[;, continue, ;, case, Token, ., WITH, :, case, Token, ., WHILE, :, case, Token, ., FOR, :, n, =]
[WHILE, :, case, Token, ., FOR, :, n, =, n, ., getLastChild, (, ), ;, continue, ;, default, :, return]
[}, }, private, boolean, isLowerPrecedenceInExpression, (, Node, n, ,, final, int, precedence, ), {, Predicate, <, Node, >, isLowerPrecedencePredicate, =]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, NodeUtil, ., precedence, (]
[Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, NodeUtil, ., precedence, (]
[public, boolean, apply, (, Node, input, ), {, return, NodeUtil, ., precedence, (, input, ., getType, (, ), ), <]
[), {, return, NodeUtil, ., precedence, (, input, ., getType, (, ), ), <, precedence, ;, }, }, ;, return]
[), {, return, NodeUtil, ., precedence, (, input, ., getType, (, ), ), <, precedence, ;, }, }, ;, return]
[., precedence, (, input, ., getType, (, ), ), <, precedence, ;, }, }, ;, return, NodeUtil, ., has, (]
[(, input, ., getType, (, ), ), <, precedence, ;, }, }, ;, return, NodeUtil, ., has, (, n, ,]
[., getType, (, ), ), <, precedence, ;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isLowerPrecedencePredicate, ,]
[,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int, precedence, ), {, return]
[,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int, precedence, ), {, return]
[,, isLowerPrecedencePredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int, precedence, ), {, return]
[), ;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (]
[), ;, }, private, boolean, isLowerPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (]
[Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (, n, ., getType, (, ), ), <]
[(, ), ), <, precedence, ;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, ), {, return]
[(, ), ), <, precedence, ;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, ), {, return]
[(, ), ), <, precedence, ;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, ), {, return]
[precedence, ;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (]
[precedence, ;, }, private, boolean, isHigherPrecedence, (, Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (]
[Node, n, ,, final, int, precedence, ), {, return, NodeUtil, ., precedence, (, n, ., getType, (, ), ), >]
[), ), >, precedence, ;, }, private, boolean, isPropertyAssignmentInExpression, (, Node, n, ), {, Predicate, <, Node, >, isPropertyAssignmentInExpressionPredicate, =]
[=, new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, (]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, (]
[new, Predicate, <, Node, >, (, ), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, (]
[), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, (, input, ., isGetProp, (, ), &&]
[), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, (, input, ., isGetProp, (, ), &&]
[), {, @, Override, public, boolean, apply, (, Node, input, ), {, return, (, input, ., isGetProp, (, ), &&]
[., isGetProp, (, ), &&, input, ., getParent, (, ), ., isAssign, (, ), ), ;, }, }, ;, return]
[., isGetProp, (, ), &&, input, ., getParent, (, ), ., isAssign, (, ), ), ;, }, }, ;, return]
[&&, input, ., getParent, (, ), ., isAssign, (, ), ), ;, }, }, ;, return, NodeUtil, ., has, (]
[., getParent, (, ), ., isAssign, (, ), ), ;, }, }, ;, return, NodeUtil, ., has, (, n, ,]
[(, ), ., isAssign, (, ), ), ;, }, }, ;, return, NodeUtil, ., has, (, n, ,, isPropertyAssignmentInExpressionPredicate, ,]
[(, n, ,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, Node, tryMinimizeCondition, (, Node, n, ), {, Node, parent, =]
[(, n, ,, isPropertyAssignmentInExpressionPredicate, ,, DONT_TRAVERSE_FUNCTIONS_PREDICATE, ), ;, }, private, Node, tryMinimizeCondition, (, Node, n, ), {, Node, parent, =]
[}, private, Node, tryMinimizeCondition, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[}, private, Node, tryMinimizeCondition, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, switch, (]
[{, Node, parent, =, n, ., getParent, (, ), ;, switch, (, n, ., getType, (, ), ), {, case]
[{, Node, parent, =, n, ., getParent, (, ), ;, switch, (, n, ., getType, (, ), ), {, case]
[(, ), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :, Node, first, =]
[(, ), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., NOT, :, Node, first, =]
[(, ), ), {, case, Token, ., NOT, :, Node, first, =, n, ., getFirstChild, (, ), ;, switch, (]
[(, ), ), {, case, Token, ., NOT, :, Node, first, =, n, ., getFirstChild, (, ), ;, switch, (]
[:, Node, first, =, n, ., getFirstChild, (, ), ;, switch, (, first, ., getType, (, ), ), {, case]
[:, Node, first, =, n, ., getFirstChild, (, ), ;, switch, (, first, ., getType, (, ), ), {, case]
[), ;, switch, (, first, ., getType, (, ), ), {, case, Token, ., NOT, :, {, Node, newRoot, =]
[), ;, switch, (, first, ., getType, (, ), ), {, case, Token, ., NOT, :, {, Node, newRoot, =]
[getType, (, ), ), {, case, Token, ., NOT, :, {, Node, newRoot, =, first, ., removeFirstChild, (, ), ;]
[getType, (, ), ), {, case, Token, ., NOT, :, {, Node, newRoot, =, first, ., removeFirstChild, (, ), ;]
[{, case, Token, ., NOT, :, {, Node, newRoot, =, first, ., removeFirstChild, (, ), ;, parent, ., replaceChild, (]
[Token, ., NOT, :, {, Node, newRoot, =, first, ., removeFirstChild, (, ), ;, parent, ., replaceChild, (, n, ,]
[:, {, Node, newRoot, =, first, ., removeFirstChild, (, ), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;]
[first, ., removeFirstChild, (, ), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return]
[), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, case]
[), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, case]
[(, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, case, Token, ., AND, :, case]
[(, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, case, Token, ., AND, :, case]
[), ;, return, newRoot, ;, }, case, Token, ., AND, :, case, Token, ., OR, :, {, Node, leftParent, =]
[), ;, return, newRoot, ;, }, case, Token, ., AND, :, case, Token, ., OR, :, {, Node, leftParent, =]
[AND, :, case, Token, ., OR, :, {, Node, leftParent, =, first, ., getFirstChild, (, ), ;, Node, rightParent, =]
[AND, :, case, Token, ., OR, :, {, Node, leftParent, =, first, ., getFirstChild, (, ), ;, Node, rightParent, =]
[getFirstChild, (, ), ;, Node, rightParent, =, first, ., getLastChild, (, ), ;, Node, left, ,, right, ;, if, (]
[getFirstChild, (, ), ;, Node, rightParent, =, first, ., getLastChild, (, ), ;, Node, left, ,, right, ;, if, (]
[(, ), ;, Node, rightParent, =, first, ., getLastChild, (, ), ;, Node, left, ,, right, ;, if, (, !]
[(, ), ;, Node, rightParent, =, first, ., getLastChild, (, ), ;, Node, left, ,, right, ;, if, (, !]
[first, ., getLastChild, (, ), ;, Node, left, ,, right, ;, if, (, !, leftParent, ., isNot, (, ), &&]
[., getLastChild, (, ), ;, Node, left, ,, right, ;, if, (, !, leftParent, ., isNot, (, ), &&, !]
[., getLastChild, (, ), ;, Node, left, ,, right, ;, if, (, !, leftParent, ., isNot, (, ), &&, !]
[if, (, !, leftParent, ., isNot, (, ), &&, !, rightParent, ., isNot, (, ), ), {, int, op_precedence, =]
[if, (, !, leftParent, ., isNot, (, ), &&, !, rightParent, ., isNot, (, ), ), {, int, op_precedence, =]
[., isNot, (, ), &&, !, rightParent, ., isNot, (, ), ), {, int, op_precedence, =, NodeUtil, ., precedence, (]
[., isNot, (, ), &&, !, rightParent, ., isNot, (, ), ), {, int, op_precedence, =, NodeUtil, ., precedence, (]
[(, ), ), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;, if, (]
[(, ), ), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;, if, (]
[), ), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;, if, (, (]
[), ), {, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;, if, (, (]
[{, int, op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;, if, (, (, isLowerPrecedence, (]
[op_precedence, =, NodeUtil, ., precedence, (, first, ., getType, (, ), ), ;, if, (, (, isLowerPrecedence, (, leftParent, ,]
[., precedence, (, first, ., getType, (, ), ), ;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&]
[(, first, ., getType, (, ), ), ;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (]
[., getType, (, ), ), ;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,]
[), ;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||]
[;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (]
[;, if, (, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (]
[(, (, isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (, isLowerPrecedence, (]
[isLowerPrecedence, (, leftParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (, isLowerPrecedence, (, rightParent, ,]
[,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&]
[), &&, isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (]
[isHigherPrecedence, (, leftParent, ,, op_precedence, ), ), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,]
[), ||, (, isLowerPrecedence, (, rightParent, ,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {, return]
[,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {, return, n, ;, }, }, if, (]
[,, NOT_PRECEDENCE, ), &&, isHigherPrecedence, (, rightParent, ,, op_precedence, ), ), ), {, return, n, ;, }, }, if, (]
[,, op_precedence, ), ), ), {, return, n, ;, }, }, if, (, leftParent, ., isNot, (, ), ), {]
[), ), ), {, return, n, ;, }, }, if, (, leftParent, ., isNot, (, ), ), {, left, =]
[), ), ), {, return, n, ;, }, }, if, (, leftParent, ., isNot, (, ), ), {, left, =]
[if, (, leftParent, ., isNot, (, ), ), {, left, =, leftParent, ., removeFirstChild, (, ), ;, }, else, {]
[if, (, leftParent, ., isNot, (, ), ), {, left, =, leftParent, ., removeFirstChild, (, ), ;, }, else, {]
[), ), {, left, =, leftParent, ., removeFirstChild, (, ), ;, }, else, {, leftParent, ., detachFromParent, (, ), ;]
[{, left, =, leftParent, ., removeFirstChild, (, ), ;, }, else, {, leftParent, ., detachFromParent, (, ), ;, left, =]
[{, left, =, leftParent, ., removeFirstChild, (, ), ;, }, else, {, leftParent, ., detachFromParent, (, ), ;, left, =]
[{, left, =, leftParent, ., removeFirstChild, (, ), ;, }, else, {, leftParent, ., detachFromParent, (, ), ;, left, =]
[., removeFirstChild, (, ), ;, }, else, {, leftParent, ., detachFromParent, (, ), ;, left, =, IR, ., not, (]
[}, else, {, leftParent, ., detachFromParent, (, ), ;, left, =, IR, ., not, (, leftParent, ), ., srcref, (]
[(, ), ;, left, =, IR, ., not, (, leftParent, ), ., srcref, (, leftParent, ), ;, }, if, (]
[(, ), ;, left, =, IR, ., not, (, leftParent, ), ., srcref, (, leftParent, ), ;, }, if, (]
[not, (, leftParent, ), ., srcref, (, leftParent, ), ;, }, if, (, rightParent, ., isNot, (, ), ), {]
[leftParent, ), ., srcref, (, leftParent, ), ;, }, if, (, rightParent, ., isNot, (, ), ), {, right, =]
[leftParent, ), ., srcref, (, leftParent, ), ;, }, if, (, rightParent, ., isNot, (, ), ), {, right, =]
[if, (, rightParent, ., isNot, (, ), ), {, right, =, rightParent, ., removeFirstChild, (, ), ;, }, else, {]
[if, (, rightParent, ., isNot, (, ), ), {, right, =, rightParent, ., removeFirstChild, (, ), ;, }, else, {]
[), ), {, right, =, rightParent, ., removeFirstChild, (, ), ;, }, else, {, rightParent, ., detachFromParent, (, ), ;]
[{, right, =, rightParent, ., removeFirstChild, (, ), ;, }, else, {, rightParent, ., detachFromParent, (, ), ;, right, =]
[{, right, =, rightParent, ., removeFirstChild, (, ), ;, }, else, {, rightParent, ., detachFromParent, (, ), ;, right, =]
[{, right, =, rightParent, ., removeFirstChild, (, ), ;, }, else, {, rightParent, ., detachFromParent, (, ), ;, right, =]
[., removeFirstChild, (, ), ;, }, else, {, rightParent, ., detachFromParent, (, ), ;, right, =, IR, ., not, (]
[}, else, {, rightParent, ., detachFromParent, (, ), ;, right, =, IR, ., not, (, rightParent, ), ., srcref, (]
[), ;, right, =, IR, ., not, (, rightParent, ), ., srcref, (, rightParent, ), ;, }, int, newOp, =]
[), ;, right, =, IR, ., not, (, rightParent, ), ., srcref, (, rightParent, ), ;, }, int, newOp, =]
[;, right, =, IR, ., not, (, rightParent, ), ., srcref, (, rightParent, ), ;, }, int, newOp, =, (]
[;, right, =, IR, ., not, (, rightParent, ), ., srcref, (, rightParent, ), ;, }, int, newOp, =, (]
[rightParent, ), ., srcref, (, rightParent, ), ;, }, int, newOp, =, (, first, ., isAnd, (, ), ), ?]
[rightParent, ), ., srcref, (, rightParent, ), ;, }, int, newOp, =, (, first, ., isAnd, (, ), ), ?]
[(, rightParent, ), ;, }, int, newOp, =, (, first, ., isAnd, (, ), ), ?, Token, ., OR, :]
[(, rightParent, ), ;, }, int, newOp, =, (, first, ., isAnd, (, ), ), ?, Token, ., OR, :]
[=, (, first, ., isAnd, (, ), ), ?, Token, ., OR, :, Token, ., AND, ;, Node, newRoot, =]
[., isAnd, (, ), ), ?, Token, ., OR, :, Token, ., AND, ;, Node, newRoot, =, new, Node, (]
[(, ), ), ?, Token, ., OR, :, Token, ., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,]
[), ?, Token, ., OR, :, Token, ., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,]
[., OR, :, Token, ., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right, ), ;]
[., OR, :, Token, ., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right, ), ;]
[., AND, ;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right, ), ;, parent, ., replaceChild, (]
[;, Node, newRoot, =, new, Node, (, newOp, ,, left, ,, right, ), ;, parent, ., replaceChild, (, n, ,]
[=, new, Node, (, newOp, ,, left, ,, right, ), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;]
[,, left, ,, right, ), ;, parent, ., replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return]
[replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, default, :, TernaryValue, nVal, =]
[replaceChild, (, n, ,, newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, default, :, TernaryValue, nVal, =]
[newRoot, ), ;, reportCodeChange, (, ), ;, return, newRoot, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (]
[), ;, return, newRoot, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, first, ), ;, if, (]
[), ;, return, newRoot, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, first, ), ;, if, (]
[return, newRoot, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, first, ), ;, if, (, nVal, !=]
[return, newRoot, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, first, ), ;, if, (, nVal, !=]
[=, NodeUtil, ., getPureBooleanValue, (, first, ), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =]
[=, NodeUtil, ., getPureBooleanValue, (, first, ), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =]
[=, NodeUtil, ., getPureBooleanValue, (, first, ), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =]
[if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., not, (, ), ., toBoolean, (]
[UNKNOWN, ), {, boolean, result, =, nVal, ., not, (, ), ., toBoolean, (, true, ), ;, int, equivalentResult, =]
[UNKNOWN, ), {, boolean, result, =, nVal, ., not, (, ), ., toBoolean, (, true, ), ;, int, equivalentResult, =]
[{, boolean, result, =, nVal, ., not, (, ), ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?]
[result, =, nVal, ., not, (, ), ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :]
[., not, (, ), ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return]
[(, ), ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (]
[., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,]
[(, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,]
[=, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, }, return]
[1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, }, return, n, ;, case]
[1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, }, return, n, ;, case]
[maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, }, return, n, ;, case, Token, ., OR, :, case]
[maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, }, return, n, ;, case, Token, ., OR, :, case]
[;, }, }, return, n, ;, case, Token, ., OR, :, case, Token, ., AND, :, {, Node, left, =]
[;, }, }, return, n, ;, case, Token, ., OR, :, case, Token, ., AND, :, {, Node, left, =]
[OR, :, case, Token, ., AND, :, {, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =]
[OR, :, case, Token, ., AND, :, {, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =]
[:, {, Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;]
[Node, left, =, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, left, =]
[=, n, ., getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, left, =, tryMinimizeCondition, (]
[getFirstChild, (, ), ;, Node, right, =, n, ., getLastChild, (, ), ;, left, =, tryMinimizeCondition, (, left, ), ;]
[), ;, Node, right, =, n, ., getLastChild, (, ), ;, left, =, tryMinimizeCondition, (, left, ), ;, right, =]
[Node, right, =, n, ., getLastChild, (, ), ;, left, =, tryMinimizeCondition, (, left, ), ;, right, =, tryMinimizeCondition, (]
[(, ), ;, left, =, tryMinimizeCondition, (, left, ), ;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =]
[(, ), ;, left, =, tryMinimizeCondition, (, left, ), ;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =]
[=, tryMinimizeCondition, (, left, ), ;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (]
[;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (]
[;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (]
[;, right, =, tryMinimizeCondition, (, right, ), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (]
[(, right, ), ;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (]
[;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, right, ), !=]
[;, TernaryValue, rightVal, =, NodeUtil, ., getPureBooleanValue, (, right, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, right, ), !=]
[right, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, right, ), !=, TernaryValue, ., UNKNOWN, ), {, int, type, =]
[right, ), ;, if, (, NodeUtil, ., getPureBooleanValue, (, right, ), !=, TernaryValue, ., UNKNOWN, ), {, int, type, =]
[right, ), !=, TernaryValue, ., UNKNOWN, ), {, int, type, =, n, ., getType, (, ), ;, Node, replacement, =]
[UNKNOWN, ), {, int, type, =, n, ., getType, (, ), ;, Node, replacement, =, null, ;, boolean, rval, =]
[UNKNOWN, ), {, int, type, =, n, ., getType, (, ), ;, Node, replacement, =, null, ;, boolean, rval, =]
[type, =, n, ., getType, (, ), ;, Node, replacement, =, null, ;, boolean, rval, =, rightVal, ., toBoolean, (]
[(, ), ;, Node, replacement, =, null, ;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (]
[(, ), ;, Node, replacement, =, null, ;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (]
[(, ), ;, Node, replacement, =, null, ;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (]
[(, ), ;, Node, replacement, =, null, ;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (]
[;, Node, replacement, =, null, ;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==]
[;, Node, replacement, =, null, ;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==]
[null, ;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==, Token, ., OR, &&]
[;, boolean, rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==, Token, ., OR, &&, !]
[rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==, Token, ., OR, &&, !, rval, ||]
[rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==, Token, ., OR, &&, !, rval, ||]
[rval, =, rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==, Token, ., OR, &&, !, rval, ||]
[rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==, Token, ., OR, &&, !, rval, ||, type, ==]
[rightVal, ., toBoolean, (, true, ), ;, if, (, type, ==, Token, ., OR, &&, !, rval, ||, type, ==]
[true, ), ;, if, (, type, ==, Token, ., OR, &&, !, rval, ||, type, ==, Token, ., AND, &&]
[if, (, type, ==, Token, ., OR, &&, !, rval, ||, type, ==, Token, ., AND, &&, rval, ), {]
[type, ==, Token, ., OR, &&, !, rval, ||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =]
[!, rval, ||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if, (]
[rval, ||, type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if, (, !]
[type, ==, Token, ., AND, &&, rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (]
[AND, &&, rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {]
[rval, ), {, replacement, =, left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement, =]
[left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right, ;, }, if, (]
[left, ;, }, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right, ;, }, if, (]
[}, else, if, (, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right, ;, }, if, (, replacement, !=]
[(, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right, ;, }, if, (, replacement, !=, null, ), {]
[(, !, mayHaveSideEffects, (, left, ), ), {, replacement, =, right, ;, }, if, (, replacement, !=, null, ), {]
[), {, replacement, =, right, ;, }, if, (, replacement, !=, null, ), {, n, ., detachChildren, (, ), ;]
[), {, replacement, =, right, ;, }, if, (, replacement, !=, null, ), {, n, ., detachChildren, (, ), ;]
[right, ;, }, if, (, replacement, !=, null, ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (]
[}, if, (, replacement, !=, null, ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,]
[replacement, !=, null, ), {, n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, replacement, ), ;]
[n, ., detachChildren, (, ), ;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return]
[;, parent, ., replaceChild, (, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, }, return]
[(, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, }, return, n, ;, }, case]
[(, n, ,, replacement, ), ;, reportCodeChange, (, ), ;, return, replacement, ;, }, }, return, n, ;, }, case]
[), ;, return, replacement, ;, }, }, return, n, ;, }, case, Token, ., HOOK, :, {, Node, condition, =]
[), ;, return, replacement, ;, }, }, return, n, ;, }, case, Token, ., HOOK, :, {, Node, condition, =]
[;, }, case, Token, ., HOOK, :, {, Node, condition, =, n, ., getFirstChild, (, ), ;, Node, trueNode, =]
[;, }, case, Token, ., HOOK, :, {, Node, condition, =, n, ., getFirstChild, (, ), ;, Node, trueNode, =]
[;, }, case, Token, ., HOOK, :, {, Node, condition, =, n, ., getFirstChild, (, ), ;, Node, trueNode, =]
[getFirstChild, (, ), ;, Node, trueNode, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, falseNode, =]
[getFirstChild, (, ), ;, Node, trueNode, =, n, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, falseNode, =]
[=, n, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, falseNode, =, n, ., getLastChild, (, ), ;]
[., getFirstChild, (, ), ., getNext, (, ), ;, Node, falseNode, =, n, ., getLastChild, (, ), ;, trueNode, =]
[(, ), ., getNext, (, ), ;, Node, falseNode, =, n, ., getLastChild, (, ), ;, trueNode, =, tryMinimizeCondition, (]
[getNext, (, ), ;, Node, falseNode, =, n, ., getLastChild, (, ), ;, trueNode, =, tryMinimizeCondition, (, trueNode, ), ;]
[), ;, Node, falseNode, =, n, ., getLastChild, (, ), ;, trueNode, =, tryMinimizeCondition, (, trueNode, ), ;, falseNode, =]
[Node, falseNode, =, n, ., getLastChild, (, ), ;, trueNode, =, tryMinimizeCondition, (, trueNode, ), ;, falseNode, =, tryMinimizeCondition, (]
[(, ), ;, trueNode, =, tryMinimizeCondition, (, trueNode, ), ;, falseNode, =, tryMinimizeCondition, (, falseNode, ), ;, Node, replacement, =]
[tryMinimizeCondition, (, trueNode, ), ;, falseNode, =, tryMinimizeCondition, (, falseNode, ), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =]
[tryMinimizeCondition, (, trueNode, ), ;, falseNode, =, tryMinimizeCondition, (, falseNode, ), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =]
[;, falseNode, =, tryMinimizeCondition, (, falseNode, ), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue, (]
[), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =]
[), ;, Node, replacement, =, null, ;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =]
[=, null, ;, TernaryValue, trueNodeVal, =, NodeUtil, ., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (]
[=, NodeUtil, ., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (]
[=, NodeUtil, ., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (]
[=, NodeUtil, ., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (]
[., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==]
[., getPureBooleanValue, (, trueNode, ), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==]
[), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&]
[), ;, TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&]
[TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal, ==]
[TernaryValue, falseNodeVal, =, NodeUtil, ., getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal, ==]
[getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {]
[getPureBooleanValue, (, falseNode, ), ;, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {]
[(, trueNodeVal, ==, TernaryValue, ., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;]
[==, TernaryValue, ., TRUE, &&, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =]
[==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (]
[==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (]
[==, TernaryValue, ., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (]
[., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==]
[., FALSE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==]
[condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&]
[condition, ., detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&]
[detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal, ==]
[detachFromParent, (, ), ;, replacement, =, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal, ==]
[=, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {]
[=, condition, ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {]
[(, trueNodeVal, ==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {, condition, ., detachFromParent, (, ), ;]
[==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =]
[==, TernaryValue, ., FALSE, &&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =]
[&&, falseNodeVal, ==, TernaryValue, ., TRUE, ), {, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (]
[{, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, ), ;, }, else, if, (]
[{, condition, ., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, ), ;, }, else, if, (]
[., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, ), ;, }, else, if, (, trueNodeVal, ==]
[., detachFromParent, (, ), ;, replacement, =, IR, ., not, (, condition, ), ;, }, else, if, (, trueNodeVal, ==]
[replacement, =, IR, ., not, (, condition, ), ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, ), {]
[replacement, =, IR, ., not, (, condition, ), ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, ), {]
[condition, ), ;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, ), {, n, ., detachChildren, (, ), ;]
[;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, ), {, n, ., detachChildren, (, ), ;, replacement, =]
[;, }, else, if, (, trueNodeVal, ==, TernaryValue, ., TRUE, ), {, n, ., detachChildren, (, ), ;, replacement, =]
[(, trueNodeVal, ==, TernaryValue, ., TRUE, ), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., or, (]
[==, TernaryValue, ., TRUE, ), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., or, (, condition, ,]
[., detachChildren, (, ), ;, replacement, =, IR, ., or, (, condition, ,, falseNode, ), ;, }, else, if, (]
[., detachChildren, (, ), ;, replacement, =, IR, ., or, (, condition, ,, falseNode, ), ;, }, else, if, (]
[(, ), ;, replacement, =, IR, ., or, (, condition, ,, falseNode, ), ;, }, else, if, (, falseNodeVal, ==]
[(, ), ;, replacement, =, IR, ., or, (, condition, ,, falseNode, ), ;, }, else, if, (, falseNodeVal, ==]
[IR, ., or, (, condition, ,, falseNode, ), ;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, ), {]
[IR, ., or, (, condition, ,, falseNode, ), ;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, ), {]
[falseNode, ), ;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, n, ., detachChildren, (, ), ;]
[;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, n, ., detachChildren, (, ), ;, replacement, =]
[;, }, else, if, (, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, n, ., detachChildren, (, ), ;, replacement, =]
[(, falseNodeVal, ==, TernaryValue, ., FALSE, ), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., and, (]
[==, TernaryValue, ., FALSE, ), {, n, ., detachChildren, (, ), ;, replacement, =, IR, ., and, (, condition, ,]
[n, ., detachChildren, (, ), ;, replacement, =, IR, ., and, (, condition, ,, trueNode, ), ;, }, if, (]
[n, ., detachChildren, (, ), ;, replacement, =, IR, ., and, (, condition, ,, trueNode, ), ;, }, if, (]
[detachChildren, (, ), ;, replacement, =, IR, ., and, (, condition, ,, trueNode, ), ;, }, if, (, replacement, !=]
[;, replacement, =, IR, ., and, (, condition, ,, trueNode, ), ;, }, if, (, replacement, !=, null, ), {]
[;, replacement, =, IR, ., and, (, condition, ,, trueNode, ), ;, }, if, (, replacement, !=, null, ), {]
[., and, (, condition, ,, trueNode, ), ;, }, if, (, replacement, !=, null, ), {, parent, ., replaceChild, (]
[(, condition, ,, trueNode, ), ;, }, if, (, replacement, !=, null, ), {, parent, ., replaceChild, (, n, ,]
[trueNode, ), ;, }, if, (, replacement, !=, null, ), {, parent, ., replaceChild, (, n, ,, replacement, ), ;]
[;, }, if, (, replacement, !=, null, ), {, parent, ., replaceChild, (, n, ,, replacement, ), ;, n, =]
[if, (, replacement, !=, null, ), {, parent, ., replaceChild, (, n, ,, replacement, ), ;, n, =, replacement, ;]
[{, parent, ., replaceChild, (, n, ,, replacement, ), ;, n, =, replacement, ;, reportCodeChange, (, ), ;, }, return]
[), ;, n, =, replacement, ;, reportCodeChange, (, ), ;, }, return, n, ;, }, default, :, TernaryValue, nVal, =]
[), ;, n, =, replacement, ;, reportCodeChange, (, ), ;, }, return, n, ;, }, default, :, TernaryValue, nVal, =]
[replacement, ;, reportCodeChange, (, ), ;, }, return, n, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (]
[;, }, return, n, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, if, (]
[;, }, return, n, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, if, (]
[return, n, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, if, (, nVal, !=]
[return, n, ;, }, default, :, TernaryValue, nVal, =, NodeUtil, ., getPureBooleanValue, (, n, ), ;, if, (, nVal, !=]
[=, NodeUtil, ., getPureBooleanValue, (, n, ), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =]
[=, NodeUtil, ., getPureBooleanValue, (, n, ), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =]
[(, n, ), ;, if, (, nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., toBoolean, (]
[nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =]
[nVal, !=, TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =]
[TernaryValue, ., UNKNOWN, ), {, boolean, result, =, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?]
[UNKNOWN, ), {, boolean, result, =, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :]
[boolean, result, =, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return]
[=, nVal, ., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (]
[., toBoolean, (, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,]
[(, true, ), ;, int, equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,]
[equivalentResult, =, result, ?, 1, :, 0, ;, return, maybeReplaceChildWithNumber, (, n, ,, parent, ,, equivalentResult, ), ;, }, return]
[;, }, }, private, Node, maybeReplaceChildWithNumber, (, Node, n, ,, Node, parent, ,, int, num, ), {, Node, newNode, =]
[;, }, }, private, Node, maybeReplaceChildWithNumber, (, Node, n, ,, Node, parent, ,, int, num, ), {, Node, newNode, =]
[Node, maybeReplaceChildWithNumber, (, Node, n, ,, Node, parent, ,, int, num, ), {, Node, newNode, =, IR, ., number, (]
[,, Node, parent, ,, int, num, ), {, Node, newNode, =, IR, ., number, (, num, ), ;, if, (]
[Node, parent, ,, int, num, ), {, Node, newNode, =, IR, ., number, (, num, ), ;, if, (, !]
[Node, parent, ,, int, num, ), {, Node, newNode, =, IR, ., number, (, num, ), ;, if, (, !]
[num, ), {, Node, newNode, =, IR, ., number, (, num, ), ;, if, (, !, newNode, ., isEquivalentTo, (]
[newNode, =, IR, ., number, (, num, ), ;, if, (, !, newNode, ., isEquivalentTo, (, n, ), ), {]
[newNode, =, IR, ., number, (, num, ), ;, if, (, !, newNode, ., isEquivalentTo, (, n, ), ), {]
[number, (, num, ), ;, if, (, !, newNode, ., isEquivalentTo, (, n, ), ), {, parent, ., replaceChild, (]
[num, ), ;, if, (, !, newNode, ., isEquivalentTo, (, n, ), ), {, parent, ., replaceChild, (, n, ,]
[if, (, !, newNode, ., isEquivalentTo, (, n, ), ), {, parent, ., replaceChild, (, n, ,, newNode, ), ;]
[isEquivalentTo, (, n, ), ), {, parent, ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return]
[), {, parent, ., replaceChild, (, n, ,, newNode, ), ;, reportCodeChange, (, ), ;, return, newNode, ;, }, return]
[(, ), ;, return, newNode, ;, }, return, n, ;, }, private, static, final, ImmutableSet, <, String, >, STANDARD_OBJECT_CONSTRUCTORS, =]
[(, ), ;, return, newNode, ;, }, return, n, ;, }, private, static, final, ImmutableSet, <, String, >, STANDARD_OBJECT_CONSTRUCTORS, =]
[newNode, ;, }, return, n, ;, }, private, static, final, ImmutableSet, <, String, >, STANDARD_OBJECT_CONSTRUCTORS, =, ImmutableSet, ., of, (]
[}, return, n, ;, }, private, static, final, ImmutableSet, <, String, >, STANDARD_OBJECT_CONSTRUCTORS, =, ImmutableSet, ., of, (, "Object", ,]
[n, ;, }, private, static, final, ImmutableSet, <, String, >, STANDARD_OBJECT_CONSTRUCTORS, =, ImmutableSet, ., of, (, "Object", ,, "Array", ,]
[}, private, static, final, ImmutableSet, <, String, >, STANDARD_OBJECT_CONSTRUCTORS, =, ImmutableSet, ., of, (, "Object", ,, "Array", ,, "RegExp", ,]
[., of, (, "Object", ,, "Array", ,, "RegExp", ,, "Error", ), ;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {]
[., of, (, "Object", ,, "Array", ,, "RegExp", ,, "Error", ), ;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {]
[,, "Array", ,, "RegExp", ,, "Error", ), ;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {, Preconditions, ., checkState, (]
[,, "Array", ,, "RegExp", ,, "Error", ), ;, private, Node, tryFoldStandardConstructors, (, Node, n, ), {, Preconditions, ., checkState, (]
[Node, tryFoldStandardConstructors, (, Node, n, ), {, Preconditions, ., checkState, (, n, ., isNew, (, ), ), ;, if, (]
[Preconditions, ., checkState, (, n, ., isNew, (, ), ), ;, if, (, isASTNormalized, (, ), ), {, if, (]
[Preconditions, ., checkState, (, n, ., isNew, (, ), ), ;, if, (, isASTNormalized, (, ), ), {, if, (]
[Preconditions, ., checkState, (, n, ., isNew, (, ), ), ;, if, (, isASTNormalized, (, ), ), {, if, (]
[(, ), ), {, if, (, n, ., getFirstChild, (, ), ., isName, (, ), ), {, String, className, =]
[(, ), ), {, if, (, n, ., getFirstChild, (, ), ., isName, (, ), ), {, String, className, =]
[(, ), ), {, if, (, n, ., getFirstChild, (, ), ., isName, (, ), ), {, String, className, =]
[isName, (, ), ), {, String, className, =, n, ., getFirstChild, (, ), ., getString, (, ), ;, if, (]
[isName, (, ), ), {, String, className, =, n, ., getFirstChild, (, ), ., getString, (, ), ;, if, (]
[{, String, className, =, n, ., getFirstChild, (, ), ., getString, (, ), ;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (]
[n, ., getFirstChild, (, ), ., getString, (, ), ;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, ), ), {]
[n, ., getFirstChild, (, ), ., getString, (, ), ;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, ), ), {]
[), ., getString, (, ), ;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, ), ), {, n, ., setType, (]
[), ., getString, (, ), ;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, ), ), {, n, ., setType, (]
[;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, ), ), {, n, ., setType, (, Token, ., CALL, ), ;]
[;, if, (, STANDARD_OBJECT_CONSTRUCTORS, ., contains, (, className, ), ), {, n, ., setType, (, Token, ., CALL, ), ;]
[., contains, (, className, ), ), {, n, ., setType, (, Token, ., CALL, ), ;, n, ., putBooleanProp, (]
[., contains, (, className, ), ), {, n, ., setType, (, Token, ., CALL, ), ;, n, ., putBooleanProp, (]
[), ), {, n, ., setType, (, Token, ., CALL, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,]
[n, ., setType, (, Token, ., CALL, ), ;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;]
[;, n, ., putBooleanProp, (, Node, ., FREE_CALL, ,, true, ), ;, reportCodeChange, (, ), ;, }, }, }, return]
[;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {]
[;, reportCodeChange, (, ), ;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {]
[;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[;, }, }, }, return, n, ;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {, Preconditions, ., checkArgument, (]
[;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isCall, (, ), ||]
[;, }, private, Node, tryFoldLiteralConstructor, (, Node, n, ), {, Preconditions, ., checkArgument, (, n, ., isCall, (, ), ||]
[Preconditions, ., checkArgument, (, n, ., isCall, (, ), ||, n, ., isNew, (, ), ), ;, Node, constructorNameNode, =]
[Preconditions, ., checkArgument, (, n, ., isCall, (, ), ||, n, ., isNew, (, ), ), ;, Node, constructorNameNode, =]
[||, n, ., isNew, (, ), ), ;, Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =]
[(, ), ), ;, Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (]
[(, ), ), ;, Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (]
[Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (, ), &&]
[Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (, ), &&]
[Node, constructorNameNode, =, n, ., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (, ), &&]
[., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (, ), &&, Token, ., NAME, ==]
[., getFirstChild, (, ), ;, Node, newLiteralNode, =, null, ;, if, (, isASTNormalized, (, ), &&, Token, ., NAME, ==]
[if, (, isASTNormalized, (, ), &&, Token, ., NAME, ==, constructorNameNode, ., getType, (, ), ), {, String, className, =]
[if, (, isASTNormalized, (, ), &&, Token, ., NAME, ==, constructorNameNode, ., getType, (, ), ), {, String, className, =]
[NAME, ==, constructorNameNode, ., getType, (, ), ), {, String, className, =, constructorNameNode, ., getString, (, ), ;, if, (]
[NAME, ==, constructorNameNode, ., getType, (, ), ), {, String, className, =, constructorNameNode, ., getString, (, ), ;, if, (]
[getType, (, ), ), {, String, className, =, constructorNameNode, ., getString, (, ), ;, if, (, "RegExp", ., equals, (]
[String, className, =, constructorNameNode, ., getString, (, ), ;, if, (, "RegExp", ., equals, (, className, ), ), {, return]
[=, constructorNameNode, ., getString, (, ), ;, if, (, "RegExp", ., equals, (, className, ), ), {, return, tryFoldRegularExpressionConstructor, (]
["RegExp", ., equals, (, className, ), ), {, return, tryFoldRegularExpressionConstructor, (, n, ), ;, }, else, {, boolean, constructorHasArgs, =]
["RegExp", ., equals, (, className, ), ), {, return, tryFoldRegularExpressionConstructor, (, n, ), ;, }, else, {, boolean, constructorHasArgs, =]
["RegExp", ., equals, (, className, ), ), {, return, tryFoldRegularExpressionConstructor, (, n, ), ;, }, else, {, boolean, constructorHasArgs, =]
[), {, return, tryFoldRegularExpressionConstructor, (, n, ), ;, }, else, {, boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=]
[(, n, ), ;, }, else, {, boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=, null, ;, if, (]
[(, n, ), ;, }, else, {, boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=, null, ;, if, (]
[(, n, ), ;, }, else, {, boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=, null, ;, if, (]
[}, else, {, boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=, null, ;, if, (, "Object", ., equals, (]
[boolean, constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=, null, ;, if, (, "Object", ., equals, (, className, ), &&]
[constructorHasArgs, =, constructorNameNode, ., getNext, (, ), !=, null, ;, if, (, "Object", ., equals, (, className, ), &&, !]
[., getNext, (, ), !=, null, ;, if, (, "Object", ., equals, (, className, ), &&, !, constructorHasArgs, ), {]
[(, ), !=, null, ;, if, (, "Object", ., equals, (, className, ), &&, !, constructorHasArgs, ), {, newLiteralNode, =]
[(, ), !=, null, ;, if, (, "Object", ., equals, (, className, ), &&, !, constructorHasArgs, ), {, newLiteralNode, =]
[(, className, ), &&, !, constructorHasArgs, ), {, newLiteralNode, =, IR, ., objectlit, (, ), ;, }, else, if, (]
[(, className, ), &&, !, constructorHasArgs, ), {, newLiteralNode, =, IR, ., objectlit, (, ), ;, }, else, if, (]
[!, constructorHasArgs, ), {, newLiteralNode, =, IR, ., objectlit, (, ), ;, }, else, if, (, "Array", ., equals, (]
[., objectlit, (, ), ;, }, else, if, (, "Array", ., equals, (, className, ), ), {, Node, arg0, =]
[., objectlit, (, ), ;, }, else, if, (, "Array", ., equals, (, className, ), ), {, Node, arg0, =]
["Array", ., equals, (, className, ), ), {, Node, arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =]
[equals, (, className, ), ), {, Node, arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (]
[{, Node, arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (]
[{, Node, arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (]
[{, Node, arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (]
[arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (, action, ==]
[arg0, =, constructorNameNode, ., getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (, action, ==]
[getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||]
[getNext, (, ), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||]
[), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==]
[), ;, FoldArrayAction, action, =, isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==]
[isSafeToFoldArrayConstructor, (, arg0, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {]
[arg0, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =]
[arg0, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =]
[==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;]
[==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ||, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;]
[., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (]
[., SAFE_TO_FOLD_WITHOUT_ARGS, ), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (]
[), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (, action, ==]
[), {, newLiteralNode, =, IR, ., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (, action, ==]
[., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {]
[., arraylit, (, ), ;, n, ., removeChildren, (, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {]
[;, n, ., removeChildren, (, ), ;, if, (, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (]
[(, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (]
[(, action, ==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (]
[==, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (, newLiteralNode, !=]
[SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (, newLiteralNode, !=, null, ), {]
[SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (, newLiteralNode, !=, null, ), {]
[SAFE_TO_FOLD_WITH_ARGS, ), {, newLiteralNode, ., addChildrenToFront, (, arg0, ), ;, }, }, }, if, (, newLiteralNode, !=, null, ), {]
[), ;, }, }, }, if, (, newLiteralNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild, (]
[}, }, }, if, (, newLiteralNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[if, (, newLiteralNode, !=, null, ), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, newLiteralNode, ), ;]
[), {, n, ., getParent, (, ), ., replaceChild, (, n, ,, newLiteralNode, ), ;, reportCodeChange, (, ), ;, return]
[), ., replaceChild, (, n, ,, newLiteralNode, ), ;, reportCodeChange, (, ), ;, return, newLiteralNode, ;, }, }, }, return]
[enum, FoldArrayAction, {, NOT_SAFE_TO_FOLD, ,, SAFE_TO_FOLD_WITH_ARGS, ,, SAFE_TO_FOLD_WITHOUT_ARGS, }, private, FoldArrayAction, isSafeToFoldArrayConstructor, (, Node, arg, ), {, FoldArrayAction, action, =]
[enum, FoldArrayAction, {, NOT_SAFE_TO_FOLD, ,, SAFE_TO_FOLD_WITH_ARGS, ,, SAFE_TO_FOLD_WITHOUT_ARGS, }, private, FoldArrayAction, isSafeToFoldArrayConstructor, (, Node, arg, ), {, FoldArrayAction, action, =]
[,, SAFE_TO_FOLD_WITHOUT_ARGS, }, private, FoldArrayAction, isSafeToFoldArrayConstructor, (, Node, arg, ), {, FoldArrayAction, action, =, FoldArrayAction, ., NOT_SAFE_TO_FOLD, ;, if, (]
[,, SAFE_TO_FOLD_WITHOUT_ARGS, }, private, FoldArrayAction, isSafeToFoldArrayConstructor, (, Node, arg, ), {, FoldArrayAction, action, =, FoldArrayAction, ., NOT_SAFE_TO_FOLD, ;, if, (]
[}, private, FoldArrayAction, isSafeToFoldArrayConstructor, (, Node, arg, ), {, FoldArrayAction, action, =, FoldArrayAction, ., NOT_SAFE_TO_FOLD, ;, if, (, arg, ==]
[isSafeToFoldArrayConstructor, (, Node, arg, ), {, FoldArrayAction, action, =, FoldArrayAction, ., NOT_SAFE_TO_FOLD, ;, if, (, arg, ==, null, ), {]
[Node, arg, ), {, FoldArrayAction, action, =, FoldArrayAction, ., NOT_SAFE_TO_FOLD, ;, if, (, arg, ==, null, ), {, action, =]
[Node, arg, ), {, FoldArrayAction, action, =, FoldArrayAction, ., NOT_SAFE_TO_FOLD, ;, if, (, arg, ==, null, ), {, action, =]
[., NOT_SAFE_TO_FOLD, ;, if, (, arg, ==, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (]
[., NOT_SAFE_TO_FOLD, ;, if, (, arg, ==, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (]
[., NOT_SAFE_TO_FOLD, ;, if, (, arg, ==, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (]
[==, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, ., getNext, (, ), !=]
[{, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, ., getNext, (, ), !=, null, ), {]
[=, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, ., getNext, (, ), !=, null, ), {, action, =]
[=, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, else, if, (, arg, ., getNext, (, ), !=, null, ), {, action, =]
[arg, ., getNext, (, ), !=, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (]
[arg, ., getNext, (, ), !=, null, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (]
[{, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (, arg, ., getType, (, ), ), {, case]
[{, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (, arg, ., getType, (, ), ), {, case]
[., SAFE_TO_FOLD_WITH_ARGS, ;, }, else, {, switch, (, arg, ., getType, (, ), ), {, case, Token, ., STRING, :]
[;, }, else, {, switch, (, arg, ., getType, (, ), ), {, case, Token, ., STRING, :, action, =]
[;, }, else, {, switch, (, arg, ., getType, (, ), ), {, case, Token, ., STRING, :, action, =]
[., getType, (, ), ), {, case, Token, ., STRING, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case]
[., getType, (, ), ), {, case, Token, ., STRING, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case]
[case, Token, ., STRING, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :, if, (]
[case, Token, ., STRING, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :, if, (]
[case, Token, ., STRING, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :, if, (]
[=, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :, if, (, arg, ., getDouble, (, ), ==]
[SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, case, Token, ., NUMBER, :, if, (, arg, ., getDouble, (, ), ==, 0, ), {]
[break, ;, case, Token, ., NUMBER, :, if, (, arg, ., getDouble, (, ), ==, 0, ), {, action, =]
[break, ;, case, Token, ., NUMBER, :, if, (, arg, ., getDouble, (, ), ==, 0, ), {, action, =]
[(, arg, ., getDouble, (, ), ==, 0, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case]
[(, arg, ., getDouble, (, ), ==, 0, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case]
[(, ), ==, 0, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case, Token, ., ARRAYLIT, :]
[==, 0, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case, Token, ., ARRAYLIT, :, action, =]
[==, 0, ), {, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITHOUT_ARGS, ;, }, break, ;, case, Token, ., ARRAYLIT, :, action, =]
[break, ;, case, Token, ., ARRAYLIT, :, action, =, FoldArrayAction, ., SAFE_TO_FOLD_WITH_ARGS, ;, break, ;, default, :, }, }, return]
[;, default, :, }, }, return, action, ;, }, private, Node, tryFoldRegularExpressionConstructor, (, Node, n, ), {, Node, parent, =]
[;, default, :, }, }, return, action, ;, }, private, Node, tryFoldRegularExpressionConstructor, (, Node, n, ), {, Node, parent, =]
[private, Node, tryFoldRegularExpressionConstructor, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, constructor, =]
[private, Node, tryFoldRegularExpressionConstructor, (, Node, n, ), {, Node, parent, =, n, ., getParent, (, ), ;, Node, constructor, =]
[parent, =, n, ., getParent, (, ), ;, Node, constructor, =, n, ., getFirstChild, (, ), ;, Node, pattern, =]
[parent, =, n, ., getParent, (, ), ;, Node, constructor, =, n, ., getFirstChild, (, ), ;, Node, pattern, =]
[constructor, =, n, ., getFirstChild, (, ), ;, Node, pattern, =, constructor, ., getNext, (, ), ;, Node, flags, =]
[constructor, =, n, ., getFirstChild, (, ), ;, Node, pattern, =, constructor, ., getNext, (, ), ;, Node, flags, =]
[constructor, =, n, ., getFirstChild, (, ), ;, Node, pattern, =, constructor, ., getNext, (, ), ;, Node, flags, =]
[n, ., getFirstChild, (, ), ;, Node, pattern, =, constructor, ., getNext, (, ), ;, Node, flags, =, null, !=]
[getFirstChild, (, ), ;, Node, pattern, =, constructor, ., getNext, (, ), ;, Node, flags, =, null, !=, pattern, ?]
[getFirstChild, (, ), ;, Node, pattern, =, constructor, ., getNext, (, ), ;, Node, flags, =, null, !=, pattern, ?]
[=, constructor, ., getNext, (, ), ;, Node, flags, =, null, !=, pattern, ?, pattern, ., getNext, (, ), :]
[(, ), ;, Node, flags, =, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (]
[(, ), ;, Node, flags, =, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (]
[(, ), ;, Node, flags, =, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (]
[;, Node, flags, =, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==]
[flags, =, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||]
[=, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (]
[=, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (]
[=, null, !=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (]
[!=, pattern, ?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (, null, !=]
[?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&]
[?, pattern, ., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&]
[., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&, null, !=]
[., getNext, (, ), :, null, ;, if, (, null, ==, pattern, ||, (, null, !=, flags, &&, null, !=]
[null, ==, pattern, ||, (, null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return]
[null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (]
[null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (]
[null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (]
[null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (]
[null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (]
[null, !=, flags, &&, null, !=, flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (]
[flags, ., getNext, (, ), ), ), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&]
[., getNext, (, ), ), ), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !]
[., getNext, (, ), ), ), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !]
[), ), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (]
[), ), {, return, n, ;, }, if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (]
[if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, ), ), &&]
[if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, ), ), &&]
[if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, ), ), &&]
[if, (, pattern, ., isString, (, ), &&, !, "", ., equals, (, pattern, ., getString, (, ), ), &&]
[., equals, (, pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <]
[(, pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&]
[pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (]
[pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (]
[pattern, ., getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (]
[getString, (, ), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==]
[), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==, flags, ||]
[), ), &&, pattern, ., getString, (, ), ., length, (, ), <, 100, &&, (, null, ==, flags, ||]
[), ., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&]
[., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (]
[., length, (, ), <, 100, &&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (]
[<, 100, &&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||]
[100, &&, (, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !]
[(, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (]
[(, null, ==, flags, ||, flags, ., isString, (, ), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (]
[), ), &&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), ), ), {]
[&&, (, isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), ), ), {, pattern, =]
[isEcmaScript5OrGreater, (, ), ||, !, containsUnicodeEscape, (, pattern, ., getString, (, ), ), ), ), {, pattern, =, makeForwardSlashBracketSafe, (]
[., getString, (, ), ), ), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (]
[., getString, (, ), ), ), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (]
[., getString, (, ), ), ), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (]
[(, ), ), ), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==]
[), ), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||]
[), ), ), {, pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||]
[pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, "", ., equals, (]
[pattern, =, makeForwardSlashBracketSafe, (, pattern, ), ;, Node, regexLiteral, ;, if, (, null, ==, flags, ||, "", ., equals, (]
[regexLiteral, ;, if, (, null, ==, flags, ||, "", ., equals, (, flags, ., getString, (, ), ), ), {]
[if, (, null, ==, flags, ||, "", ., equals, (, flags, ., getString, (, ), ), ), {, regexLiteral, =]
[if, (, null, ==, flags, ||, "", ., equals, (, flags, ., getString, (, ), ), ), {, regexLiteral, =]
[flags, ||, "", ., equals, (, flags, ., getString, (, ), ), ), {, regexLiteral, =, IR, ., regexp, (]
[getString, (, ), ), ), {, regexLiteral, =, IR, ., regexp, (, pattern, ), ;, }, else, {, if, (]
[(, ), ), ), {, regexLiteral, =, IR, ., regexp, (, pattern, ), ;, }, else, {, if, (, !]
[), ), {, regexLiteral, =, IR, ., regexp, (, pattern, ), ;, }, else, {, if, (, !, areValidRegexpFlags, (]
[), ), {, regexLiteral, =, IR, ., regexp, (, pattern, ), ;, }, else, {, if, (, !, areValidRegexpFlags, (]
[(, pattern, ), ;, }, else, {, if, (, !, areValidRegexpFlags, (, flags, ., getString, (, ), ), ), {]
[), ;, }, else, {, if, (, !, areValidRegexpFlags, (, flags, ., getString, (, ), ), ), {, report, (]
[}, else, {, if, (, !, areValidRegexpFlags, (, flags, ., getString, (, ), ), ), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,]
[(, !, areValidRegexpFlags, (, flags, ., getString, (, ), ), ), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, ), ;, return]
[., getString, (, ), ), ), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, ), ;, return, n, ;, }, if, (]
[getString, (, ), ), ), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, ), ;, return, n, ;, }, if, (, !]
[), ), ), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, ), ;, return, n, ;, }, if, (, !, areSafeFlagsToFold, (]
[), ), ), {, report, (, INVALID_REGULAR_EXPRESSION_FLAGS, ,, flags, ), ;, return, n, ;, }, if, (, !, areSafeFlagsToFold, (]
[), ;, return, n, ;, }, if, (, !, areSafeFlagsToFold, (, flags, ., getString, (, ), ), ), {, return]
[n, ;, }, if, (, !, areSafeFlagsToFold, (, flags, ., getString, (, ), ), ), {, return, n, ;, }]
[n, ;, }, if, (, !, areSafeFlagsToFold, (, flags, ., getString, (, ), ), ), {, return, n, ;, }]
[(, !, areSafeFlagsToFold, (, flags, ., getString, (, ), ), ), {, return, n, ;, }, n, ., removeChild, (]
[(, flags, ., getString, (, ), ), ), {, return, n, ;, }, n, ., removeChild, (, flags, ), ;]
[., getString, (, ), ), ), {, return, n, ;, }, n, ., removeChild, (, flags, ), ;, regexLiteral, =]
[., getString, (, ), ), ), {, return, n, ;, }, n, ., removeChild, (, flags, ), ;, regexLiteral, =]
[), ), {, return, n, ;, }, n, ., removeChild, (, flags, ), ;, regexLiteral, =, IR, ., regexp, (]
[{, return, n, ;, }, n, ., removeChild, (, flags, ), ;, regexLiteral, =, IR, ., regexp, (, pattern, ,]
[}, n, ., removeChild, (, flags, ), ;, regexLiteral, =, IR, ., regexp, (, pattern, ,, flags, ), ;, }]
[}, n, ., removeChild, (, flags, ), ;, regexLiteral, =, IR, ., regexp, (, pattern, ,, flags, ), ;, }]
[(, flags, ), ;, regexLiteral, =, IR, ., regexp, (, pattern, ,, flags, ), ;, }, parent, ., replaceChild, (]
[), ;, regexLiteral, =, IR, ., regexp, (, pattern, ,, flags, ), ;, }, parent, ., replaceChild, (, n, ,]
[=, IR, ., regexp, (, pattern, ,, flags, ), ;, }, parent, ., replaceChild, (, n, ,, regexLiteral, ), ;]
[pattern, ,, flags, ), ;, }, parent, ., replaceChild, (, n, ,, regexLiteral, ), ;, reportCodeChange, (, ), ;, return]
[;, }, parent, ., replaceChild, (, n, ,, regexLiteral, ), ;, reportCodeChange, (, ), ;, return, regexLiteral, ;, }, return]
[), ;, return, regexLiteral, ;, }, return, n, ;, }, private, Node, reduceTrueFalse, (, Node, n, ), {, if, (]
[return, n, ;, }, private, Node, reduceTrueFalse, (, Node, n, ), {, if, (, late, ), {, Node, not, =]
[return, n, ;, }, private, Node, reduceTrueFalse, (, Node, n, ), {, if, (, late, ), {, Node, not, =]
[private, Node, reduceTrueFalse, (, Node, n, ), {, if, (, late, ), {, Node, not, =, IR, ., not, (]
[private, Node, reduceTrueFalse, (, Node, n, ), {, if, (, late, ), {, Node, not, =, IR, ., not, (]
[Node, n, ), {, if, (, late, ), {, Node, not, =, IR, ., not, (, IR, ., number, (]
[Node, n, ), {, if, (, late, ), {, Node, not, =, IR, ., not, (, IR, ., number, (]
[Node, n, ), {, if, (, late, ), {, Node, not, =, IR, ., not, (, IR, ., number, (]
[late, ), {, Node, not, =, IR, ., not, (, IR, ., number, (, n, ., isTrue, (, ), ?]
[{, Node, not, =, IR, ., not, (, IR, ., number, (, n, ., isTrue, (, ), ?, 0, :]
[IR, ., not, (, IR, ., number, (, n, ., isTrue, (, ), ?, 0, :, 1, ), ), ;]
[IR, ., not, (, IR, ., number, (, n, ., isTrue, (, ), ?, 0, :, 1, ), ), ;]
[IR, ., number, (, n, ., isTrue, (, ), ?, 0, :, 1, ), ), ;, not, ., copyInformationFromForTree, (]
[(, n, ., isTrue, (, ), ?, 0, :, 1, ), ), ;, not, ., copyInformationFromForTree, (, n, ), ;]
[(, n, ., isTrue, (, ), ?, 0, :, 1, ), ), ;, not, ., copyInformationFromForTree, (, n, ), ;]
[(, n, ., isTrue, (, ), ?, 0, :, 1, ), ), ;, not, ., copyInformationFromForTree, (, n, ), ;]
[:, 1, ), ), ;, not, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ), ;, not, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[not, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, not, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, not, ), ;, reportCodeChange, (, ), ;, return]
[getParent, (, ), ., replaceChild, (, n, ,, not, ), ;, reportCodeChange, (, ), ;, return, not, ;, }, return]
[;, return, not, ;, }, return, n, ;, }, private, Node, tryMinimizeArrayLiteral, (, Node, n, ), {, boolean, allStrings, =]
[;, }, private, Node, tryMinimizeArrayLiteral, (, Node, n, ), {, boolean, allStrings, =, true, ;, for, (, Node, cur, =]
[;, }, private, Node, tryMinimizeArrayLiteral, (, Node, n, ), {, boolean, allStrings, =, true, ;, for, (, Node, cur, =]
[Node, n, ), {, boolean, allStrings, =, true, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;]
[Node, n, ), {, boolean, allStrings, =, true, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;]
[), {, boolean, allStrings, =, true, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=]
[boolean, allStrings, =, true, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=, null, ;]
[=, true, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =]
[=, true, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =]
[., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, if, (]
[getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, if, (, !]
[getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, if, (, !]
[;, cur, =, cur, ., getNext, (, ), ), {, if, (, !, cur, ., isString, (, ), ), {]
[=, cur, ., getNext, (, ), ), {, if, (, !, cur, ., isString, (, ), ), {, allStrings, =]
[), {, if, (, !, cur, ., isString, (, ), ), {, allStrings, =, false, ;, }, }, if, (]
[!, cur, ., isString, (, ), ), {, allStrings, =, false, ;, }, }, if, (, allStrings, ), {, return]
[., isString, (, ), ), {, allStrings, =, false, ;, }, }, if, (, allStrings, ), {, return, tryMinimizeStringArrayLiteral, (]
[=, false, ;, }, }, if, (, allStrings, ), {, return, tryMinimizeStringArrayLiteral, (, n, ), ;, }, else, {, return]
[), ;, }, else, {, return, n, ;, }, }, private, Node, tryMinimizeStringArrayLiteral, (, Node, n, ), {, if, (]
[;, }, else, {, return, n, ;, }, }, private, Node, tryMinimizeStringArrayLiteral, (, Node, n, ), {, if, (, !]
[return, n, ;, }, }, private, Node, tryMinimizeStringArrayLiteral, (, Node, n, ), {, if, (, !, late, ), {, return]
[Node, tryMinimizeStringArrayLiteral, (, Node, n, ), {, if, (, !, late, ), {, return, n, ;, }, int, numElements, =]
[Node, tryMinimizeStringArrayLiteral, (, Node, n, ), {, if, (, !, late, ), {, return, n, ;, }, int, numElements, =]
[!, late, ), {, return, n, ;, }, int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =]
[!, late, ), {, return, n, ;, }, int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =]
[!, late, ), {, return, n, ;, }, int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =]
[), {, return, n, ;, }, int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =, numElements, *]
[return, n, ;, }, int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =, numElements, *, 2, -]
[int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =, numElements, *, 2, -, STRING_SPLIT_OVERHEAD, ;, if, (]
[int, numElements, =, n, ., getChildCount, (, ), ;, int, saving, =, numElements, *, 2, -, STRING_SPLIT_OVERHEAD, ;, if, (]
[=, n, ., getChildCount, (, ), ;, int, saving, =, numElements, *, 2, -, STRING_SPLIT_OVERHEAD, ;, if, (, saving, <=]
[(, ), ;, int, saving, =, numElements, *, 2, -, STRING_SPLIT_OVERHEAD, ;, if, (, saving, <=, 0, ), {, return]
[2, -, STRING_SPLIT_OVERHEAD, ;, if, (, saving, <=, 0, ), {, return, n, ;, }, String, [, ], strings, =]
[;, if, (, saving, <=, 0, ), {, return, n, ;, }, String, [, ], strings, =, new, String, []
[;, if, (, saving, <=, 0, ), {, return, n, ;, }, String, [, ], strings, =, new, String, []
[;, }, String, [, ], strings, =, new, String, [, n, ., getChildCount, (, ), ], ;, int, idx, =]
[new, String, [, n, ., getChildCount, (, ), ], ;, int, idx, =, 0, ;, for, (, Node, cur, =]
[new, String, [, n, ., getChildCount, (, ), ], ;, int, idx, =, 0, ;, for, (, Node, cur, =]
[(, ), ], ;, int, idx, =, 0, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;]
[(, ), ], ;, int, idx, =, 0, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;]
[], ;, int, idx, =, 0, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=]
[int, idx, =, 0, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=, null, ;]
[=, 0, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =]
[=, 0, ;, for, (, Node, cur, =, n, ., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =]
[=, n, ., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {]
[=, n, ., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {]
[., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, strings, []
[., getFirstChild, (, ), ;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, strings, []
[;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, strings, [, idx, ++, ], =]
[;, cur, !=, null, ;, cur, =, cur, ., getNext, (, ), ), {, strings, [, idx, ++, ], =]
[(, ), ), {, strings, [, idx, ++, ], =, cur, ., getString, (, ), ;, }, String, delimiter, =]
[), {, strings, [, idx, ++, ], =, cur, ., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (]
[++, ], =, cur, ., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (]
[++, ], =, cur, ., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (]
[=, cur, ., getString, (, ), ;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (, delimiter, !=]
[;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (, delimiter, !=, null, ), {, String, template, =]
[;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (, delimiter, !=, null, ), {, String, template, =]
[;, }, String, delimiter, =, pickDelimiter, (, strings, ), ;, if, (, delimiter, !=, null, ), {, String, template, =]
[=, pickDelimiter, (, strings, ), ;, if, (, delimiter, !=, null, ), {, String, template, =, Joiner, ., on, (]
[;, if, (, delimiter, !=, null, ), {, String, template, =, Joiner, ., on, (, delimiter, ), ., join, (]
[), {, String, template, =, Joiner, ., on, (, delimiter, ), ., join, (, strings, ), ;, Node, call, =]
[), {, String, template, =, Joiner, ., on, (, delimiter, ), ., join, (, strings, ), ;, Node, call, =]
[=, Joiner, ., on, (, delimiter, ), ., join, (, strings, ), ;, Node, call, =, IR, ., call, (]
[=, Joiner, ., on, (, delimiter, ), ., join, (, strings, ), ;, Node, call, =, IR, ., call, (]
[(, delimiter, ), ., join, (, strings, ), ;, Node, call, =, IR, ., call, (, IR, ., getprop, (]
[(, delimiter, ), ., join, (, strings, ), ;, Node, call, =, IR, ., call, (, IR, ., getprop, (]
[join, (, strings, ), ;, Node, call, =, IR, ., call, (, IR, ., getprop, (, IR, ., string, (]
[), ;, Node, call, =, IR, ., call, (, IR, ., getprop, (, IR, ., string, (, template, ), ,]
[), ;, Node, call, =, IR, ., call, (, IR, ., getprop, (, IR, ., string, (, template, ), ,]
[=, IR, ., call, (, IR, ., getprop, (, IR, ., string, (, template, ), ,, IR, ., string, (]
[(, IR, ., getprop, (, IR, ., string, (, template, ), ,, IR, ., string, (, "split", ), ), ,]
[(, IR, ., getprop, (, IR, ., string, (, template, ), ,, IR, ., string, (, "split", ), ), ,]
[(, IR, ., string, (, template, ), ,, IR, ., string, (, "split", ), ), ,, IR, ., string, (]
[(, IR, ., string, (, template, ), ,, IR, ., string, (, "split", ), ), ,, IR, ., string, (]
[., string, (, template, ), ,, IR, ., string, (, "split", ), ), ,, IR, ., string, (, "", +]
[), ,, IR, ., string, (, "split", ), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;]
[), ,, IR, ., string, (, "split", ), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;]
[string, (, "split", ), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;, call, ., copyInformationFromForTree, (]
[), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;, call, ., copyInformationFromForTree, (, n, ), ;]
[), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;, call, ., copyInformationFromForTree, (, n, ), ;]
[), ), ,, IR, ., string, (, "", +, delimiter, ), ), ;, call, ., copyInformationFromForTree, (, n, ), ;]
[+, delimiter, ), ), ;, call, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (]
[), ), ;, call, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,]
[call, ., copyInformationFromForTree, (, n, ), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, call, ), ;]
[), ;, n, ., getParent, (, ), ., replaceChild, (, n, ,, call, ), ;, reportCodeChange, (, ), ;, return]
[getParent, (, ), ., replaceChild, (, n, ,, call, ), ;, reportCodeChange, (, ), ;, return, call, ;, }, return]
[call, ;, }, return, n, ;, }, private, String, pickDelimiter, (, String, [, ], strings, ), {, boolean, allLength1, =]
[private, String, pickDelimiter, (, String, [, ], strings, ), {, boolean, allLength1, =, true, ;, for, (, String, s, :]
[[, ], strings, ), {, boolean, allLength1, =, true, ;, for, (, String, s, :, strings, ), {, if, (]
[[, ], strings, ), {, boolean, allLength1, =, true, ;, for, (, String, s, :, strings, ), {, if, (]
[[, ], strings, ), {, boolean, allLength1, =, true, ;, for, (, String, s, :, strings, ), {, if, (]
[allLength1, =, true, ;, for, (, String, s, :, strings, ), {, if, (, s, ., length, (, ), !=]
[;, for, (, String, s, :, strings, ), {, if, (, s, ., length, (, ), !=, 1, ), {]
[(, String, s, :, strings, ), {, if, (, s, ., length, (, ), !=, 1, ), {, allLength1, =]
[(, s, ., length, (, ), !=, 1, ), {, allLength1, =, false, ;, break, ;, }, }, if, (]
[(, ), !=, 1, ), {, allLength1, =, false, ;, break, ;, }, }, if, (, allLength1, ), {, return]
[false, ;, break, ;, }, }, if, (, allLength1, ), {, return, "", ;, }, String, [, ], delimiters, =]
[}, }, if, (, allLength1, ), {, return, "", ;, }, String, [, ], delimiters, =, new, String, [, ]]
[}, if, (, allLength1, ), {, return, "", ;, }, String, [, ], delimiters, =, new, String, [, ], {]
[(, allLength1, ), {, return, "", ;, }, String, [, ], delimiters, =, new, String, [, ], {, " ", ,]
[), {, return, "", ;, }, String, [, ], delimiters, =, new, String, [, ], {, " ", ,, ";", ,]
[return, "", ;, }, String, [, ], delimiters, =, new, String, [, ], {, " ", ,, ";", ,, ",", ,]
[;, }, String, [, ], delimiters, =, new, String, [, ], {, " ", ,, ";", ,, ",", ,, "{", ,]
[String, [, ], delimiters, =, new, String, [, ], {, " ", ,, ";", ,, ",", ,, "{", ,, "}", ,]
[String, [, ], {, " ", ,, ";", ,, ",", ,, "{", ,, "}", ,, null, }, ;, int, i, =]
[,, ",", ,, "{", ,, "}", ,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;]
[,, ",", ,, "{", ,, "}", ,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;]
[,, ",", ,, "{", ,, "}", ,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;]
[,, "{", ,, "}", ,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, []
["}", ,, null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, [, i, ], !=]
[null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, [, i, ], !=, null, ;]
[null, }, ;, int, i, =, 0, ;, NEXT_DELIMITER, :, for, (, ;, delimiters, [, i, ], !=, null, ;]
[:, for, (, ;, delimiters, [, i, ], !=, null, ;, i, ++, ), {, for, (, String, cur, :]
[[, i, ], !=, null, ;, i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (]
[[, i, ], !=, null, ;, i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (]
[null, ;, i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (, cur, ., contains, (]
[null, ;, i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (, cur, ., contains, (]
[i, ++, ), {, for, (, String, cur, :, strings, ), {, if, (, cur, ., contains, (, delimiters, []
[cur, ., contains, (, delimiters, [, i, ], ), ), {, continue, NEXT_DELIMITER, ;, }, }, break, ;, }, return]
[cur, ., contains, (, delimiters, [, i, ], ), ), {, continue, NEXT_DELIMITER, ;, }, }, break, ;, }, return]
[contains, (, delimiters, [, i, ], ), ), {, continue, NEXT_DELIMITER, ;, }, }, break, ;, }, return, delimiters, []
[NEXT_DELIMITER, ;, }, }, break, ;, }, return, delimiters, [, i, ], ;, }, private, static, final, Pattern, REGEXP_FLAGS_RE, =]
[NEXT_DELIMITER, ;, }, }, break, ;, }, return, delimiters, [, i, ], ;, }, private, static, final, Pattern, REGEXP_FLAGS_RE, =]
[break, ;, }, return, delimiters, [, i, ], ;, }, private, static, final, Pattern, REGEXP_FLAGS_RE, =, Pattern, ., compile, (]
[Pattern, REGEXP_FLAGS_RE, =, Pattern, ., compile, (, "^[gmi]*$", ), ;, private, static, boolean, areValidRegexpFlags, (, String, flags, ), {, return]
[Pattern, REGEXP_FLAGS_RE, =, Pattern, ., compile, (, "^[gmi]*$", ), ;, private, static, boolean, areValidRegexpFlags, (, String, flags, ), {, return]
[Pattern, REGEXP_FLAGS_RE, =, Pattern, ., compile, (, "^[gmi]*$", ), ;, private, static, boolean, areValidRegexpFlags, (, String, flags, ), {, return]
[., compile, (, "^[gmi]*$", ), ;, private, static, boolean, areValidRegexpFlags, (, String, flags, ), {, return, REGEXP_FLAGS_RE, ., matcher, (]
[., matcher, (, flags, ), ., matches, (, ), ;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return]
[., matcher, (, flags, ), ., matches, (, ), ;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return]
[), ., matches, (, ), ;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return, isEcmaScript5OrGreater, (, ), ||]
[), ., matches, (, ), ;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return, isEcmaScript5OrGreater, (, ), ||]
[), ., matches, (, ), ;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return, isEcmaScript5OrGreater, (, ), ||]
[), ;, }, private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return, isEcmaScript5OrGreater, (, ), ||, flags, ., indexOf, (]
[private, boolean, areSafeFlagsToFold, (, String, flags, ), {, return, isEcmaScript5OrGreater, (, ), ||, flags, ., indexOf, (, 'g', ), <]
[indexOf, (, 'g', ), <, 0, ;, }, private, static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {, String, s, =]
[indexOf, (, 'g', ), <, 0, ;, }, private, static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {, String, s, =]
[static, Node, makeForwardSlashBracketSafe, (, Node, n, ), {, String, s, =, n, ., getString, (, ), ;, StringBuilder, sb, =]
[n, ), {, String, s, =, n, ., getString, (, ), ;, StringBuilder, sb, =, null, ;, int, pos, =]
[=, n, ., getString, (, ), ;, StringBuilder, sb, =, null, ;, int, pos, =, 0, ;, boolean, isEscaped, =]
[(, ), ;, StringBuilder, sb, =, null, ;, int, pos, =, 0, ;, boolean, isEscaped, =, false, ,, inCharset, =]
[;, int, pos, =, 0, ;, boolean, isEscaped, =, false, ,, inCharset, =, false, ;, for, (, int, i, =]
[pos, =, 0, ;, boolean, isEscaped, =, false, ,, inCharset, =, false, ;, for, (, int, i, =, 0, ;]
[pos, =, 0, ;, boolean, isEscaped, =, false, ,, inCharset, =, false, ;, for, (, int, i, =, 0, ;]
[0, ;, boolean, isEscaped, =, false, ,, inCharset, =, false, ;, for, (, int, i, =, 0, ;, i, <]
[0, ;, boolean, isEscaped, =, false, ,, inCharset, =, false, ;, for, (, int, i, =, 0, ;, i, <]
[,, inCharset, =, false, ;, for, (, int, i, =, 0, ;, i, <, s, ., length, (, ), ;]
[inCharset, =, false, ;, for, (, int, i, =, 0, ;, i, <, s, ., length, (, ), ;, ++]
[int, i, =, 0, ;, i, <, s, ., length, (, ), ;, ++, i, ), {, char, ch, =]
[int, i, =, 0, ;, i, <, s, ., length, (, ), ;, ++, i, ), {, char, ch, =]
[;, i, <, s, ., length, (, ), ;, ++, i, ), {, char, ch, =, s, ., charAt, (]
[length, (, ), ;, ++, i, ), {, char, ch, =, s, ., charAt, (, i, ), ;, switch, (]
[++, i, ), {, char, ch, =, s, ., charAt, (, i, ), ;, switch, (, ch, ), {, case]
[), {, char, ch, =, s, ., charAt, (, i, ), ;, switch, (, ch, ), {, case, '\\', :]
[char, ch, =, s, ., charAt, (, i, ), ;, switch, (, ch, ), {, case, '\\', :, isEscaped, =]
[ch, =, s, ., charAt, (, i, ), ;, switch, (, ch, ), {, case, '\\', :, isEscaped, =, !]
[(, i, ), ;, switch, (, ch, ), {, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue, ;, case]
[switch, (, ch, ), {, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue, ;, case, '/', :, if, (]
[switch, (, ch, ), {, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue, ;, case, '/', :, if, (]
[(, ch, ), {, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue, ;, case, '/', :, if, (, !]
[), {, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue, ;, case, '/', :, if, (, !, isEscaped, &&]
[{, case, '\\', :, isEscaped, =, !, isEscaped, ;, continue, ;, case, '/', :, if, (, !, isEscaped, &&, !]
[=, !, isEscaped, ;, continue, ;, case, '/', :, if, (, !, isEscaped, &&, !, inCharset, ), {, if, (]
[=, !, isEscaped, ;, continue, ;, case, '/', :, if, (, !, isEscaped, &&, !, inCharset, ), {, if, (]
[isEscaped, ;, continue, ;, case, '/', :, if, (, !, isEscaped, &&, !, inCharset, ), {, if, (, null, ==]
[;, case, '/', :, if, (, !, isEscaped, &&, !, inCharset, ), {, if, (, null, ==, sb, ), {]
['/', :, if, (, !, isEscaped, &&, !, inCharset, ), {, if, (, null, ==, sb, ), {, sb, =]
[(, !, isEscaped, &&, !, inCharset, ), {, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (]
[(, !, isEscaped, &&, !, inCharset, ), {, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (]
[(, !, isEscaped, &&, !, inCharset, ), {, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (]
[), {, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +]
[null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }]
[null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }]
[null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }]
[{, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, sb, ., append, (]
[=, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, sb, ., append, (, s, ,]
[StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, sb, ., append, (, s, ,, pos, ,]
[(, ), +, 16, ), ;, }, sb, ., append, (, s, ,, pos, ,, i, ), ., append, (]
[16, ), ;, }, sb, ., append, (, s, ,, pos, ,, i, ), ., append, (, '\\', ), ;]
[;, }, sb, ., append, (, s, ,, pos, ,, i, ), ., append, (, '\\', ), ;, pos, =]
[s, ,, pos, ,, i, ), ., append, (, '\\', ), ;, pos, =, i, ;, }, break, ;, case]
[i, ), ., append, (, '\\', ), ;, pos, =, i, ;, }, break, ;, case, '[', :, if, (]
[), ., append, (, '\\', ), ;, pos, =, i, ;, }, break, ;, case, '[', :, if, (, !]
[(, '\\', ), ;, pos, =, i, ;, }, break, ;, case, '[', :, if, (, !, isEscaped, ), {]
[), ;, pos, =, i, ;, }, break, ;, case, '[', :, if, (, !, isEscaped, ), {, inCharset, =]
[}, break, ;, case, '[', :, if, (, !, isEscaped, ), {, inCharset, =, true, ;, }, break, ;, case]
['[', :, if, (, !, isEscaped, ), {, inCharset, =, true, ;, }, break, ;, case, ']', :, if, (]
[:, if, (, !, isEscaped, ), {, inCharset, =, true, ;, }, break, ;, case, ']', :, if, (, !]
[!, isEscaped, ), {, inCharset, =, true, ;, }, break, ;, case, ']', :, if, (, !, isEscaped, ), {]
[), {, inCharset, =, true, ;, }, break, ;, case, ']', :, if, (, !, isEscaped, ), {, inCharset, =]
[}, break, ;, case, ']', :, if, (, !, isEscaped, ), {, inCharset, =, false, ;, }, break, ;, case]
[case, ']', :, if, (, !, isEscaped, ), {, inCharset, =, false, ;, }, break, ;, case, '\r', :, case]
[if, (, !, isEscaped, ), {, inCharset, =, false, ;, }, break, ;, case, '\r', :, case, '\n', :, case]
[isEscaped, ), {, inCharset, =, false, ;, }, break, ;, case, '\r', :, case, '\n', :, case, '\u2028', :, case]
[=, false, ;, }, break, ;, case, '\r', :, case, '\n', :, case, '\u2028', :, case, '\u2029', :, if, (]
[=, false, ;, }, break, ;, case, '\r', :, case, '\n', :, case, '\u2028', :, case, '\u2029', :, if, (]
[;, }, break, ;, case, '\r', :, case, '\n', :, case, '\u2028', :, case, '\u2029', :, if, (, null, ==]
[;, case, '\r', :, case, '\n', :, case, '\u2028', :, case, '\u2029', :, if, (, null, ==, sb, ), {]
['\r', :, case, '\n', :, case, '\u2028', :, case, '\u2029', :, if, (, null, ==, sb, ), {, sb, =]
['\n', :, case, '\u2028', :, case, '\u2029', :, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (]
['\n', :, case, '\u2028', :, case, '\u2029', :, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (]
['\n', :, case, '\u2028', :, case, '\u2029', :, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (]
['\u2029', :, if, (, null, ==, sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +]
[sb, ), {, sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, if, (]
[sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, if, (, isEscaped, ), {]
[sb, =, new, StringBuilder, (, s, ., length, (, ), +, 16, ), ;, }, if, (, isEscaped, ), {]
[(, s, ., length, (, ), +, 16, ), ;, }, if, (, isEscaped, ), {, sb, ., append, (]
[., length, (, ), +, 16, ), ;, }, if, (, isEscaped, ), {, sb, ., append, (, s, ,]
[(, ), +, 16, ), ;, }, if, (, isEscaped, ), {, sb, ., append, (, s, ,, pos, ,]
[(, ), +, 16, ), ;, }, if, (, isEscaped, ), {, sb, ., append, (, s, ,, pos, ,]
[+, 16, ), ;, }, if, (, isEscaped, ), {, sb, ., append, (, s, ,, pos, ,, i, -]
[(, isEscaped, ), {, sb, ., append, (, s, ,, pos, ,, i, -, 1, ), ;, }, else, {]
[(, isEscaped, ), {, sb, ., append, (, s, ,, pos, ,, i, -, 1, ), ;, }, else, {]
[sb, ., append, (, s, ,, pos, ,, i, -, 1, ), ;, }, else, {, sb, ., append, (]
[append, (, s, ,, pos, ,, i, -, 1, ), ;, }, else, {, sb, ., append, (, s, ,]
[s, ,, pos, ,, i, -, 1, ), ;, }, else, {, sb, ., append, (, s, ,, pos, ,]
[1, ), ;, }, else, {, sb, ., append, (, s, ,, pos, ,, i, ), ;, }, switch, (]
[else, {, sb, ., append, (, s, ,, pos, ,, i, ), ;, }, switch, (, ch, ), {, case]
[sb, ., append, (, s, ,, pos, ,, i, ), ;, }, switch, (, ch, ), {, case, '\r', :]
[sb, ., append, (, s, ,, pos, ,, i, ), ;, }, switch, (, ch, ), {, case, '\r', :]
[s, ,, pos, ,, i, ), ;, }, switch, (, ch, ), {, case, '\r', :, sb, ., append, (]
[;, }, switch, (, ch, ), {, case, '\r', :, sb, ., append, (, "\\r", ), ;, break, ;, case]
[switch, (, ch, ), {, case, '\r', :, sb, ., append, (, "\\r", ), ;, break, ;, case, '\n', :]
[switch, (, ch, ), {, case, '\r', :, sb, ., append, (, "\\r", ), ;, break, ;, case, '\n', :]
[{, case, '\r', :, sb, ., append, (, "\\r", ), ;, break, ;, case, '\n', :, sb, ., append, (]
[append, (, "\\r", ), ;, break, ;, case, '\n', :, sb, ., append, (, "\\n", ), ;, break, ;, case]
["\\r", ), ;, break, ;, case, '\n', :, sb, ., append, (, "\\n", ), ;, break, ;, case, '\u2028', :]
["\\r", ), ;, break, ;, case, '\n', :, sb, ., append, (, "\\n", ), ;, break, ;, case, '\u2028', :]
[;, case, '\n', :, sb, ., append, (, "\\n", ), ;, break, ;, case, '\u2028', :, sb, ., append, (]
[append, (, "\\n", ), ;, break, ;, case, '\u2028', :, sb, ., append, (, "\\u2028", ), ;, break, ;, case]
["\\n", ), ;, break, ;, case, '\u2028', :, sb, ., append, (, "\\u2028", ), ;, break, ;, case, '\u2029', :]
["\\n", ), ;, break, ;, case, '\u2028', :, sb, ., append, (, "\\u2028", ), ;, break, ;, case, '\u2029', :]
[;, case, '\u2028', :, sb, ., append, (, "\\u2028", ), ;, break, ;, case, '\u2029', :, sb, ., append, (]
[append, (, "\\u2028", ), ;, break, ;, case, '\u2029', :, sb, ., append, (, "\\u2029", ), ;, break, ;, }]
["\\u2028", ), ;, break, ;, case, '\u2029', :, sb, ., append, (, "\\u2029", ), ;, break, ;, }, pos, =]
["\\u2028", ), ;, break, ;, case, '\u2029', :, sb, ., append, (, "\\u2029", ), ;, break, ;, }, pos, =]
[;, break, ;, case, '\u2029', :, sb, ., append, (, "\\u2029", ), ;, break, ;, }, pos, =, i, +]
[:, sb, ., append, (, "\\u2029", ), ;, break, ;, }, pos, =, i, +, 1, ;, break, ;, }]
[., append, (, "\\u2029", ), ;, break, ;, }, pos, =, i, +, 1, ;, break, ;, }, isEscaped, =]
[;, break, ;, }, pos, =, i, +, 1, ;, break, ;, }, isEscaped, =, false, ;, }, if, (]
[;, break, ;, }, pos, =, i, +, 1, ;, break, ;, }, isEscaped, =, false, ;, }, if, (]
[;, }, pos, =, i, +, 1, ;, break, ;, }, isEscaped, =, false, ;, }, if, (, null, ==]
[i, +, 1, ;, break, ;, }, isEscaped, =, false, ;, }, if, (, null, ==, sb, ), {, return]
[i, +, 1, ;, break, ;, }, isEscaped, =, false, ;, }, if, (, null, ==, sb, ), {, return]
[isEscaped, =, false, ;, }, if, (, null, ==, sb, ), {, return, n, ., cloneTree, (, ), ;, }]
[isEscaped, =, false, ;, }, if, (, null, ==, sb, ), {, return, n, ., cloneTree, (, ), ;, }]
[}, if, (, null, ==, sb, ), {, return, n, ., cloneTree, (, ), ;, }, sb, ., append, (]
[(, null, ==, sb, ), {, return, n, ., cloneTree, (, ), ;, }, sb, ., append, (, s, ,]
[==, sb, ), {, return, n, ., cloneTree, (, ), ;, }, sb, ., append, (, s, ,, pos, ,]
[==, sb, ), {, return, n, ., cloneTree, (, ), ;, }, sb, ., append, (, s, ,, pos, ,]
[(, ), ;, }, sb, ., append, (, s, ,, pos, ,, s, ., length, (, ), ), ;, return]
[(, ), ;, }, sb, ., append, (, s, ,, pos, ,, s, ., length, (, ), ), ;, return]
[(, ), ;, }, sb, ., append, (, s, ,, pos, ,, s, ., length, (, ), ), ;, return]
[sb, ., append, (, s, ,, pos, ,, s, ., length, (, ), ), ;, return, IR, ., string, (]
[sb, ., append, (, s, ,, pos, ,, s, ., length, (, ), ), ;, return, IR, ., string, (]
[., length, (, ), ), ;, return, IR, ., string, (, sb, ., toString, (, ), ), ., srcref, (]
[), ), ., srcref, (, n, ), ;, }, static, boolean, containsUnicodeEscape, (, String, s, ), {, String, esc, =]
[), ), ., srcref, (, n, ), ;, }, static, boolean, containsUnicodeEscape, (, String, s, ), {, String, esc, =]
[(, n, ), ;, }, static, boolean, containsUnicodeEscape, (, String, s, ), {, String, esc, =, REGEXP_ESCAPER, ., regexpEscape, (]
[(, String, s, ), {, String, esc, =, REGEXP_ESCAPER, ., regexpEscape, (, s, ), ;, for, (, int, i, =]
[String, s, ), {, String, esc, =, REGEXP_ESCAPER, ., regexpEscape, (, s, ), ;, for, (, int, i, =, -]
[), {, String, esc, =, REGEXP_ESCAPER, ., regexpEscape, (, s, ), ;, for, (, int, i, =, -, 1, ;]
[), {, String, esc, =, REGEXP_ESCAPER, ., regexpEscape, (, s, ), ;, for, (, int, i, =, -, 1, ;]
[{, String, esc, =, REGEXP_ESCAPER, ., regexpEscape, (, s, ), ;, for, (, int, i, =, -, 1, ;, (]
[esc, =, REGEXP_ESCAPER, ., regexpEscape, (, s, ), ;, for, (, int, i, =, -, 1, ;, (, i, =]
[esc, =, REGEXP_ESCAPER, ., regexpEscape, (, s, ), ;, for, (, int, i, =, -, 1, ;, (, i, =]
[regexpEscape, (, s, ), ;, for, (, int, i, =, -, 1, ;, (, i, =, esc, ., indexOf, (]
[s, ), ;, for, (, int, i, =, -, 1, ;, (, i, =, esc, ., indexOf, (, "\\u", ,]
[s, ), ;, for, (, int, i, =, -, 1, ;, (, i, =, esc, ., indexOf, (, "\\u", ,]
[;, for, (, int, i, =, -, 1, ;, (, i, =, esc, ., indexOf, (, "\\u", ,, i, +]
[i, =, -, 1, ;, (, i, =, esc, ., indexOf, (, "\\u", ,, i, +, 1, ), ), >=]
[=, esc, ., indexOf, (, "\\u", ,, i, +, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =]
[(, "\\u", ,, i, +, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (]
[(, "\\u", ,, i, +, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (]
[(, "\\u", ,, i, +, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (]
[(, "\\u", ,, i, +, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (]
[,, i, +, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -]
[+, 1, ), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >]
[), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&]
[), ), >=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&]
[>=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==]
[>=, 0, ;, ), {, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==]
[{, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (]
[{, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (]
[{, int, nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (]
[nSlashes, =, 0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (, i, -]
[0, ;, while, (, i, -, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -]
[i, -, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {]
[-, nSlashes, >, 0, &&, '\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++]
['\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if, (]
['\\', ==, esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if, (]
[esc, ., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if, (, 0, ==]
[., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (]
[., charAt, (, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (]
[(, i, -, nSlashes, -, 1, ), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &]
[1, ), ), {, ++, nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {, return]
[nSlashes, ;, }, if, (, 0, ==, (, nSlashes, &, 1, ), ), {, return, true, ;, }, }, return]
