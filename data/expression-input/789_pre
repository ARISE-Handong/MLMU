[., util, ., logging, ., Logger, ;, class, CrossModuleCodeMotion, extends, AbstractPostOrderCallback, implements, CompilerPass, {, private, static, final, Logger, logger, =]
[., util, ., logging, ., Logger, ;, class, CrossModuleCodeMotion, extends, AbstractPostOrderCallback, implements, CompilerPass, {, private, static, final, Logger, logger, =]
[., Logger, ;, class, CrossModuleCodeMotion, extends, AbstractPostOrderCallback, implements, CompilerPass, {, private, static, final, Logger, logger, =, Logger, ., getLogger, (]
[., Logger, ;, class, CrossModuleCodeMotion, extends, AbstractPostOrderCallback, implements, CompilerPass, {, private, static, final, Logger, logger, =, Logger, ., getLogger, (]
[private, final, AbstractCompiler, compiler, ;, private, final, JSModuleGraph, graph, ;, private, final, Map, <, JSModule, ,, Node, >, moduleVarParentMap, =]
[<, JSModule, ,, Node, >, (, ), ;, private, final, Map, <, Scope, ., Var, ,, NamedInfo, >, namedInfo, =]
[=, new, LinkedHashMap, <, Var, ,, NamedInfo, >, (, ), ;, CrossModuleCodeMotion, (, AbstractCompiler, compiler, ,, JSModuleGraph, graph, ), {]
[=, new, LinkedHashMap, <, Var, ,, NamedInfo, >, (, ), ;, CrossModuleCodeMotion, (, AbstractCompiler, compiler, ,, JSModuleGraph, graph, ), {]
[Var, ,, NamedInfo, >, (, ), ;, CrossModuleCodeMotion, (, AbstractCompiler, compiler, ,, JSModuleGraph, graph, ), {, this, ., compiler, =]
[NamedInfo, >, (, ), ;, CrossModuleCodeMotion, (, AbstractCompiler, compiler, ,, JSModuleGraph, graph, ), {, this, ., compiler, =, compiler, ;]
[NamedInfo, >, (, ), ;, CrossModuleCodeMotion, (, AbstractCompiler, compiler, ,, JSModuleGraph, graph, ), {, this, ., compiler, =, compiler, ;]
[;, CrossModuleCodeMotion, (, AbstractCompiler, compiler, ,, JSModuleGraph, graph, ), {, this, ., compiler, =, compiler, ;, this, ., graph, =]
[this, ., graph, =, graph, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[this, ., graph, =, graph, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[graph, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, logger, ., fine, (]
[public, void, process, (, Node, externs, ,, Node, root, ), {, logger, ., fine, (, "Moving functions + variable into deeper modules", ), ;, if, (]
[public, void, process, (, Node, externs, ,, Node, root, ), {, logger, ., fine, (, "Moving functions + variable into deeper modules", ), ;, if, (]
[public, void, process, (, Node, externs, ,, Node, root, ), {, logger, ., fine, (, "Moving functions + variable into deeper modules", ), ;, if, (]
[process, (, Node, externs, ,, Node, root, ), {, logger, ., fine, (, "Moving functions + variable into deeper modules", ), ;, if, (, graph, !=]
[Node, externs, ,, Node, root, ), {, logger, ., fine, (, "Moving functions + variable into deeper modules", ), ;, if, (, graph, !=, null, &&]
[Node, externs, ,, Node, root, ), {, logger, ., fine, (, "Moving functions + variable into deeper modules", ), ;, if, (, graph, !=, null, &&]
[Node, externs, ,, Node, root, ), {, logger, ., fine, (, "Moving functions + variable into deeper modules", ), ;, if, (, graph, !=, null, &&]
[{, logger, ., fine, (, "Moving functions + variable into deeper modules", ), ;, if, (, graph, !=, null, &&, graph, ., getModuleCount, (, ), >]
[fine, (, "Moving functions + variable into deeper modules", ), ;, if, (, graph, !=, null, &&, graph, ., getModuleCount, (, ), >, 1, ), {]
[fine, (, "Moving functions + variable into deeper modules", ), ;, if, (, graph, !=, null, &&, graph, ., getModuleCount, (, ), >, 1, ), {]
[;, if, (, graph, !=, null, &&, graph, ., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse, (]
[(, graph, !=, null, &&, graph, ., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse, (, compiler, ,]
[!=, null, &&, graph, ., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[graph, ., getModuleCount, (, ), >, 1, ), {, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;]
[this, ), ;, moveCode, (, ), ;, }, }, private, void, moveCode, (, ), {, for, (, NamedInfo, info, :]
[this, ), ;, moveCode, (, ), ;, }, }, private, void, moveCode, (, ), {, for, (, NamedInfo, info, :]
[void, moveCode, (, ), {, for, (, NamedInfo, info, :, namedInfo, ., values, (, ), ), {, JSModule, deepestDependency, =]
[void, moveCode, (, ), {, for, (, NamedInfo, info, :, namedInfo, ., values, (, ), ), {, JSModule, deepestDependency, =]
[(, NamedInfo, info, :, namedInfo, ., values, (, ), ), {, JSModule, deepestDependency, =, info, ., deepestModule, ;, if, (]
[(, NamedInfo, info, :, namedInfo, ., values, (, ), ), {, JSModule, deepestDependency, =, info, ., deepestModule, ;, if, (]
[(, NamedInfo, info, :, namedInfo, ., values, (, ), ), {, JSModule, deepestDependency, =, info, ., deepestModule, ;, if, (]
[namedInfo, ., values, (, ), ), {, JSModule, deepestDependency, =, info, ., deepestModule, ;, if, (, info, ., allowMove, &&]
[namedInfo, ., values, (, ), ), {, JSModule, deepestDependency, =, info, ., deepestModule, ;, if, (, info, ., allowMove, &&]
[values, (, ), ), {, JSModule, deepestDependency, =, info, ., deepestModule, ;, if, (, info, ., allowMove, &&, deepestDependency, !=]
[., deepestModule, ;, if, (, info, ., allowMove, &&, deepestDependency, !=, null, ), {, Iterator, <, Declaration, >, it, =]
[., deepestModule, ;, if, (, info, ., allowMove, &&, deepestDependency, !=, null, ), {, Iterator, <, Declaration, >, it, =]
[deepestDependency, !=, null, ), {, Iterator, <, Declaration, >, it, =, info, ., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph, =]
[deepestDependency, !=, null, ), {, Iterator, <, Declaration, >, it, =, info, ., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph, =]
[>, it, =, info, ., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph, =, compiler, ., getModuleGraph, (, ), ;, while, (]
[>, it, =, info, ., declarationIterator, (, ), ;, JSModuleGraph, moduleGraph, =, compiler, ., getModuleGraph, (, ), ;, while, (]
[moduleGraph, =, compiler, ., getModuleGraph, (, ), ;, while, (, it, ., hasNext, (, ), ), {, Declaration, decl, =]
[moduleGraph, =, compiler, ., getModuleGraph, (, ), ;, while, (, it, ., hasNext, (, ), ), {, Declaration, decl, =]
[while, (, it, ., hasNext, (, ), ), {, Declaration, decl, =, it, ., next, (, ), ;, if, (]
[while, (, it, ., hasNext, (, ), ), {, Declaration, decl, =, it, ., next, (, ), ;, if, (]
[while, (, it, ., hasNext, (, ), ), {, Declaration, decl, =, it, ., next, (, ), ;, if, (]
[while, (, it, ., hasNext, (, ), ), {, Declaration, decl, =, it, ., next, (, ), ;, if, (]
[hasNext, (, ), ), {, Declaration, decl, =, it, ., next, (, ), ;, if, (, decl, ., module, !=]
[), ), {, Declaration, decl, =, it, ., next, (, ), ;, if, (, decl, ., module, !=, null, &&]
[), ), {, Declaration, decl, =, it, ., next, (, ), ;, if, (, decl, ., module, !=, null, &&]
[decl, =, it, ., next, (, ), ;, if, (, decl, ., module, !=, null, &&, moduleGraph, ., dependsOn, (]
[it, ., next, (, ), ;, if, (, decl, ., module, !=, null, &&, moduleGraph, ., dependsOn, (, deepestDependency, ,]
[it, ., next, (, ), ;, if, (, decl, ., module, !=, null, &&, moduleGraph, ., dependsOn, (, deepestDependency, ,]
[., module, !=, null, &&, moduleGraph, ., dependsOn, (, deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =]
[., module, !=, null, &&, moduleGraph, ., dependsOn, (, deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =]
[&&, moduleGraph, ., dependsOn, (, deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =, moduleVarParentMap, ., get, (]
[deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (]
[deepestDependency, ,, decl, ., module, ), ), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (]
[decl, ., module, ), ), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent, ==]
[), ), {, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent, ==, null, ), {]
[{, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent, ==, null, ), {, destParent, =]
[{, Node, destParent, =, moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent, ==, null, ), {, destParent, =]
[moduleVarParentMap, ., get, (, deepestDependency, ), ;, if, (, destParent, ==, null, ), {, destParent, =, compiler, ., getNodeForCodeInsertion, (]
[(, deepestDependency, ), ;, if, (, destParent, ==, null, ), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;]
[(, deepestDependency, ), ;, if, (, destParent, ==, null, ), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;]
[if, (, destParent, ==, null, ), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (]
[destParent, ==, null, ), {, destParent, =, compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (, deepestDependency, ,]
[compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent, =]
[compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent, =]
[compiler, ., getNodeForCodeInsertion, (, deepestDependency, ), ;, moduleVarParentMap, ., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent, =]
[., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;]
[., put, (, deepestDependency, ,, destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;]
[,, destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;, Preconditions, ., checkState, (]
[,, destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;, Preconditions, ., checkState, (]
[destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;, Preconditions, ., checkState, (, !]
[destParent, ), ;, }, Node, declParent, =, decl, ., node, ., getParent, (, ), ;, Preconditions, ., checkState, (, !]
[=, decl, ., node, ., getParent, (, ), ;, Preconditions, ., checkState, (, !, declParent, ., isVar, (, ), ||]
[=, decl, ., node, ., getParent, (, ), ;, Preconditions, ., checkState, (, !, declParent, ., isVar, (, ), ||]
[(, ), ;, Preconditions, ., checkState, (, !, declParent, ., isVar, (, ), ||, declParent, ., hasOneChild, (, ), ,]
[Preconditions, ., checkState, (, !, declParent, ., isVar, (, ), ||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", ), ;]
[Preconditions, ., checkState, (, !, declParent, ., isVar, (, ), ||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", ), ;]
[., isVar, (, ), ||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;]
[., isVar, (, ), ||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;]
[||, declParent, ., hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (]
[hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (, declParent, ), ;]
[hasOneChild, (, ), ,, "AST not normalized.", ), ;, declParent, ., detachFromParent, (, ), ;, destParent, ., addChildToFront, (, declParent, ), ;]
[), ;, compiler, ., reportCodeChange, (, ), ;, }, }, }, }, }, private, class, NamedInfo, {, boolean, allowMove, =]
[), ;, }, }, }, }, }, private, class, NamedInfo, {, boolean, allowMove, =, true, ;, private, JSModule, deepestModule, =]
[}, private, class, NamedInfo, {, boolean, allowMove, =, true, ;, private, JSModule, deepestModule, =, null, ;, private, JSModule, declModule, =]
[private, JSModule, deepestModule, =, null, ;, private, JSModule, declModule, =, null, ;, private, final, Deque, <, Declaration, >, declarations, =]
[>, declarations, =, new, ArrayDeque, <, Declaration, >, (, ), ;, void, addUsedModule, (, JSModule, m, ), {, if, (]
[declarations, =, new, ArrayDeque, <, Declaration, >, (, ), ;, void, addUsedModule, (, JSModule, m, ), {, if, (, !]
[), ;, void, addUsedModule, (, JSModule, m, ), {, if, (, !, allowMove, ), {, return, ;, }, if, (]
[), ;, void, addUsedModule, (, JSModule, m, ), {, if, (, !, allowMove, ), {, return, ;, }, if, (]
[void, addUsedModule, (, JSModule, m, ), {, if, (, !, allowMove, ), {, return, ;, }, if, (, deepestModule, ==]
[JSModule, m, ), {, if, (, !, allowMove, ), {, return, ;, }, if, (, deepestModule, ==, null, ), {]
[), {, if, (, !, allowMove, ), {, return, ;, }, if, (, deepestModule, ==, null, ), {, deepestModule, =]
[allowMove, ), {, return, ;, }, if, (, deepestModule, ==, null, ), {, deepestModule, =, m, ;, }, else, {]
[{, return, ;, }, if, (, deepestModule, ==, null, ), {, deepestModule, =, m, ;, }, else, {, deepestModule, =]
[{, return, ;, }, if, (, deepestModule, ==, null, ), {, deepestModule, =, m, ;, }, else, {, deepestModule, =]
[if, (, deepestModule, ==, null, ), {, deepestModule, =, m, ;, }, else, {, deepestModule, =, graph, ., getDeepestCommonDependencyInclusive, (]
[deepestModule, ==, null, ), {, deepestModule, =, m, ;, }, else, {, deepestModule, =, graph, ., getDeepestCommonDependencyInclusive, (, m, ,]
[graph, ., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (]
[graph, ., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (]
[graph, ., getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (]
[getDeepestCommonDependencyInclusive, (, m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (, declModule, !=]
[m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (, declModule, !=, null, &&]
[m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (, declModule, !=, null, &&]
[m, ,, deepestModule, ), ;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (, declModule, !=, null, &&]
[;, }, }, boolean, addDeclaration, (, Declaration, d, ), {, if, (, declModule, !=, null, &&, d, ., module, !=]
[addDeclaration, (, Declaration, d, ), {, if, (, declModule, !=, null, &&, d, ., module, !=, declModule, ), {, return]
[d, ), {, if, (, declModule, !=, null, &&, d, ., module, !=, declModule, ), {, return, false, ;, }]
[d, ), {, if, (, declModule, !=, null, &&, d, ., module, !=, declModule, ), {, return, false, ;, }]
[(, declModule, !=, null, &&, d, ., module, !=, declModule, ), {, return, false, ;, }, declarations, ., push, (]
[null, &&, d, ., module, !=, declModule, ), {, return, false, ;, }, declarations, ., push, (, d, ), ;]
[d, ., module, !=, declModule, ), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule, =]
[d, ., module, !=, declModule, ), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule, =]
[), {, return, false, ;, }, declarations, ., push, (, d, ), ;, declModule, =, d, ., module, ;, return]
[;, declModule, =, d, ., module, ;, return, true, ;, }, Iterator, <, Declaration, >, declarationIterator, (, ), {, return]
[;, declModule, =, d, ., module, ;, return, true, ;, }, Iterator, <, Declaration, >, declarationIterator, (, ), {, return]
[;, final, Node, node, ;, Declaration, (, JSModule, module, ,, Node, node, ,, Node, parent, ,, Node, gramps, ), {]
[;, final, Node, node, ;, Declaration, (, JSModule, module, ,, Node, node, ,, Node, parent, ,, Node, gramps, ), {]
[;, Declaration, (, JSModule, module, ,, Node, node, ,, Node, parent, ,, Node, gramps, ), {, this, ., module, =]
[(, JSModule, module, ,, Node, node, ,, Node, parent, ,, Node, gramps, ), {, this, ., module, =, module, ;]
[(, JSModule, module, ,, Node, node, ,, Node, parent, ,, Node, gramps, ), {, this, ., module, =, module, ;]
[Node, node, ,, Node, parent, ,, Node, gramps, ), {, this, ., module, =, module, ;, this, ., node, =]
[., node, =, node, ;, }, }, private, boolean, hasConditionalAncestor, (, Node, n, ), {, for, (, Node, ancestor, :]
[., node, =, node, ;, }, }, private, boolean, hasConditionalAncestor, (, Node, n, ), {, for, (, Node, ancestor, :]
[hasConditionalAncestor, (, Node, n, ), {, for, (, Node, ancestor, :, n, ., getAncestors, (, ), ), {, switch, (]
[hasConditionalAncestor, (, Node, n, ), {, for, (, Node, ancestor, :, n, ., getAncestors, (, ), ), {, switch, (]
[Node, ancestor, :, n, ., getAncestors, (, ), ), {, switch, (, ancestor, ., getType, (, ), ), {, case]
[Node, ancestor, :, n, ., getAncestors, (, ), ), {, switch, (, ancestor, ., getType, (, ), ), {, case]
[getAncestors, (, ), ), {, switch, (, ancestor, ., getType, (, ), ), {, case, Token, ., DO, :, case]
[getAncestors, (, ), ), {, switch, (, ancestor, ., getType, (, ), ), {, case, Token, ., DO, :, case]
[switch, (, ancestor, ., getType, (, ), ), {, case, Token, ., DO, :, case, Token, ., FOR, :, case]
[switch, (, ancestor, ., getType, (, ), ), {, case, Token, ., DO, :, case, Token, ., FOR, :, case]
[(, ), ), {, case, Token, ., DO, :, case, Token, ., FOR, :, case, Token, ., HOOK, :, case]
[(, ), ), {, case, Token, ., DO, :, case, Token, ., FOR, :, case, Token, ., HOOK, :, case]
[Token, ., DO, :, case, Token, ., FOR, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case]
[Token, ., DO, :, case, Token, ., FOR, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case]
[Token, ., FOR, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case]
[Token, ., FOR, :, case, Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case]
[Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., WHILE, :, case]
[Token, ., HOOK, :, case, Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., WHILE, :, case]
[Token, ., IF, :, case, Token, ., SWITCH, :, case, Token, ., WHILE, :, case, Token, ., FUNCTION, :, return]
[Token, ., SWITCH, :, case, Token, ., WHILE, :, case, Token, ., FUNCTION, :, return, true, ;, }, }, return]
[return, true, ;, }, }, return, false, ;, }, private, NamedInfo, getNamedInfo, (, Var, v, ), {, NamedInfo, info, =]
[return, true, ;, }, }, return, false, ;, }, private, NamedInfo, getNamedInfo, (, Var, v, ), {, NamedInfo, info, =]
[}, return, false, ;, }, private, NamedInfo, getNamedInfo, (, Var, v, ), {, NamedInfo, info, =, namedInfo, ., get, (]
[private, NamedInfo, getNamedInfo, (, Var, v, ), {, NamedInfo, info, =, namedInfo, ., get, (, v, ), ;, if, (]
[private, NamedInfo, getNamedInfo, (, Var, v, ), {, NamedInfo, info, =, namedInfo, ., get, (, v, ), ;, if, (]
[getNamedInfo, (, Var, v, ), {, NamedInfo, info, =, namedInfo, ., get, (, v, ), ;, if, (, info, ==]
[v, ), {, NamedInfo, info, =, namedInfo, ., get, (, v, ), ;, if, (, info, ==, null, ), {]
[{, NamedInfo, info, =, namedInfo, ., get, (, v, ), ;, if, (, info, ==, null, ), {, info, =]
[., get, (, v, ), ;, if, (, info, ==, null, ), {, info, =, new, NamedInfo, (, ), ;]
[., get, (, v, ), ;, if, (, info, ==, null, ), {, info, =, new, NamedInfo, (, ), ;]
[), ;, if, (, info, ==, null, ), {, info, =, new, NamedInfo, (, ), ;, namedInfo, ., put, (]
[if, (, info, ==, null, ), {, info, =, new, NamedInfo, (, ), ;, namedInfo, ., put, (, v, ,]
[), {, info, =, new, NamedInfo, (, ), ;, namedInfo, ., put, (, v, ,, info, ), ;, }, return]
[info, ;, }, private, void, processReference, (, NodeTraversal, t, ,, NamedInfo, info, ,, String, name, ), {, boolean, recursive, =]
[processReference, (, NodeTraversal, t, ,, NamedInfo, info, ,, String, name, ), {, boolean, recursive, =, false, ;, Node, rootNode, =]
[processReference, (, NodeTraversal, t, ,, NamedInfo, info, ,, String, name, ), {, boolean, recursive, =, false, ;, Node, rootNode, =]
[processReference, (, NodeTraversal, t, ,, NamedInfo, info, ,, String, name, ), {, boolean, recursive, =, false, ;, Node, rootNode, =]
[boolean, recursive, =, false, ;, Node, rootNode, =, t, ., getScope, (, ), ., getRootNode, (, ), ;, if, (]
[boolean, recursive, =, false, ;, Node, rootNode, =, t, ., getScope, (, ), ., getRootNode, (, ), ;, if, (]
[getScope, (, ), ., getRootNode, (, ), ;, if, (, rootNode, ., isFunction, (, ), ), {, String, scopeFuncName, =]
[getScope, (, ), ., getRootNode, (, ), ;, if, (, rootNode, ., isFunction, (, ), ), {, String, scopeFuncName, =]
[getScope, (, ), ., getRootNode, (, ), ;, if, (, rootNode, ., isFunction, (, ), ), {, String, scopeFuncName, =]
[(, ), ), {, String, scopeFuncName, =, rootNode, ., getFirstChild, (, ), ., getString, (, ), ;, Node, scopeFuncParent, =]
[(, ), ), {, String, scopeFuncName, =, rootNode, ., getFirstChild, (, ), ., getString, (, ), ;, Node, scopeFuncParent, =]
[., getFirstChild, (, ), ., getString, (, ), ;, Node, scopeFuncParent, =, rootNode, ., getParent, (, ), ;, if, (]
[., getFirstChild, (, ), ., getString, (, ), ;, Node, scopeFuncParent, =, rootNode, ., getParent, (, ), ;, if, (]
[., getString, (, ), ;, Node, scopeFuncParent, =, rootNode, ., getParent, (, ), ;, if, (, scopeFuncName, ., equals, (]
[;, Node, scopeFuncParent, =, rootNode, ., getParent, (, ), ;, if, (, scopeFuncName, ., equals, (, name, ), ), {]
[scopeFuncParent, =, rootNode, ., getParent, (, ), ;, if, (, scopeFuncName, ., equals, (, name, ), ), {, recursive, =]
[), ;, if, (, scopeFuncName, ., equals, (, name, ), ), {, recursive, =, true, ;, }, else, if, (]
[), ;, if, (, scopeFuncName, ., equals, (, name, ), ), {, recursive, =, true, ;, }, else, if, (]
[), ;, if, (, scopeFuncName, ., equals, (, name, ), ), {, recursive, =, true, ;, }, else, if, (]
[equals, (, name, ), ), {, recursive, =, true, ;, }, else, if, (, scopeFuncParent, ., isName, (, ), &&]
[equals, (, name, ), ), {, recursive, =, true, ;, }, else, if, (, scopeFuncParent, ., isName, (, ), &&]
[equals, (, name, ), ), {, recursive, =, true, ;, }, else, if, (, scopeFuncParent, ., isName, (, ), &&]
[true, ;, }, else, if, (, scopeFuncParent, ., isName, (, ), &&, scopeFuncParent, ., getString, (, ), ., equals, (]
[if, (, scopeFuncParent, ., isName, (, ), &&, scopeFuncParent, ., getString, (, ), ., equals, (, name, ), ), {]
[scopeFuncParent, ., isName, (, ), &&, scopeFuncParent, ., getString, (, ), ., equals, (, name, ), ), {, recursive, =]
[), ., equals, (, name, ), ), {, recursive, =, true, ;, }, else, {, for, (, Scope, s, =]
[), ., equals, (, name, ), ), {, recursive, =, true, ;, }, else, {, for, (, Scope, s, =]
[), {, recursive, =, true, ;, }, else, {, for, (, Scope, s, =, t, ., getScope, (, ), ;]
[), {, recursive, =, true, ;, }, else, {, for, (, Scope, s, =, t, ., getScope, (, ), ;]
[), {, recursive, =, true, ;, }, else, {, for, (, Scope, s, =, t, ., getScope, (, ), ;]
[}, else, {, for, (, Scope, s, =, t, ., getScope, (, ), ;, s, ., getParent, (, ), !=]
[{, for, (, Scope, s, =, t, ., getScope, (, ), ;, s, ., getParent, (, ), !=, null, ;]
[(, Scope, s, =, t, ., getScope, (, ), ;, s, ., getParent, (, ), !=, null, ;, s, =]
[(, Scope, s, =, t, ., getScope, (, ), ;, s, ., getParent, (, ), !=, null, ;, s, =]
[s, ., getParent, (, ), !=, null, ;, s, =, s, ., getParent, (, ), ), {, Node, curRoot, =]
[s, ., getParent, (, ), !=, null, ;, s, =, s, ., getParent, (, ), ), {, Node, curRoot, =]
[s, =, s, ., getParent, (, ), ), {, Node, curRoot, =, s, ., getRootNode, (, ), ;, if, (]
[s, =, s, ., getParent, (, ), ), {, Node, curRoot, =, s, ., getRootNode, (, ), ;, if, (]
[s, =, s, ., getParent, (, ), ), {, Node, curRoot, =, s, ., getRootNode, (, ), ;, if, (]
[getRootNode, (, ), ;, if, (, curRoot, ., getParent, (, ), ., isAssign, (, ), ), {, Node, owner, =]
[getRootNode, (, ), ;, if, (, curRoot, ., getParent, (, ), ., isAssign, (, ), ), {, Node, owner, =]
[getRootNode, (, ), ;, if, (, curRoot, ., getParent, (, ), ., isAssign, (, ), ), {, Node, owner, =]
[isAssign, (, ), ), {, Node, owner, =, curRoot, ., getParent, (, ), ., getFirstChild, (, ), ;, while, (]
[isAssign, (, ), ), {, Node, owner, =, curRoot, ., getParent, (, ), ., getFirstChild, (, ), ;, while, (]
[=, curRoot, ., getParent, (, ), ., getFirstChild, (, ), ;, while, (, owner, ., isGetProp, (, ), ), {]
[., getParent, (, ), ., getFirstChild, (, ), ;, while, (, owner, ., isGetProp, (, ), ), {, owner, =]
[., getParent, (, ), ., getFirstChild, (, ), ;, while, (, owner, ., isGetProp, (, ), ), {, owner, =]
[while, (, owner, ., isGetProp, (, ), ), {, owner, =, owner, ., getFirstChild, (, ), ;, }, if, (]
[while, (, owner, ., isGetProp, (, ), ), {, owner, =, owner, ., getFirstChild, (, ), ;, }, if, (]
[while, (, owner, ., isGetProp, (, ), ), {, owner, =, owner, ., getFirstChild, (, ), ;, }, if, (]
[), ), {, owner, =, owner, ., getFirstChild, (, ), ;, }, if, (, owner, ., isName, (, ), &&]
[), ), {, owner, =, owner, ., getFirstChild, (, ), ;, }, if, (, owner, ., isName, (, ), &&]
[), ), {, owner, =, owner, ., getFirstChild, (, ), ;, }, if, (, owner, ., isName, (, ), &&]
[(, ), ;, }, if, (, owner, ., isName, (, ), &&, owner, ., getString, (, ), ., equals, (]
[if, (, owner, ., isName, (, ), &&, owner, ., getString, (, ), ., equals, (, name, ), ), {]
[owner, ., isName, (, ), &&, owner, ., getString, (, ), ., equals, (, name, ), ), {, recursive, =]
[., equals, (, name, ), ), {, recursive, =, true, ;, break, ;, }, }, }, }, }, if, (]
[equals, (, name, ), ), {, recursive, =, true, ;, break, ;, }, }, }, }, }, if, (, !]
[), ), {, recursive, =, true, ;, break, ;, }, }, }, }, }, if, (, !, recursive, ), {]
[), ), {, recursive, =, true, ;, break, ;, }, }, }, }, }, if, (, !, recursive, ), {]
[=, true, ;, break, ;, }, }, }, }, }, if, (, !, recursive, ), {, info, ., addUsedModule, (]
[=, true, ;, break, ;, }, }, }, }, }, if, (, !, recursive, ), {, info, ., addUsedModule, (]
[}, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[}, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, !]
[}, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, !]
[Node, parent, ), {, if, (, !, n, ., isName, (, ), ), {, return, ;, }, String, name, =]
[Node, parent, ), {, if, (, !, n, ., isName, (, ), ), {, return, ;, }, String, name, =]
[., isName, (, ), ), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, if, (]
[., isName, (, ), ), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, if, (]
[., isName, (, ), ), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, if, (]
[return, ;, }, String, name, =, n, ., getString, (, ), ;, if, (, name, ., isEmpty, (, ), ||]
[return, ;, }, String, name, =, n, ., getString, (, ), ;, if, (, name, ., isEmpty, (, ), ||]
[return, ;, }, String, name, =, n, ., getString, (, ), ;, if, (, name, ., isEmpty, (, ), ||]
[getString, (, ), ;, if, (, name, ., isEmpty, (, ), ||, compiler, ., getCodingConvention, (, ), ., isExported, (]
[), ||, compiler, ., getCodingConvention, (, ), ., isExported, (, name, ), ), {, return, ;, }, Var, v, =]
[), ||, compiler, ., getCodingConvention, (, ), ., isExported, (, name, ), ), {, return, ;, }, Var, v, =]
[), ||, compiler, ., getCodingConvention, (, ), ., isExported, (, name, ), ), {, return, ;, }, Var, v, =]
[isExported, (, name, ), ), {, return, ;, }, Var, v, =, t, ., getScope, (, ), ., getVar, (]
[{, return, ;, }, Var, v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (]
[{, return, ;, }, Var, v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (]
[{, return, ;, }, Var, v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (]
[;, }, Var, v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (, v, ==]
[Var, v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (, v, ==, null, ||]
[v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (, v, ==, null, ||, !]
[v, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (, v, ==, null, ||, !]
[if, (, v, ==, null, ||, !, v, ., isGlobal, (, ), ), {, return, ;, }, NamedInfo, info, =]
[v, ==, null, ||, !, v, ., isGlobal, (, ), ), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (]
[v, ., isGlobal, (, ), ), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (, v, ), ;, if, (]
[v, ., isGlobal, (, ), ), {, return, ;, }, NamedInfo, info, =, getNamedInfo, (, v, ), ;, if, (]
[return, ;, }, NamedInfo, info, =, getNamedInfo, (, v, ), ;, if, (, info, ., allowMove, ), {, if, (]
[}, NamedInfo, info, =, getNamedInfo, (, v, ), ;, if, (, info, ., allowMove, ), {, if, (, maybeProcessDeclaration, (]
[info, =, getNamedInfo, (, v, ), ;, if, (, info, ., allowMove, ), {, if, (, maybeProcessDeclaration, (, t, ,]
[getNamedInfo, (, v, ), ;, if, (, info, ., allowMove, ), {, if, (, maybeProcessDeclaration, (, t, ,, n, ,]
[v, ), ;, if, (, info, ., allowMove, ), {, if, (, maybeProcessDeclaration, (, t, ,, n, ,, parent, ,]
[., allowMove, ), {, if, (, maybeProcessDeclaration, (, t, ,, n, ,, parent, ,, info, ), ), {, if, (]
[), {, if, (, maybeProcessDeclaration, (, t, ,, n, ,, parent, ,, info, ), ), {, if, (, hasConditionalAncestor, (]
[), {, if, (, maybeProcessDeclaration, (, t, ,, n, ,, parent, ,, info, ), ), {, if, (, hasConditionalAncestor, (]
[n, ,, parent, ,, info, ), ), {, if, (, hasConditionalAncestor, (, parent, ., getParent, (, ), ), ), {]
[n, ,, parent, ,, info, ), ), {, if, (, hasConditionalAncestor, (, parent, ., getParent, (, ), ), ), {]
[info, ), ), {, if, (, hasConditionalAncestor, (, parent, ., getParent, (, ), ), ), {, info, ., allowMove, =]
[hasConditionalAncestor, (, parent, ., getParent, (, ), ), ), {, info, ., allowMove, =, false, ;, }, }, else, {]
[parent, ., getParent, (, ), ), ), {, info, ., allowMove, =, false, ;, }, }, else, {, processReference, (]
[getParent, (, ), ), ), {, info, ., allowMove, =, false, ;, }, }, else, {, processReference, (, t, ,]
[), ), ), {, info, ., allowMove, =, false, ;, }, }, else, {, processReference, (, t, ,, info, ,]
[private, boolean, maybeProcessDeclaration, (, NodeTraversal, t, ,, Node, name, ,, Node, parent, ,, NamedInfo, info, ), {, Node, gramps, =]
[private, boolean, maybeProcessDeclaration, (, NodeTraversal, t, ,, Node, name, ,, Node, parent, ,, NamedInfo, info, ), {, Node, gramps, =]
[name, ,, Node, parent, ,, NamedInfo, info, ), {, Node, gramps, =, parent, ., getParent, (, ), ;, switch, (]
[name, ,, Node, parent, ,, NamedInfo, info, ), {, Node, gramps, =, parent, ., getParent, (, ), ;, switch, (]
[{, Node, gramps, =, parent, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[{, Node, gramps, =, parent, ., getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case]
[getParent, (, ), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., VAR, :, if, (]
[), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., VAR, :, if, (, canMoveValue, (]
[), ;, switch, (, parent, ., getType, (, ), ), {, case, Token, ., VAR, :, if, (, canMoveValue, (]
[), {, case, Token, ., VAR, :, if, (, canMoveValue, (, name, ., getFirstChild, (, ), ), ), {, return]
[), {, case, Token, ., VAR, :, if, (, canMoveValue, (, name, ., getFirstChild, (, ), ), ), {, return]
[., VAR, :, if, (, canMoveValue, (, name, ., getFirstChild, (, ), ), ), {, return, info, ., addDeclaration, (]
[if, (, canMoveValue, (, name, ., getFirstChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (]
[if, (, canMoveValue, (, name, ., getFirstChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (]
[getFirstChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,]
[), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent, ,]
[(, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;, }, return]
[(, t, ., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case]
[(, t, ., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case]
[,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, ., FUNCTION, :, if, (]
[,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, ., FUNCTION, :, if, (]
[,, gramps, ), ), ;, }, return, false, ;, case, Token, ., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (]
[}, return, false, ;, case, Token, ., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), ), {, return]
[}, return, false, ;, case, Token, ., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), ), {, return]
[case, Token, ., FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), ), {, return, info, ., addDeclaration, (]
[FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (]
[FUNCTION, :, if, (, NodeUtil, ., isFunctionDeclaration, (, parent, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (]
[isFunctionDeclaration, (, parent, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,]
[parent, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent, ,]
[(, new, Declaration, (, t, ., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;, }, return]
[(, t, ., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case]
[(, t, ., getModule, (, ), ,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case]
[), ,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, ., ASSIGN, :, case]
[), ,, name, ,, parent, ,, gramps, ), ), ;, }, return, false, ;, case, Token, ., ASSIGN, :, case]
[), ), ;, }, return, false, ;, case, Token, ., ASSIGN, :, case, Token, ., GETPROP, :, Node, child, =]
[case, Token, ., ASSIGN, :, case, Token, ., GETPROP, :, Node, child, =, name, ;, for, (, Node, current, :]
[case, Token, ., ASSIGN, :, case, Token, ., GETPROP, :, Node, child, =, name, ;, for, (, Node, current, :]
[:, Node, child, =, name, ;, for, (, Node, current, :, name, ., getAncestors, (, ), ), {, if, (]
[:, Node, child, =, name, ;, for, (, Node, current, :, name, ., getAncestors, (, ), ), {, if, (]
[name, ., getAncestors, (, ), ), {, if, (, current, ., isGetProp, (, ), ), {, }, else, if, (]
[name, ., getAncestors, (, ), ), {, if, (, current, ., isGetProp, (, ), ), {, }, else, if, (]
[name, ., getAncestors, (, ), ), {, if, (, current, ., isGetProp, (, ), ), {, }, else, if, (]
[{, if, (, current, ., isGetProp, (, ), ), {, }, else, if, (, current, ., isAssign, (, ), &&]
[{, if, (, current, ., isGetProp, (, ), ), {, }, else, if, (, current, ., isAssign, (, ), &&]
[{, if, (, current, ., isGetProp, (, ), ), {, }, else, if, (, current, ., isAssign, (, ), &&]
[(, ), ), {, }, else, if, (, current, ., isAssign, (, ), &&, current, ., getFirstChild, (, ), ==]
[if, (, current, ., isAssign, (, ), &&, current, ., getFirstChild, (, ), ==, child, ), {, Node, currentParent, =]
[if, (, current, ., isAssign, (, ), &&, current, ., getFirstChild, (, ), ==, child, ), {, Node, currentParent, =]
[current, ., getFirstChild, (, ), ==, child, ), {, Node, currentParent, =, current, ., getParent, (, ), ;, if, (]
[current, ., getFirstChild, (, ), ==, child, ), {, Node, currentParent, =, current, ., getParent, (, ), ;, if, (]
[current, ., getFirstChild, (, ), ==, child, ), {, Node, currentParent, =, current, ., getParent, (, ), ;, if, (]
[child, ), {, Node, currentParent, =, current, ., getParent, (, ), ;, if, (, currentParent, ., isExprResult, (, ), &&]
[{, Node, currentParent, =, current, ., getParent, (, ), ;, if, (, currentParent, ., isExprResult, (, ), &&, canMoveValue, (]
[{, Node, currentParent, =, current, ., getParent, (, ), ;, if, (, currentParent, ., isExprResult, (, ), &&, canMoveValue, (]
[;, if, (, currentParent, ., isExprResult, (, ), &&, canMoveValue, (, current, ., getLastChild, (, ), ), ), {, return]
[;, if, (, currentParent, ., isExprResult, (, ), &&, canMoveValue, (, current, ., getLastChild, (, ), ), ), {, return]
[., isExprResult, (, ), &&, canMoveValue, (, current, ., getLastChild, (, ), ), ), {, return, info, ., addDeclaration, (]
[), &&, canMoveValue, (, current, ., getLastChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (]
[), &&, canMoveValue, (, current, ., getLastChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (]
[getLastChild, (, ), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,]
[), ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, current, ,]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, current, ,, currentParent, ,]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, current, ,, currentParent, ,]
[(, ), ,, current, ,, currentParent, ,, currentParent, ., getParent, (, ), ), ), ;, }, }, else, {, return]
[current, ,, currentParent, ,, currentParent, ., getParent, (, ), ), ), ;, }, }, else, {, return, false, ;, }]
[currentParent, ,, currentParent, ., getParent, (, ), ), ), ;, }, }, else, {, return, false, ;, }, child, =]
[getParent, (, ), ), ), ;, }, }, else, {, return, false, ;, }, child, =, current, ;, }, return]
[), ), ;, }, }, else, {, return, false, ;, }, child, =, current, ;, }, return, false, ;, case]
[), ), ;, }, }, else, {, return, false, ;, }, child, =, current, ;, }, return, false, ;, case]
[{, return, false, ;, }, child, =, current, ;, }, return, false, ;, case, Token, ., CALL, :, if, (]
[{, return, false, ;, }, child, =, current, ;, }, return, false, ;, case, Token, ., CALL, :, if, (]
[}, child, =, current, ;, }, return, false, ;, case, Token, ., CALL, :, if, (, NodeUtil, ., isExprCall, (]
[false, ;, case, Token, ., CALL, :, if, (, NodeUtil, ., isExprCall, (, gramps, ), ), {, SubclassRelationship, relationship, =]
[false, ;, case, Token, ., CALL, :, if, (, NodeUtil, ., isExprCall, (, gramps, ), ), {, SubclassRelationship, relationship, =]
[false, ;, case, Token, ., CALL, :, if, (, NodeUtil, ., isExprCall, (, gramps, ), ), {, SubclassRelationship, relationship, =]
[(, NodeUtil, ., isExprCall, (, gramps, ), ), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (]
[gramps, ), ), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (]
[gramps, ), ), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (]
[gramps, ), ), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (]
[), {, SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship, !=]
[SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship, !=, null, &&]
[SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship, !=, null, &&]
[SubclassRelationship, relationship, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship, !=, null, &&]
[., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship, !=, null, &&, name, ., getString, (, ), ., equals, (]
[., getClassesDefinedByCall, (, parent, ), ;, if, (, relationship, !=, null, &&, name, ., getString, (, ), ., equals, (]
[(, relationship, !=, null, &&, name, ., getString, (, ), ., equals, (, relationship, ., subclassName, ), ), {, return]
[(, relationship, !=, null, &&, name, ., getString, (, ), ., equals, (, relationship, ., subclassName, ), ), {, return]
[&&, name, ., getString, (, ), ., equals, (, relationship, ., subclassName, ), ), {, return, info, ., addDeclaration, (]
[getString, (, ), ., equals, (, relationship, ., subclassName, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (]
[getString, (, ), ., equals, (, relationship, ., subclassName, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (]
[relationship, ., subclassName, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,]
[subclassName, ), ), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, parent, ,]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, parent, ,, gramps, ,]
[), {, return, info, ., addDeclaration, (, new, Declaration, (, t, ., getModule, (, ), ,, parent, ,, gramps, ,]
[., getModule, (, ), ,, parent, ,, gramps, ,, gramps, ., getParent, (, ), ), ), ;, }, }, return]
[parent, ,, gramps, ,, gramps, ., getParent, (, ), ), ), ;, }, }, return, false, ;, default, :, return]
[return, false, ;, default, :, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (]
[return, false, ;, default, :, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (]
[return, false, ;, default, :, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (]
[return, false, ;, default, :, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (]
[;, default, :, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (, n, ==]
[:, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (, n, ==, null, ||]
[:, return, false, ;, }, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (, n, ==, null, ||]
[}, }, private, boolean, canMoveValue, (, Node, n, ), {, if, (, n, ==, null, ||, NodeUtil, ., isLiteralValue, (]
[private, boolean, canMoveValue, (, Node, n, ), {, if, (, n, ==, null, ||, NodeUtil, ., isLiteralValue, (, n, ,]
[(, Node, n, ), {, if, (, n, ==, null, ||, NodeUtil, ., isLiteralValue, (, n, ,, true, ), ||]
[(, Node, n, ), {, if, (, n, ==, null, ||, NodeUtil, ., isLiteralValue, (, n, ,, true, ), ||]
[==, null, ||, NodeUtil, ., isLiteralValue, (, n, ,, true, ), ||, n, ., isFunction, (, ), ), {, return]
[(, n, ,, true, ), ||, n, ., isFunction, (, ), ), {, return, true, ;, }, else, if, (]
[(, n, ,, true, ), ||, n, ., isFunction, (, ), ), {, return, true, ;, }, else, if, (]
[), ), {, return, true, ;, }, else, if, (, n, ., isCall, (, ), ), {, Node, functionName, =]
[), ), {, return, true, ;, }, else, if, (, n, ., isCall, (, ), ), {, Node, functionName, =]
[else, if, (, n, ., isCall, (, ), ), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return]
[else, if, (, n, ., isCall, (, ), ), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return]
[else, if, (, n, ., isCall, (, ), ), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return]
[(, ), ), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return, functionName, ., isName, (, ), &&]
[), ), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return, functionName, ., isName, (, ), &&, (]
[), ), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return, functionName, ., isName, (, ), &&, (]
[), ), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return, functionName, ., isName, (, ), &&, (]
[), ), {, Node, functionName, =, n, ., getFirstChild, (, ), ;, return, functionName, ., isName, (, ), &&, (]
[getFirstChild, (, ), ;, return, functionName, ., isName, (, ), &&, (, functionName, ., getString, (, ), ., equals, (]
[getFirstChild, (, ), ;, return, functionName, ., isName, (, ), &&, (, functionName, ., getString, (, ), ., equals, (]
[functionName, ., isName, (, ), &&, (, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME, ), ||]
[functionName, ., isName, (, ), &&, (, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME, ), ||]
[functionName, ., isName, (, ), &&, (, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME, ), ||]
[., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME, ), ||, functionName, ., getString, (, ), ., equals, (]
[., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., STUB_METHOD_NAME, ), ||, functionName, ., getString, (, ), ., equals, (]
[), ||, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (]
[), ||, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (]
[), ||, functionName, ., getString, (, ), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (]
[), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (, n, ., isArrayLit, (, ), ||]
[), ., equals, (, CrossModuleMethodMotion, ., UNSTUB_METHOD_NAME, ), ), ;, }, else, if, (, n, ., isArrayLit, (, ), ||]
[}, else, if, (, n, ., isArrayLit, (, ), ||, n, ., isObjectLit, (, ), ), {, boolean, isObjectLit, =]
[}, else, if, (, n, ., isArrayLit, (, ), ||, n, ., isObjectLit, (, ), ), {, boolean, isObjectLit, =]
[., isObjectLit, (, ), ), {, boolean, isObjectLit, =, n, ., isObjectLit, (, ), ;, for, (, Node, child, =]
[., isObjectLit, (, ), ), {, boolean, isObjectLit, =, n, ., isObjectLit, (, ), ;, for, (, Node, child, =]
[boolean, isObjectLit, =, n, ., isObjectLit, (, ), ;, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[boolean, isObjectLit, =, n, ., isObjectLit, (, ), ;, for, (, Node, child, =, n, ., getFirstChild, (, ), ;]
[=, n, ., isObjectLit, (, ), ;, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=]
[., isObjectLit, (, ), ;, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;]
[(, ), ;, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[(, ), ;, for, (, Node, child, =, n, ., getFirstChild, (, ), ;, child, !=, null, ;, child, =]
[., getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (]
[getFirstChild, (, ), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !]
[), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (]
[), ;, child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (]
[child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (, isObjectLit, ?]
[child, !=, null, ;, child, =, child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (, isObjectLit, ?]
[child, ., getNext, (, ), ), {, if, (, !, canMoveValue, (, isObjectLit, ?, child, ., getFirstChild, (, ), :]
[), {, if, (, !, canMoveValue, (, isObjectLit, ?, child, ., getFirstChild, (, ), :, child, ), ), {, return]
[canMoveValue, (, isObjectLit, ?, child, ., getFirstChild, (, ), :, child, ), ), {, return, false, ;, }, }, return]
[child, ., getFirstChild, (, ), :, child, ), ), {, return, false, ;, }, }, return, true, ;, }, return]
