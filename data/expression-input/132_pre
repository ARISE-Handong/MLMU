[;, protected, final, Set, <, DiGraphNode, <, N, ,, Branch, >, >, orderedWorkSet, ;, public, static, final, int, MAX_STEPS, =]
[int, MAX_STEPS, =, 200000, ;, DataFlowAnalysis, (, ControlFlowGraph, <, N, >, targetCfg, ,, JoinOp, <, L, >, joinOp, ), {]
[int, MAX_STEPS, =, 200000, ;, DataFlowAnalysis, (, ControlFlowGraph, <, N, >, targetCfg, ,, JoinOp, <, L, >, joinOp, ), {]
[;, DataFlowAnalysis, (, ControlFlowGraph, <, N, >, targetCfg, ,, JoinOp, <, L, >, joinOp, ), {, this, ., cfg, =]
[(, ControlFlowGraph, <, N, >, targetCfg, ,, JoinOp, <, L, >, joinOp, ), {, this, ., cfg, =, targetCfg, ;]
[(, ControlFlowGraph, <, N, >, targetCfg, ,, JoinOp, <, L, >, joinOp, ), {, this, ., cfg, =, targetCfg, ;]
[>, targetCfg, ,, JoinOp, <, L, >, joinOp, ), {, this, ., cfg, =, targetCfg, ;, this, ., joinOp, =]
[=, targetCfg, ;, this, ., joinOp, =, joinOp, ;, Comparator, <, DiGraphNode, <, N, ,, Branch, >, >, nodeComparator, =]
[=, targetCfg, ;, this, ., joinOp, =, joinOp, ;, Comparator, <, DiGraphNode, <, N, ,, Branch, >, >, nodeComparator, =]
[., joinOp, =, joinOp, ;, Comparator, <, DiGraphNode, <, N, ,, Branch, >, >, nodeComparator, =, cfg, ., getOptionalNodeComparator, (]
[DiGraphNode, <, N, ,, Branch, >, >, nodeComparator, =, cfg, ., getOptionalNodeComparator, (, isForward, (, ), ), ;, if, (]
[DiGraphNode, <, N, ,, Branch, >, >, nodeComparator, =, cfg, ., getOptionalNodeComparator, (, isForward, (, ), ), ;, if, (]
[N, ,, Branch, >, >, nodeComparator, =, cfg, ., getOptionalNodeComparator, (, isForward, (, ), ), ;, if, (, nodeComparator, !=]
[>, >, nodeComparator, =, cfg, ., getOptionalNodeComparator, (, isForward, (, ), ), ;, if, (, nodeComparator, !=, null, ), {]
[>, >, nodeComparator, =, cfg, ., getOptionalNodeComparator, (, isForward, (, ), ), ;, if, (, nodeComparator, !=, null, ), {]
[cfg, ., getOptionalNodeComparator, (, isForward, (, ), ), ;, if, (, nodeComparator, !=, null, ), {, this, ., orderedWorkSet, =]
[cfg, ., getOptionalNodeComparator, (, isForward, (, ), ), ;, if, (, nodeComparator, !=, null, ), {, this, ., orderedWorkSet, =]
[isForward, (, ), ), ;, if, (, nodeComparator, !=, null, ), {, this, ., orderedWorkSet, =, Sets, ., newTreeSet, (]
[(, nodeComparator, !=, null, ), {, this, ., orderedWorkSet, =, Sets, ., newTreeSet, (, nodeComparator, ), ;, }, else, {]
[(, nodeComparator, !=, null, ), {, this, ., orderedWorkSet, =, Sets, ., newTreeSet, (, nodeComparator, ), ;, }, else, {]
[), {, this, ., orderedWorkSet, =, Sets, ., newTreeSet, (, nodeComparator, ), ;, }, else, {, this, ., orderedWorkSet, =]
[), {, this, ., orderedWorkSet, =, Sets, ., newTreeSet, (, nodeComparator, ), ;, }, else, {, this, ., orderedWorkSet, =]
[orderedWorkSet, =, Sets, ., newLinkedHashSet, (, ), ;, }, }, final, ControlFlowGraph, <, N, >, getCfg, (, ), {, return]
[(, ), {, return, cfg, ;, }, L, getExitLatticeElement, (, ), {, DiGraphNode, <, N, ,, Branch, >, node, =]
[(, ), {, return, cfg, ;, }, L, getExitLatticeElement, (, ), {, DiGraphNode, <, N, ,, Branch, >, node, =]
[N, ,, Branch, >, node, =, getCfg, (, ), ., getImplicitReturn, (, ), ;, FlowState, <, L, >, state, =]
[N, ,, Branch, >, node, =, getCfg, (, ), ., getImplicitReturn, (, ), ;, FlowState, <, L, >, state, =]
[(, ), ., getImplicitReturn, (, ), ;, FlowState, <, L, >, state, =, node, ., getAnnotation, (, ), ;, return]
[(, ), ., getImplicitReturn, (, ), ;, FlowState, <, L, >, state, =, node, ., getAnnotation, (, ), ;, return]
[FlowState, <, L, >, state, =, node, ., getAnnotation, (, ), ;, return, state, ., getIn, (, ), ;, }]
[>, state, =, node, ., getAnnotation, (, ), ;, return, state, ., getIn, (, ), ;, }, @, SuppressWarnings, (]
[), ;, }, @, SuppressWarnings, (, "unchecked", ), protected, L, join, (, L, latticeA, ,, L, latticeB, ), {, return]
[), ;, }, @, SuppressWarnings, (, "unchecked", ), protected, L, join, (, L, latticeA, ,, L, latticeB, ), {, return]
[SuppressWarnings, (, "unchecked", ), protected, L, join, (, L, latticeA, ,, L, latticeB, ), {, return, joinOp, ., apply, (]
[SuppressWarnings, (, "unchecked", ), protected, L, join, (, L, latticeA, ,, L, latticeB, ), {, return, joinOp, ., apply, (]
[(, L, latticeA, ,, L, latticeB, ), {, return, joinOp, ., apply, (, Lists, ., <, L, >, newArrayList, (]
[latticeA, ,, L, latticeB, ), {, return, joinOp, ., apply, (, Lists, ., <, L, >, newArrayList, (, latticeA, ,]
[(, ), ;, abstract, L, flowThrough, (, N, node, ,, L, input, ), ;, final, void, analyze, (, ), {]
[;, abstract, L, flowThrough, (, N, node, ,, L, input, ), ;, final, void, analyze, (, ), {, analyze, (]
[final, void, analyze, (, ), {, analyze, (, MAX_STEPS, ), ;, }, final, void, analyze, (, int, maxSteps, ), {]
[(, MAX_STEPS, ), ;, }, final, void, analyze, (, int, maxSteps, ), {, initialize, (, ), ;, int, step, =]
[}, final, void, analyze, (, int, maxSteps, ), {, initialize, (, ), ;, int, step, =, 0, ;, while, (]
[final, void, analyze, (, int, maxSteps, ), {, initialize, (, ), ;, int, step, =, 0, ;, while, (, !]
[final, void, analyze, (, int, maxSteps, ), {, initialize, (, ), ;, int, step, =, 0, ;, while, (, !]
[(, ), ;, int, step, =, 0, ;, while, (, !, orderedWorkSet, ., isEmpty, (, ), ), {, if, (]
[(, ), ;, int, step, =, 0, ;, while, (, !, orderedWorkSet, ., isEmpty, (, ), ), {, if, (]
[;, int, step, =, 0, ;, while, (, !, orderedWorkSet, ., isEmpty, (, ), ), {, if, (, step, >]
[0, ;, while, (, !, orderedWorkSet, ., isEmpty, (, ), ), {, if, (, step, >, maxSteps, ), {, throw]
[(, !, orderedWorkSet, ., isEmpty, (, ), ), {, if, (, step, >, maxSteps, ), {, throw, new, MaxIterationsExceededException, (]
[(, !, orderedWorkSet, ., isEmpty, (, ), ), {, if, (, step, >, maxSteps, ), {, throw, new, MaxIterationsExceededException, (]
[(, !, orderedWorkSet, ., isEmpty, (, ), ), {, if, (, step, >, maxSteps, ), {, throw, new, MaxIterationsExceededException, (]
[orderedWorkSet, ., isEmpty, (, ), ), {, if, (, step, >, maxSteps, ), {, throw, new, MaxIterationsExceededException, (, "Analysis did not terminate after ", +]
[isEmpty, (, ), ), {, if, (, step, >, maxSteps, ), {, throw, new, MaxIterationsExceededException, (, "Analysis did not terminate after ", +, maxSteps, +]
[throw, new, MaxIterationsExceededException, (, "Analysis did not terminate after ", +, maxSteps, +, " iterations", ), ;, }, DiGraphNode, <, N, ,, Branch, >, curNode, =]
[throw, new, MaxIterationsExceededException, (, "Analysis did not terminate after ", +, maxSteps, +, " iterations", ), ;, }, DiGraphNode, <, N, ,, Branch, >, curNode, =]
[throw, new, MaxIterationsExceededException, (, "Analysis did not terminate after ", +, maxSteps, +, " iterations", ), ;, }, DiGraphNode, <, N, ,, Branch, >, curNode, =]
[;, }, DiGraphNode, <, N, ,, Branch, >, curNode, =, orderedWorkSet, ., iterator, (, ), ., next, (, ), ;]
[;, }, DiGraphNode, <, N, ,, Branch, >, curNode, =, orderedWorkSet, ., iterator, (, ), ., next, (, ), ;]
[N, ,, Branch, >, curNode, =, orderedWorkSet, ., iterator, (, ), ., next, (, ), ;, orderedWorkSet, ., remove, (]
[>, curNode, =, orderedWorkSet, ., iterator, (, ), ., next, (, ), ;, orderedWorkSet, ., remove, (, curNode, ), ;]
[=, orderedWorkSet, ., iterator, (, ), ., next, (, ), ;, orderedWorkSet, ., remove, (, curNode, ), ;, joinInputs, (]
[), ., next, (, ), ;, orderedWorkSet, ., remove, (, curNode, ), ;, joinInputs, (, curNode, ), ;, if, (]
[next, (, ), ;, orderedWorkSet, ., remove, (, curNode, ), ;, joinInputs, (, curNode, ), ;, if, (, flow, (]
[;, if, (, flow, (, curNode, ), ), {, List, <, DiGraphNode, <, N, ,, Branch, >, >, nextNodes, =]
[;, if, (, flow, (, curNode, ), ), {, List, <, DiGraphNode, <, N, ,, Branch, >, >, nextNodes, =]
[(, curNode, ), ), {, List, <, DiGraphNode, <, N, ,, Branch, >, >, nextNodes, =, isForward, (, ), ?]
[(, curNode, ), ), {, List, <, DiGraphNode, <, N, ,, Branch, >, >, nextNodes, =, isForward, (, ), ?]
[{, List, <, DiGraphNode, <, N, ,, Branch, >, >, nextNodes, =, isForward, (, ), ?, cfg, ., getDirectedSuccNodes, (]
[DiGraphNode, <, N, ,, Branch, >, >, nextNodes, =, isForward, (, ), ?, cfg, ., getDirectedSuccNodes, (, curNode, ), :]
[DiGraphNode, <, N, ,, Branch, >, >, nextNodes, =, isForward, (, ), ?, cfg, ., getDirectedSuccNodes, (, curNode, ), :]
[Branch, >, >, nextNodes, =, isForward, (, ), ?, cfg, ., getDirectedSuccNodes, (, curNode, ), :, cfg, ., getDirectedPredNodes, (]
[curNode, ), :, cfg, ., getDirectedPredNodes, (, curNode, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, nextNode, :]
[getDirectedPredNodes, (, curNode, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, nextNode, :, nextNodes, ), {, if, (]
[getDirectedPredNodes, (, curNode, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, nextNode, :, nextNodes, ), {, if, (]
[curNode, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, nextNode, :, nextNodes, ), {, if, (, nextNode, !=]
[curNode, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, nextNode, :, nextNodes, ), {, if, (, nextNode, !=]
[N, ,, Branch, >, nextNode, :, nextNodes, ), {, if, (, nextNode, !=, cfg, ., getImplicitReturn, (, ), ), {]
[N, ,, Branch, >, nextNode, :, nextNodes, ), {, if, (, nextNode, !=, cfg, ., getImplicitReturn, (, ), ), {]
[nextNode, :, nextNodes, ), {, if, (, nextNode, !=, cfg, ., getImplicitReturn, (, ), ), {, orderedWorkSet, ., add, (]
[(, nextNode, !=, cfg, ., getImplicitReturn, (, ), ), {, orderedWorkSet, ., add, (, nextNode, ), ;, }, }, }]
[(, nextNode, !=, cfg, ., getImplicitReturn, (, ), ), {, orderedWorkSet, ., add, (, nextNode, ), ;, }, }, }]
[(, ), ), {, orderedWorkSet, ., add, (, nextNode, ), ;, }, }, }, step, ++, ;, }, if, (]
[., add, (, nextNode, ), ;, }, }, }, step, ++, ;, }, if, (, isForward, (, ), ), {]
[(, nextNode, ), ;, }, }, }, step, ++, ;, }, if, (, isForward, (, ), ), {, joinInputs, (]
[(, nextNode, ), ;, }, }, }, step, ++, ;, }, if, (, isForward, (, ), ), {, joinInputs, (]
[}, }, abstract, L, createInitialEstimateLattice, (, ), ;, abstract, L, createEntryLattice, (, ), ;, protected, void, initialize, (, ), {]
[}, }, abstract, L, createInitialEstimateLattice, (, ), ;, abstract, L, createEntryLattice, (, ), ;, protected, void, initialize, (, ), {]
[initialize, (, ), {, orderedWorkSet, ., clear, (, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, node, :]
[initialize, (, ), {, orderedWorkSet, ., clear, (, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, node, :]
[(, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, node, :, cfg, ., getDirectedGraphNodes, (, ), ), {]
[(, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, node, :, cfg, ., getDirectedGraphNodes, (, ), ), {]
[(, DiGraphNode, <, N, ,, Branch, >, node, :, cfg, ., getDirectedGraphNodes, (, ), ), {, node, ., setAnnotation, (]
[>, node, :, cfg, ., getDirectedGraphNodes, (, ), ), {, node, ., setAnnotation, (, new, FlowState, <, L, >, (]
[., getDirectedGraphNodes, (, ), ), {, node, ., setAnnotation, (, new, FlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,]
[setAnnotation, (, new, FlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,, createInitialEstimateLattice, (, ), ), ), ;, if, (]
[setAnnotation, (, new, FlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,, createInitialEstimateLattice, (, ), ), ), ;, if, (]
[new, FlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,, createInitialEstimateLattice, (, ), ), ), ;, if, (, node, !=]
[new, FlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,, createInitialEstimateLattice, (, ), ), ), ;, if, (, node, !=]
[(, ), ,, createInitialEstimateLattice, (, ), ), ), ;, if, (, node, !=, cfg, ., getImplicitReturn, (, ), ), {]
[(, ), ,, createInitialEstimateLattice, (, ), ), ), ;, if, (, node, !=, cfg, ., getImplicitReturn, (, ), ), {]
[(, ), ), ), ;, if, (, node, !=, cfg, ., getImplicitReturn, (, ), ), {, orderedWorkSet, ., add, (]
[}, protected, boolean, flow, (, DiGraphNode, <, N, ,, Branch, >, node, ), {, FlowState, <, L, >, state, =]
[}, protected, boolean, flow, (, DiGraphNode, <, N, ,, Branch, >, node, ), {, FlowState, <, L, >, state, =]
[,, Branch, >, node, ), {, FlowState, <, L, >, state, =, node, ., getAnnotation, (, ), ;, if, (]
[L, >, state, =, node, ., getAnnotation, (, ), ;, if, (, isForward, (, ), ), {, L, outBefore, =]
[L, >, state, =, node, ., getAnnotation, (, ), ;, if, (, isForward, (, ), ), {, L, outBefore, =]
[node, ., getAnnotation, (, ), ;, if, (, isForward, (, ), ), {, L, outBefore, =, state, ., out, ;]
[node, ., getAnnotation, (, ), ;, if, (, isForward, (, ), ), {, L, outBefore, =, state, ., out, ;]
[), ;, if, (, isForward, (, ), ), {, L, outBefore, =, state, ., out, ;, state, ., out, =]
[if, (, isForward, (, ), ), {, L, outBefore, =, state, ., out, ;, state, ., out, =, flowThrough, (]
[if, (, isForward, (, ), ), {, L, outBefore, =, state, ., out, ;, state, ., out, =, flowThrough, (]
[{, L, outBefore, =, state, ., out, ;, state, ., out, =, flowThrough, (, node, ., getValue, (, ), ,]
[{, L, outBefore, =, state, ., out, ;, state, ., out, =, flowThrough, (, node, ., getValue, (, ), ,]
[out, ;, state, ., out, =, flowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;, return]
[;, state, ., out, =, flowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;, return, !]
[;, state, ., out, =, flowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;, return, !]
[=, flowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;, return, !, outBefore, ., equals, (]
[=, flowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;, return, !, outBefore, ., equals, (]
[in, ), ;, return, !, outBefore, ., equals, (, state, ., out, ), ;, }, else, {, L, inBefore, =]
[in, ), ;, return, !, outBefore, ., equals, (, state, ., out, ), ;, }, else, {, L, inBefore, =]
[!, outBefore, ., equals, (, state, ., out, ), ;, }, else, {, L, inBefore, =, state, ., in, ;]
[!, outBefore, ., equals, (, state, ., out, ), ;, }, else, {, L, inBefore, =, state, ., in, ;]
[(, state, ., out, ), ;, }, else, {, L, inBefore, =, state, ., in, ;, state, ., in, =]
[., out, ), ;, }, else, {, L, inBefore, =, state, ., in, ;, state, ., in, =, flowThrough, (]
[., out, ), ;, }, else, {, L, inBefore, =, state, ., in, ;, state, ., in, =, flowThrough, (]
[{, L, inBefore, =, state, ., in, ;, state, ., in, =, flowThrough, (, node, ., getValue, (, ), ,]
[{, L, inBefore, =, state, ., in, ;, state, ., in, =, flowThrough, (, node, ., getValue, (, ), ,]
[in, ;, state, ., in, =, flowThrough, (, node, ., getValue, (, ), ,, state, ., out, ), ;, return]
[;, state, ., in, =, flowThrough, (, node, ., getValue, (, ), ,, state, ., out, ), ;, return, !]
[;, state, ., in, =, flowThrough, (, node, ., getValue, (, ), ,, state, ., out, ), ;, return, !]
[=, flowThrough, (, node, ., getValue, (, ), ,, state, ., out, ), ;, return, !, inBefore, ., equals, (]
[=, flowThrough, (, node, ., getValue, (, ), ,, state, ., out, ), ;, return, !, inBefore, ., equals, (]
[}, protected, void, joinInputs, (, DiGraphNode, <, N, ,, Branch, >, node, ), {, FlowState, <, L, >, state, =]
[}, protected, void, joinInputs, (, DiGraphNode, <, N, ,, Branch, >, node, ), {, FlowState, <, L, >, state, =]
[,, Branch, >, node, ), {, FlowState, <, L, >, state, =, node, ., getAnnotation, (, ), ;, if, (]
[<, L, >, state, =, node, ., getAnnotation, (, ), ;, if, (, isForward, (, ), ), {, if, (]
[<, L, >, state, =, node, ., getAnnotation, (, ), ;, if, (, isForward, (, ), ), {, if, (]
[<, L, >, state, =, node, ., getAnnotation, (, ), ;, if, (, isForward, (, ), ), {, if, (]
[., getAnnotation, (, ), ;, if, (, isForward, (, ), ), {, if, (, cfg, ., getEntry, (, ), ==]
[), ;, if, (, isForward, (, ), ), {, if, (, cfg, ., getEntry, (, ), ==, node, ), {]
[), ;, if, (, isForward, (, ), ), {, if, (, cfg, ., getEntry, (, ), ==, node, ), {]
[isForward, (, ), ), {, if, (, cfg, ., getEntry, (, ), ==, node, ), {, state, ., setIn, (]
[(, createEntryLattice, (, ), ), ;, }, else, {, List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =]
[(, createEntryLattice, (, ), ), ;, }, else, {, List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =]
[), ;, }, else, {, List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =, cfg, ., getDirectedPredNodes, (]
[List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =, cfg, ., getDirectedPredNodes, (, node, ), ;, if, (]
[List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =, cfg, ., getDirectedPredNodes, (, node, ), ;, if, (]
[List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =, cfg, ., getDirectedPredNodes, (, node, ), ;, if, (]
[Branch, >, >, inNodes, =, cfg, ., getDirectedPredNodes, (, node, ), ;, if, (, inNodes, ., size, (, ), ==]
[node, ), ;, if, (, inNodes, ., size, (, ), ==, 1, ), {, FlowState, <, L, >, inNodeState, =]
[node, ), ;, if, (, inNodes, ., size, (, ), ==, 1, ), {, FlowState, <, L, >, inNodeState, =]
[node, ), ;, if, (, inNodes, ., size, (, ), ==, 1, ), {, FlowState, <, L, >, inNodeState, =]
[(, inNodes, ., size, (, ), ==, 1, ), {, FlowState, <, L, >, inNodeState, =, inNodes, ., get, (]
[1, ), {, FlowState, <, L, >, inNodeState, =, inNodes, ., get, (, 0, ), ., getAnnotation, (, ), ;]
[1, ), {, FlowState, <, L, >, inNodeState, =, inNodes, ., get, (, 0, ), ., getAnnotation, (, ), ;]
[<, L, >, inNodeState, =, inNodes, ., get, (, 0, ), ., getAnnotation, (, ), ;, state, ., setIn, (]
[<, L, >, inNodeState, =, inNodes, ., get, (, 0, ), ., getAnnotation, (, ), ;, state, ., setIn, (]
[., getAnnotation, (, ), ;, state, ., setIn, (, inNodeState, ., getOut, (, ), ), ;, }, else, if, (]
[., getAnnotation, (, ), ;, state, ., setIn, (, inNodeState, ., getOut, (, ), ), ;, }, else, if, (]
[., getAnnotation, (, ), ;, state, ., setIn, (, inNodeState, ., getOut, (, ), ), ;, }, else, if, (]
[., setIn, (, inNodeState, ., getOut, (, ), ), ;, }, else, if, (, inNodes, ., size, (, ), >]
[;, }, else, if, (, inNodes, ., size, (, ), >, 1, ), {, List, <, L, >, values, =]
[., size, (, ), >, 1, ), {, List, <, L, >, values, =, new, ArrayList, <, L, >, (]
[., size, (, ), >, 1, ), {, List, <, L, >, values, =, new, ArrayList, <, L, >, (]
[L, >, (, inNodes, ., size, (, ), ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, currentNode, :]
[;, for, (, DiGraphNode, <, N, ,, Branch, >, currentNode, :, inNodes, ), {, FlowState, <, L, >, currentNodeState, =]
[;, for, (, DiGraphNode, <, N, ,, Branch, >, currentNode, :, inNodes, ), {, FlowState, <, L, >, currentNodeState, =]
[,, Branch, >, currentNode, :, inNodes, ), {, FlowState, <, L, >, currentNodeState, =, currentNode, ., getAnnotation, (, ), ;]
[,, Branch, >, currentNode, :, inNodes, ), {, FlowState, <, L, >, currentNodeState, =, currentNode, ., getAnnotation, (, ), ;]
[:, inNodes, ), {, FlowState, <, L, >, currentNodeState, =, currentNode, ., getAnnotation, (, ), ;, values, ., add, (]
[:, inNodes, ), {, FlowState, <, L, >, currentNodeState, =, currentNode, ., getAnnotation, (, ), ;, values, ., add, (]
[currentNodeState, =, currentNode, ., getAnnotation, (, ), ;, values, ., add, (, currentNodeState, ., getOut, (, ), ), ;, }]
[currentNodeState, =, currentNode, ., getAnnotation, (, ), ;, values, ., add, (, currentNodeState, ., getOut, (, ), ), ;, }]
[getAnnotation, (, ), ;, values, ., add, (, currentNodeState, ., getOut, (, ), ), ;, }, state, ., setIn, (]
[getAnnotation, (, ), ;, values, ., add, (, currentNodeState, ., getOut, (, ), ), ;, }, state, ., setIn, (]
[values, ., add, (, currentNodeState, ., getOut, (, ), ), ;, }, state, ., setIn, (, joinOp, ., apply, (]
[values, ), ), ;, }, }, }, else, {, List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =]
[values, ), ), ;, }, }, }, else, {, List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =]
[}, }, }, else, {, List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =, cfg, ., getDirectedSuccNodes, (]
[List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =, cfg, ., getDirectedSuccNodes, (, node, ), ;, if, (]
[List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =, cfg, ., getDirectedSuccNodes, (, node, ), ;, if, (]
[List, <, DiGraphNode, <, N, ,, Branch, >, >, inNodes, =, cfg, ., getDirectedSuccNodes, (, node, ), ;, if, (]
[Branch, >, >, inNodes, =, cfg, ., getDirectedSuccNodes, (, node, ), ;, if, (, inNodes, ., size, (, ), ==]
[;, if, (, inNodes, ., size, (, ), ==, 1, ), {, DiGraphNode, <, N, ,, Branch, >, inNode, =]
[;, if, (, inNodes, ., size, (, ), ==, 1, ), {, DiGraphNode, <, N, ,, Branch, >, inNode, =]
[., size, (, ), ==, 1, ), {, DiGraphNode, <, N, ,, Branch, >, inNode, =, inNodes, ., get, (]
[1, ), {, DiGraphNode, <, N, ,, Branch, >, inNode, =, inNodes, ., get, (, 0, ), ;, if, (]
[1, ), {, DiGraphNode, <, N, ,, Branch, >, inNode, =, inNodes, ., get, (, 0, ), ;, if, (]
[{, DiGraphNode, <, N, ,, Branch, >, inNode, =, inNodes, ., get, (, 0, ), ;, if, (, inNode, ==]
[{, DiGraphNode, <, N, ,, Branch, >, inNode, =, inNodes, ., get, (, 0, ), ;, if, (, inNode, ==]
[inNode, =, inNodes, ., get, (, 0, ), ;, if, (, inNode, ==, cfg, ., getImplicitReturn, (, ), ), {]
[inNode, =, inNodes, ., get, (, 0, ), ;, if, (, inNode, ==, cfg, ., getImplicitReturn, (, ), ), {]
[get, (, 0, ), ;, if, (, inNode, ==, cfg, ., getImplicitReturn, (, ), ), {, state, ., setOut, (]
[), {, state, ., setOut, (, createEntryLattice, (, ), ), ;, }, else, {, FlowState, <, L, >, inNodeState, =]
[), {, state, ., setOut, (, createEntryLattice, (, ), ), ;, }, else, {, FlowState, <, L, >, inNodeState, =]
[createEntryLattice, (, ), ), ;, }, else, {, FlowState, <, L, >, inNodeState, =, inNode, ., getAnnotation, (, ), ;]
[createEntryLattice, (, ), ), ;, }, else, {, FlowState, <, L, >, inNodeState, =, inNode, ., getAnnotation, (, ), ;]
[;, }, else, {, FlowState, <, L, >, inNodeState, =, inNode, ., getAnnotation, (, ), ;, state, ., setOut, (]
[;, }, else, {, FlowState, <, L, >, inNodeState, =, inNode, ., getAnnotation, (, ), ;, state, ., setOut, (]
[getAnnotation, (, ), ;, state, ., setOut, (, inNodeState, ., getIn, (, ), ), ;, }, }, else, if, (]
[getAnnotation, (, ), ;, state, ., setOut, (, inNodeState, ., getIn, (, ), ), ;, }, }, else, if, (]
[getAnnotation, (, ), ;, state, ., setOut, (, inNodeState, ., getIn, (, ), ), ;, }, }, else, if, (]
[setOut, (, inNodeState, ., getIn, (, ), ), ;, }, }, else, if, (, inNodes, ., size, (, ), >]
[}, }, else, if, (, inNodes, ., size, (, ), >, 1, ), {, List, <, L, >, values, =]
[., size, (, ), >, 1, ), {, List, <, L, >, values, =, new, ArrayList, <, L, >, (]
[., size, (, ), >, 1, ), {, List, <, L, >, values, =, new, ArrayList, <, L, >, (]
[L, >, (, inNodes, ., size, (, ), ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, currentNode, :]
[;, for, (, DiGraphNode, <, N, ,, Branch, >, currentNode, :, inNodes, ), {, FlowState, <, L, >, currentNodeState, =]
[;, for, (, DiGraphNode, <, N, ,, Branch, >, currentNode, :, inNodes, ), {, FlowState, <, L, >, currentNodeState, =]
[,, Branch, >, currentNode, :, inNodes, ), {, FlowState, <, L, >, currentNodeState, =, currentNode, ., getAnnotation, (, ), ;]
[,, Branch, >, currentNode, :, inNodes, ), {, FlowState, <, L, >, currentNodeState, =, currentNode, ., getAnnotation, (, ), ;]
[:, inNodes, ), {, FlowState, <, L, >, currentNodeState, =, currentNode, ., getAnnotation, (, ), ;, values, ., add, (]
[:, inNodes, ), {, FlowState, <, L, >, currentNodeState, =, currentNode, ., getAnnotation, (, ), ;, values, ., add, (]
[currentNodeState, =, currentNode, ., getAnnotation, (, ), ;, values, ., add, (, currentNodeState, ., getIn, (, ), ), ;, }]
[currentNodeState, =, currentNode, ., getAnnotation, (, ), ;, values, ., add, (, currentNodeState, ., getIn, (, ), ), ;, }]
[getAnnotation, (, ), ;, values, ., add, (, currentNodeState, ., getIn, (, ), ), ;, }, state, ., setOut, (]
[getAnnotation, (, ), ;, values, ., add, (, currentNodeState, ., getIn, (, ), ), ;, }, state, ., setOut, (]
[values, ., add, (, currentNodeState, ., getIn, (, ), ), ;, }, state, ., setOut, (, joinOp, ., apply, (]
[Annotation, {, private, L, in, ;, private, L, out, ;, private, FlowState, (, L, inState, ,, L, outState, ), {]
[Annotation, {, private, L, in, ;, private, L, out, ;, private, FlowState, (, L, inState, ,, L, outState, ), {]
[in, ;, private, L, out, ;, private, FlowState, (, L, inState, ,, L, outState, ), {, Preconditions, ., checkNotNull, (]
[L, out, ;, private, FlowState, (, L, inState, ,, L, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;]
[L, out, ;, private, FlowState, (, L, inState, ,, L, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;]
[FlowState, (, L, inState, ,, L, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (]
[inState, ,, L, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;]
[inState, ,, L, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;]
[), {, Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;, this, ., in, =]
[Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;, this, ., in, =, inState, ;]
[Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;, this, ., in, =, inState, ;]
[inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;, this, ., in, =, inState, ;, this, ., out, =]
[;, this, ., in, =, inState, ;, this, ., out, =, outState, ;, }, L, getIn, (, ), {, return]
[=, outState, ;, }, L, getIn, (, ), {, return, in, ;, }, void, setIn, (, L, in, ), {]
[=, outState, ;, }, L, getIn, (, ), {, return, in, ;, }, void, setIn, (, L, in, ), {]
[L, getIn, (, ), {, return, in, ;, }, void, setIn, (, L, in, ), {, Preconditions, ., checkNotNull, (]
[), {, return, in, ;, }, void, setIn, (, L, in, ), {, Preconditions, ., checkNotNull, (, in, ), ;]
[), {, return, in, ;, }, void, setIn, (, L, in, ), {, Preconditions, ., checkNotNull, (, in, ), ;]
[;, }, void, setIn, (, L, in, ), {, Preconditions, ., checkNotNull, (, in, ), ;, this, ., in, =]
[Preconditions, ., checkNotNull, (, in, ), ;, this, ., in, =, in, ;, }, L, getOut, (, ), {, return]
[=, in, ;, }, L, getOut, (, ), {, return, out, ;, }, void, setOut, (, L, out, ), {]
[=, in, ;, }, L, getOut, (, ), {, return, out, ;, }, void, setOut, (, L, out, ), {]
[L, getOut, (, ), {, return, out, ;, }, void, setOut, (, L, out, ), {, Preconditions, ., checkNotNull, (]
[), {, return, out, ;, }, void, setOut, (, L, out, ), {, Preconditions, ., checkNotNull, (, out, ), ;]
[), {, return, out, ;, }, void, setOut, (, L, out, ), {, Preconditions, ., checkNotNull, (, out, ), ;]
[;, }, void, setOut, (, L, out, ), {, Preconditions, ., checkNotNull, (, out, ), ;, this, ., out, =]
[(, out, ), ;, this, ., out, =, out, ;, }, @, Override, public, String, toString, (, ), {, return]
[(, out, ), ;, this, ., out, =, out, ;, }, @, Override, public, String, toString, (, ), {, return]
[this, ., out, =, out, ;, }, @, Override, public, String, toString, (, ), {, return, String, ., format, (]
[out, =, out, ;, }, @, Override, public, String, toString, (, ), {, return, String, ., format, (, "IN: %s OUT: %s", ,]
[out, ;, }, @, Override, public, String, toString, (, ), {, return, String, ., format, (, "IN: %s OUT: %s", ,, in, ,]
[., format, (, "IN: %s OUT: %s", ,, in, ,, out, ), ;, }, @, Override, public, int, hashCode, (, ), {, return]
[., format, (, "IN: %s OUT: %s", ,, in, ,, out, ), ;, }, @, Override, public, int, hashCode, (, ), {, return]
[,, in, ,, out, ), ;, }, @, Override, public, int, hashCode, (, ), {, return, Objects, ., hashCode, (]
[,, out, ), ;, }, @, Override, public, int, hashCode, (, ), {, return, Objects, ., hashCode, (, in, ,]
[(, in, ,, out, ), ;, }, }, static, class, MaxIterationsExceededException, extends, RuntimeException, {, private, static, final, long, serialVersionUID, =]
[MaxIterationsExceededException, extends, RuntimeException, {, private, static, final, long, serialVersionUID, =, 1L, ;, MaxIterationsExceededException, (, String, msg, ), {, super, (]
[L, extends, LatticeElement, >, extends, DataFlowAnalysis, <, N, ,, L, >, {, @, Override, protected, void, initialize, (, ), {]
[L, extends, LatticeElement, >, extends, DataFlowAnalysis, <, N, ,, L, >, {, @, Override, protected, void, initialize, (, ), {]
[initialize, (, ), {, orderedWorkSet, ., clear, (, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, node, :]
[initialize, (, ), {, orderedWorkSet, ., clear, (, ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, node, :]
[DiGraphNode, <, N, ,, Branch, >, node, :, getCfg, (, ), ., getDirectedGraphNodes, (, ), ), {, int, outEdgeCount, =]
[DiGraphNode, <, N, ,, Branch, >, node, :, getCfg, (, ), ., getDirectedGraphNodes, (, ), ), {, int, outEdgeCount, =]
[DiGraphNode, <, N, ,, Branch, >, node, :, getCfg, (, ), ., getDirectedGraphNodes, (, ), ), {, int, outEdgeCount, =]
[node, :, getCfg, (, ), ., getDirectedGraphNodes, (, ), ), {, int, outEdgeCount, =, getCfg, (, ), ., getOutEdges, (]
[node, :, getCfg, (, ), ., getDirectedGraphNodes, (, ), ), {, int, outEdgeCount, =, getCfg, (, ), ., getOutEdges, (]
[., getOutEdges, (, node, ., getValue, (, ), ), ., size, (, ), ;, List, <, L, >, outLattices, =]
[., getOutEdges, (, node, ., getValue, (, ), ), ., size, (, ), ;, List, <, L, >, outLattices, =]
[(, ), ;, List, <, L, >, outLattices, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =]
[;, List, <, L, >, outLattices, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =, 0, ;]
[;, List, <, L, >, outLattices, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =, 0, ;]
[<, L, >, outLattices, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =, 0, ;, i, <]
[>, outLattices, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =, 0, ;, i, <, outEdgeCount, ;]
[>, outLattices, =, Lists, ., newArrayList, (, ), ;, for, (, int, i, =, 0, ;, i, <, outEdgeCount, ;]
[., newArrayList, (, ), ;, for, (, int, i, =, 0, ;, i, <, outEdgeCount, ;, i, ++, ), {]
[., newArrayList, (, ), ;, for, (, int, i, =, 0, ;, i, <, outEdgeCount, ;, i, ++, ), {]
[;, for, (, int, i, =, 0, ;, i, <, outEdgeCount, ;, i, ++, ), {, outLattices, ., add, (]
[0, ;, i, <, outEdgeCount, ;, i, ++, ), {, outLattices, ., add, (, createInitialEstimateLattice, (, ), ), ;, }]
[0, ;, i, <, outEdgeCount, ;, i, ++, ), {, outLattices, ., add, (, createInitialEstimateLattice, (, ), ), ;, }]
[outEdgeCount, ;, i, ++, ), {, outLattices, ., add, (, createInitialEstimateLattice, (, ), ), ;, }, node, ., setAnnotation, (]
[outLattices, ., add, (, createInitialEstimateLattice, (, ), ), ;, }, node, ., setAnnotation, (, new, BranchedFlowState, <, L, >, (]
[createInitialEstimateLattice, (, ), ), ;, }, node, ., setAnnotation, (, new, BranchedFlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,]
[node, ., setAnnotation, (, new, BranchedFlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,, outLattices, ), ), ;, if, (]
[node, ., setAnnotation, (, new, BranchedFlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,, outLattices, ), ), ;, if, (]
[setAnnotation, (, new, BranchedFlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,, outLattices, ), ), ;, if, (, node, !=]
[setAnnotation, (, new, BranchedFlowState, <, L, >, (, createInitialEstimateLattice, (, ), ,, outLattices, ), ), ;, if, (, node, !=]
[(, ), ,, outLattices, ), ), ;, if, (, node, !=, getCfg, (, ), ., getImplicitReturn, (, ), ), {]
[(, ), ,, outLattices, ), ), ;, if, (, node, !=, getCfg, (, ), ., getImplicitReturn, (, ), ), {]
[), ), ;, if, (, node, !=, getCfg, (, ), ., getImplicitReturn, (, ), ), {, orderedWorkSet, ., add, (]
[}, }, }, BranchedForwardDataFlowAnalysis, (, ControlFlowGraph, <, N, >, targetCfg, ,, JoinOp, <, L, >, joinOp, ), {, super, (]
[}, BranchedForwardDataFlowAnalysis, (, ControlFlowGraph, <, N, >, targetCfg, ,, JoinOp, <, L, >, joinOp, ), {, super, (, targetCfg, ,]
[,, joinOp, ), ;, }, @, Override, L, getExitLatticeElement, (, ), {, DiGraphNode, <, N, ,, Branch, >, node, =]
[,, joinOp, ), ;, }, @, Override, L, getExitLatticeElement, (, ), {, DiGraphNode, <, N, ,, Branch, >, node, =]
[N, ,, Branch, >, node, =, getCfg, (, ), ., getImplicitReturn, (, ), ;, BranchedFlowState, <, L, >, state, =]
[N, ,, Branch, >, node, =, getCfg, (, ), ., getImplicitReturn, (, ), ;, BranchedFlowState, <, L, >, state, =]
[(, ), ., getImplicitReturn, (, ), ;, BranchedFlowState, <, L, >, state, =, node, ., getAnnotation, (, ), ;, return]
[(, ), ., getImplicitReturn, (, ), ;, BranchedFlowState, <, L, >, state, =, node, ., getAnnotation, (, ), ;, return]
[(, ), ;, return, state, ., getIn, (, ), ;, }, @, Override, final, boolean, isForward, (, ), {, return]
[protected, final, boolean, flow, (, DiGraphNode, <, N, ,, Branch, >, node, ), {, BranchedFlowState, <, L, >, state, =]
[protected, final, boolean, flow, (, DiGraphNode, <, N, ,, Branch, >, node, ), {, BranchedFlowState, <, L, >, state, =]
[), {, BranchedFlowState, <, L, >, state, =, node, ., getAnnotation, (, ), ;, List, <, L, >, outBefore, =]
[), {, BranchedFlowState, <, L, >, state, =, node, ., getAnnotation, (, ), ;, List, <, L, >, outBefore, =]
[L, >, state, =, node, ., getAnnotation, (, ), ;, List, <, L, >, outBefore, =, state, ., out, ;]
[L, >, state, =, node, ., getAnnotation, (, ), ;, List, <, L, >, outBefore, =, state, ., out, ;]
[node, ., getAnnotation, (, ), ;, List, <, L, >, outBefore, =, state, ., out, ;, state, ., out, =]
[getAnnotation, (, ), ;, List, <, L, >, outBefore, =, state, ., out, ;, state, ., out, =, branchedFlowThrough, (]
[getAnnotation, (, ), ;, List, <, L, >, outBefore, =, state, ., out, ;, state, ., out, =, branchedFlowThrough, (]
[L, >, outBefore, =, state, ., out, ;, state, ., out, =, branchedFlowThrough, (, node, ., getValue, (, ), ,]
[L, >, outBefore, =, state, ., out, ;, state, ., out, =, branchedFlowThrough, (, node, ., getValue, (, ), ,]
[., out, ;, state, ., out, =, branchedFlowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;]
[., out, ;, state, ., out, =, branchedFlowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;]
[., out, =, branchedFlowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;, Preconditions, ., checkState, (]
[., out, =, branchedFlowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;, Preconditions, ., checkState, (]
[., out, =, branchedFlowThrough, (, node, ., getValue, (, ), ,, state, ., in, ), ;, Preconditions, ., checkState, (]
[., getValue, (, ), ,, state, ., in, ), ;, Preconditions, ., checkState, (, outBefore, ., size, (, ), ==]
[., getValue, (, ), ,, state, ., in, ), ;, Preconditions, ., checkState, (, outBefore, ., size, (, ), ==]
[., getValue, (, ), ,, state, ., in, ), ;, Preconditions, ., checkState, (, outBefore, ., size, (, ), ==]
[outBefore, ., size, (, ), ==, state, ., out, ., size, (, ), ), ;, for, (, int, i, =]
[size, (, ), ==, state, ., out, ., size, (, ), ), ;, for, (, int, i, =, 0, ;]
[size, (, ), ==, state, ., out, ., size, (, ), ), ;, for, (, int, i, =, 0, ;]
[), ==, state, ., out, ., size, (, ), ), ;, for, (, int, i, =, 0, ;, i, <]
[), ==, state, ., out, ., size, (, ), ), ;, for, (, int, i, =, 0, ;, i, <]
[size, (, ), ), ;, for, (, int, i, =, 0, ;, i, <, outBefore, ., size, (, ), ;]
[size, (, ), ), ;, for, (, int, i, =, 0, ;, i, <, outBefore, ., size, (, ), ;]
[(, int, i, =, 0, ;, i, <, outBefore, ., size, (, ), ;, i, ++, ), {, if, (]
[int, i, =, 0, ;, i, <, outBefore, ., size, (, ), ;, i, ++, ), {, if, (, !]
[int, i, =, 0, ;, i, <, outBefore, ., size, (, ), ;, i, ++, ), {, if, (, !]
[int, i, =, 0, ;, i, <, outBefore, ., size, (, ), ;, i, ++, ), {, if, (, !]
[;, i, <, outBefore, ., size, (, ), ;, i, ++, ), {, if, (, !, outBefore, ., get, (]
[size, (, ), ;, i, ++, ), {, if, (, !, outBefore, ., get, (, i, ), ., equals, (]
[size, (, ), ;, i, ++, ), {, if, (, !, outBefore, ., get, (, i, ), ., equals, (]
[size, (, ), ;, i, ++, ), {, if, (, !, outBefore, ., get, (, i, ), ., equals, (]
[), {, if, (, !, outBefore, ., get, (, i, ), ., equals, (, state, ., out, ., get, (]
[., get, (, i, ), ., equals, (, state, ., out, ., get, (, i, ), ), ), {, return]
[., equals, (, state, ., out, ., get, (, i, ), ), ), {, return, true, ;, }, }, return]
[Override, protected, void, joinInputs, (, DiGraphNode, <, N, ,, Branch, >, node, ), {, BranchedFlowState, <, L, >, state, =]
[Override, protected, void, joinInputs, (, DiGraphNode, <, N, ,, Branch, >, node, ), {, BranchedFlowState, <, L, >, state, =]
[>, state, =, node, ., getAnnotation, (, ), ;, List, <, DiGraphNode, <, N, ,, Branch, >, >, predNodes, =]
[>, state, =, node, ., getAnnotation, (, ), ;, List, <, DiGraphNode, <, N, ,, Branch, >, >, predNodes, =]
[(, ), ;, List, <, DiGraphNode, <, N, ,, Branch, >, >, predNodes, =, getCfg, (, ), ., getDirectedPredNodes, (]
[Branch, >, >, predNodes, =, getCfg, (, ), ., getDirectedPredNodes, (, node, ), ;, List, <, L, >, values, =]
[(, ), ., getDirectedPredNodes, (, node, ), ;, List, <, L, >, values, =, new, ArrayList, <, L, >, (]
[(, ), ., getDirectedPredNodes, (, node, ), ;, List, <, L, >, values, =, new, ArrayList, <, L, >, (]
[L, >, (, predNodes, ., size, (, ), ), ;, for, (, DiGraphNode, <, N, ,, Branch, >, predNode, :]
[;, for, (, DiGraphNode, <, N, ,, Branch, >, predNode, :, predNodes, ), {, BranchedFlowState, <, L, >, predNodeState, =]
[;, for, (, DiGraphNode, <, N, ,, Branch, >, predNode, :, predNodes, ), {, BranchedFlowState, <, L, >, predNodeState, =]
[predNode, :, predNodes, ), {, BranchedFlowState, <, L, >, predNodeState, =, predNode, ., getAnnotation, (, ), ;, L, in, =]
[predNode, :, predNodes, ), {, BranchedFlowState, <, L, >, predNodeState, =, predNode, ., getAnnotation, (, ), ;, L, in, =]
[predNode, :, predNodes, ), {, BranchedFlowState, <, L, >, predNodeState, =, predNode, ., getAnnotation, (, ), ;, L, in, =]
[<, L, >, predNodeState, =, predNode, ., getAnnotation, (, ), ;, L, in, =, predNodeState, ., out, ., get, (]
[<, L, >, predNodeState, =, predNode, ., getAnnotation, (, ), ;, L, in, =, predNodeState, ., out, ., get, (]
[<, L, >, predNodeState, =, predNode, ., getAnnotation, (, ), ;, L, in, =, predNodeState, ., out, ., get, (]
[., getAnnotation, (, ), ;, L, in, =, predNodeState, ., out, ., get, (, getCfg, (, ), ., getDirectedSuccNodes, (]
[L, in, =, predNodeState, ., out, ., get, (, getCfg, (, ), ., getDirectedSuccNodes, (, predNode, ), ., indexOf, (]
[., out, ., get, (, getCfg, (, ), ., getDirectedSuccNodes, (, predNode, ), ., indexOf, (, node, ), ), ;]
[., out, ., get, (, getCfg, (, ), ., getDirectedSuccNodes, (, predNode, ), ., indexOf, (, node, ), ), ;]
[(, getCfg, (, ), ., getDirectedSuccNodes, (, predNode, ), ., indexOf, (, node, ), ), ;, values, ., add, (]
[(, predNode, ), ., indexOf, (, node, ), ), ;, values, ., add, (, in, ), ;, }, if, (]
[(, predNode, ), ., indexOf, (, node, ), ), ;, values, ., add, (, in, ), ;, }, if, (]
[(, predNode, ), ., indexOf, (, node, ), ), ;, values, ., add, (, in, ), ;, }, if, (]
[), ;, values, ., add, (, in, ), ;, }, if, (, getCfg, (, ), ., getEntry, (, ), ==]
[., add, (, in, ), ;, }, if, (, getCfg, (, ), ., getEntry, (, ), ==, node, ), {]
[., add, (, in, ), ;, }, if, (, getCfg, (, ), ., getEntry, (, ), ==, node, ), {]
[), ;, }, if, (, getCfg, (, ), ., getEntry, (, ), ==, node, ), {, state, ., setIn, (]
[getEntry, (, ), ==, node, ), {, state, ., setIn, (, createEntryLattice, (, ), ), ;, }, else, if, (]
[(, ), ==, node, ), {, state, ., setIn, (, createEntryLattice, (, ), ), ;, }, else, if, (, !]
[(, ), ==, node, ), {, state, ., setIn, (, createEntryLattice, (, ), ), ;, }, else, if, (, !]
[., setIn, (, createEntryLattice, (, ), ), ;, }, else, if, (, !, values, ., isEmpty, (, ), ), {]
[., setIn, (, createEntryLattice, (, ), ), ;, }, else, if, (, !, values, ., isEmpty, (, ), ), {]
[(, ), ), ;, }, else, if, (, !, values, ., isEmpty, (, ), ), {, state, ., setIn, (]
[(, ), ), ;, }, else, if, (, !, values, ., isEmpty, (, ), ), {, state, ., setIn, (]
[}, else, if, (, !, values, ., isEmpty, (, ), ), {, state, ., setIn, (, joinOp, ., apply, (]
[private, List, <, L, >, out, ;, private, BranchedFlowState, (, L, inState, ,, List, <, L, >, outState, ), {]
[private, List, <, L, >, out, ;, private, BranchedFlowState, (, L, inState, ,, List, <, L, >, outState, ), {]
[>, out, ;, private, BranchedFlowState, (, L, inState, ,, List, <, L, >, outState, ), {, Preconditions, ., checkNotNull, (]
[private, BranchedFlowState, (, L, inState, ,, List, <, L, >, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;]
[private, BranchedFlowState, (, L, inState, ,, List, <, L, >, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;]
[inState, ,, List, <, L, >, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (]
[<, L, >, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;]
[<, L, >, outState, ), {, Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;]
[), {, Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;, this, ., in, =]
[Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;, this, ., in, =, inState, ;]
[Preconditions, ., checkNotNull, (, inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;, this, ., in, =, inState, ;]
[inState, ), ;, Preconditions, ., checkNotNull, (, outState, ), ;, this, ., in, =, inState, ;, this, ., out, =]
[;, this, ., in, =, inState, ;, this, ., out, =, outState, ;, }, L, getIn, (, ), {, return]
[=, outState, ;, }, L, getIn, (, ), {, return, in, ;, }, void, setIn, (, L, in, ), {]
[=, outState, ;, }, L, getIn, (, ), {, return, in, ;, }, void, setIn, (, L, in, ), {]
[L, getIn, (, ), {, return, in, ;, }, void, setIn, (, L, in, ), {, Preconditions, ., checkNotNull, (]
[), {, return, in, ;, }, void, setIn, (, L, in, ), {, Preconditions, ., checkNotNull, (, in, ), ;]
[), {, return, in, ;, }, void, setIn, (, L, in, ), {, Preconditions, ., checkNotNull, (, in, ), ;]
[;, }, void, setIn, (, L, in, ), {, Preconditions, ., checkNotNull, (, in, ), ;, this, ., in, =]
[(, in, ), ;, this, ., in, =, in, ;, }, List, <, L, >, getOut, (, ), {, return]
[L, >, getOut, (, ), {, return, out, ;, }, void, setOut, (, List, <, L, >, out, ), {]
[L, >, getOut, (, ), {, return, out, ;, }, void, setOut, (, List, <, L, >, out, ), {]
[), {, return, out, ;, }, void, setOut, (, List, <, L, >, out, ), {, Preconditions, ., checkNotNull, (]
[(, List, <, L, >, out, ), {, Preconditions, ., checkNotNull, (, out, ), ;, for, (, L, item, :]
[L, >, out, ), {, Preconditions, ., checkNotNull, (, out, ), ;, for, (, L, item, :, out, ), {]
[L, >, out, ), {, Preconditions, ., checkNotNull, (, out, ), ;, for, (, L, item, :, out, ), {]
[{, Preconditions, ., checkNotNull, (, out, ), ;, for, (, L, item, :, out, ), {, Preconditions, ., checkNotNull, (]
[(, out, ), ;, for, (, L, item, :, out, ), {, Preconditions, ., checkNotNull, (, item, ), ;, }]
[(, out, ), ;, for, (, L, item, :, out, ), {, Preconditions, ., checkNotNull, (, item, ), ;, }]
[for, (, L, item, :, out, ), {, Preconditions, ., checkNotNull, (, item, ), ;, }, this, ., out, =]
[item, ), ;, }, this, ., out, =, out, ;, }, @, Override, public, String, toString, (, ), {, return]
[item, ), ;, }, this, ., out, =, out, ;, }, @, Override, public, String, toString, (, ), {, return]
[this, ., out, =, out, ;, }, @, Override, public, String, toString, (, ), {, return, String, ., format, (]
[out, =, out, ;, }, @, Override, public, String, toString, (, ), {, return, String, ., format, (, "IN: %s OUT: %s", ,]
[out, ;, }, @, Override, public, String, toString, (, ), {, return, String, ., format, (, "IN: %s OUT: %s", ,, in, ,]
[., format, (, "IN: %s OUT: %s", ,, in, ,, out, ), ;, }, @, Override, public, int, hashCode, (, ), {, return]
[., format, (, "IN: %s OUT: %s", ,, in, ,, out, ), ;, }, @, Override, public, int, hashCode, (, ), {, return]
[,, in, ,, out, ), ;, }, @, Override, public, int, hashCode, (, ), {, return, Objects, ., hashCode, (]
[,, out, ), ;, }, @, Override, public, int, hashCode, (, ), {, return, Objects, ., hashCode, (, in, ,]
[computeEscaped, (, final, Scope, jsScope, ,, final, Set, <, Var, >, escaped, ,, AbstractCompiler, compiler, ), {, AbstractPostOrderCallback, finder, =]
[), {, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[), {, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[), {, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[), {, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (]
[@, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, jsScope, ==]
[@, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, jsScope, ==]
[NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, if, (, jsScope, ==, t, ., getScope, (, ), ||]
[t, ,, Node, n, ,, Node, parent, ), {, if, (, jsScope, ==, t, ., getScope, (, ), ||, !]
[t, ,, Node, n, ,, Node, parent, ), {, if, (, jsScope, ==, t, ., getScope, (, ), ||, !]
[parent, ), {, if, (, jsScope, ==, t, ., getScope, (, ), ||, !, n, ., isName, (, ), ||]
[parent, ), {, if, (, jsScope, ==, t, ., getScope, (, ), ||, !, n, ., isName, (, ), ||]
[!, n, ., isName, (, ), ||, parent, ., isFunction, (, ), ), {, return, ;, }, String, name, =]
[!, n, ., isName, (, ), ||, parent, ., isFunction, (, ), ), {, return, ;, }, String, name, =]
[isFunction, (, ), ), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, Var, var, =]
[isFunction, (, ), ), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, Var, var, =]
[isFunction, (, ), ), {, return, ;, }, String, name, =, n, ., getString, (, ), ;, Var, var, =]
[String, name, =, n, ., getString, (, ), ;, Var, var, =, t, ., getScope, (, ), ., getVar, (]
[getString, (, ), ;, Var, var, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (]
[getString, (, ), ;, Var, var, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (]
[getString, (, ), ;, Var, var, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (]
[), ;, Var, var, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (, var, !=]
[Var, var, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (, var, !=, null, &&]
[Var, var, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (, var, !=, null, &&]
[Var, var, =, t, ., getScope, (, ), ., getVar, (, name, ), ;, if, (, var, !=, null, &&]
[., getScope, (, ), ., getVar, (, name, ), ;, if, (, var, !=, null, &&, var, ., scope, ==]
[), ., getVar, (, name, ), ;, if, (, var, !=, null, &&, var, ., scope, ==, jsScope, ), {]
[), ., getVar, (, name, ), ;, if, (, var, !=, null, &&, var, ., scope, ==, jsScope, ), {]
[name, ), ;, if, (, var, !=, null, &&, var, ., scope, ==, jsScope, ), {, escaped, ., add, (]
[name, ), ;, if, (, var, !=, null, &&, var, ., scope, ==, jsScope, ), {, escaped, ., add, (]
[(, var, !=, null, &&, var, ., scope, ==, jsScope, ), {, escaped, ., add, (, jsScope, ., getVar, (]
[{, escaped, ., add, (, jsScope, ., getVar, (, name, ), ), ;, }, }, }, ;, NodeTraversal, t, =]
[add, (, jsScope, ., getVar, (, name, ), ), ;, }, }, }, ;, NodeTraversal, t, =, new, NodeTraversal, (]
[jsScope, ., getVar, (, name, ), ), ;, }, }, }, ;, NodeTraversal, t, =, new, NodeTraversal, (, compiler, ,]
[(, name, ), ), ;, }, }, }, ;, NodeTraversal, t, =, new, NodeTraversal, (, compiler, ,, finder, ), ;]
[(, name, ), ), ;, }, }, }, ;, NodeTraversal, t, =, new, NodeTraversal, (, compiler, ,, finder, ), ;]
[;, }, }, }, ;, NodeTraversal, t, =, new, NodeTraversal, (, compiler, ,, finder, ), ;, t, ., traverseAtScope, (]
[compiler, ,, finder, ), ;, t, ., traverseAtScope, (, jsScope, ), ;, for, (, Iterator, <, Var, >, i, =]
[compiler, ,, finder, ), ;, t, ., traverseAtScope, (, jsScope, ), ;, for, (, Iterator, <, Var, >, i, =]
[., traverseAtScope, (, jsScope, ), ;, for, (, Iterator, <, Var, >, i, =, jsScope, ., getVars, (, ), ;]
[., traverseAtScope, (, jsScope, ), ;, for, (, Iterator, <, Var, >, i, =, jsScope, ., getVars, (, ), ;]
[>, i, =, jsScope, ., getVars, (, ), ;, i, ., hasNext, (, ), ;, ), {, Var, var, =]
[>, i, =, jsScope, ., getVars, (, ), ;, i, ., hasNext, (, ), ;, ), {, Var, var, =]
[;, i, ., hasNext, (, ), ;, ), {, Var, var, =, i, ., next, (, ), ;, if, (]
[;, i, ., hasNext, (, ), ;, ), {, Var, var, =, i, ., next, (, ), ;, if, (]
[;, i, ., hasNext, (, ), ;, ), {, Var, var, =, i, ., next, (, ), ;, if, (]
[;, i, ., hasNext, (, ), ;, ), {, Var, var, =, i, ., next, (, ), ;, if, (]
[var, =, i, ., next, (, ), ;, if, (, var, ., getParentNode, (, ), ., isCatch, (, ), ||]
[var, =, i, ., next, (, ), ;, if, (, var, ., getParentNode, (, ), ., isCatch, (, ), ||]
[var, =, i, ., next, (, ), ;, if, (, var, ., getParentNode, (, ), ., isCatch, (, ), ||]
[if, (, var, ., getParentNode, (, ), ., isCatch, (, ), ||, compiler, ., getCodingConvention, (, ), ., isExported, (]
[if, (, var, ., getParentNode, (, ), ., isCatch, (, ), ||, compiler, ., getCodingConvention, (, ), ., isExported, (]
[isCatch, (, ), ||, compiler, ., getCodingConvention, (, ), ., isExported, (, var, ., getName, (, ), ), ), {]
[isCatch, (, ), ||, compiler, ., getCodingConvention, (, ), ., isExported, (, var, ., getName, (, ), ), ), {]
[compiler, ., getCodingConvention, (, ), ., isExported, (, var, ., getName, (, ), ), ), {, escaped, ., add, (]
