[;, public, class, RegionFactory, <, S, extends, Space, >, {, private, final, NodesCleaner, nodeCleaner, ;, public, RegionFactory, (, ), {]
[class, RegionFactory, <, S, extends, Space, >, {, private, final, NodesCleaner, nodeCleaner, ;, public, RegionFactory, (, ), {, nodeCleaner, =]
[;, }, public, Region, <, S, >, buildConvex, (, final, Hyperplane, <, S, >, ..., hyperplanes, ), {, if, (]
[;, }, public, Region, <, S, >, buildConvex, (, final, Hyperplane, <, S, >, ..., hyperplanes, ), {, if, (]
[}, public, Region, <, S, >, buildConvex, (, final, Hyperplane, <, S, >, ..., hyperplanes, ), {, if, (, (]
[}, public, Region, <, S, >, buildConvex, (, final, Hyperplane, <, S, >, ..., hyperplanes, ), {, if, (, (]
[Region, <, S, >, buildConvex, (, final, Hyperplane, <, S, >, ..., hyperplanes, ), {, if, (, (, hyperplanes, ==]
[>, buildConvex, (, final, Hyperplane, <, S, >, ..., hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||]
[buildConvex, (, final, Hyperplane, <, S, >, ..., hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||, (]
[buildConvex, (, final, Hyperplane, <, S, >, ..., hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||, (]
[buildConvex, (, final, Hyperplane, <, S, >, ..., hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||, (]
[<, S, >, ..., hyperplanes, ), {, if, (, (, hyperplanes, ==, null, ), ||, (, hyperplanes, ., length, ==]
[), {, if, (, (, hyperplanes, ==, null, ), ||, (, hyperplanes, ., length, ==, 0, ), ), {, return]
[(, hyperplanes, ., length, ==, 0, ), ), {, return, null, ;, }, final, Region, <, S, >, region, =]
[(, hyperplanes, ., length, ==, 0, ), ), {, return, null, ;, }, final, Region, <, S, >, region, =]
[(, hyperplanes, ., length, ==, 0, ), ), {, return, null, ;, }, final, Region, <, S, >, region, =]
[., length, ==, 0, ), ), {, return, null, ;, }, final, Region, <, S, >, region, =, hyperplanes, []
[<, S, >, region, =, hyperplanes, [, 0, ], ., wholeSpace, (, ), ;, BSPTree, <, S, >, node, =]
[<, S, >, region, =, hyperplanes, [, 0, ], ., wholeSpace, (, ), ;, BSPTree, <, S, >, node, =]
[=, hyperplanes, [, 0, ], ., wholeSpace, (, ), ;, BSPTree, <, S, >, node, =, region, ., getTree, (]
[0, ], ., wholeSpace, (, ), ;, BSPTree, <, S, >, node, =, region, ., getTree, (, false, ), ;]
[0, ], ., wholeSpace, (, ), ;, BSPTree, <, S, >, node, =, region, ., getTree, (, false, ), ;]
[(, ), ;, BSPTree, <, S, >, node, =, region, ., getTree, (, false, ), ;, node, ., setAttribute, (]
[(, ), ;, BSPTree, <, S, >, node, =, region, ., getTree, (, false, ), ;, node, ., setAttribute, (]
[), ;, node, ., setAttribute, (, Boolean, ., TRUE, ), ;, for, (, final, Hyperplane, <, S, >, hyperplane, :]
[(, Boolean, ., TRUE, ), ;, for, (, final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (]
[(, Boolean, ., TRUE, ), ;, for, (, final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (]
[), ;, for, (, final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (, node, ., insertCut, (]
[final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {]
[final, Hyperplane, <, S, >, hyperplane, :, hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {]
[>, hyperplane, :, hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {, node, ., setAttribute, (]
[hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;]
[hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;]
[hyperplanes, ), {, if, (, node, ., insertCut, (, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;]
[(, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (]
[(, hyperplane, ), ), {, node, ., setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (]
[node, ., setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;]
[setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;, node, =]
[setAttribute, (, null, ), ;, node, ., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;, node, =]
[., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;, node, =, node, ., getMinus, (, ), ;]
[., getPlus, (, ), ., setAttribute, (, Boolean, ., FALSE, ), ;, node, =, node, ., getMinus, (, ), ;]
[., setAttribute, (, Boolean, ., FALSE, ), ;, node, =, node, ., getMinus, (, ), ;, node, ., setAttribute, (]
[., setAttribute, (, Boolean, ., FALSE, ), ;, node, =, node, ., getMinus, (, ), ;, node, ., setAttribute, (]
[node, =, node, ., getMinus, (, ), ;, node, ., setAttribute, (, Boolean, ., TRUE, ), ;, }, }, return]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (]
[>, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (]
[>, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (]
[final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (, region2, ., getTree, (]
[S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,]
[getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,, new, UnionMerger, (, ), ), ;]
[getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,, new, UnionMerger, (, ), ), ;]
[., merge, (, region2, ., getTree, (, false, ), ,, new, UnionMerger, (, ), ), ;, tree, ., visit, (]
[., getTree, (, false, ), ,, new, UnionMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return]
[., getTree, (, false, ), ,, new, UnionMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return]
[), ,, new, UnionMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return, region1, ., buildNew, (]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (]
[>, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (]
[>, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (]
[final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (, region2, ., getTree, (]
[S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,]
[getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,, new, IntersectionMerger, (, ), ), ;]
[getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,, new, IntersectionMerger, (, ), ), ;]
[., merge, (, region2, ., getTree, (, false, ), ,, new, IntersectionMerger, (, ), ), ;, tree, ., visit, (]
[., getTree, (, false, ), ,, new, IntersectionMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return]
[., getTree, (, false, ), ,, new, IntersectionMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return]
[), ,, new, IntersectionMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return, region1, ., buildNew, (]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (]
[>, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (]
[>, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (]
[final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (, region2, ., getTree, (]
[S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,]
[getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,, new, XorMerger, (, ), ), ;]
[getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,, new, XorMerger, (, ), ), ;]
[., merge, (, region2, ., getTree, (, false, ), ,, new, XorMerger, (, ), ), ;, tree, ., visit, (]
[., getTree, (, false, ), ,, new, XorMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return]
[., getTree, (, false, ), ,, new, XorMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return]
[), ,, new, XorMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return, region1, ., buildNew, (]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[<, S, >, region1, ,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =]
[,, final, Region, <, S, >, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (]
[>, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (]
[>, region2, ), {, final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (]
[final, BSPTree, <, S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (, region2, ., getTree, (]
[S, >, tree, =, region1, ., getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,]
[getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,, new, DifferenceMerger, (, ), ), ;]
[getTree, (, false, ), ., merge, (, region2, ., getTree, (, false, ), ,, new, DifferenceMerger, (, ), ), ;]
[., merge, (, region2, ., getTree, (, false, ), ,, new, DifferenceMerger, (, ), ), ;, tree, ., visit, (]
[., getTree, (, false, ), ,, new, DifferenceMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return]
[., getTree, (, false, ), ,, new, DifferenceMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return]
[), ,, new, DifferenceMerger, (, ), ), ;, tree, ., visit, (, nodeCleaner, ), ;, return, region1, ., buildNew, (]
[tree, ), ;, }, public, Region, <, S, >, getComplement, (, final, Region, <, S, >, region, ), {, return]
[tree, ), ;, }, public, Region, <, S, >, getComplement, (, final, Region, <, S, >, region, ), {, return]
[public, Region, <, S, >, getComplement, (, final, Region, <, S, >, region, ), {, return, region, ., buildNew, (]
[<, S, >, getComplement, (, final, Region, <, S, >, region, ), {, return, region, ., buildNew, (, recurseComplement, (]
[<, S, >, getComplement, (, final, Region, <, S, >, region, ), {, return, region, ., buildNew, (, recurseComplement, (]
[(, final, Region, <, S, >, region, ), {, return, region, ., buildNew, (, recurseComplement, (, region, ., getTree, (]
[), ;, }, private, BSPTree, <, S, >, recurseComplement, (, final, BSPTree, <, S, >, node, ), {, if, (]
[), ;, }, private, BSPTree, <, S, >, recurseComplement, (, final, BSPTree, <, S, >, node, ), {, if, (]
[), ;, }, private, BSPTree, <, S, >, recurseComplement, (, final, BSPTree, <, S, >, node, ), {, if, (]
[S, >, recurseComplement, (, final, BSPTree, <, S, >, node, ), {, if, (, node, ., getCut, (, ), ==]
[final, BSPTree, <, S, >, node, ), {, if, (, node, ., getCut, (, ), ==, null, ), {, return]
[), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, new, BSPTree, <, S, >, (]
[), {, if, (, node, ., getCut, (, ), ==, null, ), {, return, new, BSPTree, <, S, >, (]
[{, if, (, node, ., getCut, (, ), ==, null, ), {, return, new, BSPTree, <, S, >, (, (]
[node, ., getCut, (, ), ==, null, ), {, return, new, BSPTree, <, S, >, (, (, (, Boolean, )]
[node, ., getCut, (, ), ==, null, ), {, return, new, BSPTree, <, S, >, (, (, (, Boolean, )]
[), {, return, new, BSPTree, <, S, >, (, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?]
[), {, return, new, BSPTree, <, S, >, (, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?]
[BSPTree, <, S, >, (, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?, Boolean, ., FALSE, :]
[BSPTree, <, S, >, (, (, (, Boolean, ), node, ., getAttribute, (, ), ), ?, Boolean, ., FALSE, :]
[(, Boolean, ), node, ., getAttribute, (, ), ), ?, Boolean, ., FALSE, :, Boolean, ., TRUE, ), ;, }]
[node, ., getAttribute, (, ), ), ?, Boolean, ., FALSE, :, Boolean, ., TRUE, ), ;, }, @, SuppressWarnings, (]
[., FALSE, :, Boolean, ., TRUE, ), ;, }, @, SuppressWarnings, (, "unchecked", ), BoundaryAttribute, <, S, >, attribute, =]
[), ;, }, @, SuppressWarnings, (, "unchecked", ), BoundaryAttribute, <, S, >, attribute, =, (, BoundaryAttribute, <, S, >, )]
[), ;, }, @, SuppressWarnings, (, "unchecked", ), BoundaryAttribute, <, S, >, attribute, =, (, BoundaryAttribute, <, S, >, )]
[BoundaryAttribute, <, S, >, attribute, =, (, BoundaryAttribute, <, S, >, ), node, ., getAttribute, (, ), ;, if, (]
[BoundaryAttribute, <, S, >, attribute, =, (, BoundaryAttribute, <, S, >, ), node, ., getAttribute, (, ), ;, if, (]
[S, >, attribute, =, (, BoundaryAttribute, <, S, >, ), node, ., getAttribute, (, ), ;, if, (, attribute, !=]
[node, ., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, plusOutside, =]
[node, ., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, plusOutside, =]
[., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, plusOutside, =, (]
[., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, plusOutside, =, (]
[., getAttribute, (, ), ;, if, (, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, plusOutside, =, (]
[(, attribute, !=, null, ), {, final, SubHyperplane, <, S, >, plusOutside, =, (, attribute, ., getPlusInside, (, ), ==]
[null, ), {, final, SubHyperplane, <, S, >, plusOutside, =, (, attribute, ., getPlusInside, (, ), ==, null, ), ?]
[{, final, SubHyperplane, <, S, >, plusOutside, =, (, attribute, ., getPlusInside, (, ), ==, null, ), ?, null, :]
[{, final, SubHyperplane, <, S, >, plusOutside, =, (, attribute, ., getPlusInside, (, ), ==, null, ), ?, null, :]
[{, final, SubHyperplane, <, S, >, plusOutside, =, (, attribute, ., getPlusInside, (, ), ==, null, ), ?, null, :]
[?, null, :, attribute, ., getPlusInside, (, ), ., copySelf, (, ), ;, final, SubHyperplane, <, S, >, plusInside, =]
[?, null, :, attribute, ., getPlusInside, (, ), ., copySelf, (, ), ;, final, SubHyperplane, <, S, >, plusInside, =]
[null, :, attribute, ., getPlusInside, (, ), ., copySelf, (, ), ;, final, SubHyperplane, <, S, >, plusInside, =, (]
[null, :, attribute, ., getPlusInside, (, ), ., copySelf, (, ), ;, final, SubHyperplane, <, S, >, plusInside, =, (]
[null, :, attribute, ., getPlusInside, (, ), ., copySelf, (, ), ;, final, SubHyperplane, <, S, >, plusInside, =, (]
[), ., copySelf, (, ), ;, final, SubHyperplane, <, S, >, plusInside, =, (, attribute, ., getPlusOutside, (, ), ==]
[(, ), ;, final, SubHyperplane, <, S, >, plusInside, =, (, attribute, ., getPlusOutside, (, ), ==, null, ), ?]
[;, final, SubHyperplane, <, S, >, plusInside, =, (, attribute, ., getPlusOutside, (, ), ==, null, ), ?, null, :]
[;, final, SubHyperplane, <, S, >, plusInside, =, (, attribute, ., getPlusOutside, (, ), ==, null, ), ?, null, :]
[;, final, SubHyperplane, <, S, >, plusInside, =, (, attribute, ., getPlusOutside, (, ), ==, null, ), ?, null, :]
[., getPlusOutside, (, ), ==, null, ), ?, null, :, attribute, ., getPlusOutside, (, ), ., copySelf, (, ), ;]
[(, ), ==, null, ), ?, null, :, attribute, ., getPlusOutside, (, ), ., copySelf, (, ), ;, attribute, =]
[null, :, attribute, ., getPlusOutside, (, ), ., copySelf, (, ), ;, attribute, =, new, BoundaryAttribute, <, S, >, (]
[attribute, ., getPlusOutside, (, ), ., copySelf, (, ), ;, attribute, =, new, BoundaryAttribute, <, S, >, (, plusOutside, ,]
[., copySelf, (, ), ;, attribute, =, new, BoundaryAttribute, <, S, >, (, plusOutside, ,, plusInside, ), ;, }, return]
[=, new, BoundaryAttribute, <, S, >, (, plusOutside, ,, plusInside, ), ;, }, return, new, BSPTree, <, S, >, (]
[=, new, BoundaryAttribute, <, S, >, (, plusOutside, ,, plusInside, ), ;, }, return, new, BSPTree, <, S, >, (]
[=, new, BoundaryAttribute, <, S, >, (, plusOutside, ,, plusInside, ), ;, }, return, new, BSPTree, <, S, >, (]
[), ;, }, return, new, BSPTree, <, S, >, (, node, ., getCut, (, ), ., copySelf, (, ), ,]
[}, return, new, BSPTree, <, S, >, (, node, ., getCut, (, ), ., copySelf, (, ), ,, recurseComplement, (]
[}, return, new, BSPTree, <, S, >, (, node, ., getCut, (, ), ., copySelf, (, ), ,, recurseComplement, (]
[(, node, ., getCut, (, ), ., copySelf, (, ), ,, recurseComplement, (, node, ., getPlus, (, ), ), ,]
[., getCut, (, ), ., copySelf, (, ), ,, recurseComplement, (, node, ., getPlus, (, ), ), ,, recurseComplement, (]
[., getCut, (, ), ., copySelf, (, ), ,, recurseComplement, (, node, ., getPlus, (, ), ), ,, recurseComplement, (]
[), ,, recurseComplement, (, node, ., getPlus, (, ), ), ,, recurseComplement, (, node, ., getMinus, (, ), ), ,]
[tree, ,, final, BSPTree, <, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (]
[BSPTree, <, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, )]
[BSPTree, <, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, )]
[boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {]
[boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {]
[boolean, leafFromInstance, ), {, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, leaf, ., insertInTree, (]
[), {, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, leaf, ., insertInTree, (, parentTree, ,]
[(, Boolean, ), leaf, ., getAttribute, (, ), ), {, leaf, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return]
[leaf, ., getAttribute, (, ), ), {, leaf, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, leaf, ;, }]
[leaf, ., getAttribute, (, ), ), {, leaf, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, leaf, ;, }]
[), ), {, leaf, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, leaf, ;, }, tree, ., insertInTree, (]
[{, leaf, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, leaf, ;, }, tree, ., insertInTree, (, parentTree, ,]
[(, parentTree, ,, isPlusChild, ), ;, return, leaf, ;, }, tree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return]
[tree, ,, final, BSPTree, <, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (]
[BSPTree, <, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, )]
[BSPTree, <, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, )]
[boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {]
[boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {]
[boolean, leafFromInstance, ), {, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, tree, ., insertInTree, (]
[), {, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, tree, ., insertInTree, (, parentTree, ,]
[(, Boolean, ), leaf, ., getAttribute, (, ), ), {, tree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return]
[leaf, ., getAttribute, (, ), ), {, tree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, tree, ;, }]
[leaf, ., getAttribute, (, ), ), {, tree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, tree, ;, }]
[), ), {, tree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, tree, ;, }, leaf, ., insertInTree, (]
[{, tree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, tree, ;, }, leaf, ., insertInTree, (, parentTree, ,]
[(, parentTree, ,, isPlusChild, ), ;, return, tree, ;, }, leaf, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return]
[<, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, BSPTree, <, S, >, t, =]
[,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, BSPTree, <, S, >, t, =, tree, ;, if, (]
[isPlusChild, ,, final, boolean, leafFromInstance, ), {, BSPTree, <, S, >, t, =, tree, ;, if, (, (, Boolean, )]
[isPlusChild, ,, final, boolean, leafFromInstance, ), {, BSPTree, <, S, >, t, =, tree, ;, if, (, (, Boolean, )]
[BSPTree, <, S, >, t, =, tree, ;, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {]
[S, >, t, =, tree, ;, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, t, =]
[t, =, tree, ;, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, t, =, recurseComplement, (]
[if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, t, =, recurseComplement, (, t, ), ;, }]
[if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, t, =, recurseComplement, (, t, ), ;, }]
[), leaf, ., getAttribute, (, ), ), {, t, =, recurseComplement, (, t, ), ;, }, t, ., insertInTree, (]
[., getAttribute, (, ), ), {, t, =, recurseComplement, (, t, ), ;, }, t, ., insertInTree, (, parentTree, ,]
[), {, t, =, recurseComplement, (, t, ), ;, }, t, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return]
[tree, ,, final, BSPTree, <, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (]
[BSPTree, <, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, )]
[BSPTree, <, S, >, parentTree, ,, final, boolean, isPlusChild, ,, final, boolean, leafFromInstance, ), {, if, (, (, Boolean, )]
[{, if, (, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, final, BSPTree, <, S, >, argTree, =]
[(, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, final, BSPTree, <, S, >, argTree, =, recurseComplement, (]
[(, (, Boolean, ), leaf, ., getAttribute, (, ), ), {, final, BSPTree, <, S, >, argTree, =, recurseComplement, (]
[Boolean, ), leaf, ., getAttribute, (, ), ), {, final, BSPTree, <, S, >, argTree, =, recurseComplement, (, leafFromInstance, ?]
[leaf, ., getAttribute, (, ), ), {, final, BSPTree, <, S, >, argTree, =, recurseComplement, (, leafFromInstance, ?, tree, :]
[(, ), ), {, final, BSPTree, <, S, >, argTree, =, recurseComplement, (, leafFromInstance, ?, tree, :, leaf, ), ;]
[(, ), ), {, final, BSPTree, <, S, >, argTree, =, recurseComplement, (, leafFromInstance, ?, tree, :, leaf, ), ;]
[final, BSPTree, <, S, >, argTree, =, recurseComplement, (, leafFromInstance, ?, tree, :, leaf, ), ;, argTree, ., insertInTree, (]
[<, S, >, argTree, =, recurseComplement, (, leafFromInstance, ?, tree, :, leaf, ), ;, argTree, ., insertInTree, (, parentTree, ,]
[=, recurseComplement, (, leafFromInstance, ?, tree, :, leaf, ), ;, argTree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return]
[argTree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, argTree, ;, }, final, BSPTree, <, S, >, instanceTree, =]
[argTree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, argTree, ;, }, final, BSPTree, <, S, >, instanceTree, =]
[insertInTree, (, parentTree, ,, isPlusChild, ), ;, return, argTree, ;, }, final, BSPTree, <, S, >, instanceTree, =, leafFromInstance, ?]
[parentTree, ,, isPlusChild, ), ;, return, argTree, ;, }, final, BSPTree, <, S, >, instanceTree, =, leafFromInstance, ?, leaf, :]
[isPlusChild, ), ;, return, argTree, ;, }, final, BSPTree, <, S, >, instanceTree, =, leafFromInstance, ?, leaf, :, tree, ;]
[isPlusChild, ), ;, return, argTree, ;, }, final, BSPTree, <, S, >, instanceTree, =, leafFromInstance, ?, leaf, :, tree, ;]
[argTree, ;, }, final, BSPTree, <, S, >, instanceTree, =, leafFromInstance, ?, leaf, :, tree, ;, instanceTree, ., insertInTree, (]
[}, final, BSPTree, <, S, >, instanceTree, =, leafFromInstance, ?, leaf, :, tree, ;, instanceTree, ., insertInTree, (, parentTree, ,]
[S, >, instanceTree, =, leafFromInstance, ?, leaf, :, tree, ;, instanceTree, ., insertInTree, (, parentTree, ,, isPlusChild, ), ;, return]
[NodesCleaner, implements, BSPTreeVisitor, <, S, >, {, public, Order, visitOrder, (, final, BSPTree, <, S, >, node, ), {, return]
[NodesCleaner, implements, BSPTreeVisitor, <, S, >, {, public, Order, visitOrder, (, final, BSPTree, <, S, >, node, ), {, return]
[), {, return, Order, ., PLUS_SUB_MINUS, ;, }, public, void, visitInternalNode, (, final, BSPTree, <, S, >, node, ), {]
[), {, return, Order, ., PLUS_SUB_MINUS, ;, }, public, void, visitInternalNode, (, final, BSPTree, <, S, >, node, ), {]
[., PLUS_SUB_MINUS, ;, }, public, void, visitInternalNode, (, final, BSPTree, <, S, >, node, ), {, node, ., setAttribute, (]
