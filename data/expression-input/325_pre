[Branch, >, ,, Integer, >, nodePriorities, ;, private, final, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, priorityComparator, =]
[compare, (, DiGraphNode, <, Node, ,, Branch, >, a, ,, DiGraphNode, <, Node, ,, Branch, >, b, ), {, return]
[compare, (, DiGraphNode, <, Node, ,, Branch, >, a, ,, DiGraphNode, <, Node, ,, Branch, >, b, ), {, return]
[compare, (, DiGraphNode, <, Node, ,, Branch, >, a, ,, DiGraphNode, <, Node, ,, Branch, >, b, ), {, return]
[Node, ,, Branch, >, a, ,, DiGraphNode, <, Node, ,, Branch, >, b, ), {, return, astPosition, ., get, (]
[Node, ,, Branch, >, a, ,, DiGraphNode, <, Node, ,, Branch, >, b, ), {, return, astPosition, ., get, (]
[<, Node, ,, Branch, >, b, ), {, return, astPosition, ., get, (, a, ., getValue, (, ), ), -]
[<, Node, ,, Branch, >, b, ), {, return, astPosition, ., get, (, a, ., getValue, (, ), ), -]
[>, b, ), {, return, astPosition, ., get, (, a, ., getValue, (, ), ), -, astPosition, ., get, (]
[>, b, ), {, return, astPosition, ., get, (, a, ., getValue, (, ), ), -, astPosition, ., get, (]
[boolean, shouldTraverseFunctions, ;, private, final, boolean, edgeAnnotations, ;, private, Node, root, ;, private, final, Deque, <, Node, >, exceptionHandler, =]
[exceptionHandler, =, new, ArrayDeque, <, Node, >, (, ), ;, private, final, Multimap, <, Node, ,, Node, >, finallyMap, =]
[exceptionHandler, =, new, ArrayDeque, <, Node, >, (, ), ;, private, final, Multimap, <, Node, ,, Node, >, finallyMap, =]
[finallyMap, =, HashMultimap, ., create, (, ), ;, ControlFlowAnalysis, (, AbstractCompiler, compiler, ,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {]
[finallyMap, =, HashMultimap, ., create, (, ), ;, ControlFlowAnalysis, (, AbstractCompiler, compiler, ,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {]
[create, (, ), ;, ControlFlowAnalysis, (, AbstractCompiler, compiler, ,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {, this, ., compiler, =]
[), ;, ControlFlowAnalysis, (, AbstractCompiler, compiler, ,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {, this, ., compiler, =, compiler, ;]
[), ;, ControlFlowAnalysis, (, AbstractCompiler, compiler, ,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {, this, ., compiler, =, compiler, ;]
[AbstractCompiler, compiler, ,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {, this, ., compiler, =, compiler, ;, this, ., shouldTraverseFunctions, =]
[,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {, this, ., compiler, =, compiler, ;, this, ., shouldTraverseFunctions, =, shouldTraverseFunctions, ;]
[,, boolean, shouldTraverseFunctions, ,, boolean, edgeAnnotations, ), {, this, ., compiler, =, compiler, ;, this, ., shouldTraverseFunctions, =, shouldTraverseFunctions, ;]
[boolean, edgeAnnotations, ), {, this, ., compiler, =, compiler, ;, this, ., shouldTraverseFunctions, =, shouldTraverseFunctions, ;, this, ., edgeAnnotations, =]
[shouldTraverseFunctions, =, shouldTraverseFunctions, ;, this, ., edgeAnnotations, =, edgeAnnotations, ;, }, ControlFlowGraph, <, Node, >, getCfg, (, ), {, return]
[(, ), {, return, cfg, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[(, ), {, return, cfg, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {]
[cfg, ;, }, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, this, ., root, =]
[}, @, Override, public, void, process, (, Node, externs, ,, Node, root, ), {, this, ., root, =, root, ;]
[Override, public, void, process, (, Node, externs, ,, Node, root, ), {, this, ., root, =, root, ;, astPositionCounter, =]
[void, process, (, Node, externs, ,, Node, root, ), {, this, ., root, =, root, ;, astPositionCounter, =, 0, ;]
[(, Node, externs, ,, Node, root, ), {, this, ., root, =, root, ;, astPositionCounter, =, 0, ;, astPosition, =]
[(, Node, externs, ,, Node, root, ), {, this, ., root, =, root, ;, astPositionCounter, =, 0, ;, astPosition, =]
[), {, this, ., root, =, root, ;, astPositionCounter, =, 0, ;, astPosition, =, Maps, ., newHashMap, (, ), ;]
[this, ., root, =, root, ;, astPositionCounter, =, 0, ;, astPosition, =, Maps, ., newHashMap, (, ), ;, nodePriorities, =]
[this, ., root, =, root, ;, astPositionCounter, =, 0, ;, astPosition, =, Maps, ., newHashMap, (, ), ;, nodePriorities, =]
[astPositionCounter, =, 0, ;, astPosition, =, Maps, ., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap, (, ), ;]
[0, ;, astPosition, =, Maps, ., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg, =]
[=, Maps, ., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (]
[., newHashMap, (, ), ;, nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (]
[), ;, nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,]
[nodePriorities, =, Maps, ., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,]
[., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;]
[., newHashMap, (, ), ;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;]
[;, cfg, =, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (]
[=, new, AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,]
[AstControlFlowGraph, (, computeFallThrough, (, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,]
[(, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;]
[(, root, ), ,, nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;]
[nodePriorities, ,, edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, ., put, (]
[edgeAnnotations, ), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, ., put, (, null, ,]
[), ;, NodeTraversal, ., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, ., put, (, null, ,, ++]
[., traverse, (, compiler, ,, root, ,, this, ), ;, astPosition, ., put, (, null, ,, ++, astPositionCounter, ), ;]
[(, compiler, ,, root, ,, this, ), ;, astPosition, ., put, (, null, ,, ++, astPositionCounter, ), ;, priorityCounter, =]
[put, (, null, ,, ++, astPositionCounter, ), ;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry, =]
[put, (, null, ,, ++, astPositionCounter, ), ;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry, =]
[), ;, priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry, =, cfg, ., getEntry, (, ), ;]
[priorityCounter, =, 0, ;, DiGraphNode, <, Node, ,, Branch, >, entry, =, cfg, ., getEntry, (, ), ;, prioritizeFromEntryNode, (]
[<, Node, ,, Branch, >, entry, =, cfg, ., getEntry, (, ), ;, prioritizeFromEntryNode, (, entry, ), ;, if, (]
[prioritizeFromEntryNode, (, entry, ), ;, if, (, shouldTraverseFunctions, ), {, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :]
[prioritizeFromEntryNode, (, entry, ), ;, if, (, shouldTraverseFunctions, ), {, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :]
[for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, Node, value, =]
[for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, Node, value, =]
[candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, Node, value, =, candidate, ., getValue, (, ), ;, if, (]
[candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, Node, value, =, candidate, ., getValue, (, ), ;, if, (]
[candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, Node, value, =, candidate, ., getValue, (, ), ;, if, (]
[cfg, ., getDirectedGraphNodes, (, ), ), {, Node, value, =, candidate, ., getValue, (, ), ;, if, (, value, !=]
[getDirectedGraphNodes, (, ), ), {, Node, value, =, candidate, ., getValue, (, ), ;, if, (, value, !=, null, &&]
[getDirectedGraphNodes, (, ), ), {, Node, value, =, candidate, ., getValue, (, ), ;, if, (, value, !=, null, &&]
[=, candidate, ., getValue, (, ), ;, if, (, value, !=, null, &&, value, ., isFunction, (, ), ), {]
[=, candidate, ., getValue, (, ), ;, if, (, value, !=, null, &&, value, ., isFunction, (, ), ), {]
[(, ), ;, if, (, value, !=, null, &&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (]
[(, ), ;, if, (, value, !=, null, &&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (]
[), ;, if, (, value, !=, null, &&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (, !]
[), ;, if, (, value, !=, null, &&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (, !]
[value, !=, null, &&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (]
[&&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||]
[&&, value, ., isFunction, (, ), ), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||]
[., isFunction, (, ), ), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||, candidate, ==]
[), ), {, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||, candidate, ==, entry, ), ;]
[{, Preconditions, ., checkState, (, !, nodePriorities, ., containsKey, (, candidate, ), ||, candidate, ==, entry, ), ;, prioritizeFromEntryNode, (]
[), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :]
[), ;, prioritizeFromEntryNode, (, candidate, ), ;, }, }, }, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :]
[}, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (]
[for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (, !]
[for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (, !]
[Node, ,, Branch, >, candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (, !, nodePriorities, ., containsKey, (]
[candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (, !, nodePriorities, ., containsKey, (, candidate, ), ), {]
[candidate, :, cfg, ., getDirectedGraphNodes, (, ), ), {, if, (, !, nodePriorities, ., containsKey, (, candidate, ), ), {]
[getDirectedGraphNodes, (, ), ), {, if, (, !, nodePriorities, ., containsKey, (, candidate, ), ), {, nodePriorities, ., put, (]
[), ), {, if, (, !, nodePriorities, ., containsKey, (, candidate, ), ), {, nodePriorities, ., put, (, candidate, ,]
[), {, if, (, !, nodePriorities, ., containsKey, (, candidate, ), ), {, nodePriorities, ., put, (, candidate, ,, ++]
[nodePriorities, ., containsKey, (, candidate, ), ), {, nodePriorities, ., put, (, candidate, ,, ++, priorityCounter, ), ;, }, }]
[nodePriorities, ., containsKey, (, candidate, ), ), {, nodePriorities, ., put, (, candidate, ,, ++, priorityCounter, ), ;, }, }]
[candidate, ), ), {, nodePriorities, ., put, (, candidate, ,, ++, priorityCounter, ), ;, }, }, nodePriorities, ., put, (]
[candidate, ), ), {, nodePriorities, ., put, (, candidate, ,, ++, priorityCounter, ), ;, }, }, nodePriorities, ., put, (]
[put, (, candidate, ,, ++, priorityCounter, ), ;, }, }, nodePriorities, ., put, (, cfg, ., getImplicitReturn, (, ), ,]
[(, candidate, ,, ++, priorityCounter, ), ;, }, }, nodePriorities, ., put, (, cfg, ., getImplicitReturn, (, ), ,, ++]
[DiGraphNode, <, Node, ,, Branch, >, entry, ), {, PriorityQueue, <, DiGraphNode, <, Node, ,, Branch, >, >, worklist, =]
[DiGraphNode, <, Node, ,, Branch, >, >, worklist, =, new, PriorityQueue, <, DiGraphNode, <, Node, ,, Branch, >, >, (]
[Node, ,, Branch, >, >, worklist, =, new, PriorityQueue, <, DiGraphNode, <, Node, ,, Branch, >, >, (, 10, ,]
[>, >, worklist, =, new, PriorityQueue, <, DiGraphNode, <, Node, ,, Branch, >, >, (, 10, ,, priorityComparator, ), ;]
[>, >, worklist, =, new, PriorityQueue, <, DiGraphNode, <, Node, ,, Branch, >, >, (, 10, ,, priorityComparator, ), ;]
[new, PriorityQueue, <, DiGraphNode, <, Node, ,, Branch, >, >, (, 10, ,, priorityComparator, ), ;, worklist, ., add, (]
[Node, ,, Branch, >, >, (, 10, ,, priorityComparator, ), ;, worklist, ., add, (, entry, ), ;, while, (]
[,, Branch, >, >, (, 10, ,, priorityComparator, ), ;, worklist, ., add, (, entry, ), ;, while, (, !]
[,, Branch, >, >, (, 10, ,, priorityComparator, ), ;, worklist, ., add, (, entry, ), ;, while, (, !]
[), ;, while, (, !, worklist, ., isEmpty, (, ), ), {, DiGraphNode, <, Node, ,, Branch, >, current, =]
[), ;, while, (, !, worklist, ., isEmpty, (, ), ), {, DiGraphNode, <, Node, ,, Branch, >, current, =]
[(, ), ), {, DiGraphNode, <, Node, ,, Branch, >, current, =, worklist, ., remove, (, ), ;, if, (]
[(, ), ), {, DiGraphNode, <, Node, ,, Branch, >, current, =, worklist, ., remove, (, ), ;, if, (]
[DiGraphNode, <, Node, ,, Branch, >, current, =, worklist, ., remove, (, ), ;, if, (, nodePriorities, ., containsKey, (]
[=, worklist, ., remove, (, ), ;, if, (, nodePriorities, ., containsKey, (, current, ), ), {, continue, ;, }]
[=, worklist, ., remove, (, ), ;, if, (, nodePriorities, ., containsKey, (, current, ), ), {, continue, ;, }]
[(, ), ;, if, (, nodePriorities, ., containsKey, (, current, ), ), {, continue, ;, }, nodePriorities, ., put, (]
[;, if, (, nodePriorities, ., containsKey, (, current, ), ), {, continue, ;, }, nodePriorities, ., put, (, current, ,]
[if, (, nodePriorities, ., containsKey, (, current, ), ), {, continue, ;, }, nodePriorities, ., put, (, current, ,, ++]
[., put, (, current, ,, ++, priorityCounter, ), ;, List, <, DiGraphNode, <, Node, ,, Branch, >, >, successors, =]
[., put, (, current, ,, ++, priorityCounter, ), ;, List, <, DiGraphNode, <, Node, ,, Branch, >, >, successors, =]
[,, ++, priorityCounter, ), ;, List, <, DiGraphNode, <, Node, ,, Branch, >, >, successors, =, cfg, ., getDirectedSuccNodes, (]
[>, successors, =, cfg, ., getDirectedSuccNodes, (, current, ), ;, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :]
[cfg, ., getDirectedSuccNodes, (, current, ), ;, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, successors, ), {]
[cfg, ., getDirectedSuccNodes, (, current, ), ;, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, successors, ), {]
[current, ), ;, for, (, DiGraphNode, <, Node, ,, Branch, >, candidate, :, successors, ), {, worklist, ., add, (]
[;, }, }, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {]
[;, }, }, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {]
[@, Override, public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {, astPosition, ., put, (]
[public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {, astPosition, ., put, (, n, ,]
[public, boolean, shouldTraverse, (, NodeTraversal, nodeTraversal, ,, Node, n, ,, Node, parent, ), {, astPosition, ., put, (, n, ,]
[,, Node, n, ,, Node, parent, ), {, astPosition, ., put, (, n, ,, astPositionCounter, ++, ), ;, switch, (]
[,, Node, n, ,, Node, parent, ), {, astPosition, ., put, (, n, ,, astPositionCounter, ++, ), ;, switch, (]
[astPosition, ., put, (, n, ,, astPositionCounter, ++, ), ;, switch, (, n, ., getType, (, ), ), {, case]
[astPosition, ., put, (, n, ,, astPositionCounter, ++, ), ;, switch, (, n, ., getType, (, ), ), {, case]
[astPositionCounter, ++, ), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (]
[astPositionCounter, ++, ), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (]
[), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions, ||]
[), ;, switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions, ||]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions, ||, n, ==]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions, ||, n, ==]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FUNCTION, :, if, (, shouldTraverseFunctions, ||, n, ==]
[., FUNCTION, :, if, (, shouldTraverseFunctions, ||, n, ==, cfg, ., getEntry, (, ), ., getValue, (, ), ), {]
[., FUNCTION, :, if, (, shouldTraverseFunctions, ||, n, ==, cfg, ., getEntry, (, ), ., getValue, (, ), ), {]
[(, shouldTraverseFunctions, ||, n, ==, cfg, ., getEntry, (, ), ., getValue, (, ), ), {, exceptionHandler, ., push, (]
[==, cfg, ., getEntry, (, ), ., getValue, (, ), ), {, exceptionHandler, ., push, (, n, ), ;, return]
[(, ), ., getValue, (, ), ), {, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, return]
[getValue, (, ), ), {, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, return, false, ;, case]
[getValue, (, ), ), {, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, return, false, ;, case]
[{, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, return, false, ;, case, Token, ., TRY, :]
[{, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, return, false, ;, case, Token, ., TRY, :]
[(, n, ), ;, return, true, ;, }, return, false, ;, case, Token, ., TRY, :, exceptionHandler, ., push, (]
[return, true, ;, }, return, false, ;, case, Token, ., TRY, :, exceptionHandler, ., push, (, n, ), ;, return]
[false, ;, case, Token, ., TRY, :, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, if, (]
[false, ;, case, Token, ., TRY, :, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, if, (]
[case, Token, ., TRY, :, exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, if, (, parent, !=]
[exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, if, (, parent, !=, null, ), {, switch, (]
[exceptionHandler, ., push, (, n, ), ;, return, true, ;, }, if, (, parent, !=, null, ), {, switch, (]
[true, ;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case]
[true, ;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case]
[parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, return]
[parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, return]
[null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, return, n, ==]
[null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., FOR, :, return, n, ==]
[getType, (, ), ), {, case, Token, ., FOR, :, return, n, ==, parent, ., getLastChild, (, ), ;, case]
[getType, (, ), ), {, case, Token, ., FOR, :, return, n, ==, parent, ., getLastChild, (, ), ;, case]
[case, Token, ., FOR, :, return, n, ==, parent, ., getLastChild, (, ), ;, case, Token, ., IF, :, case]
[case, Token, ., FOR, :, return, n, ==, parent, ., getLastChild, (, ), ;, case, Token, ., IF, :, case]
[return, n, ==, parent, ., getLastChild, (, ), ;, case, Token, ., IF, :, case, Token, ., WHILE, :, case]
[return, n, ==, parent, ., getLastChild, (, ), ;, case, Token, ., IF, :, case, Token, ., WHILE, :, case]
[getLastChild, (, ), ;, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, return]
[getLastChild, (, ), ;, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, return]
[), ;, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, return, n, !=]
[), ;, case, Token, ., IF, :, case, Token, ., WHILE, :, case, Token, ., WITH, :, return, n, !=]
[case, Token, ., WHILE, :, case, Token, ., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case]
[case, Token, ., WHILE, :, case, Token, ., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case]
[case, Token, ., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return]
[case, Token, ., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return]
[., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, !=]
[., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, !=]
[., WITH, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., DO, :, return, n, !=]
[;, case, Token, ., DO, :, return, n, !=, parent, ., getFirstChild, (, ), ., getNext, (, ), ;, case]
[;, case, Token, ., DO, :, return, n, !=, parent, ., getFirstChild, (, ), ., getNext, (, ), ;, case]
[:, return, n, !=, parent, ., getFirstChild, (, ), ., getNext, (, ), ;, case, Token, ., SWITCH, :, case]
[:, return, n, !=, parent, ., getFirstChild, (, ), ., getNext, (, ), ;, case, Token, ., SWITCH, :, case]
[., getFirstChild, (, ), ., getNext, (, ), ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case]
[., getFirstChild, (, ), ., getNext, (, ), ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case]
[getNext, (, ), ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :, case]
[getNext, (, ), ;, case, Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :, case]
[Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :, case, Token, ., LABEL, :, return]
[Token, ., SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :, case, Token, ., LABEL, :, return]
[SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :, case, Token, ., LABEL, :, return, n, !=]
[SWITCH, :, case, Token, ., CASE, :, case, Token, ., CATCH, :, case, Token, ., LABEL, :, return, n, !=]
[case, Token, ., CATCH, :, case, Token, ., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case]
[case, Token, ., CATCH, :, case, Token, ., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case]
[case, Token, ., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return]
[case, Token, ., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return]
[., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, n, ==]
[., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, n, ==]
[., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, n, ==]
[., LABEL, :, return, n, !=, parent, ., getFirstChild, (, ), ;, case, Token, ., FUNCTION, :, return, n, ==]
[FUNCTION, :, return, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, case]
[FUNCTION, :, return, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, case]
[parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, case, Token, ., CONTINUE, :, case]
[parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, case, Token, ., CONTINUE, :, case]
[., getNext, (, ), ., getNext, (, ), ;, case, Token, ., CONTINUE, :, case, Token, ., BREAK, :, case]
[., getNext, (, ), ., getNext, (, ), ;, case, Token, ., CONTINUE, :, case, Token, ., BREAK, :, case]
[getNext, (, ), ;, case, Token, ., CONTINUE, :, case, Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case]
[getNext, (, ), ;, case, Token, ., CONTINUE, :, case, Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case]
[Token, ., CONTINUE, :, case, Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR, :, case]
[Token, ., CONTINUE, :, case, Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR, :, case]
[Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR, :, case, Token, ., RETURN, :, case]
[Token, ., BREAK, :, case, Token, ., EXPR_RESULT, :, case, Token, ., VAR, :, case, Token, ., RETURN, :, case]
[Token, ., EXPR_RESULT, :, case, Token, ., VAR, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, return]
[:, case, Token, ., VAR, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, return, false, ;, case]
[:, case, Token, ., VAR, :, case, Token, ., RETURN, :, case, Token, ., THROW, :, return, false, ;, case]
[case, Token, ., RETURN, :, case, Token, ., THROW, :, return, false, ;, case, Token, ., TRY, :, if, (]
[case, Token, ., RETURN, :, case, Token, ., THROW, :, return, false, ;, case, Token, ., TRY, :, if, (]
[., RETURN, :, case, Token, ., THROW, :, return, false, ;, case, Token, ., TRY, :, if, (, n, ==]
[., RETURN, :, case, Token, ., THROW, :, return, false, ;, case, Token, ., TRY, :, if, (, n, ==]
[., RETURN, :, case, Token, ., THROW, :, return, false, ;, case, Token, ., TRY, :, if, (, n, ==]
[case, Token, ., TRY, :, if, (, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ), {]
[case, Token, ., TRY, :, if, (, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ), {]
[:, if, (, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ), {, Preconditions, ., checkState, (]
[:, if, (, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ), {, Preconditions, ., checkState, (]
[:, if, (, n, ==, parent, ., getFirstChild, (, ), ., getNext, (, ), ), {, Preconditions, ., checkState, (]
[., getFirstChild, (, ), ., getNext, (, ), ), {, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==]
[), ., getNext, (, ), ), {, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, parent, ), ;]
[), ., getNext, (, ), ), {, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, parent, ), ;]
[(, exceptionHandler, ., peek, (, ), ==, parent, ), ;, exceptionHandler, ., pop, (, ), ;, }, }, }, return]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, switch, (]
[;, }, @, Override, public, void, visit, (, NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, switch, (]
[NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, switch, (, n, ., getType, (, ), ), {, case]
[NodeTraversal, t, ,, Node, n, ,, Node, parent, ), {, switch, (, n, ., getType, (, ), ), {, case]
[n, ,, Node, parent, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :]
[Node, parent, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., IF, :, handleIf, (]
[n, ., getType, (, ), ), {, case, Token, ., IF, :, handleIf, (, n, ), ;, return, ;, case]
[n, ., getType, (, ), ), {, case, Token, ., IF, :, handleIf, (, n, ), ;, return, ;, case]
[), ), {, case, Token, ., IF, :, handleIf, (, n, ), ;, return, ;, case, Token, ., WHILE, :]
[{, case, Token, ., IF, :, handleIf, (, n, ), ;, return, ;, case, Token, ., WHILE, :, handleWhile, (]
[handleIf, (, n, ), ;, return, ;, case, Token, ., WHILE, :, handleWhile, (, n, ), ;, return, ;, case]
[handleIf, (, n, ), ;, return, ;, case, Token, ., WHILE, :, handleWhile, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., WHILE, :, handleWhile, (, n, ), ;, return, ;, case, Token, ., DO, :]
[;, case, Token, ., WHILE, :, handleWhile, (, n, ), ;, return, ;, case, Token, ., DO, :, handleDo, (]
[handleWhile, (, n, ), ;, return, ;, case, Token, ., DO, :, handleDo, (, n, ), ;, return, ;, case]
[handleWhile, (, n, ), ;, return, ;, case, Token, ., DO, :, handleDo, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., DO, :, handleDo, (, n, ), ;, return, ;, case, Token, ., FOR, :]
[;, case, Token, ., DO, :, handleDo, (, n, ), ;, return, ;, case, Token, ., FOR, :, handleFor, (]
[handleDo, (, n, ), ;, return, ;, case, Token, ., FOR, :, handleFor, (, n, ), ;, return, ;, case]
[handleDo, (, n, ), ;, return, ;, case, Token, ., FOR, :, handleFor, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., FOR, :, handleFor, (, n, ), ;, return, ;, case, Token, ., SWITCH, :]
[;, case, Token, ., FOR, :, handleFor, (, n, ), ;, return, ;, case, Token, ., SWITCH, :, handleSwitch, (]
[handleFor, (, n, ), ;, return, ;, case, Token, ., SWITCH, :, handleSwitch, (, n, ), ;, return, ;, case]
[handleFor, (, n, ), ;, return, ;, case, Token, ., SWITCH, :, handleSwitch, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., SWITCH, :, handleSwitch, (, n, ), ;, return, ;, case, Token, ., CASE, :]
[;, case, Token, ., SWITCH, :, handleSwitch, (, n, ), ;, return, ;, case, Token, ., CASE, :, handleCase, (]
[handleSwitch, (, n, ), ;, return, ;, case, Token, ., CASE, :, handleCase, (, n, ), ;, return, ;, case]
[handleSwitch, (, n, ), ;, return, ;, case, Token, ., CASE, :, handleCase, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., CASE, :, handleCase, (, n, ), ;, return, ;, case, Token, ., DEFAULT_CASE, :]
[;, case, Token, ., CASE, :, handleCase, (, n, ), ;, return, ;, case, Token, ., DEFAULT_CASE, :, handleDefault, (]
[handleCase, (, n, ), ;, return, ;, case, Token, ., DEFAULT_CASE, :, handleDefault, (, n, ), ;, return, ;, case]
[handleCase, (, n, ), ;, return, ;, case, Token, ., DEFAULT_CASE, :, handleDefault, (, n, ), ;, return, ;, case]
[return, ;, case, Token, ., DEFAULT_CASE, :, handleDefault, (, n, ), ;, return, ;, case, Token, ., BLOCK, :, case]
[return, ;, case, Token, ., DEFAULT_CASE, :, handleDefault, (, n, ), ;, return, ;, case, Token, ., BLOCK, :, case]
[., DEFAULT_CASE, :, handleDefault, (, n, ), ;, return, ;, case, Token, ., BLOCK, :, case, Token, ., SCRIPT, :]
[:, handleDefault, (, n, ), ;, return, ;, case, Token, ., BLOCK, :, case, Token, ., SCRIPT, :, handleStmtList, (]
[return, ;, case, Token, ., BLOCK, :, case, Token, ., SCRIPT, :, handleStmtList, (, n, ), ;, return, ;, case]
[return, ;, case, Token, ., BLOCK, :, case, Token, ., SCRIPT, :, handleStmtList, (, n, ), ;, return, ;, case]
[., BLOCK, :, case, Token, ., SCRIPT, :, handleStmtList, (, n, ), ;, return, ;, case, Token, ., FUNCTION, :]
[:, case, Token, ., SCRIPT, :, handleStmtList, (, n, ), ;, return, ;, case, Token, ., FUNCTION, :, handleFunction, (]
[handleStmtList, (, n, ), ;, return, ;, case, Token, ., FUNCTION, :, handleFunction, (, n, ), ;, return, ;, case]
[handleStmtList, (, n, ), ;, return, ;, case, Token, ., FUNCTION, :, handleFunction, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., FUNCTION, :, handleFunction, (, n, ), ;, return, ;, case, Token, ., EXPR_RESULT, :]
[;, case, Token, ., FUNCTION, :, handleFunction, (, n, ), ;, return, ;, case, Token, ., EXPR_RESULT, :, handleExpr, (]
[handleFunction, (, n, ), ;, return, ;, case, Token, ., EXPR_RESULT, :, handleExpr, (, n, ), ;, return, ;, case]
[handleFunction, (, n, ), ;, return, ;, case, Token, ., EXPR_RESULT, :, handleExpr, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., EXPR_RESULT, :, handleExpr, (, n, ), ;, return, ;, case, Token, ., THROW, :]
[;, case, Token, ., EXPR_RESULT, :, handleExpr, (, n, ), ;, return, ;, case, Token, ., THROW, :, handleThrow, (]
[handleExpr, (, n, ), ;, return, ;, case, Token, ., THROW, :, handleThrow, (, n, ), ;, return, ;, case]
[handleExpr, (, n, ), ;, return, ;, case, Token, ., THROW, :, handleThrow, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., THROW, :, handleThrow, (, n, ), ;, return, ;, case, Token, ., TRY, :]
[;, case, Token, ., THROW, :, handleThrow, (, n, ), ;, return, ;, case, Token, ., TRY, :, handleTry, (]
[handleThrow, (, n, ), ;, return, ;, case, Token, ., TRY, :, handleTry, (, n, ), ;, return, ;, case]
[handleThrow, (, n, ), ;, return, ;, case, Token, ., TRY, :, handleTry, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., TRY, :, handleTry, (, n, ), ;, return, ;, case, Token, ., CATCH, :]
[;, case, Token, ., TRY, :, handleTry, (, n, ), ;, return, ;, case, Token, ., CATCH, :, handleCatch, (]
[handleTry, (, n, ), ;, return, ;, case, Token, ., CATCH, :, handleCatch, (, n, ), ;, return, ;, case]
[handleTry, (, n, ), ;, return, ;, case, Token, ., CATCH, :, handleCatch, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., CATCH, :, handleCatch, (, n, ), ;, return, ;, case, Token, ., BREAK, :]
[;, case, Token, ., CATCH, :, handleCatch, (, n, ), ;, return, ;, case, Token, ., BREAK, :, handleBreak, (]
[handleCatch, (, n, ), ;, return, ;, case, Token, ., BREAK, :, handleBreak, (, n, ), ;, return, ;, case]
[handleCatch, (, n, ), ;, return, ;, case, Token, ., BREAK, :, handleBreak, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., BREAK, :, handleBreak, (, n, ), ;, return, ;, case, Token, ., CONTINUE, :]
[;, case, Token, ., BREAK, :, handleBreak, (, n, ), ;, return, ;, case, Token, ., CONTINUE, :, handleContinue, (]
[handleBreak, (, n, ), ;, return, ;, case, Token, ., CONTINUE, :, handleContinue, (, n, ), ;, return, ;, case]
[handleBreak, (, n, ), ;, return, ;, case, Token, ., CONTINUE, :, handleContinue, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., CONTINUE, :, handleContinue, (, n, ), ;, return, ;, case, Token, ., RETURN, :]
[;, case, Token, ., CONTINUE, :, handleContinue, (, n, ), ;, return, ;, case, Token, ., RETURN, :, handleReturn, (]
[handleContinue, (, n, ), ;, return, ;, case, Token, ., RETURN, :, handleReturn, (, n, ), ;, return, ;, case]
[handleContinue, (, n, ), ;, return, ;, case, Token, ., RETURN, :, handleReturn, (, n, ), ;, return, ;, case]
[;, return, ;, case, Token, ., RETURN, :, handleReturn, (, n, ), ;, return, ;, case, Token, ., WITH, :]
[;, case, Token, ., RETURN, :, handleReturn, (, n, ), ;, return, ;, case, Token, ., WITH, :, handleWith, (]
[handleReturn, (, n, ), ;, return, ;, case, Token, ., WITH, :, handleWith, (, n, ), ;, return, ;, case]
[handleReturn, (, n, ), ;, return, ;, case, Token, ., WITH, :, handleWith, (, n, ), ;, return, ;, case]
[Token, ., WITH, :, handleWith, (, n, ), ;, return, ;, case, Token, ., LABEL, :, return, ;, default, :]
[WITH, :, handleWith, (, n, ), ;, return, ;, case, Token, ., LABEL, :, return, ;, default, :, handleStmt, (]
[handleStmt, (, n, ), ;, return, ;, }, }, private, void, handleIf, (, Node, node, ), {, Node, thenBlock, =]
[handleStmt, (, n, ), ;, return, ;, }, }, private, void, handleIf, (, Node, node, ), {, Node, thenBlock, =]
[handleStmt, (, n, ), ;, return, ;, }, }, private, void, handleIf, (, Node, node, ), {, Node, thenBlock, =]
[Node, node, ), {, Node, thenBlock, =, node, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, elseBlock, =]
[Node, node, ), {, Node, thenBlock, =, node, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, elseBlock, =]
[=, node, ., getFirstChild, (, ), ., getNext, (, ), ;, Node, elseBlock, =, thenBlock, ., getNext, (, ), ;]
[., getFirstChild, (, ), ., getNext, (, ), ;, Node, elseBlock, =, thenBlock, ., getNext, (, ), ;, createEdge, (]
[(, ), ., getNext, (, ), ;, Node, elseBlock, =, thenBlock, ., getNext, (, ), ;, createEdge, (, node, ,]
[(, ), ., getNext, (, ), ;, Node, elseBlock, =, thenBlock, ., getNext, (, ), ;, createEdge, (, node, ,]
[(, ), ;, Node, elseBlock, =, thenBlock, ., getNext, (, ), ;, createEdge, (, node, ,, Branch, ., ON_TRUE, ,]
[;, Node, elseBlock, =, thenBlock, ., getNext, (, ), ;, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[getNext, (, ), ;, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (]
[getNext, (, ), ;, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (]
[), ;, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (, elseBlock, ==]
[(, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (, elseBlock, ==, null, ), {]
[,, Branch, ., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (, elseBlock, ==, null, ), {, createEdge, (]
[., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,]
[., ON_TRUE, ,, computeFallThrough, (, thenBlock, ), ), ;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,]
[(, thenBlock, ), ), ;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,]
[), ), ;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (]
[;, if, (, elseBlock, ==, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,]
[{, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, else, {]
[(, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, else, {, createEdge, (]
[,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, else, {, createEdge, (, node, ,]
[,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, else, {, createEdge, (, node, ,]
[,, computeFollowNode, (, node, ,, this, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,]
[(, node, ,, this, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFallThrough, (]
[), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;, }]
[}, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;, }, connectToPossibleExceptionHandler, (]
[{, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;, }, connectToPossibleExceptionHandler, (, node, ,]
[{, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;, }, connectToPossibleExceptionHandler, (, node, ,]
[,, Branch, ., ON_FALSE, ,, computeFallThrough, (, elseBlock, ), ), ;, }, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (]
[(, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleWhile, (, Node, node, ), {]
[,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (]
[., getConditionExpression, (, node, ), ), ;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,]
[., getConditionExpression, (, node, ), ), ;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,]
[), ), ;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,]
[;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[;, }, private, void, handleWhile, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ), ), ;]
[Branch, ., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ), ), ;, createEdge, (]
[ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ), ), ;, createEdge, (, node, ,]
[ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ), ), ;, createEdge, (, node, ,]
[node, ., getFirstChild, (, ), ., getNext, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,]
[getFirstChild, (, ), ., getNext, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (]
[), ., getNext, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,]
[), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;]
[), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (]
[createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,]
[createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,]
[Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (]
[(, node, ,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleDo, (, Node, node, ), {]
[,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (]
[., getConditionExpression, (, node, ), ), ;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (, node, ,]
[., getConditionExpression, (, node, ), ), ;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (, node, ,]
[), ), ;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,]
[;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[;, }, private, void, handleDo, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ), ), ;]
[createEdge, (, node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ), ), ;, createEdge, (]
[node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ), ), ;, createEdge, (, node, ,]
[node, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ), ), ;, createEdge, (, node, ,]
[ON_TRUE, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,]
[computeFallThrough, (, node, ., getFirstChild, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (]
[node, ., getFirstChild, (, ), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,]
[), ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;]
[), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (]
[createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,]
[createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,]
[Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, NodeUtil, ., getConditionExpression, (]
[,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleFor, (, Node, forNode, ), {, if, (]
[,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleFor, (, Node, forNode, ), {, if, (]
[,, NodeUtil, ., getConditionExpression, (, node, ), ), ;, }, private, void, handleFor, (, Node, forNode, ), {, if, (]
[), ), ;, }, private, void, handleFor, (, Node, forNode, ), {, if, (, forNode, ., getChildCount, (, ), ==]
[handleFor, (, Node, forNode, ), {, if, (, forNode, ., getChildCount, (, ), ==, 4, ), {, Node, init, =]
[handleFor, (, Node, forNode, ), {, if, (, forNode, ., getChildCount, (, ), ==, 4, ), {, Node, init, =]
[., getChildCount, (, ), ==, 4, ), {, Node, init, =, forNode, ., getFirstChild, (, ), ;, Node, cond, =]
[., getChildCount, (, ), ==, 4, ), {, Node, init, =, forNode, ., getFirstChild, (, ), ;, Node, cond, =]
[init, =, forNode, ., getFirstChild, (, ), ;, Node, cond, =, init, ., getNext, (, ), ;, Node, iter, =]
[init, =, forNode, ., getFirstChild, (, ), ;, Node, cond, =, init, ., getNext, (, ), ;, Node, iter, =]
[cond, =, init, ., getNext, (, ), ;, Node, iter, =, cond, ., getNext, (, ), ;, Node, body, =]
[cond, =, init, ., getNext, (, ), ;, Node, iter, =, cond, ., getNext, (, ), ;, Node, body, =]
[), ;, Node, iter, =, cond, ., getNext, (, ), ;, Node, body, =, iter, ., getNext, (, ), ;]
[Node, iter, =, cond, ., getNext, (, ), ;, Node, body, =, iter, ., getNext, (, ), ;, createEdge, (]
[=, cond, ., getNext, (, ), ;, Node, body, =, iter, ., getNext, (, ), ;, createEdge, (, init, ,]
[=, cond, ., getNext, (, ), ;, Node, body, =, iter, ., getNext, (, ), ;, createEdge, (, init, ,]
[(, ), ;, Node, body, =, iter, ., getNext, (, ), ;, createEdge, (, init, ,, Branch, ., UNCOND, ,]
[Node, body, =, iter, ., getNext, (, ), ;, createEdge, (, init, ,, Branch, ., UNCOND, ,, forNode, ), ;]
[=, iter, ., getNext, (, ), ;, createEdge, (, init, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (]
[., getNext, (, ), ;, createEdge, (, init, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,]
[., getNext, (, ), ;, createEdge, (, init, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,]
[;, createEdge, (, init, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,]
[(, init, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;]
[,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,]
[forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,]
[Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (]
[ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,]
[body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (]
[createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (, iter, ,]
[createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (, iter, ,]
[Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,]
[,, computeFollowNode, (, forNode, ,, this, ), ), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;]
[(, forNode, ,, this, ), ), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (]
[,, this, ), ), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,]
[), ;, createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;]
[createEdge, (, iter, ,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (]
[iter, ,, Branch, ., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,]
[., UNCOND, ,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;]
[,, forNode, ), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (]
[), ;, connectToPossibleExceptionHandler, (, init, ,, init, ), ;, connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (, iter, ,]
[connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (, iter, ,, iter, ), ;, }, else, {, Node, item, =]
[connectToPossibleExceptionHandler, (, forNode, ,, cond, ), ;, connectToPossibleExceptionHandler, (, iter, ,, iter, ), ;, }, else, {, Node, item, =]
[iter, ,, iter, ), ;, }, else, {, Node, item, =, forNode, ., getFirstChild, (, ), ;, Node, collection, =]
[iter, ,, iter, ), ;, }, else, {, Node, item, =, forNode, ., getFirstChild, (, ), ;, Node, collection, =]
[item, =, forNode, ., getFirstChild, (, ), ;, Node, collection, =, item, ., getNext, (, ), ;, Node, body, =]
[item, =, forNode, ., getFirstChild, (, ), ;, Node, collection, =, item, ., getNext, (, ), ;, Node, body, =]
[), ;, Node, collection, =, item, ., getNext, (, ), ;, Node, body, =, collection, ., getNext, (, ), ;]
[Node, collection, =, item, ., getNext, (, ), ;, Node, body, =, collection, ., getNext, (, ), ;, createEdge, (]
[=, item, ., getNext, (, ), ;, Node, body, =, collection, ., getNext, (, ), ;, createEdge, (, collection, ,]
[=, item, ., getNext, (, ), ;, Node, body, =, collection, ., getNext, (, ), ;, createEdge, (, collection, ,]
[(, ), ;, Node, body, =, collection, ., getNext, (, ), ;, createEdge, (, collection, ,, Branch, ., UNCOND, ,]
[Node, body, =, collection, ., getNext, (, ), ;, createEdge, (, collection, ,, Branch, ., UNCOND, ,, forNode, ), ;]
[=, collection, ., getNext, (, ), ;, createEdge, (, collection, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (]
[., getNext, (, ), ;, createEdge, (, collection, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,]
[., getNext, (, ), ;, createEdge, (, collection, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,]
[;, createEdge, (, collection, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,]
[(, collection, ,, Branch, ., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (]
[., UNCOND, ,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;]
[,, forNode, ), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,]
[forNode, ,, Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,]
[Branch, ., ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (]
[ON_TRUE, ,, computeFallThrough, (, body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,]
[body, ), ), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;]
[), ;, createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, connectToPossibleExceptionHandler, (]
[createEdge, (, forNode, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, forNode, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, forNode, ,]
[connectToPossibleExceptionHandler, (, forNode, ,, collection, ), ;, }, }, private, void, handleSwitch, (, Node, node, ), {, Node, next, =]
[forNode, ,, collection, ), ;, }, }, private, void, handleSwitch, (, Node, node, ), {, Node, next, =, getNextSiblingOfType, (]
[forNode, ,, collection, ), ;, }, }, private, void, handleSwitch, (, Node, node, ), {, Node, next, =, getNextSiblingOfType, (]
[forNode, ,, collection, ), ;, }, }, private, void, handleSwitch, (, Node, node, ), {, Node, next, =, getNextSiblingOfType, (]
[(, Node, node, ), {, Node, next, =, getNextSiblingOfType, (, node, ., getFirstChild, (, ), ., getNext, (, ), ,]
[(, Node, node, ), {, Node, next, =, getNextSiblingOfType, (, node, ., getFirstChild, (, ), ., getNext, (, ), ,]
[{, Node, next, =, getNextSiblingOfType, (, node, ., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., CASE, ,]
[{, Node, next, =, getNextSiblingOfType, (, node, ., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., CASE, ,]
[., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (]
[., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (]
[(, ), ., getNext, (, ), ,, Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (, next, !=]
[getNext, (, ), ,, Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (, next, !=, null, ), {]
[), ,, Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (, next, !=, null, ), {, createEdge, (]
[Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (, next, !=, null, ), {, createEdge, (, node, ,]
[Token, ., CASE, ,, Token, ., EMPTY, ), ;, if, (, next, !=, null, ), {, createEdge, (, node, ,]
[Token, ., EMPTY, ), ;, if, (, next, !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[!=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next, ), ;, }, else, {, if, (]
[!=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next, ), ;, }, else, {, if, (]
[!=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next, ), ;, }, else, {, if, (]
[!=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, next, ), ;, }, else, {, if, (]
[UNCOND, ,, next, ), ;, }, else, {, if, (, node, ., getFirstChild, (, ), ., getNext, (, ), !=]
[), ;, }, else, {, if, (, node, ., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {]
[}, else, {, if, (, node, ., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {, createEdge, (]
[{, if, (, node, ., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {, createEdge, (, node, ,]
[{, if, (, node, ., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {, createEdge, (, node, ,]
[., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[., getFirstChild, (, ), ., getNext, (, ), !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[node, ,, Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, }, else, {]
[Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, }, else, {, createEdge, (]
[UNCOND, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, }, else, {, createEdge, (, node, ,]
[UNCOND, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, }, else, {, createEdge, (, node, ,]
[getFirstChild, (, ), ., getNext, (, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[), ., getNext, (, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (]
[getNext, (, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,]
[else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }]
[createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (]
[node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,]
[node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,]
[connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCase, (, Node, node, ), {]
[node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (]
[node, ., getFirstChild, (, ), ), ;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (, node, ,]
[node, ., getFirstChild, (, ), ), ;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (, node, ,]
[), ), ;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,]
[), ), ;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,]
[), ), ;, }, private, void, handleCase, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., ON_TRUE, ,]
[node, ,, Branch, ., ON_TRUE, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, next, =]
[Branch, ., ON_TRUE, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, next, =, getNextSiblingOfType, (]
[Branch, ., ON_TRUE, ,, node, ., getFirstChild, (, ), ., getNext, (, ), ), ;, Node, next, =, getNextSiblingOfType, (]
[getFirstChild, (, ), ., getNext, (, ), ), ;, Node, next, =, getNextSiblingOfType, (, node, ., getNext, (, ), ,]
[getFirstChild, (, ), ., getNext, (, ), ), ;, Node, next, =, getNextSiblingOfType, (, node, ., getNext, (, ), ,]
[), ;, Node, next, =, getNextSiblingOfType, (, node, ., getNext, (, ), ,, Token, ., CASE, ), ;, if, (]
[), ;, Node, next, =, getNextSiblingOfType, (, node, ., getNext, (, ), ,, Token, ., CASE, ), ;, if, (]
[Node, next, =, getNextSiblingOfType, (, node, ., getNext, (, ), ,, Token, ., CASE, ), ;, if, (, next, !=]
[getNextSiblingOfType, (, node, ., getNext, (, ), ,, Token, ., CASE, ), ;, if, (, next, !=, null, ), {]
[getNextSiblingOfType, (, node, ., getNext, (, ), ,, Token, ., CASE, ), ;, if, (, next, !=, null, ), {]
[getNext, (, ), ,, Token, ., CASE, ), ;, if, (, next, !=, null, ), {, Preconditions, ., checkState, (]
[getNext, (, ), ,, Token, ., CASE, ), ;, if, (, next, !=, null, ), {, Preconditions, ., checkState, (]
[), ;, if, (, next, !=, null, ), {, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;]
[if, (, next, !=, null, ), {, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;, createEdge, (]
[next, !=, null, ), {, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;, createEdge, (, node, ,]
[next, !=, null, ), {, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;, createEdge, (, node, ,]
[{, Preconditions, ., checkState, (, next, ., isCase, (, ), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,]
[), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, next, ), ;, }, else, {, Node, parent, =]
[), ), ;, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, next, ), ;, }, else, {, Node, parent, =]
[ON_FALSE, ,, next, ), ;, }, else, {, Node, parent, =, node, ., getParent, (, ), ;, Node, deflt, =]
[next, ), ;, }, else, {, Node, parent, =, node, ., getParent, (, ), ;, Node, deflt, =, getNextSiblingOfType, (]
[next, ), ;, }, else, {, Node, parent, =, node, ., getParent, (, ), ;, Node, deflt, =, getNextSiblingOfType, (]
[next, ), ;, }, else, {, Node, parent, =, node, ., getParent, (, ), ;, Node, deflt, =, getNextSiblingOfType, (]
[., getParent, (, ), ;, Node, deflt, =, getNextSiblingOfType, (, parent, ., getFirstChild, (, ), ., getNext, (, ), ,]
[., getParent, (, ), ;, Node, deflt, =, getNextSiblingOfType, (, parent, ., getFirstChild, (, ), ., getNext, (, ), ,]
[=, getNextSiblingOfType, (, parent, ., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., DEFAULT_CASE, ), ;, if, (]
[=, getNextSiblingOfType, (, parent, ., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., DEFAULT_CASE, ), ;, if, (]
[(, parent, ., getFirstChild, (, ), ., getNext, (, ), ,, Token, ., DEFAULT_CASE, ), ;, if, (, deflt, !=]
[getFirstChild, (, ), ., getNext, (, ), ,, Token, ., DEFAULT_CASE, ), ;, if, (, deflt, !=, null, ), {]
[), ., getNext, (, ), ,, Token, ., DEFAULT_CASE, ), ;, if, (, deflt, !=, null, ), {, createEdge, (]
[getNext, (, ), ,, Token, ., DEFAULT_CASE, ), ;, if, (, deflt, !=, null, ), {, createEdge, (, node, ,]
[getNext, (, ), ,, Token, ., DEFAULT_CASE, ), ;, if, (, deflt, !=, null, ), {, createEdge, (, node, ,]
[Token, ., DEFAULT_CASE, ), ;, if, (, deflt, !=, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,]
[(, deflt, !=, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {]
[!=, null, ), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (]
[), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (, node, ,]
[), {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (, node, ,]
[node, ,, Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,]
[Branch, ., ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (]
[ON_FALSE, ,, deflt, ), ;, }, else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,]
[else, {, createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }]
[createEdge, (, node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (]
[node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,]
[node, ,, Branch, ., ON_FALSE, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, }, connectToPossibleExceptionHandler, (, node, ,]
[connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleDefault, (, Node, node, ), {]
[node, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleDefault, (, Node, node, ), {, createEdge, (]
[node, ., getFirstChild, (, ), ), ;, }, private, void, handleDefault, (, Node, node, ), {, createEdge, (, node, ,]
[node, ., getFirstChild, (, ), ), ;, }, private, void, handleDefault, (, Node, node, ), {, createEdge, (, node, ,]
[), ), ;, }, private, void, handleDefault, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[), ), ;, }, private, void, handleDefault, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleWith, (, Node, node, ), {]
[UNCOND, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleWith, (, Node, node, ), {, createEdge, (]
[node, ., getFirstChild, (, ), ), ;, }, private, void, handleWith, (, Node, node, ), {, createEdge, (, node, ,]
[node, ., getFirstChild, (, ), ), ;, }, private, void, handleWith, (, Node, node, ), {, createEdge, (, node, ,]
[), ), ;, }, private, void, handleWith, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[), ), ;, }, private, void, handleWith, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[(, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, ., getLastChild, (, ), ), ;]
[node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, ., getLastChild, (, ), ), ;, connectToPossibleExceptionHandler, (]
[{, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, ., getLastChild, (, ), ), ;, connectToPossibleExceptionHandler, (, node, ,]
[{, createEdge, (, node, ,, Branch, ., UNCOND, ,, node, ., getLastChild, (, ), ), ;, connectToPossibleExceptionHandler, (, node, ,]
[,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =]
[,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =]
[}, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[}, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[}, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[}, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[}, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[}, private, void, handleStmtList, (, Node, node, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[node, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (, node, ., isBlock, (, ), &&]
[node, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (, node, ., isBlock, (, ), &&]
[{, Node, parent, =, node, ., getParent, (, ), ;, if, (, node, ., isBlock, (, ), &&, parent, !=]
[parent, =, node, ., getParent, (, ), ;, if, (, node, ., isBlock, (, ), &&, parent, !=, null, &&]
[parent, =, node, ., getParent, (, ), ;, if, (, node, ., isBlock, (, ), &&, parent, !=, null, &&]
[), ;, if, (, node, ., isBlock, (, ), &&, parent, !=, null, &&, parent, ., isTry, (, ), &&]
[), ;, if, (, node, ., isBlock, (, ), &&, parent, !=, null, &&, parent, ., isTry, (, ), &&]
[), ;, if, (, node, ., isBlock, (, ), &&, parent, !=, null, &&, parent, ., isTry, (, ), &&]
[node, ., isBlock, (, ), &&, parent, !=, null, &&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (]
[(, ), &&, parent, !=, null, &&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==]
[&&, parent, !=, null, &&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&]
[parent, !=, null, &&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !]
[parent, !=, null, &&, parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !]
[parent, ., isTry, (, ), &&, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler, (]
[parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =]
[parent, ), ==, node, &&, !, NodeUtil, ., hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =]
[hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (]
[hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (]
[hasCatchHandler, (, node, ), ), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (]
[node, ), ), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (, child, !=]
[), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (, child, !=, null, &&]
[), {, return, ;, }, Node, child, =, node, ., getFirstChild, (, ), ;, while, (, child, !=, null, &&]
[=, node, ., getFirstChild, (, ), ;, while, (, child, !=, null, &&, child, ., isFunction, (, ), ), {]
[., getFirstChild, (, ), ;, while, (, child, !=, null, &&, child, ., isFunction, (, ), ), {, child, =]
[., getFirstChild, (, ), ;, while, (, child, !=, null, &&, child, ., isFunction, (, ), ), {, child, =]
[null, &&, child, ., isFunction, (, ), ), {, child, =, child, ., getNext, (, ), ;, }, if, (]
[null, &&, child, ., isFunction, (, ), ), {, child, =, child, ., getNext, (, ), ;, }, if, (]
[child, ., isFunction, (, ), ), {, child, =, child, ., getNext, (, ), ;, }, if, (, child, !=]
[(, ), ), {, child, =, child, ., getNext, (, ), ;, }, if, (, child, !=, null, ), {]
[), {, child, =, child, ., getNext, (, ), ;, }, if, (, child, !=, null, ), {, createEdge, (]
[child, =, child, ., getNext, (, ), ;, }, if, (, child, !=, null, ), {, createEdge, (, node, ,]
[child, =, child, ., getNext, (, ), ;, }, if, (, child, !=, null, ), {, createEdge, (, node, ,]
[getNext, (, ), ;, }, if, (, child, !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[), ;, }, if, (, child, !=, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (]
[null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else, {]
[{, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge, (]
[(, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge, (, node, ,]
[(, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge, (, node, ,]
[., UNCOND, ,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[,, computeFallThrough, (, child, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (]
[(, child, ), ), ;, }, else, {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,]
[{, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, if, (]
[{, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, if, (]
[(, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, if, (, parent, !=]
[UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, if, (, parent, !=, null, ), {, switch, (]
[UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, }, if, (, parent, !=, null, ), {, switch, (]
[), ;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case]
[), ;, }, if, (, parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case]
[parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., DEFAULT_CASE, :, case]
[parent, !=, null, ), {, switch, (, parent, ., getType, (, ), ), {, case, Token, ., DEFAULT_CASE, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., DEFAULT_CASE, :, case, Token, ., CASE, :, case]
[switch, (, parent, ., getType, (, ), ), {, case, Token, ., DEFAULT_CASE, :, case, Token, ., CASE, :, case]
[Token, ., DEFAULT_CASE, :, case, Token, ., CASE, :, case, Token, ., TRY, :, break, ;, default, :, if, (]
[Token, ., DEFAULT_CASE, :, case, Token, ., CASE, :, case, Token, ., TRY, :, break, ;, default, :, if, (]
[Token, ., DEFAULT_CASE, :, case, Token, ., CASE, :, case, Token, ., TRY, :, break, ;, default, :, if, (]
[., CASE, :, case, Token, ., TRY, :, break, ;, default, :, if, (, node, ., isBlock, (, ), &&]
[., CASE, :, case, Token, ., TRY, :, break, ;, default, :, if, (, node, ., isBlock, (, ), &&]
[:, break, ;, default, :, if, (, node, ., isBlock, (, ), &&, node, ., isSyntheticBlock, (, ), ), {]
[;, default, :, if, (, node, ., isBlock, (, ), &&, node, ., isSyntheticBlock, (, ), ), {, createEdge, (]
[:, if, (, node, ., isBlock, (, ), &&, node, ., isSyntheticBlock, (, ), ), {, createEdge, (, node, ,]
[:, if, (, node, ., isBlock, (, ), &&, node, ., isSyntheticBlock, (, ), ), {, createEdge, (, node, ,]
[., isBlock, (, ), &&, node, ., isSyntheticBlock, (, ), ), {, createEdge, (, node, ,, Branch, ., SYN_BLOCK, ,]
[(, ), &&, node, ., isSyntheticBlock, (, ), ), {, createEdge, (, node, ,, Branch, ., SYN_BLOCK, ,, computeFollowNode, (]
[&&, node, ., isSyntheticBlock, (, ), ), {, createEdge, (, node, ,, Branch, ., SYN_BLOCK, ,, computeFollowNode, (, node, ,]
[node, ,, this, ), ), ;, }, break, ;, }, }, }, private, void, handleFunction, (, Node, node, ), {]
[node, ,, this, ), ), ;, }, break, ;, }, }, }, private, void, handleFunction, (, Node, node, ), {]
[), ;, }, break, ;, }, }, }, private, void, handleFunction, (, Node, node, ), {, Preconditions, ., checkState, (]
[), ;, }, break, ;, }, }, }, private, void, handleFunction, (, Node, node, ), {, Preconditions, ., checkState, (]
[), ;, }, break, ;, }, }, }, private, void, handleFunction, (, Node, node, ), {, Preconditions, ., checkState, (]
[}, }, private, void, handleFunction, (, Node, node, ), {, Preconditions, ., checkState, (, node, ., getChildCount, (, ), >=]
[void, handleFunction, (, Node, node, ), {, Preconditions, ., checkState, (, node, ., getChildCount, (, ), >=, 3, ), ;]
[(, Node, node, ), {, Preconditions, ., checkState, (, node, ., getChildCount, (, ), >=, 3, ), ;, createEdge, (]
[node, ), {, Preconditions, ., checkState, (, node, ., getChildCount, (, ), >=, 3, ), ;, createEdge, (, node, ,]
[node, ), {, Preconditions, ., checkState, (, node, ., getChildCount, (, ), >=, 3, ), ;, createEdge, (, node, ,]
[., checkState, (, node, ., getChildCount, (, ), >=, 3, ), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[(, node, ., getChildCount, (, ), >=, 3, ), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (]
[(, node, ., getChildCount, (, ), >=, 3, ), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (]
[(, node, ., getChildCount, (, ), >=, 3, ), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (]
[(, node, ., getChildCount, (, ), >=, 3, ), ;, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFallThrough, (]
[UNCOND, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ), ), ;]
[UNCOND, ,, computeFallThrough, (, node, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ), ), ;]
[node, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ), ), ;, Preconditions, ., checkState, (]
[node, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ), ), ;, Preconditions, ., checkState, (]
[node, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ), ), ;, Preconditions, ., checkState, (]
[getNext, (, ), ., getNext, (, ), ), ), ;, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==]
[., getNext, (, ), ), ), ;, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, node, ), ;]
[., getNext, (, ), ), ), ;, Preconditions, ., checkState, (, exceptionHandler, ., peek, (, ), ==, node, ), ;]
[), ==, node, ), ;, exceptionHandler, ., pop, (, ), ;, }, private, void, handleExpr, (, Node, node, ), {]
[node, ), ;, exceptionHandler, ., pop, (, ), ;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (]
[;, exceptionHandler, ., pop, (, ), ;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (, node, ,]
[;, exceptionHandler, ., pop, (, ), ;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (, node, ,]
[(, ), ;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[;, }, private, void, handleExpr, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (]
[private, void, handleExpr, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,]
[Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (]
[createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,]
[this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleThrow, (, Node, node, ), {]
[), ;, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleThrow, (, Node, node, ), {, connectToPossibleExceptionHandler, (]
[connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleThrow, (, Node, node, ), {, connectToPossibleExceptionHandler, (, node, ,]
[Node, node, ), {, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleTry, (, Node, node, ), {]
[), {, connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleTry, (, Node, node, ), {, createEdge, (]
[connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleTry, (, Node, node, ), {, createEdge, (, node, ,]
[connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, private, void, handleTry, (, Node, node, ), {, createEdge, (, node, ,]
[node, ), ;, }, private, void, handleTry, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[node, ), ;, }, private, void, handleTry, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[Branch, ., UNCOND, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCatch, (, Node, node, ), {]
[UNCOND, ,, node, ., getFirstChild, (, ), ), ;, }, private, void, handleCatch, (, Node, node, ), {, createEdge, (]
[node, ., getFirstChild, (, ), ), ;, }, private, void, handleCatch, (, Node, node, ), {, createEdge, (, node, ,]
[node, ., getFirstChild, (, ), ), ;, }, private, void, handleCatch, (, Node, node, ), {, createEdge, (, node, ,]
[), ), ;, }, private, void, handleCatch, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[), ), ;, }, private, void, handleCatch, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[,, node, ., getLastChild, (, ), ), ;, }, private, void, handleBreak, (, Node, node, ), {, String, label, =]
[(, ), ), ;, }, private, void, handleBreak, (, Node, node, ), {, String, label, =, null, ;, if, (]
[(, ), ), ;, }, private, void, handleBreak, (, Node, node, ), {, String, label, =, null, ;, if, (]
[handleBreak, (, Node, node, ), {, String, label, =, null, ;, if, (, node, ., hasChildren, (, ), ), {]
[Node, node, ), {, String, label, =, null, ;, if, (, node, ., hasChildren, (, ), ), {, label, =]
[Node, node, ), {, String, label, =, null, ;, if, (, node, ., hasChildren, (, ), ), {, label, =]
[Node, node, ), {, String, label, =, null, ;, if, (, node, ., hasChildren, (, ), ), {, label, =]
[{, label, =, node, ., getFirstChild, (, ), ., getString, (, ), ;, }, Node, cur, ;, Node, previous, =]
[., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =]
[., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =]
[;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (]
[previous, =, null, ;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =]
[null, ;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,]
[Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =]
[;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;]
[Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !]
[=, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isBreakTarget, (]
[., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,]
[), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,, label, ), ;]
[for, (, cur, =, node, ,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,, label, ), ;, cur, =]
[cur, =, node, ,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,, label, ), ;, cur, =, parent, ,]
[node, ,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,, label, ), ;, cur, =, parent, ,, parent, =]
[node, ,, lastJump, =, node, ;, !, isBreakTarget, (, cur, ,, label, ), ;, cur, =, parent, ,, parent, =]
[cur, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (]
[cur, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (]
[cur, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (]
[cur, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (]
[=, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&]
[=, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&]
[=, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (]
[getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&]
[getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&]
[getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&]
[(, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=]
[), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (]
[), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (]
[NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==]
[(, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {]
[), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (]
[cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,]
[cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,]
[), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,]
[previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (]
[previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (]
[(, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, else, {]
[(, lastJump, ,, Branch, ., UNCOND, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, else, {]
[., UNCOND, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, else, {, finallyMap, ., put, (]
[,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[(, cur, ., getLastChild, (, ), ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (]
[(, cur, ., getLastChild, (, ), ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (]
[}, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }]
[{, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =]
[lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, if, (]
[lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, if, (]
[computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, if, (, parent, ==]
[(, ), ), ), ;, }, lastJump, =, cur, ;, }, if, (, parent, ==, null, ), {, if, (]
[(, ), ), ), ;, }, lastJump, =, cur, ;, }, if, (, parent, ==, null, ), {, if, (]
[parent, ==, null, ), {, if, (, compiler, ., isIdeMode, (, ), ), {, return, ;, }, else, {, throw]
[), {, if, (, compiler, ., isIdeMode, (, ), ), {, return, ;, }, else, {, throw, new, IllegalStateException, (]
[., isIdeMode, (, ), ), {, return, ;, }, else, {, throw, new, IllegalStateException, (, "Cannot find break target.", ), ;, }, }]
[(, ), ), {, return, ;, }, else, {, throw, new, IllegalStateException, (, "Cannot find break target.", ), ;, }, }, previous, =]
[;, }, else, {, throw, new, IllegalStateException, (, "Cannot find break target.", ), ;, }, }, previous, =, cur, ;, }, if, (]
[;, }, else, {, throw, new, IllegalStateException, (, "Cannot find break target.", ), ;, }, }, previous, =, cur, ;, }, if, (]
[else, {, throw, new, IllegalStateException, (, "Cannot find break target.", ), ;, }, }, previous, =, cur, ;, }, if, (, lastJump, ==]
[new, IllegalStateException, (, "Cannot find break target.", ), ;, }, }, previous, =, cur, ;, }, if, (, lastJump, ==, node, ), {]
[(, "Cannot find break target.", ), ;, }, }, previous, =, cur, ;, }, if, (, lastJump, ==, node, ), {, createEdge, (]
[), ;, }, }, previous, =, cur, ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,]
[), ;, }, }, previous, =, cur, ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,]
[previous, =, cur, ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,]
[cur, ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFollowNode, (]
[}, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFollowNode, (, cur, ,]
[{, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else, {]
[{, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else, {]
[,, Branch, ., UNCOND, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else, {, finallyMap, ., put, (]
[., UNCOND, ,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[,, computeFollowNode, (, cur, ,, this, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFollowNode, (]
[(, cur, ,, this, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFollowNode, (, cur, ,]
[(, cur, ,, this, ), ), ;, }, }, private, void, handleContinue, (, Node, node, ), {, String, label, =]
[), ), ;, }, }, private, void, handleContinue, (, Node, node, ), {, String, label, =, null, ;, if, (]
[), ), ;, }, }, private, void, handleContinue, (, Node, node, ), {, String, label, =, null, ;, if, (]
[handleContinue, (, Node, node, ), {, String, label, =, null, ;, if, (, node, ., hasChildren, (, ), ), {]
[Node, node, ), {, String, label, =, null, ;, if, (, node, ., hasChildren, (, ), ), {, label, =]
[Node, node, ), {, String, label, =, null, ;, if, (, node, ., hasChildren, (, ), ), {, label, =]
[Node, node, ), {, String, label, =, null, ;, if, (, node, ., hasChildren, (, ), ), {, label, =]
[{, label, =, node, ., getFirstChild, (, ), ., getString, (, ), ;, }, Node, cur, ;, Node, previous, =]
[., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =]
[., getString, (, ), ;, }, Node, cur, ;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =]
[;, Node, previous, =, null, ;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (]
[previous, =, null, ;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =]
[null, ;, Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,]
[Node, lastJump, ;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =]
[;, Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;]
[Node, parent, =, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !]
[=, node, ., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isContinueTarget, (]
[., getParent, (, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isContinueTarget, (, cur, ,]
[(, ), ;, for, (, cur, =, node, ,, lastJump, =, node, ;, !, isContinueTarget, (, cur, ,, parent, ,]
[for, (, cur, =, node, ,, lastJump, =, node, ;, !, isContinueTarget, (, cur, ,, parent, ,, label, ), ;]
[cur, =, node, ,, lastJump, =, node, ;, !, isContinueTarget, (, cur, ,, parent, ,, label, ), ;, cur, =]
[node, ,, lastJump, =, node, ;, !, isContinueTarget, (, cur, ,, parent, ,, label, ), ;, cur, =, parent, ,]
[lastJump, =, node, ;, !, isContinueTarget, (, cur, ,, parent, ,, label, ), ;, cur, =, parent, ,, parent, =]
[lastJump, =, node, ;, !, isContinueTarget, (, cur, ,, parent, ,, label, ), ;, cur, =, parent, ,, parent, =]
[parent, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (]
[parent, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (]
[parent, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (]
[parent, ,, label, ), ;, cur, =, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (]
[=, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&]
[=, parent, ,, parent, =, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&]
[=, parent, ., getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (]
[getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&]
[getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&]
[getParent, (, ), ), {, if, (, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&]
[(, cur, ., isTry, (, ), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=]
[), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (]
[), &&, NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (]
[NodeUtil, ., hasFinally, (, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==]
[(, cur, ), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {]
[), &&, cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (]
[cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,]
[cur, ., getLastChild, (, ), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,]
[), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,]
[), !=, previous, ), {, if, (, lastJump, ==, node, ), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,]
[), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {]
[), {, createEdge, (, lastJump, ,, Branch, ., UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {]
[lastJump, ,, Branch, ., UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (]
[Branch, ., UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (]
[UNCOND, ,, cur, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (]
[}, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }]
[{, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =]
[put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }]
[put, (, lastJump, ,, computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }]
[computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (]
[computeFallThrough, (, cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (]
[cur, ., getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (, parent, !=]
[getLastChild, (, ), ), ), ;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (, parent, !=, null, ,]
[), ), ;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (, parent, !=, null, ,, "Cannot find continue target.", ), ;]
[;, }, lastJump, =, cur, ;, }, Preconditions, ., checkState, (, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous, =]
[}, Preconditions, ., checkState, (, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }, Node, iter, =]
[(, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }, Node, iter, =, cur, ;, if, (]
[(, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }, Node, iter, =, cur, ;, if, (]
[(, parent, !=, null, ,, "Cannot find continue target.", ), ;, previous, =, cur, ;, }, Node, iter, =, cur, ;, if, (]
[), ;, previous, =, cur, ;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==]
[=, cur, ;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==, 4, ), {]
[;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==, 4, ), {, iter, =]
[;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==, 4, ), {, iter, =]
[;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==, 4, ), {, iter, =]
[;, }, Node, iter, =, cur, ;, if, (, cur, ., getChildCount, (, ), ==, 4, ), {, iter, =]
[{, iter, =, cur, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, if, (]
[{, iter, =, cur, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, if, (]
[=, cur, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, if, (, lastJump, ==]
[getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, if, (, lastJump, ==, node, ), {]
[), ., getNext, (, ), ., getNext, (, ), ;, }, if, (, lastJump, ==, node, ), {, createEdge, (]
[getNext, (, ), ., getNext, (, ), ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, node, ,]
[getNext, (, ), ., getNext, (, ), ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, node, ,]
[getNext, (, ), ;, }, if, (, lastJump, ==, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[(, lastJump, ==, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, iter, ), ;, }, else, {]
[(, lastJump, ==, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, iter, ), ;, }, else, {]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, iter, ), ;, }, else, {, finallyMap, ., put, (]
[createEdge, (, node, ,, Branch, ., UNCOND, ,, iter, ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[put, (, lastJump, ,, iter, ), ;, }, }, private, void, handleReturn, (, Node, node, ), {, Node, lastJump, =]
[void, handleReturn, (, Node, node, ), {, Node, lastJump, =, null, ;, for, (, Iterator, <, Node, >, iter, =]
[void, handleReturn, (, Node, node, ), {, Node, lastJump, =, null, ;, for, (, Iterator, <, Node, >, iter, =]
[{, Node, lastJump, =, null, ;, for, (, Iterator, <, Node, >, iter, =, exceptionHandler, ., iterator, (, ), ;]
[{, Node, lastJump, =, null, ;, for, (, Iterator, <, Node, >, iter, =, exceptionHandler, ., iterator, (, ), ;]
[>, iter, =, exceptionHandler, ., iterator, (, ), ;, iter, ., hasNext, (, ), ;, ), {, Node, curHandler, =]
[>, iter, =, exceptionHandler, ., iterator, (, ), ;, iter, ., hasNext, (, ), ;, ), {, Node, curHandler, =]
[;, iter, ., hasNext, (, ), ;, ), {, Node, curHandler, =, iter, ., next, (, ), ;, if, (]
[;, iter, ., hasNext, (, ), ;, ), {, Node, curHandler, =, iter, ., next, (, ), ;, if, (]
[iter, ., next, (, ), ;, if, (, curHandler, ., isFunction, (, ), ), {, break, ;, }, if, (]
[iter, ., next, (, ), ;, if, (, curHandler, ., isFunction, (, ), ), {, break, ;, }, if, (]
[), ;, if, (, curHandler, ., isFunction, (, ), ), {, break, ;, }, if, (, NodeUtil, ., hasFinally, (]
[isFunction, (, ), ), {, break, ;, }, if, (, NodeUtil, ., hasFinally, (, curHandler, ), ), {, if, (]
[isFunction, (, ), ), {, break, ;, }, if, (, NodeUtil, ., hasFinally, (, curHandler, ), ), {, if, (]
[), ), {, break, ;, }, if, (, NodeUtil, ., hasFinally, (, curHandler, ), ), {, if, (, lastJump, ==]
[break, ;, }, if, (, NodeUtil, ., hasFinally, (, curHandler, ), ), {, if, (, lastJump, ==, null, ), {]
[}, if, (, NodeUtil, ., hasFinally, (, curHandler, ), ), {, if, (, lastJump, ==, null, ), {, createEdge, (]
[(, NodeUtil, ., hasFinally, (, curHandler, ), ), {, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,]
[(, NodeUtil, ., hasFinally, (, curHandler, ), ), {, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,]
[(, curHandler, ), ), {, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[(, curHandler, ), ), {, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {]
[node, ,, Branch, ., UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (]
[Branch, ., UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (]
[UNCOND, ,, curHandler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (]
[}, else, {, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, curHandler, ., getLastChild, (, ), ), ), ;, }]
[{, finallyMap, ., put, (, lastJump, ,, computeFallThrough, (, curHandler, ., getLastChild, (, ), ), ), ;, }, lastJump, =]
[,, computeFallThrough, (, curHandler, ., getLastChild, (, ), ), ), ;, }, lastJump, =, curHandler, ;, }, }, if, (]
[,, computeFallThrough, (, curHandler, ., getLastChild, (, ), ), ), ;, }, lastJump, =, curHandler, ;, }, }, if, (]
[), ), ), ;, }, lastJump, =, curHandler, ;, }, }, if, (, node, ., hasChildren, (, ), ), {]
[), ;, }, lastJump, =, curHandler, ;, }, }, if, (, node, ., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (]
[}, lastJump, =, curHandler, ;, }, }, if, (, node, ., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (, node, ,]
[}, lastJump, =, curHandler, ;, }, }, if, (, node, ., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (, node, ,]
[., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, if, (]
[., hasChildren, (, ), ), {, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, if, (]
[(, ), ), {, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, if, (, lastJump, ==]
[{, connectToPossibleExceptionHandler, (, node, ,, node, ., getFirstChild, (, ), ), ;, }, if, (, lastJump, ==, null, ), {]
[(, node, ,, node, ., getFirstChild, (, ), ), ;, }, if, (, lastJump, ==, null, ), {, createEdge, (]
[,, node, ., getFirstChild, (, ), ), ;, }, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,]
[,, node, ., getFirstChild, (, ), ), ;, }, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,]
[(, ), ), ;, }, if, (, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[(, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, null, ), ;, }, else, {]
[(, lastJump, ==, null, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, null, ), ;, }, else, {]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, null, ), ;, }, else, {, finallyMap, ., put, (]
[createEdge, (, node, ,, Branch, ., UNCOND, ,, null, ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[{, finallyMap, ., put, (, lastJump, ,, null, ), ;, }, }, private, void, handleStmt, (, Node, node, ), {]
[., put, (, lastJump, ,, null, ), ;, }, }, private, void, handleStmt, (, Node, node, ), {, createEdge, (]
[(, lastJump, ,, null, ), ;, }, }, private, void, handleStmt, (, Node, node, ), {, createEdge, (, node, ,]
[(, lastJump, ,, null, ), ;, }, }, private, void, handleStmt, (, Node, node, ), {, createEdge, (, node, ,]
[), ;, }, }, private, void, handleStmt, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,]
[}, }, private, void, handleStmt, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (]
[private, void, handleStmt, (, Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,]
[Node, node, ), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;]
[), {, createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (]
[createEdge, (, node, ,, Branch, ., UNCOND, ,, computeFollowNode, (, node, ,, this, ), ), ;, connectToPossibleExceptionHandler, (, node, ,]
[connectToPossibleExceptionHandler, (, node, ,, node, ), ;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa, ), {, return]
[node, ,, node, ), ;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa, ), {, return, computeFollowNode, (]
[node, ), ;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa, ), {, return, computeFollowNode, (, node, ,]
[;, }, static, Node, computeFollowNode, (, Node, node, ,, ControlFlowAnalysis, cfa, ), {, return, computeFollowNode, (, node, ,, node, ,]
[return, computeFollowNode, (, node, ,, node, ,, cfa, ), ;, }, static, Node, computeFollowNode, (, Node, node, ), {, return]
[(, node, ,, node, ,, cfa, ), ;, }, static, Node, computeFollowNode, (, Node, node, ), {, return, computeFollowNode, (]
[,, node, ,, cfa, ), ;, }, static, Node, computeFollowNode, (, Node, node, ), {, return, computeFollowNode, (, node, ,]
[,, cfa, ), ;, }, static, Node, computeFollowNode, (, Node, node, ), {, return, computeFollowNode, (, node, ,, node, ,]
[;, }, private, static, Node, computeFollowNode, (, Node, fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa, ), {, Node, parent, =]
[;, }, private, static, Node, computeFollowNode, (, Node, fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa, ), {, Node, parent, =]
[fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[fromNode, ,, Node, node, ,, ControlFlowAnalysis, cfa, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (]
[Node, node, ,, ControlFlowAnalysis, cfa, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (, parent, ==]
[,, ControlFlowAnalysis, cfa, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (, parent, ==, null, ||]
[,, ControlFlowAnalysis, cfa, ), {, Node, parent, =, node, ., getParent, (, ), ;, if, (, parent, ==, null, ||]
[parent, =, node, ., getParent, (, ), ;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||]
[=, node, ., getParent, (, ), ;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (]
[=, node, ., getParent, (, ), ;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (]
[=, node, ., getParent, (, ), ;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (]
[., getParent, (, ), ;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (, cfa, !=]
[(, ), ;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (, cfa, !=, null, &&]
[(, ), ;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (, cfa, !=, null, &&]
[;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (, cfa, !=, null, &&, node, ==]
[;, if, (, parent, ==, null, ||, parent, ., isFunction, (, ), ||, (, cfa, !=, null, &&, node, ==]
[parent, ., isFunction, (, ), ||, (, cfa, !=, null, &&, node, ==, cfa, ., root, ), ), {, return]
[||, (, cfa, !=, null, &&, node, ==, cfa, ., root, ), ), {, return, null, ;, }, switch, (]
[||, (, cfa, !=, null, &&, node, ==, cfa, ., root, ), ), {, return, null, ;, }, switch, (]
[cfa, ., root, ), ), {, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {, case]
[cfa, ., root, ), ), {, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {, case]
[{, return, null, ;, }, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, return]
[null, ;, }, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, return, computeFollowNode, (]
[}, switch, (, parent, ., getType, (, ), ), {, case, Token, ., IF, :, return, computeFollowNode, (, fromNode, ,]
[(, parent, ., getType, (, ), ), {, case, Token, ., IF, :, return, computeFollowNode, (, fromNode, ,, parent, ,]
[(, ), ), {, case, Token, ., IF, :, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, case]
[(, ), ), {, case, Token, ., IF, :, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, case]
[Token, ., IF, :, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, case, Token, ., CASE, :, case]
[Token, ., IF, :, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, case, Token, ., CASE, :, case]
[(, fromNode, ,, parent, ,, cfa, ), ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, if, (]
[(, fromNode, ,, parent, ,, cfa, ), ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, if, (]
[(, fromNode, ,, parent, ,, cfa, ), ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, if, (]
[), ;, case, Token, ., CASE, :, case, Token, ., DEFAULT_CASE, :, if, (, parent, ., getNext, (, ), !=]
[CASE, :, case, Token, ., DEFAULT_CASE, :, if, (, parent, ., getNext, (, ), !=, null, ), {, if, (]
[CASE, :, case, Token, ., DEFAULT_CASE, :, if, (, parent, ., getNext, (, ), !=, null, ), {, if, (]
[CASE, :, case, Token, ., DEFAULT_CASE, :, if, (, parent, ., getNext, (, ), !=, null, ), {, if, (]
[(, ), !=, null, ), {, if, (, parent, ., getNext, (, ), ., isCase, (, ), ), {, return]
[(, ), !=, null, ), {, if, (, parent, ., getNext, (, ), ., isCase, (, ), ), {, return]
[(, ), !=, null, ), {, if, (, parent, ., getNext, (, ), ., isCase, (, ), ), {, return]
[(, ), !=, null, ), {, if, (, parent, ., getNext, (, ), ., isCase, (, ), ), {, return]
[{, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ., getNext, (, ), ;, }, else, if, (]
[{, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ., getNext, (, ), ;, }, else, if, (]
[{, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ., getNext, (, ), ;, }, else, if, (]
[getNext, (, ), ;, }, else, if, (, parent, ., getNext, (, ), ., isDefaultCase, (, ), ), {, return]
[getNext, (, ), ;, }, else, if, (, parent, ., getNext, (, ), ., isDefaultCase, (, ), ), {, return]
[getNext, (, ), ;, }, else, if, (, parent, ., getNext, (, ), ., isDefaultCase, (, ), ), {, return]
[., isDefaultCase, (, ), ), {, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ;, }, else, {]
[., isDefaultCase, (, ), ), {, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ;, }, else, {]
[), {, return, parent, ., getNext, (, ), ., getFirstChild, (, ), ;, }, else, {, Preconditions, ., checkState, (]
[return, parent, ., getNext, (, ), ., getFirstChild, (, ), ;, }, else, {, Preconditions, ., checkState, (, false, ,]
[(, ), ;, }, else, {, Preconditions, ., checkState, (, false, ,, "Not reachable", ), ;, }, }, else, {, return]
[;, }, else, {, Preconditions, ., checkState, (, false, ,, "Not reachable", ), ;, }, }, else, {, return, computeFollowNode, (]
[else, {, Preconditions, ., checkState, (, false, ,, "Not reachable", ), ;, }, }, else, {, return, computeFollowNode, (, fromNode, ,]
[Preconditions, ., checkState, (, false, ,, "Not reachable", ), ;, }, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,]
[), ;, }, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, break, ;, case]
[), ;, }, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, break, ;, case]
[return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, break, ;, case, Token, ., FOR, :, if, (]
[return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, break, ;, case, Token, ., FOR, :, if, (]
[,, parent, ,, cfa, ), ;, }, break, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (]
[;, }, break, ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return]
[., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, parent, ;, }, else, {, return]
[., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, parent, ;, }, else, {, return]
[., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, parent, ;, }, else, {, return]
[., FOR, :, if, (, NodeUtil, ., isForIn, (, parent, ), ), {, return, parent, ;, }, else, {, return]
[}, else, {, return, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, case]
[}, else, {, return, parent, ., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, case]
[., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, case, Token, ., WHILE, :, case]
[., getFirstChild, (, ), ., getNext, (, ), ., getNext, (, ), ;, }, case, Token, ., WHILE, :, case]
[getNext, (, ), ., getNext, (, ), ;, }, case, Token, ., WHILE, :, case, Token, ., DO, :, return]
[., getNext, (, ), ;, }, case, Token, ., WHILE, :, case, Token, ., DO, :, return, parent, ;, case]
[., getNext, (, ), ;, }, case, Token, ., WHILE, :, case, Token, ., DO, :, return, parent, ;, case]
[case, Token, ., WHILE, :, case, Token, ., DO, :, return, parent, ;, case, Token, ., TRY, :, if, (]
[case, Token, ., WHILE, :, case, Token, ., DO, :, return, parent, ;, case, Token, ., TRY, :, if, (]
[case, Token, ., WHILE, :, case, Token, ., DO, :, return, parent, ;, case, Token, ., TRY, :, if, (]
[Token, ., DO, :, return, parent, ;, case, Token, ., TRY, :, if, (, parent, ., getFirstChild, (, ), ==]
[parent, ;, case, Token, ., TRY, :, if, (, parent, ., getFirstChild, (, ), ==, node, ), {, if, (]
[parent, ;, case, Token, ., TRY, :, if, (, parent, ., getFirstChild, (, ), ==, node, ), {, if, (]
[., TRY, :, if, (, parent, ., getFirstChild, (, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (]
[parent, ., getFirstChild, (, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return]
[getFirstChild, (, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (]
[getFirstChild, (, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (]
[hasFinally, (, parent, ), ), {, return, computeFallThrough, (, parent, ., getLastChild, (, ), ), ;, }, else, {, return]
[parent, ), ), {, return, computeFallThrough, (, parent, ., getLastChild, (, ), ), ;, }, else, {, return, computeFollowNode, (]
[), {, return, computeFallThrough, (, parent, ., getLastChild, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,]
[return, computeFallThrough, (, parent, ., getLastChild, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,]
[), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (]
[), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (]
[), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (]
[{, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (, NodeUtil, ., getCatchBlock, (]
[(, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (, NodeUtil, ., getCatchBlock, (, parent, ), ==]
[cfa, ), ;, }, }, else, if, (, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, ), {, if, (]
[cfa, ), ;, }, }, else, if, (, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, ), {, if, (]
[}, else, if, (, NodeUtil, ., getCatchBlock, (, parent, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (]
[., getCatchBlock, (, parent, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return]
[(, parent, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (]
[(, parent, ), ==, node, ), {, if, (, NodeUtil, ., hasFinally, (, parent, ), ), {, return, computeFallThrough, (]
[hasFinally, (, parent, ), ), {, return, computeFallThrough, (, node, ., getNext, (, ), ), ;, }, else, {, return]
[parent, ), ), {, return, computeFallThrough, (, node, ., getNext, (, ), ), ;, }, else, {, return, computeFollowNode, (]
[), {, return, computeFallThrough, (, node, ., getNext, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,]
[return, computeFallThrough, (, node, ., getNext, (, ), ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,]
[), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (]
[), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (]
[), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (]
[computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, else, if, (, parent, ., getLastChild, (, ), ==]
[,, cfa, ), ;, }, }, else, if, (, parent, ., getLastChild, (, ), ==, node, ), {, if, (]
[,, cfa, ), ;, }, }, else, if, (, parent, ., getLastChild, (, ), ==, node, ), {, if, (]
[), ;, }, }, else, if, (, parent, ., getLastChild, (, ), ==, node, ), {, if, (, cfa, !=]
[., getLastChild, (, ), ==, node, ), {, if, (, cfa, !=, null, ), {, for, (, Node, finallyNode, :]
[., getLastChild, (, ), ==, node, ), {, if, (, cfa, !=, null, ), {, for, (, Node, finallyNode, :]
[., getLastChild, (, ), ==, node, ), {, if, (, cfa, !=, null, ), {, for, (, Node, finallyNode, :]
[), {, if, (, cfa, !=, null, ), {, for, (, Node, finallyNode, :, cfa, ., finallyMap, ., get, (]
[cfa, !=, null, ), {, for, (, Node, finallyNode, :, cfa, ., finallyMap, ., get, (, parent, ), ), {]
[cfa, !=, null, ), {, for, (, Node, finallyNode, :, cfa, ., finallyMap, ., get, (, parent, ), ), {]
[{, for, (, Node, finallyNode, :, cfa, ., finallyMap, ., get, (, parent, ), ), {, cfa, ., createEdge, (]
[(, Node, finallyNode, :, cfa, ., finallyMap, ., get, (, parent, ), ), {, cfa, ., createEdge, (, fromNode, ,]
[(, Node, finallyNode, :, cfa, ., finallyMap, ., get, (, parent, ), ), {, cfa, ., createEdge, (, fromNode, ,]
[cfa, ., finallyMap, ., get, (, parent, ), ), {, cfa, ., createEdge, (, fromNode, ,, Branch, ., ON_EX, ,]
[parent, ), ), {, cfa, ., createEdge, (, fromNode, ,, Branch, ., ON_EX, ,, finallyNode, ), ;, }, }, return]
[), {, cfa, ., createEdge, (, fromNode, ,, Branch, ., ON_EX, ,, finallyNode, ), ;, }, }, return, computeFollowNode, (]
[cfa, ., createEdge, (, fromNode, ,, Branch, ., ON_EX, ,, finallyNode, ), ;, }, }, return, computeFollowNode, (, fromNode, ,]
[createEdge, (, fromNode, ,, Branch, ., ON_EX, ,, finallyNode, ), ;, }, }, return, computeFollowNode, (, fromNode, ,, parent, ,]
[finallyNode, ), ;, }, }, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, Node, nextSibling, =]
[finallyNode, ), ;, }, }, return, computeFollowNode, (, fromNode, ,, parent, ,, cfa, ), ;, }, }, Node, nextSibling, =]
[fromNode, ,, parent, ,, cfa, ), ;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (]
[fromNode, ,, parent, ,, cfa, ), ;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (]
[fromNode, ,, parent, ,, cfa, ), ;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (]
[parent, ,, cfa, ), ;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (, nextSibling, !=]
[cfa, ), ;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (, nextSibling, !=, null, &&]
[cfa, ), ;, }, }, Node, nextSibling, =, node, ., getNext, (, ), ;, while, (, nextSibling, !=, null, &&]
[=, node, ., getNext, (, ), ;, while, (, nextSibling, !=, null, &&, nextSibling, ., isFunction, (, ), ), {]
[., getNext, (, ), ;, while, (, nextSibling, !=, null, &&, nextSibling, ., isFunction, (, ), ), {, nextSibling, =]
[., getNext, (, ), ;, while, (, nextSibling, !=, null, &&, nextSibling, ., isFunction, (, ), ), {, nextSibling, =]
[null, &&, nextSibling, ., isFunction, (, ), ), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (]
[null, &&, nextSibling, ., isFunction, (, ), ), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (]
[nextSibling, ., isFunction, (, ), ), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (, nextSibling, !=]
[), ), {, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (, nextSibling, !=, null, ), {, return]
[{, nextSibling, =, nextSibling, ., getNext, (, ), ;, }, if, (, nextSibling, !=, null, ), {, return, computeFallThrough, (]
[), ;, }, if, (, nextSibling, !=, null, ), {, return, computeFallThrough, (, nextSibling, ), ;, }, else, {, return]
[}, if, (, nextSibling, !=, null, ), {, return, computeFallThrough, (, nextSibling, ), ;, }, else, {, return, computeFollowNode, (]
[(, nextSibling, !=, null, ), {, return, computeFallThrough, (, nextSibling, ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,]
[!=, null, ), {, return, computeFallThrough, (, nextSibling, ), ;, }, else, {, return, computeFollowNode, (, fromNode, ,, parent, ,]
[(, fromNode, ,, parent, ,, cfa, ), ;, }, }, static, Node, computeFallThrough, (, Node, n, ), {, switch, (]
[(, fromNode, ,, parent, ,, cfa, ), ;, }, }, static, Node, computeFallThrough, (, Node, n, ), {, switch, (]
[}, }, static, Node, computeFallThrough, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, }, static, Node, computeFallThrough, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., DO, :, return]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., DO, :, return, computeFallThrough, (]
[n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., DO, :, return, computeFallThrough, (]
[(, ), ), {, case, Token, ., DO, :, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case]
[(, ), ), {, case, Token, ., DO, :, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case]
[., DO, :, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., FOR, :, if, (]
[., DO, :, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., FOR, :, if, (]
[computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (]
[(, ), ), ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return]
[(, ), ), ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return]
[(, ), ), ;, case, Token, ., FOR, :, if, (, NodeUtil, ., isForIn, (, n, ), ), {, return]
[., isForIn, (, n, ), ), {, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, return]
[(, n, ), ), {, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, return, computeFallThrough, (]
[(, n, ), ), {, return, n, ., getFirstChild, (, ), ., getNext, (, ), ;, }, return, computeFallThrough, (]
[getFirstChild, (, ), ., getNext, (, ), ;, }, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case]
[getFirstChild, (, ), ., getNext, (, ), ;, }, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case]
[(, ), ;, }, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., LABEL, :, return]
[;, }, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., LABEL, :, return, computeFallThrough, (]
[;, }, return, computeFallThrough, (, n, ., getFirstChild, (, ), ), ;, case, Token, ., LABEL, :, return, computeFallThrough, (]
[), ;, case, Token, ., LABEL, :, return, computeFallThrough, (, n, ., getLastChild, (, ), ), ;, default, :, return]
[n, ;, }, }, private, void, createEdge, (, Node, fromNode, ,, ControlFlowGraph, ., Branch, branch, ,, Node, toNode, ), {]
[n, ;, }, }, private, void, createEdge, (, Node, fromNode, ,, ControlFlowGraph, ., Branch, branch, ,, Node, toNode, ), {]
[private, void, createEdge, (, Node, fromNode, ,, ControlFlowGraph, ., Branch, branch, ,, Node, toNode, ), {, cfg, ., createNode, (]
[(, Node, fromNode, ,, ControlFlowGraph, ., Branch, branch, ,, Node, toNode, ), {, cfg, ., createNode, (, fromNode, ), ;]
[(, Node, fromNode, ,, ControlFlowGraph, ., Branch, branch, ,, Node, toNode, ), {, cfg, ., createNode, (, fromNode, ), ;]
[ControlFlowGraph, ., Branch, branch, ,, Node, toNode, ), {, cfg, ., createNode, (, fromNode, ), ;, cfg, ., createNode, (]
[branch, ,, Node, toNode, ), {, cfg, ., createNode, (, fromNode, ), ;, cfg, ., createNode, (, toNode, ), ;]
[branch, ,, Node, toNode, ), {, cfg, ., createNode, (, fromNode, ), ;, cfg, ., createNode, (, toNode, ), ;]
[), {, cfg, ., createNode, (, fromNode, ), ;, cfg, ., createNode, (, toNode, ), ;, cfg, ., connectIfNotFound, (]
[cfg, ., createNode, (, fromNode, ), ;, cfg, ., createNode, (, toNode, ), ;, cfg, ., connectIfNotFound, (, fromNode, ,]
[createNode, (, fromNode, ), ;, cfg, ., createNode, (, toNode, ), ;, cfg, ., connectIfNotFound, (, fromNode, ,, branch, ,]
[,, branch, ,, toNode, ), ;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (]
[,, branch, ,, toNode, ), ;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (]
[,, toNode, ), ;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (, mayThrowException, (]
[;, }, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (, mayThrowException, (, target, ), &&]
[}, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (, mayThrowException, (, target, ), &&, !]
[}, private, void, connectToPossibleExceptionHandler, (, Node, cfgNode, ,, Node, target, ), {, if, (, mayThrowException, (, target, ), &&, !]
[), {, if, (, mayThrowException, (, target, ), &&, !, exceptionHandler, ., isEmpty, (, ), ), {, Node, lastJump, =]
[), &&, !, exceptionHandler, ., isEmpty, (, ), ), {, Node, lastJump, =, cfgNode, ;, for, (, Node, handler, :]
[isEmpty, (, ), ), {, Node, lastJump, =, cfgNode, ;, for, (, Node, handler, :, exceptionHandler, ), {, if, (]
[isEmpty, (, ), ), {, Node, lastJump, =, cfgNode, ;, for, (, Node, handler, :, exceptionHandler, ), {, if, (]
[for, (, Node, handler, :, exceptionHandler, ), {, if, (, handler, ., isFunction, (, ), ), {, return, ;, }]
[for, (, Node, handler, :, exceptionHandler, ), {, if, (, handler, ., isFunction, (, ), ), {, return, ;, }]
[:, exceptionHandler, ), {, if, (, handler, ., isFunction, (, ), ), {, return, ;, }, Preconditions, ., checkState, (]
[:, exceptionHandler, ), {, if, (, handler, ., isFunction, (, ), ), {, return, ;, }, Preconditions, ., checkState, (]
[), ), {, return, ;, }, Preconditions, ., checkState, (, handler, ., isTry, (, ), ), ;, Node, catchBlock, =]
[), ), {, return, ;, }, Preconditions, ., checkState, (, handler, ., isTry, (, ), ), ;, Node, catchBlock, =]
[;, }, Preconditions, ., checkState, (, handler, ., isTry, (, ), ), ;, Node, catchBlock, =, NodeUtil, ., getCatchBlock, (]
[(, handler, ., isTry, (, ), ), ;, Node, catchBlock, =, NodeUtil, ., getCatchBlock, (, handler, ), ;, if, (]
[handler, ., isTry, (, ), ), ;, Node, catchBlock, =, NodeUtil, ., getCatchBlock, (, handler, ), ;, if, (, !]
[handler, ., isTry, (, ), ), ;, Node, catchBlock, =, NodeUtil, ., getCatchBlock, (, handler, ), ;, if, (, !]
[), ), ;, Node, catchBlock, =, NodeUtil, ., getCatchBlock, (, handler, ), ;, if, (, !, NodeUtil, ., hasCatchHandler, (]
[NodeUtil, ., getCatchBlock, (, handler, ), ;, if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (]
[NodeUtil, ., getCatchBlock, (, handler, ), ;, if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (]
[getCatchBlock, (, handler, ), ;, if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (, lastJump, ==]
[), ;, if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (, lastJump, ==, cfgNode, ), {]
[if, (, !, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (]
[!, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,]
[!, NodeUtil, ., hasCatchHandler, (, catchBlock, ), ), {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,]
[(, catchBlock, ), ), {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,]
[(, catchBlock, ), ), {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,]
[), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }, else, {]
[), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }, else, {]
[cfgNode, ,, Branch, ., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (]
[Branch, ., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[Branch, ., ON_EX, ,, handler, ., getLastChild, (, ), ), ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[{, finallyMap, ., put, (, lastJump, ,, handler, ., getLastChild, (, ), ), ;, }, }, else, {, if, (]
[{, finallyMap, ., put, (, lastJump, ,, handler, ., getLastChild, (, ), ), ;, }, }, else, {, if, (]
[., put, (, lastJump, ,, handler, ., getLastChild, (, ), ), ;, }, }, else, {, if, (, lastJump, ==]
[lastJump, ,, handler, ., getLastChild, (, ), ), ;, }, }, else, {, if, (, lastJump, ==, cfgNode, ), {]
[handler, ., getLastChild, (, ), ), ;, }, }, else, {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (]
[getLastChild, (, ), ), ;, }, }, else, {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,]
[getLastChild, (, ), ), ;, }, }, else, {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,]
[;, }, }, else, {, if, (, lastJump, ==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,]
[==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, catchBlock, ), ;, return, ;, }, else, {]
[==, cfgNode, ), {, createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, catchBlock, ), ;, return, ;, }, else, {]
[createEdge, (, cfgNode, ,, Branch, ., ON_EX, ,, catchBlock, ), ;, return, ;, }, else, {, finallyMap, ., put, (]
[cfgNode, ,, Branch, ., ON_EX, ,, catchBlock, ), ;, return, ;, }, else, {, finallyMap, ., put, (, lastJump, ,]
[,, catchBlock, ), ;, return, ;, }, else, {, finallyMap, ., put, (, lastJump, ,, catchBlock, ), ;, }, }]
[), ;, return, ;, }, else, {, finallyMap, ., put, (, lastJump, ,, catchBlock, ), ;, }, }, lastJump, =]
[}, }, private, static, Node, getNextSiblingOfType, (, Node, first, ,, int, ..., types, ), {, for, (, Node, c, =]
[private, static, Node, getNextSiblingOfType, (, Node, first, ,, int, ..., types, ), {, for, (, Node, c, =, first, ;]
[private, static, Node, getNextSiblingOfType, (, Node, first, ,, int, ..., types, ), {, for, (, Node, c, =, first, ;]
[Node, getNextSiblingOfType, (, Node, first, ,, int, ..., types, ), {, for, (, Node, c, =, first, ;, c, !=]
[(, Node, first, ,, int, ..., types, ), {, for, (, Node, c, =, first, ;, c, !=, null, ;]
[first, ,, int, ..., types, ), {, for, (, Node, c, =, first, ;, c, !=, null, ;, c, =]
[first, ,, int, ..., types, ), {, for, (, Node, c, =, first, ;, c, !=, null, ;, c, =]
[first, ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, for, (, int, type, :]
[;, c, =, c, ., getNext, (, ), ), {, for, (, int, type, :, types, ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, for, (, int, type, :, types, ), {, if, (]
[;, c, =, c, ., getNext, (, ), ), {, for, (, int, type, :, types, ), {, if, (]
[(, ), ), {, for, (, int, type, :, types, ), {, if, (, c, ., getType, (, ), ==]
[for, (, int, type, :, types, ), {, if, (, c, ., getType, (, ), ==, type, ), {, return]
[), {, if, (, c, ., getType, (, ), ==, type, ), {, return, c, ;, }, }, }, return]
[}, }, }, return, null, ;, }, public, static, boolean, isBreakTarget, (, Node, target, ,, String, label, ), {, return]
[}, }, }, return, null, ;, }, public, static, boolean, isBreakTarget, (, Node, target, ,, String, label, ), {, return]
[}, return, null, ;, }, public, static, boolean, isBreakTarget, (, Node, target, ,, String, label, ), {, return, isBreakStructure, (]
[null, ;, }, public, static, boolean, isBreakTarget, (, Node, target, ,, String, label, ), {, return, isBreakStructure, (, target, ,]
[null, ;, }, public, static, boolean, isBreakTarget, (, Node, target, ,, String, label, ), {, return, isBreakStructure, (, target, ,]
[}, public, static, boolean, isBreakTarget, (, Node, target, ,, String, label, ), {, return, isBreakStructure, (, target, ,, label, !=]
[boolean, isBreakTarget, (, Node, target, ,, String, label, ), {, return, isBreakStructure, (, target, ,, label, !=, null, ), &&]
[(, Node, target, ,, String, label, ), {, return, isBreakStructure, (, target, ,, label, !=, null, ), &&, matchLabel, (]
[(, Node, target, ,, String, label, ), {, return, isBreakStructure, (, target, ,, label, !=, null, ), &&, matchLabel, (]
[), {, return, isBreakStructure, (, target, ,, label, !=, null, ), &&, matchLabel, (, target, ., getParent, (, ), ,]
[label, ), ;, }, private, static, boolean, isContinueTarget, (, Node, target, ,, Node, parent, ,, String, label, ), {, return]
[label, ), ;, }, private, static, boolean, isContinueTarget, (, Node, target, ,, Node, parent, ,, String, label, ), {, return]
[;, }, private, static, boolean, isContinueTarget, (, Node, target, ,, Node, parent, ,, String, label, ), {, return, isContinueStructure, (]
[static, boolean, isContinueTarget, (, Node, target, ,, Node, parent, ,, String, label, ), {, return, isContinueStructure, (, target, ), &&]
[isContinueTarget, (, Node, target, ,, Node, parent, ,, String, label, ), {, return, isContinueStructure, (, target, ), &&, matchLabel, (]
[Node, target, ,, Node, parent, ,, String, label, ), {, return, isContinueStructure, (, target, ), &&, matchLabel, (, parent, ,]
[parent, ,, label, ), ;, }, private, static, boolean, matchLabel, (, Node, target, ,, String, label, ), {, if, (]
[parent, ,, label, ), ;, }, private, static, boolean, matchLabel, (, Node, target, ,, String, label, ), {, if, (]
[label, ), ;, }, private, static, boolean, matchLabel, (, Node, target, ,, String, label, ), {, if, (, label, ==]
[private, static, boolean, matchLabel, (, Node, target, ,, String, label, ), {, if, (, label, ==, null, ), {, return]
[Node, target, ,, String, label, ), {, if, (, label, ==, null, ), {, return, true, ;, }, while, (]
[Node, target, ,, String, label, ), {, if, (, label, ==, null, ), {, return, true, ;, }, while, (]
[label, ==, null, ), {, return, true, ;, }, while, (, target, ., isLabel, (, ), ), {, if, (]
[label, ==, null, ), {, return, true, ;, }, while, (, target, ., isLabel, (, ), ), {, if, (]
[label, ==, null, ), {, return, true, ;, }, while, (, target, ., isLabel, (, ), ), {, if, (]
[label, ==, null, ), {, return, true, ;, }, while, (, target, ., isLabel, (, ), ), {, if, (]
[., isLabel, (, ), ), {, if, (, target, ., getFirstChild, (, ), ., getString, (, ), ., equals, (]
[{, if, (, target, ., getFirstChild, (, ), ., getString, (, ), ., equals, (, label, ), ), {, return]
[target, ., getFirstChild, (, ), ., getString, (, ), ., equals, (, label, ), ), {, return, true, ;, }]
[getFirstChild, (, ), ., getString, (, ), ., equals, (, label, ), ), {, return, true, ;, }, target, =]
[getFirstChild, (, ), ., getString, (, ), ., equals, (, label, ), ), {, return, true, ;, }, target, =]
[equals, (, label, ), ), {, return, true, ;, }, target, =, target, ., getParent, (, ), ;, }, return]
[getParent, (, ), ;, }, return, false, ;, }, public, static, boolean, mayThrowException, (, Node, n, ), {, switch, (]
[getParent, (, ), ;, }, return, false, ;, }, public, static, boolean, mayThrowException, (, Node, n, ), {, switch, (]
[}, public, static, boolean, mayThrowException, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, public, static, boolean, mayThrowException, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, case, Token, ., GETPROP, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., CALL, :, case, Token, ., GETPROP, :, case]
[(, ), ), {, case, Token, ., CALL, :, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, case]
[(, ), ), {, case, Token, ., CALL, :, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, case]
[Token, ., CALL, :, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, case, Token, ., THROW, :, case]
[Token, ., CALL, :, case, Token, ., GETPROP, :, case, Token, ., GETELEM, :, case, Token, ., THROW, :, case]
[Token, ., GETPROP, :, case, Token, ., GETELEM, :, case, Token, ., THROW, :, case, Token, ., NEW, :, case]
[Token, ., GETPROP, :, case, Token, ., GETELEM, :, case, Token, ., THROW, :, case, Token, ., NEW, :, case]
[Token, ., GETELEM, :, case, Token, ., THROW, :, case, Token, ., NEW, :, case, Token, ., ASSIGN, :, case]
[Token, ., GETELEM, :, case, Token, ., THROW, :, case, Token, ., NEW, :, case, Token, ., ASSIGN, :, case]
[Token, ., THROW, :, case, Token, ., NEW, :, case, Token, ., ASSIGN, :, case, Token, ., INC, :, case]
[Token, ., THROW, :, case, Token, ., NEW, :, case, Token, ., ASSIGN, :, case, Token, ., INC, :, case]
[Token, ., NEW, :, case, Token, ., ASSIGN, :, case, Token, ., INC, :, case, Token, ., DEC, :, case]
[Token, ., NEW, :, case, Token, ., ASSIGN, :, case, Token, ., INC, :, case, Token, ., DEC, :, case]
[Token, ., ASSIGN, :, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., INSTANCEOF, :, return]
[:, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., INSTANCEOF, :, return, true, ;, case]
[:, case, Token, ., INC, :, case, Token, ., DEC, :, case, Token, ., INSTANCEOF, :, return, true, ;, case]
[:, case, Token, ., DEC, :, case, Token, ., INSTANCEOF, :, return, true, ;, case, Token, ., FUNCTION, :, return]
[., INSTANCEOF, :, return, true, ;, case, Token, ., FUNCTION, :, return, false, ;, }, for, (, Node, c, =]
[., INSTANCEOF, :, return, true, ;, case, Token, ., FUNCTION, :, return, false, ;, }, for, (, Node, c, =]
[case, Token, ., FUNCTION, :, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[case, Token, ., FUNCTION, :, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;]
[., FUNCTION, :, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=]
[:, return, false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;]
[false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[false, ;, }, for, (, Node, c, =, n, ., getFirstChild, (, ), ;, c, !=, null, ;, c, =]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[., getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (]
[getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !]
[getFirstChild, (, ), ;, c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !]
[c, !=, null, ;, c, =, c, ., getNext, (, ), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (]
[;, c, =, c, ., getNext, (, ), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), &&]
[=, c, ., getNext, (, ), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), &&, mayThrowException, (]
[), ), {, if, (, !, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), &&, mayThrowException, (, c, ), ), {, return]
[!, ControlFlowGraph, ., isEnteringNewCfgNode, (, c, ), &&, mayThrowException, (, c, ), ), {, return, true, ;, }, }, return]
[;, }, }, return, false, ;, }, static, boolean, isBreakStructure, (, Node, n, ,, boolean, labeled, ), {, switch, (]
[;, }, }, return, false, ;, }, static, boolean, isBreakStructure, (, Node, n, ,, boolean, labeled, ), {, switch, (]
[boolean, isBreakStructure, (, Node, n, ,, boolean, labeled, ), {, switch, (, n, ., getType, (, ), ), {, case]
[boolean, isBreakStructure, (, Node, n, ,, boolean, labeled, ), {, switch, (, n, ., getType, (, ), ), {, case]
[,, boolean, labeled, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[,, boolean, labeled, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case]
[(, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case]
[(, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case]
[Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., SWITCH, :, return]
[:, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., SWITCH, :, return, true, ;, case]
[:, case, Token, ., DO, :, case, Token, ., WHILE, :, case, Token, ., SWITCH, :, return, true, ;, case]
[:, case, Token, ., WHILE, :, case, Token, ., SWITCH, :, return, true, ;, case, Token, ., BLOCK, :, case]
[:, case, Token, ., WHILE, :, case, Token, ., SWITCH, :, return, true, ;, case, Token, ., BLOCK, :, case]
[:, case, Token, ., SWITCH, :, return, true, ;, case, Token, ., BLOCK, :, case, Token, ., IF, :, case]
[:, case, Token, ., SWITCH, :, return, true, ;, case, Token, ., BLOCK, :, case, Token, ., IF, :, case]
[:, return, true, ;, case, Token, ., BLOCK, :, case, Token, ., IF, :, case, Token, ., TRY, :, return]
[Token, ., BLOCK, :, case, Token, ., IF, :, case, Token, ., TRY, :, return, labeled, ;, default, :, return]
[return, labeled, ;, default, :, return, false, ;, }, }, static, boolean, isContinueStructure, (, Node, n, ), {, switch, (]
[return, labeled, ;, default, :, return, false, ;, }, }, static, boolean, isContinueStructure, (, Node, n, ), {, switch, (]
[}, }, static, boolean, isContinueStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[}, }, static, boolean, isContinueStructure, (, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[(, Node, n, ), {, switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case]
[switch, (, n, ., getType, (, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case]
[(, ), ), {, case, Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, return]
[Token, ., FOR, :, case, Token, ., DO, :, case, Token, ., WHILE, :, return, true, ;, default, :, return]
[default, :, return, false, ;, }, }, static, Node, getExceptionHandler, (, Node, n, ), {, for, (, Node, cur, =]
[return, false, ;, }, }, static, Node, getExceptionHandler, (, Node, n, ), {, for, (, Node, cur, =, n, ;]
[return, false, ;, }, }, static, Node, getExceptionHandler, (, Node, n, ), {, for, (, Node, cur, =, n, ;]
[false, ;, }, }, static, Node, getExceptionHandler, (, Node, n, ), {, for, (, Node, cur, =, n, ;, !]
[false, ;, }, }, static, Node, getExceptionHandler, (, Node, n, ), {, for, (, Node, cur, =, n, ;, !]
[getExceptionHandler, (, Node, n, ), {, for, (, Node, cur, =, n, ;, !, cur, ., isScript, (, ), &&]
[(, Node, n, ), {, for, (, Node, cur, =, n, ;, !, cur, ., isScript, (, ), &&, !]
[(, Node, n, ), {, for, (, Node, cur, =, n, ;, !, cur, ., isScript, (, ), &&, !]
[(, Node, cur, =, n, ;, !, cur, ., isScript, (, ), &&, !, cur, ., isFunction, (, ), ;]
[cur, =, n, ;, !, cur, ., isScript, (, ), &&, !, cur, ., isFunction, (, ), ;, cur, =]
[cur, =, n, ;, !, cur, ., isScript, (, ), &&, !, cur, ., isFunction, (, ), ;, cur, =]
[&&, !, cur, ., isFunction, (, ), ;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =]
[cur, ., isFunction, (, ), ;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (]
[;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (]
[;, cur, =, cur, ., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (]
[=, cur, ., getParent, (, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (, catchNode, !=]
[(, ), ), {, Node, catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (, catchNode, !=, null, ), {, return]
[catchNode, =, getCatchHandlerForBlock, (, cur, ), ;, if, (, catchNode, !=, null, ), {, return, catchNode, ;, }, }, return]
[{, return, catchNode, ;, }, }, return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if, (]
[{, return, catchNode, ;, }, }, return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if, (]
[{, return, catchNode, ;, }, }, return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if, (]
[{, return, catchNode, ;, }, }, return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if, (]
[return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if, (, block, ., isBlock, (, ), &&]
[return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if, (, block, ., isBlock, (, ), &&]
[return, null, ;, }, static, Node, getCatchHandlerForBlock, (, Node, block, ), {, if, (, block, ., isBlock, (, ), &&]
[), {, if, (, block, ., isBlock, (, ), &&, block, ., getParent, (, ), ., isTry, (, ), &&]
[), {, if, (, block, ., isBlock, (, ), &&, block, ., getParent, (, ), ., isTry, (, ), &&]
[), {, if, (, block, ., isBlock, (, ), &&, block, ., getParent, (, ), ., isTry, (, ), &&]
[), {, if, (, block, ., isBlock, (, ), &&, block, ., getParent, (, ), ., isTry, (, ), &&]
[block, ., getParent, (, ), ., isTry, (, ), &&, block, ., getParent, (, ), ., getFirstChild, (, ), ==]
[), &&, block, ., getParent, (, ), ., getFirstChild, (, ), ==, block, ), {, for, (, Node, s, =]
[), &&, block, ., getParent, (, ), ., getFirstChild, (, ), ==, block, ), {, for, (, Node, s, =]
[), ., getFirstChild, (, ), ==, block, ), {, for, (, Node, s, =, block, ., getNext, (, ), ;]
[), ., getFirstChild, (, ), ==, block, ), {, for, (, Node, s, =, block, ., getNext, (, ), ;]
[getFirstChild, (, ), ==, block, ), {, for, (, Node, s, =, block, ., getNext, (, ), ;, s, !=]
[), ==, block, ), {, for, (, Node, s, =, block, ., getNext, (, ), ;, s, !=, null, ;]
[block, ), {, for, (, Node, s, =, block, ., getNext, (, ), ;, s, !=, null, ;, s, =]
[block, ), {, for, (, Node, s, =, block, ., getNext, (, ), ;, s, !=, null, ;, s, =]
[., getNext, (, ), ;, s, !=, null, ;, s, =, s, ., getNext, (, ), ), {, if, (]
[., getNext, (, ), ;, s, !=, null, ;, s, =, s, ., getNext, (, ), ), {, if, (]
[;, s, !=, null, ;, s, =, s, ., getNext, (, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (]
[s, =, s, ., getNext, (, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, s, ), ), {, return]
[s, =, s, ., getNext, (, ), ), {, if, (, NodeUtil, ., hasCatchHandler, (, s, ), ), {, return]
[(, NodeUtil, ., hasCatchHandler, (, s, ), ), {, return, s, ., getFirstChild, (, ), ;, }, }, }, return]
[,, Map, <, DiGraphNode, <, Node, ,, Branch, >, ,, Integer, >, priorities, ,, boolean, edgeAnnotations, ), {, super, (]
[<, DiGraphNode, <, Node, ,, Branch, >, ,, Integer, >, priorities, ,, boolean, edgeAnnotations, ), {, super, (, entry, ,]
[<, Node, ,, Branch, >, ,, Integer, >, priorities, ,, boolean, edgeAnnotations, ), {, super, (, entry, ,, true, ,]
[Branch, >, ,, Integer, >, priorities, ,, boolean, edgeAnnotations, ), {, super, (, entry, ,, true, ,, edgeAnnotations, ), ;]
[Branch, >, ,, Integer, >, priorities, ,, boolean, edgeAnnotations, ), {, super, (, entry, ,, true, ,, edgeAnnotations, ), ;]
[>, priorities, ,, boolean, edgeAnnotations, ), {, super, (, entry, ,, true, ,, edgeAnnotations, ), ;, this, ., priorities, =]
[@, Override, public, Comparator, <, DiGraphNode, <, Node, ,, Branch, >, >, getOptionalNodeComparator, (, boolean, isForward, ), {, if, (]
[<, DiGraphNode, <, Node, ,, Branch, >, >, getOptionalNodeComparator, (, boolean, isForward, ), {, if, (, isForward, ), {, return]
[compare, (, DiGraphNode, <, Node, ,, Branch, >, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return]
[compare, (, DiGraphNode, <, Node, ,, Branch, >, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return]
[DiGraphNode, <, Node, ,, Branch, >, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return, getPosition, (]
[,, Branch, >, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return, getPosition, (, n1, ), -]
[>, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return, getPosition, (, n1, ), -, getPosition, (]
[), {, return, getPosition, (, n1, ), -, getPosition, (, n2, ), ;, }, }, ;, }, else, {, return]
[compare, (, DiGraphNode, <, Node, ,, Branch, >, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return]
[compare, (, DiGraphNode, <, Node, ,, Branch, >, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return]
[DiGraphNode, <, Node, ,, Branch, >, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return, getPosition, (]
[,, Branch, >, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return, getPosition, (, n2, ), -]
[>, n1, ,, DiGraphNode, <, Node, ,, Branch, >, n2, ), {, return, getPosition, (, n2, ), -, getPosition, (]
[}, ;, }, }, private, int, getPosition, (, DiGraphNode, <, Node, ,, Branch, >, n, ), {, Integer, priority, =]
[}, ;, }, }, private, int, getPosition, (, DiGraphNode, <, Node, ,, Branch, >, n, ), {, Integer, priority, =]
[private, int, getPosition, (, DiGraphNode, <, Node, ,, Branch, >, n, ), {, Integer, priority, =, priorities, ., get, (]
[(, DiGraphNode, <, Node, ,, Branch, >, n, ), {, Integer, priority, =, priorities, ., get, (, n, ), ;]
[(, DiGraphNode, <, Node, ,, Branch, >, n, ), {, Integer, priority, =, priorities, ., get, (, n, ), ;]
[,, Branch, >, n, ), {, Integer, priority, =, priorities, ., get, (, n, ), ;, Preconditions, ., checkNotNull, (]
[), {, Integer, priority, =, priorities, ., get, (, n, ), ;, Preconditions, ., checkNotNull, (, priority, ), ;, return]
