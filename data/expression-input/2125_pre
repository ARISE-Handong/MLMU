[public, class, StandardUnionFind, <, E, >, implements, Serializable, ,, UnionFind, <, E, >, {, private, static, final, long, serialVersionUID, =]
[class, StandardUnionFind, <, E, >, implements, Serializable, ,, UnionFind, <, E, >, {, private, static, final, long, serialVersionUID, =, -]
[final, long, serialVersionUID, =, -, 1L, ;, private, final, Map, <, E, ,, Node, <, E, >, >, elmap, =]
[final, long, serialVersionUID, =, -, 1L, ;, private, final, Map, <, E, ,, Node, <, E, >, >, elmap, =]
[StandardUnionFind, (, ), {, }, public, StandardUnionFind, (, UnionFind, <, E, >, other, ), {, for, (, E, elem, :]
[StandardUnionFind, (, ), {, }, public, StandardUnionFind, (, UnionFind, <, E, >, other, ), {, for, (, E, elem, :]
[(, UnionFind, <, E, >, other, ), {, for, (, E, elem, :, other, ., elements, (, ), ), {]
[<, E, >, other, ), {, for, (, E, elem, :, other, ., elements, (, ), ), {, union, (]
[>, other, ), {, for, (, E, elem, :, other, ., elements, (, ), ), {, union, (, elem, ,]
[>, other, ), {, for, (, E, elem, :, other, ., elements, (, ), ), {, union, (, elem, ,]
[for, (, E, elem, :, other, ., elements, (, ), ), {, union, (, elem, ,, other, ., find, (]
[other, ., find, (, elem, ), ), ;, }, }, @, Override, public, void, add, (, E, e, ), {]
[find, (, elem, ), ), ;, }, }, @, Override, public, void, add, (, E, e, ), {, union, (]
[elem, ), ), ;, }, }, @, Override, public, void, add, (, E, e, ), {, union, (, e, ,]
[}, @, Override, public, E, union, (, E, a, ,, E, b, ), {, Node, <, E, >, nodeA, =]
[Override, public, E, union, (, E, a, ,, E, b, ), {, Node, <, E, >, nodeA, =, findRootOrCreateNode, (]
[b, ), {, Node, <, E, >, nodeA, =, findRootOrCreateNode, (, a, ), ;, Node, <, E, >, nodeB, =]
[{, Node, <, E, >, nodeA, =, findRootOrCreateNode, (, a, ), ;, Node, <, E, >, nodeB, =, findRootOrCreateNode, (]
[nodeA, =, findRootOrCreateNode, (, a, ), ;, Node, <, E, >, nodeB, =, findRootOrCreateNode, (, b, ), ;, if, (]
[nodeA, =, findRootOrCreateNode, (, a, ), ;, Node, <, E, >, nodeB, =, findRootOrCreateNode, (, b, ), ;, if, (]
[findRootOrCreateNode, (, a, ), ;, Node, <, E, >, nodeB, =, findRootOrCreateNode, (, b, ), ;, if, (, nodeA, ==]
[;, Node, <, E, >, nodeB, =, findRootOrCreateNode, (, b, ), ;, if, (, nodeA, ==, nodeB, ), {, return]
[;, Node, <, E, >, nodeB, =, findRootOrCreateNode, (, b, ), ;, if, (, nodeA, ==, nodeB, ), {, return]
[findRootOrCreateNode, (, b, ), ;, if, (, nodeA, ==, nodeB, ), {, return, nodeA, ., element, ;, }, if, (]
[findRootOrCreateNode, (, b, ), ;, if, (, nodeA, ==, nodeB, ), {, return, nodeA, ., element, ;, }, if, (]
[findRootOrCreateNode, (, b, ), ;, if, (, nodeA, ==, nodeB, ), {, return, nodeA, ., element, ;, }, if, (]
[;, if, (, nodeA, ==, nodeB, ), {, return, nodeA, ., element, ;, }, if, (, nodeA, ., rank, >]
[;, if, (, nodeA, ==, nodeB, ), {, return, nodeA, ., element, ;, }, if, (, nodeA, ., rank, >]
[nodeB, ), {, return, nodeA, ., element, ;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, ), {]
[nodeB, ), {, return, nodeA, ., element, ;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, ), {]
[nodeA, ., element, ;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, ), {, nodeB, ., parent, =]
[element, ;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA, ;]
[element, ;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA, ;]
[(, nodeA, ., rank, >, nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=]
[(, nodeA, ., rank, >, nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=]
[nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return]
[nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return]
[nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }]
[nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }]
[nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =]
[size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (]
[size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (]
[size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (]
[size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA, ., rank, ==]
[size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA, ., rank, ==]
[element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB, ., rank, ), {]
[element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB, ., rank, ), {]
[element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB, ., rank, ), {]
[=, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }]
[=, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }]
[(, nodeA, ., rank, ==, nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }, nodeB, ., size, +=]
[(, nodeA, ., rank, ==, nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }, nodeB, ., size, +=]
[nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }, nodeB, ., size, +=, nodeA, ., size, ;, return]
[nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }, nodeB, ., size, +=, nodeA, ., size, ;, return]
[nodeA, ., size, ;, return, nodeB, ., element, ;, }, @, Override, public, E, find, (, E, e, ), {]
[size, ;, return, nodeB, ., element, ;, }, @, Override, public, E, find, (, E, e, ), {, checkArgument, (]
[size, ;, return, nodeB, ., element, ;, }, @, Override, public, E, find, (, E, e, ), {, checkArgument, (]
[., element, ;, }, @, Override, public, E, find, (, E, e, ), {, checkArgument, (, elmap, ., containsKey, (]
[}, @, Override, public, E, find, (, E, e, ), {, checkArgument, (, elmap, ., containsKey, (, e, ), ,]
[Override, public, E, find, (, E, e, ), {, checkArgument, (, elmap, ., containsKey, (, e, ), ,, "Element does not exist: %s", ,]
[(, E, e, ), {, checkArgument, (, elmap, ., containsKey, (, e, ), ,, "Element does not exist: %s", ,, e, ), ;, return]
[(, E, e, ), {, checkArgument, (, elmap, ., containsKey, (, e, ), ,, "Element does not exist: %s", ,, e, ), ;, return]
[e, ), {, checkArgument, (, elmap, ., containsKey, (, e, ), ,, "Element does not exist: %s", ,, e, ), ;, return, findRoot, (]
[e, ), {, checkArgument, (, elmap, ., containsKey, (, e, ), ,, "Element does not exist: %s", ,, e, ), ;, return, findRoot, (]
[(, elmap, ., containsKey, (, e, ), ,, "Element does not exist: %s", ,, e, ), ;, return, findRoot, (, elmap, ., get, (]
[., element, ;, }, @, Override, public, boolean, areEquivalent, (, E, a, ,, E, b, ), {, E, aRep, =]
[;, }, @, Override, public, boolean, areEquivalent, (, E, a, ,, E, b, ), {, E, aRep, =, find, (]
[areEquivalent, (, E, a, ,, E, b, ), {, E, aRep, =, find, (, a, ), ;, E, bRep, =]
[E, a, ,, E, b, ), {, E, aRep, =, find, (, a, ), ;, E, bRep, =, find, (]
[b, ), {, E, aRep, =, find, (, a, ), ;, E, bRep, =, find, (, b, ), ;, return]
[b, ), {, E, aRep, =, find, (, a, ), ;, E, bRep, =, find, (, b, ), ;, return]
[{, E, aRep, =, find, (, a, ), ;, E, bRep, =, find, (, b, ), ;, return, aRep, ==]
[), ;, return, aRep, ==, bRep, ;, }, @, Override, public, Set, <, E, >, elements, (, ), {, return]
[), ;, return, aRep, ==, bRep, ;, }, @, Override, public, Set, <, E, >, elements, (, ), {, return]
[==, bRep, ;, }, @, Override, public, Set, <, E, >, elements, (, ), {, return, Collections, ., unmodifiableSet, (]
[==, bRep, ;, }, @, Override, public, Set, <, E, >, elements, (, ), {, return, Collections, ., unmodifiableSet, (]
[allEquivalenceClasses, (, ), {, Map, <, Node, <, E, >, ,, ImmutableSet, ., Builder, <, E, >, >, groupsTmp, =]
[allEquivalenceClasses, (, ), {, Map, <, Node, <, E, >, ,, ImmutableSet, ., Builder, <, E, >, >, groupsTmp, =]
[<, E, >, >, groupsTmp, =, Maps, ., newHashMap, (, ), ;, for, (, Node, <, E, >, elem, :]
[<, E, >, >, groupsTmp, =, Maps, ., newHashMap, (, ), ;, for, (, Node, <, E, >, elem, :]
[(, Node, <, E, >, elem, :, elmap, ., values, (, ), ), {, Node, <, E, >, root, =]
[<, E, >, elem, :, elmap, ., values, (, ), ), {, Node, <, E, >, root, =, findRoot, (]
[{, Node, <, E, >, root, =, findRoot, (, elem, ), ;, ImmutableSet, ., Builder, <, E, >, builder, =]
[{, Node, <, E, >, root, =, findRoot, (, elem, ), ;, ImmutableSet, ., Builder, <, E, >, builder, =]
[>, root, =, findRoot, (, elem, ), ;, ImmutableSet, ., Builder, <, E, >, builder, =, groupsTmp, ., get, (]
[elem, ), ;, ImmutableSet, ., Builder, <, E, >, builder, =, groupsTmp, ., get, (, root, ), ;, if, (]
[elem, ), ;, ImmutableSet, ., Builder, <, E, >, builder, =, groupsTmp, ., get, (, root, ), ;, if, (]
[;, ImmutableSet, ., Builder, <, E, >, builder, =, groupsTmp, ., get, (, root, ), ;, if, (, builder, ==]
[Builder, <, E, >, builder, =, groupsTmp, ., get, (, root, ), ;, if, (, builder, ==, null, ), {]
[E, >, builder, =, groupsTmp, ., get, (, root, ), ;, if, (, builder, ==, null, ), {, builder, =]
[E, >, builder, =, groupsTmp, ., get, (, root, ), ;, if, (, builder, ==, null, ), {, builder, =]
[get, (, root, ), ;, if, (, builder, ==, null, ), {, builder, =, ImmutableSet, ., builder, (, ), ;]
[get, (, root, ), ;, if, (, builder, ==, null, ), {, builder, =, ImmutableSet, ., builder, (, ), ;]
[;, if, (, builder, ==, null, ), {, builder, =, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (]
[(, builder, ==, null, ), {, builder, =, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (, root, ,]
[), {, builder, =, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (, root, ,, builder, ), ;, }]
[), {, builder, =, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (, root, ,, builder, ), ;, }]
[ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (, root, ,, builder, ), ;, }, builder, ., add, (]
[ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (, root, ,, builder, ), ;, }, builder, ., add, (]
[., add, (, elem, ., element, ), ;, }, ImmutableList, ., Builder, <, Set, <, E, >, >, result, =]
[., add, (, elem, ., element, ), ;, }, ImmutableList, ., Builder, <, Set, <, E, >, >, result, =]
[>, >, result, =, ImmutableList, ., builder, (, ), ;, for, (, ImmutableSet, ., Builder, <, E, >, group, :]
[>, >, result, =, ImmutableList, ., builder, (, ), ;, for, (, ImmutableSet, ., Builder, <, E, >, group, :]
[(, ), ;, for, (, ImmutableSet, ., Builder, <, E, >, group, :, groupsTmp, ., values, (, ), ), {]
[(, ), ;, for, (, ImmutableSet, ., Builder, <, E, >, group, :, groupsTmp, ., values, (, ), ), {]
[(, ImmutableSet, ., Builder, <, E, >, group, :, groupsTmp, ., values, (, ), ), {, result, ., add, (]
[(, ImmutableSet, ., Builder, <, E, >, group, :, groupsTmp, ., values, (, ), ), {, result, ., add, (]
[groupsTmp, ., values, (, ), ), {, result, ., add, (, group, ., build, (, ), ), ;, }, return]
[groupsTmp, ., values, (, ), ), {, result, ., add, (, group, ., build, (, ), ), ;, }, return]
[), ;, }, private, Node, <, E, >, findRootOrCreateNode, (, E, e, ), {, Node, <, E, >, node, =]
[), ;, }, private, Node, <, E, >, findRootOrCreateNode, (, E, e, ), {, Node, <, E, >, node, =]
[Node, <, E, >, findRootOrCreateNode, (, E, e, ), {, Node, <, E, >, node, =, elmap, ., get, (]
[(, E, e, ), {, Node, <, E, >, node, =, elmap, ., get, (, e, ), ;, if, (]
[(, E, e, ), {, Node, <, E, >, node, =, elmap, ., get, (, e, ), ;, if, (]
[e, ), {, Node, <, E, >, node, =, elmap, ., get, (, e, ), ;, if, (, node, !=]
[<, E, >, node, =, elmap, ., get, (, e, ), ;, if, (, node, !=, null, ), {, return]
[>, node, =, elmap, ., get, (, e, ), ;, if, (, node, !=, null, ), {, return, findRoot, (]
[., get, (, e, ), ;, if, (, node, !=, null, ), {, return, findRoot, (, node, ), ;, }]
[(, e, ), ;, if, (, node, !=, null, ), {, return, findRoot, (, node, ), ;, }, node, =]
[node, !=, null, ), {, return, findRoot, (, node, ), ;, }, node, =, new, Node, <, E, >, (]
[), {, return, findRoot, (, node, ), ;, }, node, =, new, Node, <, E, >, (, e, ), ;]
[), {, return, findRoot, (, node, ), ;, }, node, =, new, Node, <, E, >, (, e, ), ;]
[(, node, ), ;, }, node, =, new, Node, <, E, >, (, e, ), ;, elmap, ., put, (]
[), ;, }, node, =, new, Node, <, E, >, (, e, ), ;, elmap, ., put, (, e, ,]
[=, new, Node, <, E, >, (, e, ), ;, elmap, ., put, (, e, ,, node, ), ;, return]
[return, node, ;, }, private, Node, <, E, >, findRoot, (, Node, <, E, >, node, ), {, if, (]
[return, node, ;, }, private, Node, <, E, >, findRoot, (, Node, <, E, >, node, ), {, if, (]
[return, node, ;, }, private, Node, <, E, >, findRoot, (, Node, <, E, >, node, ), {, if, (]
[private, Node, <, E, >, findRoot, (, Node, <, E, >, node, ), {, if, (, node, ., parent, !=]
[E, >, findRoot, (, Node, <, E, >, node, ), {, if, (, node, ., parent, !=, node, ), {]
[E, >, findRoot, (, Node, <, E, >, node, ), {, if, (, node, ., parent, !=, node, ), {]
[Node, <, E, >, node, ), {, if, (, node, ., parent, !=, node, ), {, node, ., parent, =]
[E, >, node, ), {, if, (, node, ., parent, !=, node, ), {, node, ., parent, =, findRoot, (]
[E, >, node, ), {, if, (, node, ., parent, !=, node, ), {, node, ., parent, =, findRoot, (]
[node, ., parent, !=, node, ), {, node, ., parent, =, findRoot, (, node, ., parent, ), ;, }, return]
[node, ., parent, !=, node, ), {, node, ., parent, =, findRoot, (, node, ., parent, ), ;, }, return]
[return, node, ., parent, ;, }, @, Override, public, Set, <, E, >, findAll, (, final, E, value, ), {]
[., parent, ;, }, @, Override, public, Set, <, E, >, findAll, (, final, E, value, ), {, checkArgument, (]
[., parent, ;, }, @, Override, public, Set, <, E, >, findAll, (, final, E, value, ), {, checkArgument, (]
[@, Override, public, Set, <, E, >, findAll, (, final, E, value, ), {, checkArgument, (, elmap, ., containsKey, (]
[Set, <, E, >, findAll, (, final, E, value, ), {, checkArgument, (, elmap, ., containsKey, (, value, ), ,]
[Set, <, E, >, findAll, (, final, E, value, ), {, checkArgument, (, elmap, ., containsKey, (, value, ), ,]
[E, >, findAll, (, final, E, value, ), {, checkArgument, (, elmap, ., containsKey, (, value, ), ,, "Element does not exist: ", +]
[(, elmap, ., containsKey, (, value, ), ,, "Element does not exist: ", +, value, ), ;, final, Predicate, <, Object, >, isSameRoot, =]
[Predicate, <, Object, >, isSameRoot, =, new, Predicate, <, Object, >, (, ), {, Node, <, E, >, nodeForValue, =]
[Predicate, <, Object, >, isSameRoot, =, new, Predicate, <, Object, >, (, ), {, Node, <, E, >, nodeForValue, =]
[isSameRoot, =, new, Predicate, <, Object, >, (, ), {, Node, <, E, >, nodeForValue, =, elmap, ., get, (]
[., get, (, value, ), ;, @, Override, public, boolean, apply, (, @, Nullable, Object, b, ), {, if, (]
[., get, (, value, ), ;, @, Override, public, boolean, apply, (, @, Nullable, Object, b, ), {, if, (]
[), ;, @, Override, public, boolean, apply, (, @, Nullable, Object, b, ), {, if, (, Objects, ., equal, (]
[@, Override, public, boolean, apply, (, @, Nullable, Object, b, ), {, if, (, Objects, ., equal, (, value, ,]
[(, @, Nullable, Object, b, ), {, if, (, Objects, ., equal, (, value, ,, b, ), ), {, return]
[Objects, ., equal, (, value, ,, b, ), ), {, return, true, ;, }, Node, <, E, >, nodeForB, =]
[Objects, ., equal, (, value, ,, b, ), ), {, return, true, ;, }, Node, <, E, >, nodeForB, =]
[value, ,, b, ), ), {, return, true, ;, }, Node, <, E, >, nodeForB, =, elmap, ., get, (]
[{, return, true, ;, }, Node, <, E, >, nodeForB, =, elmap, ., get, (, b, ), ;, if, (]
[{, return, true, ;, }, Node, <, E, >, nodeForB, =, elmap, ., get, (, b, ), ;, if, (]
[true, ;, }, Node, <, E, >, nodeForB, =, elmap, ., get, (, b, ), ;, if, (, nodeForB, ==]
[<, E, >, nodeForB, =, elmap, ., get, (, b, ), ;, if, (, nodeForB, ==, null, ), {, return]
[nodeForB, =, elmap, ., get, (, b, ), ;, if, (, nodeForB, ==, null, ), {, return, false, ;, }]
[elmap, ., get, (, b, ), ;, if, (, nodeForB, ==, null, ), {, return, false, ;, }, nodeForValue, =]
[get, (, b, ), ;, if, (, nodeForB, ==, null, ), {, return, false, ;, }, nodeForValue, =, findRoot, (]
[;, if, (, nodeForB, ==, null, ), {, return, false, ;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return]
[;, if, (, nodeForB, ==, null, ), {, return, false, ;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return]
[(, nodeForB, ==, null, ), {, return, false, ;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return, findRoot, (]
[null, ), {, return, false, ;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return, findRoot, (, nodeForB, ), ==]
[}, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return, findRoot, (, nodeForB, ), ==, nodeForValue, ;, }, }, ;, return]
[return, new, AbstractSet, <, E, >, (, ), {, @, Override, public, boolean, contains, (, Object, o, ), {, return]
[return, new, AbstractSet, <, E, >, (, ), {, @, Override, public, boolean, contains, (, Object, o, ), {, return]
[E, >, (, ), {, @, Override, public, boolean, contains, (, Object, o, ), {, return, isSameRoot, ., apply, (]
[isSameRoot, ., apply, (, o, ), ;, }, @, Override, public, Iterator, <, E, >, iterator, (, ), {, return]
[apply, (, o, ), ;, }, @, Override, public, Iterator, <, E, >, iterator, (, ), {, return, filter, (]
[apply, (, o, ), ;, }, @, Override, public, Iterator, <, E, >, iterator, (, ), {, return, filter, (]
[apply, (, o, ), ;, }, @, Override, public, Iterator, <, E, >, iterator, (, ), {, return, filter, (]
[<, E, >, iterator, (, ), {, return, filter, (, elmap, ., keySet, (, ), ., iterator, (, ), ,]
[(, ), ., iterator, (, ), ,, isSameRoot, ), ;, }, @, Override, public, int, size, (, ), {, return]
[(, ), ., iterator, (, ), ,, isSameRoot, ), ;, }, @, Override, public, int, size, (, ), {, return]
[., iterator, (, ), ,, isSameRoot, ), ;, }, @, Override, public, int, size, (, ), {, return, findRoot, (]
[., iterator, (, ), ,, isSameRoot, ), ;, }, @, Override, public, int, size, (, ), {, return, findRoot, (]
[,, isSameRoot, ), ;, }, @, Override, public, int, size, (, ), {, return, findRoot, (, elmap, ., get, (]
[static, class, Node, <, E, >, {, Node, <, E, >, parent, ;, final, E, element, ;, int, rank, =]
[>, {, Node, <, E, >, parent, ;, final, E, element, ;, int, rank, =, 0, ;, int, size, =]
[final, E, element, ;, int, rank, =, 0, ;, int, size, =, 1, ;, Node, (, E, element, ), {]
[final, E, element, ;, int, rank, =, 0, ;, int, size, =, 1, ;, Node, (, E, element, ), {]
[int, rank, =, 0, ;, int, size, =, 1, ;, Node, (, E, element, ), {, this, ., parent, =]
[=, 0, ;, int, size, =, 1, ;, Node, (, E, element, ), {, this, ., parent, =, this, ;]
[=, 0, ;, int, size, =, 1, ;, Node, (, E, element, ), {, this, ., parent, =, this, ;]
[size, =, 1, ;, Node, (, E, element, ), {, this, ., parent, =, this, ;, this, ., element, =]
