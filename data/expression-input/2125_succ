[;, private, final, Map, <, E, ,, Node, <, E, >, >, elmap, =, Maps, ., newLinkedHashMap, (, ), ;]
[;, private, final, Map, <, E, ,, Node, <, E, >, >, elmap, =, Maps, ., newLinkedHashMap, (, ), ;]
[;, public, StandardUnionFind, (, ), {, }, public, StandardUnionFind, (, UnionFind, <, E, >, other, ), {, for, (, E]
[., newLinkedHashMap, (, ), ;, public, StandardUnionFind, (, ), {, }, public, StandardUnionFind, (, UnionFind, <, E, >, other, )]
[), {, union, (, elem, ,, other, ., find, (, elem, ), ), ;, }, }, @, Override, public, void]
[., elements, (, ), ), {, union, (, elem, ,, other, ., find, (, elem, ), ), ;, }, }]
[;, }, }, @, Override, public, void, add, (, E, e, ), {, union, (, e, ,, e, ), ;]
[,, other, ., find, (, elem, ), ), ;, }, }, @, Override, public, void, add, (, E, e, )]
[), ;, }, }, @, Override, public, void, add, (, E, e, ), {, union, (, e, ,, e, )]
[., find, (, elem, ), ), ;, }, }, @, Override, public, void, add, (, E, e, ), {, union]
[), ), ;, }, }, @, Override, public, void, add, (, E, e, ), {, union, (, e, ,, e]
[;, }, @, Override, public, E, union, (, E, a, ,, E, b, ), {, Node, <, E, >, nodeA]
[,, e, ), ;, }, @, Override, public, E, union, (, E, a, ,, E, b, ), {, Node, <]
[), ;, }, @, Override, public, E, union, (, E, a, ,, E, b, ), {, Node, <, E, >]
[;, Node, <, E, >, nodeB, =, findRootOrCreateNode, (, b, ), ;, if, (, nodeA, ==, nodeB, ), {, return]
[), ;, Node, <, E, >, nodeB, =, findRootOrCreateNode, (, b, ), ;, if, (, nodeA, ==, nodeB, ), {]
[;, if, (, nodeA, ==, nodeB, ), {, return, nodeA, ., element, ;, }, if, (, nodeA, ., rank, >]
[), ;, if, (, nodeA, ==, nodeB, ), {, return, nodeA, ., element, ;, }, if, (, nodeA, ., rank]
[), {, return, nodeA, ., element, ;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, ), {, nodeB]
[==, nodeB, ), {, return, nodeA, ., element, ;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, )]
[), {, return, nodeA, ., element, ;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, ), {, nodeB]
[;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA, ;, nodeA]
[., element, ;, }, if, (, nodeA, ., rank, >, nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA]
[), {, nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return, nodeA, ., element]
[>, nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;]
[., rank, >, nodeB, ., rank, ), {, nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, .]
[), {, nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return, nodeA, ., element]
[., rank, ), {, nodeB, ., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return, nodeA]
[=, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent]
[., parent, =, nodeA, ;, nodeA, ., size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }, nodeA]
[;, nodeA, ., size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB]
[+=, nodeB, ., size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA]
[., size, +=, nodeB, ., size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB, ;, if]
[;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB]
[., size, ;, return, nodeA, ., element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA, ., rank]
[;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB, ., rank, ), {, nodeB]
[., element, ;, }, nodeA, ., parent, =, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB, ., rank, )]
[=, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }]
[., parent, =, nodeB, ;, if, (, nodeA, ., rank, ==, nodeB, ., rank, ), {, nodeB, ., rank, ++]
[;, if, (, nodeA, ., rank, ==, nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }, nodeB, .]
[), {, nodeB, ., rank, ++, ;, }, nodeB, ., size, +=, nodeA, ., size, ;, return, nodeB, ., element]
[==, nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }, nodeB, ., size, +=, nodeA, ., size, ;]
[., rank, ==, nodeB, ., rank, ), {, nodeB, ., rank, ++, ;, }, nodeB, ., size, +=, nodeA, .]
[), {, nodeB, ., rank, ++, ;, }, nodeB, ., size, +=, nodeA, ., size, ;, return, nodeB, ., element]
[., rank, ), {, nodeB, ., rank, ++, ;, }, nodeB, ., size, +=, nodeA, ., size, ;, return, nodeB]
[;, }, nodeB, ., size, +=, nodeA, ., size, ;, return, nodeB, ., element, ;, }, @, Override, public, E]
[++, ;, }, nodeB, ., size, +=, nodeA, ., size, ;, return, nodeB, ., element, ;, }, @, Override, public]
[., rank, ++, ;, }, nodeB, ., size, +=, nodeA, ., size, ;, return, nodeB, ., element, ;, }, @]
[+=, nodeA, ., size, ;, return, nodeB, ., element, ;, }, @, Override, public, E, find, (, E, e, )]
[., size, +=, nodeA, ., size, ;, return, nodeB, ., element, ;, }, @, Override, public, E, find, (, E]
[;, return, nodeB, ., element, ;, }, @, Override, public, E, find, (, E, e, ), {, checkArgument, (, elmap]
[., size, ;, return, nodeB, ., element, ;, }, @, Override, public, E, find, (, E, e, ), {, checkArgument]
[;, }, @, Override, public, E, find, (, E, e, ), {, checkArgument, (, elmap, ., containsKey, (, e, )]
[., element, ;, }, @, Override, public, E, find, (, E, e, ), {, checkArgument, (, elmap, ., containsKey, (]
[;, return, findRoot, (, elmap, ., get, (, e, ), ), ., element, ;, }, @, Override, public, boolean, areEquivalent]
[,, "Element does not exist: %s", ,, e, ), ;, return, findRoot, (, elmap, ., get, (, e, ), ), ., element, ;, }]
[., containsKey, (, e, ), ,, "Element does not exist: %s", ,, e, ), ;, return, findRoot, (, elmap, ., get, (, e, )]
[), ,, "Element does not exist: %s", ,, e, ), ;, return, findRoot, (, elmap, ., get, (, e, ), ), ., element, ;]
[,, e, ), ;, return, findRoot, (, elmap, ., get, (, e, ), ), ., element, ;, }, @, Override]
[), ;, return, findRoot, (, elmap, ., get, (, e, ), ), ., element, ;, }, @, Override, public, boolean]
[;, }, @, Override, public, boolean, areEquivalent, (, E, a, ,, E, b, ), {, E, aRep, =, find, (]
[., element, ;, }, @, Override, public, boolean, areEquivalent, (, E, a, ,, E, b, ), {, E, aRep, =]
[), ., element, ;, }, @, Override, public, boolean, areEquivalent, (, E, a, ,, E, b, ), {, E, aRep]
[., get, (, e, ), ), ., element, ;, }, @, Override, public, boolean, areEquivalent, (, E, a, ,, E]
[), ), ., element, ;, }, @, Override, public, boolean, areEquivalent, (, E, a, ,, E, b, ), {, E]
[;, E, bRep, =, find, (, b, ), ;, return, aRep, ==, bRep, ;, }, @, Override, public, Set, <]
[), ;, E, bRep, =, find, (, b, ), ;, return, aRep, ==, bRep, ;, }, @, Override, public, Set]
[;, return, aRep, ==, bRep, ;, }, @, Override, public, Set, <, E, >, elements, (, ), {, return, Collections]
[), ;, return, aRep, ==, bRep, ;, }, @, Override, public, Set, <, E, >, elements, (, ), {, return]
[;, }, @, Override, public, Set, <, E, >, elements, (, ), {, return, Collections, ., unmodifiableSet, (, elmap, .]
[==, bRep, ;, }, @, Override, public, Set, <, E, >, elements, (, ), {, return, Collections, ., unmodifiableSet, (]
[;, }, @, Override, public, Set, <, E, >, elements, (, ), {, return, Collections, ., unmodifiableSet, (, elmap, .]
[;, }, @, Override, public, Collection, <, Set, <, E, >, >, allEquivalenceClasses, (, ), {, Map, <, Node, <]
[., unmodifiableSet, (, elmap, ., keySet, (, ), ), ;, }, @, Override, public, Collection, <, Set, <, E, >]
[), ;, }, @, Override, public, Collection, <, Set, <, E, >, >, allEquivalenceClasses, (, ), {, Map, <, Node]
[., keySet, (, ), ), ;, }, @, Override, public, Collection, <, Set, <, E, >, >, allEquivalenceClasses, (, )]
[;, for, (, Node, <, E, >, elem, :, elmap, ., values, (, ), ), {, Node, <, E, >]
[., newHashMap, (, ), ;, for, (, Node, <, E, >, elem, :, elmap, ., values, (, ), ), {]
[), {, Node, <, E, >, root, =, findRoot, (, elem, ), ;, ImmutableSet, ., Builder, <, E, >, builder]
[., values, (, ), ), {, Node, <, E, >, root, =, findRoot, (, elem, ), ;, ImmutableSet, ., Builder]
[;, ImmutableSet, ., Builder, <, E, >, builder, =, groupsTmp, ., get, (, root, ), ;, if, (, builder, ==]
[), ;, ImmutableSet, ., Builder, <, E, >, builder, =, groupsTmp, ., get, (, root, ), ;, if, (, builder]
[;, if, (, builder, ==, null, ), {, builder, =, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (]
[., get, (, root, ), ;, if, (, builder, ==, null, ), {, builder, =, ImmutableSet, ., builder, (, )]
[), ;, if, (, builder, ==, null, ), {, builder, =, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put]
[), {, builder, =, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (, root, ,, builder, ), ;, }]
[==, null, ), {, builder, =, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (, root, ,, builder, )]
[), {, builder, =, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (, root, ,, builder, ), ;, }]
[=, ImmutableSet, ., builder, (, ), ;, groupsTmp, ., put, (, root, ,, builder, ), ;, }, builder, ., add]
[;, groupsTmp, ., put, (, root, ,, builder, ), ;, }, builder, ., add, (, elem, ., element, ), ;]
[., builder, (, ), ;, groupsTmp, ., put, (, root, ,, builder, ), ;, }, builder, ., add, (, elem]
[;, }, builder, ., add, (, elem, ., element, ), ;, }, ImmutableList, ., Builder, <, Set, <, E, >]
[., put, (, root, ,, builder, ), ;, }, builder, ., add, (, elem, ., element, ), ;, }, ImmutableList]
[,, builder, ), ;, }, builder, ., add, (, elem, ., element, ), ;, }, ImmutableList, ., Builder, <, Set]
[), ;, }, builder, ., add, (, elem, ., element, ), ;, }, ImmutableList, ., Builder, <, Set, <, E]
[;, }, ImmutableList, ., Builder, <, Set, <, E, >, >, result, =, ImmutableList, ., builder, (, ), ;, for]
[., add, (, elem, ., element, ), ;, }, ImmutableList, ., Builder, <, Set, <, E, >, >, result, =]
[), ;, }, ImmutableList, ., Builder, <, Set, <, E, >, >, result, =, ImmutableList, ., builder, (, ), ;]
[., element, ), ;, }, ImmutableList, ., Builder, <, Set, <, E, >, >, result, =, ImmutableList, ., builder, (]
[;, for, (, ImmutableSet, ., Builder, <, E, >, group, :, groupsTmp, ., values, (, ), ), {, result, .]
[., builder, (, ), ;, for, (, ImmutableSet, ., Builder, <, E, >, group, :, groupsTmp, ., values, (, )]
[), {, result, ., add, (, group, ., build, (, ), ), ;, }, return, result, ., build, (, )]
[., values, (, ), ), {, result, ., add, (, group, ., build, (, ), ), ;, }, return, result]
[;, }, return, result, ., build, (, ), ;, }, private, Node, <, E, >, findRootOrCreateNode, (, E, e, )]
[., add, (, group, ., build, (, ), ), ;, }, return, result, ., build, (, ), ;, }, private]
[), ;, }, return, result, ., build, (, ), ;, }, private, Node, <, E, >, findRootOrCreateNode, (, E, e]
[., build, (, ), ), ;, }, return, result, ., build, (, ), ;, }, private, Node, <, E, >]
[;, }, private, Node, <, E, >, findRootOrCreateNode, (, E, e, ), {, Node, <, E, >, node, =, elmap]
[., build, (, ), ;, }, private, Node, <, E, >, findRootOrCreateNode, (, E, e, ), {, Node, <, E]
[;, if, (, node, !=, null, ), {, return, findRoot, (, node, ), ;, }, node, =, new, Node, <]
[., get, (, e, ), ;, if, (, node, !=, null, ), {, return, findRoot, (, node, ), ;, }]
[), ;, if, (, node, !=, null, ), {, return, findRoot, (, node, ), ;, }, node, =, new, Node]
[), {, return, findRoot, (, node, ), ;, }, node, =, new, Node, <, E, >, (, e, ), ;]
[!=, null, ), {, return, findRoot, (, node, ), ;, }, node, =, new, Node, <, E, >, (, e]
[), {, return, findRoot, (, node, ), ;, }, node, =, new, Node, <, E, >, (, e, ), ;]
[;, }, node, =, new, Node, <, E, >, (, e, ), ;, elmap, ., put, (, e, ,, node]
[), ;, }, node, =, new, Node, <, E, >, (, e, ), ;, elmap, ., put, (, e, ,]
[=, new, Node, <, E, >, (, e, ), ;, elmap, ., put, (, e, ,, node, ), ;, return]
[;, elmap, ., put, (, e, ,, node, ), ;, return, node, ;, }, private, Node, <, E, >, findRoot]
[), ;, elmap, ., put, (, e, ,, node, ), ;, return, node, ;, }, private, Node, <, E, >]
[;, return, node, ;, }, private, Node, <, E, >, findRoot, (, Node, <, E, >, node, ), {, if]
[., put, (, e, ,, node, ), ;, return, node, ;, }, private, Node, <, E, >, findRoot, (, Node]
[,, node, ), ;, return, node, ;, }, private, Node, <, E, >, findRoot, (, Node, <, E, >, node]
[), ;, return, node, ;, }, private, Node, <, E, >, findRoot, (, Node, <, E, >, node, ), {]
[;, }, private, Node, <, E, >, findRoot, (, Node, <, E, >, node, ), {, if, (, node, .]
[), {, node, ., parent, =, findRoot, (, node, ., parent, ), ;, }, return, node, ., parent, ;, }]
[!=, node, ), {, node, ., parent, =, findRoot, (, node, ., parent, ), ;, }, return, node, ., parent]
[., parent, !=, node, ), {, node, ., parent, =, findRoot, (, node, ., parent, ), ;, }, return, node]
[), {, node, ., parent, =, findRoot, (, node, ., parent, ), ;, }, return, node, ., parent, ;, }]
[=, findRoot, (, node, ., parent, ), ;, }, return, node, ., parent, ;, }, @, Override, public, Set, <]
[., parent, =, findRoot, (, node, ., parent, ), ;, }, return, node, ., parent, ;, }, @, Override, public]
[;, }, return, node, ., parent, ;, }, @, Override, public, Set, <, E, >, findAll, (, final, E, value]
[), ;, }, return, node, ., parent, ;, }, @, Override, public, Set, <, E, >, findAll, (, final, E]
[., parent, ), ;, }, return, node, ., parent, ;, }, @, Override, public, Set, <, E, >, findAll, (]
[;, }, @, Override, public, Set, <, E, >, findAll, (, final, E, value, ), {, checkArgument, (, elmap, .]
[., parent, ;, }, @, Override, public, Set, <, E, >, findAll, (, final, E, value, ), {, checkArgument, (]
[;, final, Predicate, <, Object, >, isSameRoot, =, new, Predicate, <, Object, >, (, ), {, Node, <, E, >]
[,, "Element does not exist: ", +, value, ), ;, final, Predicate, <, Object, >, isSameRoot, =, new, Predicate, <, Object, >, (, )]
[., containsKey, (, value, ), ,, "Element does not exist: ", +, value, ), ;, final, Predicate, <, Object, >, isSameRoot, =, new, Predicate]
[), ,, "Element does not exist: ", +, value, ), ;, final, Predicate, <, Object, >, isSameRoot, =, new, Predicate, <, Object, >, (]
[), ;, final, Predicate, <, Object, >, isSameRoot, =, new, Predicate, <, Object, >, (, ), {, Node, <, E]
[+, value, ), ;, final, Predicate, <, Object, >, isSameRoot, =, new, Predicate, <, Object, >, (, ), {, Node]
[), ;, final, Predicate, <, Object, >, isSameRoot, =, new, Predicate, <, Object, >, (, ), {, Node, <, E]
[;, return, new, AbstractSet, <, E, >, (, ), {, @, Override, public, boolean, contains, (, Object, o, ), {]
[;, @, Override, public, boolean, apply, (, @, Nullable, Object, b, ), {, if, (, Objects, ., equal, (, value]
[., get, (, value, ), ;, @, Override, public, boolean, apply, (, @, Nullable, Object, b, ), {, if, (]
[), ;, @, Override, public, boolean, apply, (, @, Nullable, Object, b, ), {, if, (, Objects, ., equal, (]
[), {, return, true, ;, }, Node, <, E, >, nodeForB, =, elmap, ., get, (, b, ), ;, if]
[., equal, (, value, ,, b, ), ), {, return, true, ;, }, Node, <, E, >, nodeForB, =, elmap]
[,, b, ), ), {, return, true, ;, }, Node, <, E, >, nodeForB, =, elmap, ., get, (, b]
[), ), {, return, true, ;, }, Node, <, E, >, nodeForB, =, elmap, ., get, (, b, ), ;]
[;, }, Node, <, E, >, nodeForB, =, elmap, ., get, (, b, ), ;, if, (, nodeForB, ==, null]
[;, if, (, nodeForB, ==, null, ), {, return, false, ;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return]
[., get, (, b, ), ;, if, (, nodeForB, ==, null, ), {, return, false, ;, }, nodeForValue, =, findRoot]
[), ;, if, (, nodeForB, ==, null, ), {, return, false, ;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;]
[), {, return, false, ;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return, findRoot, (, nodeForB, ), ==, nodeForValue]
[==, null, ), {, return, false, ;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return, findRoot, (, nodeForB, )]
[), {, return, false, ;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return, findRoot, (, nodeForB, ), ==, nodeForValue]
[;, }, nodeForValue, =, findRoot, (, nodeForValue, ), ;, return, findRoot, (, nodeForB, ), ==, nodeForValue, ;, }, }, ;]
[=, findRoot, (, nodeForValue, ), ;, return, findRoot, (, nodeForB, ), ==, nodeForValue, ;, }, }, ;, return, new, AbstractSet]
[;, return, findRoot, (, nodeForB, ), ==, nodeForValue, ;, }, }, ;, return, new, AbstractSet, <, E, >, (, )]
[), ;, return, findRoot, (, nodeForB, ), ==, nodeForValue, ;, }, }, ;, return, new, AbstractSet, <, E, >, (]
[;, }, }, ;, return, new, AbstractSet, <, E, >, (, ), {, @, Override, public, boolean, contains, (, Object]
[==, nodeForValue, ;, }, }, ;, return, new, AbstractSet, <, E, >, (, ), {, @, Override, public, boolean, contains]
[), ==, nodeForValue, ;, }, }, ;, return, new, AbstractSet, <, E, >, (, ), {, @, Override, public, boolean]
[;, }, }, ;, return, new, AbstractSet, <, E, >, (, ), {, @, Override, public, boolean, contains, (, Object]
[;, }, private, static, class, Node, <, E, >, {, Node, <, E, >, parent, ;, final, E, element, ;]
[;, }, @, Override, public, Iterator, <, E, >, iterator, (, ), {, return, filter, (, elmap, ., keySet, (]
[., apply, (, o, ), ;, }, @, Override, public, Iterator, <, E, >, iterator, (, ), {, return, filter]
[), ;, }, @, Override, public, Iterator, <, E, >, iterator, (, ), {, return, filter, (, elmap, ., keySet]
[;, }, @, Override, public, int, size, (, ), {, return, findRoot, (, elmap, ., get, (, value, ), )]
[,, isSameRoot, ), ;, }, @, Override, public, int, size, (, ), {, return, findRoot, (, elmap, ., get, (]
[., iterator, (, ), ,, isSameRoot, ), ;, }, @, Override, public, int, size, (, ), {, return, findRoot, (]
[., keySet, (, ), ., iterator, (, ), ,, isSameRoot, ), ;, }, @, Override, public, int, size, (, )]
[), ;, }, @, Override, public, int, size, (, ), {, return, findRoot, (, elmap, ., get, (, value, )]
[;, }, }, ;, }, private, static, class, Node, <, E, >, {, Node, <, E, >, parent, ;, final]
[., size, ;, }, }, ;, }, private, static, class, Node, <, E, >, {, Node, <, E, >, parent]
[), ., size, ;, }, }, ;, }, private, static, class, Node, <, E, >, {, Node, <, E, >]
[., get, (, value, ), ), ., size, ;, }, }, ;, }, private, static, class, Node, <, E, >]
[), ), ., size, ;, }, }, ;, }, private, static, class, Node, <, E, >, {, Node, <, E]
[;, int, size, =, 1, ;, Node, (, E, element, ), {, this, ., parent, =, this, ;, this, .]
[;, Node, (, E, element, ), {, this, ., parent, =, this, ;, this, ., element, =, element, ;, }]
[=, this, ;, this, ., element, =, element, ;, }, }, }]
[., parent, =, this, ;, this, ., element, =, element, ;, }, }, }]
[;, this, ., element, =, element, ;, }, }, }]
[=, element, ;, }, }, }]
[., element, =, element, ;, }, }, }]
[;, }, }, }]
