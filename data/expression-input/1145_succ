[=, compiler, ;, this, ., replacements, =, replacements, ;, }, @, Override, public, boolean, classDefiningCallsHaveSideEffects, (, ), {, return, true]
[., compiler, =, compiler, ;, this, ., replacements, =, replacements, ;, }, @, Override, public, boolean, classDefiningCallsHaveSideEffects, (, ), {]
[;, this, ., replacements, =, replacements, ;, }, @, Override, public, boolean, classDefiningCallsHaveSideEffects, (, ), {, return, true, ;, }]
[=, replacements, ;, }, @, Override, public, boolean, classDefiningCallsHaveSideEffects, (, ), {, return, true, ;, }, @, Override, public, void]
[., replacements, =, replacements, ;, }, @, Override, public, boolean, classDefiningCallsHaveSideEffects, (, ), {, return, true, ;, }, @, Override]
[;, }, @, Override, public, boolean, classDefiningCallsHaveSideEffects, (, ), {, return, true, ;, }, @, Override, public, void, keepSubTree, (]
[;, }, @, Override, public, void, keepSubTree, (, Node, original, ), {, if, (, original, ., getParent, (, ), !=]
[), {, original, ., detachFromParent, (, ), ;, }, replacements, ., add, (, original, ), ;, }, @, Override, public]
[!=, null, ), {, original, ., detachFromParent, (, ), ;, }, replacements, ., add, (, original, ), ;, }, @]
[., getParent, (, ), !=, null, ), {, original, ., detachFromParent, (, ), ;, }, replacements, ., add, (, original]
[), {, original, ., detachFromParent, (, ), ;, }, replacements, ., add, (, original, ), ;, }, @, Override, public]
[;, }, replacements, ., add, (, original, ), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {]
[., detachFromParent, (, ), ;, }, replacements, ., add, (, original, ), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (]
[;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument, (, (, original, ., isAnd]
[., add, (, original, ), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument]
[), ;, }, @, Override, public, void, keepSimplifiedShortCircuitExpression, (, Node, original, ), {, Preconditions, ., checkArgument, (, (, original, .]
[;, Node, left, =, original, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, Node]
[., checkArgument, (, (, original, ., isAnd, (, ), ), ||, (, original, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s"]
[,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, original, ., getType, (, ), ), ), ;, Node, left, =, original, .]
[||, (, original, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, original, ., getType, (, )]
[), ||, (, original, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, original, ., getType, (]
[., isAnd, (, ), ), ||, (, original, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (]
[,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, original, ., getType, (, ), ), ), ;, Node, left, =, original, .]
[), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, original, ., getType, (, ), ), ), ;, Node, left, =, original]
[., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, original, ., getType, (, ), ), ), ;]
[,, Token, ., name, (, original, ., getType, (, ), ), ), ;, Node, left, =, original, ., getFirstChild, (]
[), ;, Node, left, =, original, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;]
[., name, (, original, ., getType, (, ), ), ), ;, Node, left, =, original, ., getFirstChild, (, ), ;]
[), ), ;, Node, left, =, original, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, )]
[., getType, (, ), ), ), ;, Node, left, =, original, ., getFirstChild, (, ), ;, Node, right, =, left]
[;, Node, right, =, left, ., getNext, (, ), ;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;, original, .]
[., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (, right]
[;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;, original, ., detachChildren, (, ), ;, original, ., addChildToBack, (, left]
[., getNext, (, ), ;, Node, simplifiedRight, =, simplifyShortCircuitBranch, (, right, ), ;, original, ., detachChildren, (, ), ;, original]
[;, original, ., detachChildren, (, ), ;, original, ., addChildToBack, (, left, ), ;, original, ., addChildToBack, (, simplifiedRight, )]
[), ;, original, ., detachChildren, (, ), ;, original, ., addChildToBack, (, left, ), ;, original, ., addChildToBack, (, simplifiedRight]
[;, original, ., addChildToBack, (, left, ), ;, original, ., addChildToBack, (, simplifiedRight, ), ;, keepSubTree, (, original, ), ;]
[., detachChildren, (, ), ;, original, ., addChildToBack, (, left, ), ;, original, ., addChildToBack, (, simplifiedRight, ), ;, keepSubTree]
[;, original, ., addChildToBack, (, simplifiedRight, ), ;, keepSubTree, (, original, ), ;, }, @, Override, public, void, keepSimplifiedHookExpression, (]
[., addChildToBack, (, left, ), ;, original, ., addChildToBack, (, simplifiedRight, ), ;, keepSubTree, (, original, ), ;, }, @]
[), ;, original, ., addChildToBack, (, simplifiedRight, ), ;, keepSubTree, (, original, ), ;, }, @, Override, public, void, keepSimplifiedHookExpression]
[;, keepSubTree, (, original, ), ;, }, @, Override, public, void, keepSimplifiedHookExpression, (, Node, hook, ,, boolean, thenHasSideEffects, ,, boolean]
[., addChildToBack, (, simplifiedRight, ), ;, keepSubTree, (, original, ), ;, }, @, Override, public, void, keepSimplifiedHookExpression, (, Node, hook]
[), ;, keepSubTree, (, original, ), ;, }, @, Override, public, void, keepSimplifiedHookExpression, (, Node, hook, ,, boolean, thenHasSideEffects, ,]
[;, }, @, Override, public, void, keepSimplifiedHookExpression, (, Node, hook, ,, boolean, thenHasSideEffects, ,, boolean, elseHasSideEffects, ), {, Preconditions, .]
[), ;, }, @, Override, public, void, keepSimplifiedHookExpression, (, Node, hook, ,, boolean, thenHasSideEffects, ,, boolean, elseHasSideEffects, ), {, Preconditions]
[;, Node, condition, =, hook, ., getFirstChild, (, ), ;, Node, thenBranch, =, condition, ., getNext, (, ), ;, Node]
[., checkArgument, (, hook, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, hook, ., getType, (, )]
[,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, hook, ., getType, (, ), ), ), ;, Node, condition, =, hook, .]
[., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, hook, ., getType, (, ), ), ), ;, Node]
[,, Token, ., name, (, hook, ., getType, (, ), ), ), ;, Node, condition, =, hook, ., getFirstChild, (]
[), ;, Node, condition, =, hook, ., getFirstChild, (, ), ;, Node, thenBranch, =, condition, ., getNext, (, ), ;]
[., name, (, hook, ., getType, (, ), ), ), ;, Node, condition, =, hook, ., getFirstChild, (, ), ;]
[), ), ;, Node, condition, =, hook, ., getFirstChild, (, ), ;, Node, thenBranch, =, condition, ., getNext, (, )]
[., getType, (, ), ), ), ;, Node, condition, =, hook, ., getFirstChild, (, ), ;, Node, thenBranch, =, condition]
[;, Node, thenBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if]
[., getFirstChild, (, ), ;, Node, thenBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext]
[;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {, hook, ., detachChildren]
[., getNext, (, ), ;, Node, elseBranch, =, thenBranch, ., getNext, (, ), ;, if, (, thenHasSideEffects, &&, elseHasSideEffects, )]
[;, if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {, hook, ., detachChildren, (, ), ;, hook, ., addChildToBack, (, condition, )]
[., getNext, (, ), ;, if, (, thenHasSideEffects, &&, elseHasSideEffects, ), {, hook, ., detachChildren, (, ), ;, hook, .]
[), {, hook, ., detachChildren, (, ), ;, hook, ., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch]
[&&, elseHasSideEffects, ), {, hook, ., detachChildren, (, ), ;, hook, ., addChildToBack, (, condition, ), ;, hook, ., addChildToBack]
[), {, hook, ., detachChildren, (, ), ;, hook, ., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch]
[;, hook, ., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;, hook, .]
[., detachChildren, (, ), ;, hook, ., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, )]
[;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), )]
[., addChildToBack, (, condition, ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;, hook, ., addChildToBack, (]
[), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, )]
[;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;, keepSubTree, (, hook, ), ;, }, else, if, (]
[., addChildToBack, (, simplifyShortCircuitBranch, (, thenBranch, ), ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;, keepSubTree]
[), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;, keepSubTree, (, hook, ), ;, }, else, if]
[), ), ;, hook, ., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;, keepSubTree, (, hook, ), ;, }, else]
[;, keepSubTree, (, hook, ), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?]
[., addChildToBack, (, simplifyShortCircuitBranch, (, elseBranch, ), ), ;, keepSubTree, (, hook, ), ;, }, else, if, (, thenHasSideEffects, ||]
[), ;, keepSubTree, (, hook, ), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects]
[), ), ;, keepSubTree, (, hook, ), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =]
[;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :, Token]
[), ;, }, else, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :]
[), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?]
[||, elseHasSideEffects, ), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :, Token, ., OR, ;, Node, body, =]
[), {, int, type, =, thenHasSideEffects, ?, Token, ., AND, :, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?]
[;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (, type, ,, condition, .]
[?, Token, ., AND, :, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified]
[:, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (]
[., AND, :, Token, ., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =, new]
[;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (, type, ,, condition, .]
[., OR, ;, Node, body, =, thenHasSideEffects, ?, thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (, type, ,]
[;, Node, simplified, =, new, Node, (, type, ,, condition, ., detachFromParent, (, ), ,, simplifyShortCircuitBranch, (, body, ), )]
[?, thenBranch, :, elseBranch, ;, Node, simplified, =, new, Node, (, type, ,, condition, ., detachFromParent, (, ), ,, simplifyShortCircuitBranch]
[:, elseBranch, ;, Node, simplified, =, new, Node, (, type, ,, condition, ., detachFromParent, (, ), ,, simplifyShortCircuitBranch, (, body]
[;, Node, simplified, =, new, Node, (, type, ,, condition, ., detachFromParent, (, ), ,, simplifyShortCircuitBranch, (, body, ), )]
[;, keepSubTree, (, simplified, ), ;, }, else, {, throw, new, IllegalArgumentException, (, "keepSimplifiedHookExpression must keep at least 1 branch", ), ;, }, }, private, Node]
[., copyInformationFrom, (, hook, ), ;, keepSubTree, (, simplified, ), ;, }, else, {, throw, new, IllegalArgumentException, (, "keepSimplifiedHookExpression must keep at least 1 branch", )]
[,, condition, ., detachFromParent, (, ), ,, simplifyShortCircuitBranch, (, body, ), ), ., copyInformationFrom, (, hook, ), ;, keepSubTree, (]
[,, simplifyShortCircuitBranch, (, body, ), ), ., copyInformationFrom, (, hook, ), ;, keepSubTree, (, simplified, ), ;, }, else, {]
[., detachFromParent, (, ), ,, simplifyShortCircuitBranch, (, body, ), ), ., copyInformationFrom, (, hook, ), ;, keepSubTree, (, simplified, )]
[), ., copyInformationFrom, (, hook, ), ;, keepSubTree, (, simplified, ), ;, }, else, {, throw, new, IllegalArgumentException, (, "keepSimplifiedHookExpression must keep at least 1 branch"]
[), ), ., copyInformationFrom, (, hook, ), ;, keepSubTree, (, simplified, ), ;, }, else, {, throw, new, IllegalArgumentException, (]
[), ;, keepSubTree, (, simplified, ), ;, }, else, {, throw, new, IllegalArgumentException, (, "keepSimplifiedHookExpression must keep at least 1 branch", ), ;, }, }, private]
[;, }, else, {, throw, new, IllegalArgumentException, (, "keepSimplifiedHookExpression must keep at least 1 branch", ), ;, }, }, private, Node, simplifyShortCircuitBranch, (, Node, node, )]
[), ;, }, else, {, throw, new, IllegalArgumentException, (, "keepSimplifiedHookExpression must keep at least 1 branch", ), ;, }, }, private, Node, simplifyShortCircuitBranch, (, Node, node]
[;, }, }, private, Node, simplifyShortCircuitBranch, (, Node, node, ), {, List, <, Node, >, parts, =, Lists, ., newArrayList]
[), ;, }, }, private, Node, simplifyShortCircuitBranch, (, Node, node, ), {, List, <, Node, >, parts, =, Lists, .]
[;, NodeTraversal, ., traverse, (, compiler, ,, node, ,, new, GatherSideEffectSubexpressionsCallback, (, compiler, ,, new, GetReplacementSideEffectSubexpressions, (, compiler, ,, parts]
[., newArrayList, (, ), ;, NodeTraversal, ., traverse, (, compiler, ,, node, ,, new, GatherSideEffectSubexpressionsCallback, (, compiler, ,, new, GetReplacementSideEffectSubexpressions]
[;, Node, ret, =, null, ;, for, (, Node, part, :, parts, ), {, if, (, ret, !=, null, )]
[., traverse, (, compiler, ,, node, ,, new, GatherSideEffectSubexpressionsCallback, (, compiler, ,, new, GetReplacementSideEffectSubexpressions, (, compiler, ,, parts, ), )]
[,, node, ,, new, GatherSideEffectSubexpressionsCallback, (, compiler, ,, new, GetReplacementSideEffectSubexpressions, (, compiler, ,, parts, ), ), ), ;, Node, ret]
[,, new, GatherSideEffectSubexpressionsCallback, (, compiler, ,, new, GetReplacementSideEffectSubexpressions, (, compiler, ,, parts, ), ), ), ;, Node, ret, =, null]
[), ;, Node, ret, =, null, ;, for, (, Node, part, :, parts, ), {, if, (, ret, !=, null]
[,, new, GetReplacementSideEffectSubexpressions, (, compiler, ,, parts, ), ), ), ;, Node, ret, =, null, ;, for, (, Node, part]
[), ), ;, Node, ret, =, null, ;, for, (, Node, part, :, parts, ), {, if, (, ret, !=]
[,, parts, ), ), ), ;, Node, ret, =, null, ;, for, (, Node, part, :, parts, ), {, if]
[), ), ), ;, Node, ret, =, null, ;, for, (, Node, part, :, parts, ), {, if, (, ret]
[;, for, (, Node, part, :, parts, ), {, if, (, ret, !=, null, ), {, ret, =, IR, .]
[), {, if, (, ret, !=, null, ), {, ret, =, IR, ., comma, (, ret, ,, part, ), .]
[), {, ret, =, IR, ., comma, (, ret, ,, part, ), ., srcref, (, node, ), ;, }, else]
[!=, null, ), {, ret, =, IR, ., comma, (, ret, ,, part, ), ., srcref, (, node, ), ;]
[), {, ret, =, IR, ., comma, (, ret, ,, part, ), ., srcref, (, node, ), ;, }, else]
[=, IR, ., comma, (, ret, ,, part, ), ., srcref, (, node, ), ;, }, else, {, ret, =]
[;, }, else, {, ret, =, part, ;, }, }, if, (, ret, ==, null, ), {, throw, new, IllegalArgumentException]
[., srcref, (, node, ), ;, }, else, {, ret, =, part, ;, }, }, if, (, ret, ==, null]
[., comma, (, ret, ,, part, ), ., srcref, (, node, ), ;, }, else, {, ret, =, part, ;]
[,, part, ), ., srcref, (, node, ), ;, }, else, {, ret, =, part, ;, }, }, if, (]
[), ., srcref, (, node, ), ;, }, else, {, ret, =, part, ;, }, }, if, (, ret, ==]
[), ;, }, else, {, ret, =, part, ;, }, }, if, (, ret, ==, null, ), {, throw, new]
[=, part, ;, }, }, if, (, ret, ==, null, ), {, throw, new, IllegalArgumentException, (, "expected at least one side effect subexpression in short ", +, "circuit branch.", )]
[;, }, }, if, (, ret, ==, null, ), {, throw, new, IllegalArgumentException, (, "expected at least one side effect subexpression in short ", +, "circuit branch.", ), ;, }]
[), {, throw, new, IllegalArgumentException, (, "expected at least one side effect subexpression in short ", +, "circuit branch.", ), ;, }, return, ret, ;, }, }, private, static, final]
[==, null, ), {, throw, new, IllegalArgumentException, (, "expected at least one side effect subexpression in short ", +, "circuit branch.", ), ;, }, return, ret, ;, }, }, private]
[), {, throw, new, IllegalArgumentException, (, "expected at least one side effect subexpression in short ", +, "circuit branch.", ), ;, }, return, ret, ;, }, }, private, static, final]
[;, }, return, ret, ;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (]
[), ;, }, return, ret, ;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of]
[+, "circuit branch.", ), ;, }, return, ret, ;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet]
[), ;, }, return, ret, ;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of]
[;, }, }, private, static, final, Set, <, Integer, >, FORBIDDEN_TYPES, =, ImmutableSet, ., of, (, Token, ., BLOCK, ,]
[;, private, final, AbstractCompiler, compiler, ;, private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler, ,, SideEffectAccumulator, accumulator, ), {]
[., of, (, Token, ., BLOCK, ,, Token, ., SCRIPT, ,, Token, ., VAR, ,, Token, ., EXPR_RESULT, ,, Token]
[,, Token, ., SCRIPT, ,, Token, ., VAR, ,, Token, ., EXPR_RESULT, ,, Token, ., RETURN, ), ;, private, final]
[., BLOCK, ,, Token, ., SCRIPT, ,, Token, ., VAR, ,, Token, ., EXPR_RESULT, ,, Token, ., RETURN, ), ;]
[,, Token, ., VAR, ,, Token, ., EXPR_RESULT, ,, Token, ., RETURN, ), ;, private, final, AbstractCompiler, compiler, ;, private]
[., SCRIPT, ,, Token, ., VAR, ,, Token, ., EXPR_RESULT, ,, Token, ., RETURN, ), ;, private, final, AbstractCompiler, compiler]
[,, Token, ., EXPR_RESULT, ,, Token, ., RETURN, ), ;, private, final, AbstractCompiler, compiler, ;, private, final, SideEffectAccumulator, accumulator, ;]
[., VAR, ,, Token, ., EXPR_RESULT, ,, Token, ., RETURN, ), ;, private, final, AbstractCompiler, compiler, ;, private, final, SideEffectAccumulator]
[,, Token, ., RETURN, ), ;, private, final, AbstractCompiler, compiler, ;, private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler]
[., EXPR_RESULT, ,, Token, ., RETURN, ), ;, private, final, AbstractCompiler, compiler, ;, private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (]
[), ;, private, final, AbstractCompiler, compiler, ;, private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler, ,, SideEffectAccumulator, accumulator, )]
[., RETURN, ), ;, private, final, AbstractCompiler, compiler, ;, private, final, SideEffectAccumulator, accumulator, ;, GatherSideEffectSubexpressionsCallback, (, AbstractCompiler, compiler, ,, SideEffectAccumulator]
[=, compiler, ;, this, ., accumulator, =, accumulator, ;, }, private, boolean, isClassDefiningCall, (, Node, callNode, ), {, SubclassRelationship, classes]
[., compiler, =, compiler, ;, this, ., accumulator, =, accumulator, ;, }, private, boolean, isClassDefiningCall, (, Node, callNode, ), {]
[;, this, ., accumulator, =, accumulator, ;, }, private, boolean, isClassDefiningCall, (, Node, callNode, ), {, SubclassRelationship, classes, =, compiler]
[=, accumulator, ;, }, private, boolean, isClassDefiningCall, (, Node, callNode, ), {, SubclassRelationship, classes, =, compiler, ., getCodingConvention, (, )]
[., accumulator, =, accumulator, ;, }, private, boolean, isClassDefiningCall, (, Node, callNode, ), {, SubclassRelationship, classes, =, compiler, ., getCodingConvention]
[;, }, private, boolean, isClassDefiningCall, (, Node, callNode, ), {, SubclassRelationship, classes, =, compiler, ., getCodingConvention, (, ), ., getClassesDefinedByCall]
[;, return, classes, !=, null, ;, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,, Node]
[., getClassesDefinedByCall, (, callNode, ), ;, return, classes, !=, null, ;, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, traversal]
[., getCodingConvention, (, ), ., getClassesDefinedByCall, (, callNode, ), ;, return, classes, !=, null, ;, }, @, Override, public, boolean]
[), ;, return, classes, !=, null, ;, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,]
[;, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, ), {, if, (]
[!=, null, ;, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, ), {]
[;, }, @, Override, public, boolean, shouldTraverse, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, ), {, if, (]
[), {, throw, new, IllegalArgumentException, (, Token, ., name, (, node, ., getType, (, ), ), +, " nodes are not supported.", ), ;]
[||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw, new, IllegalArgumentException, (, Token, ., name, (, node, ., getType]
[., contains, (, node, ., getType, (, ), ), ||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw, new]
[), ||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw, new, IllegalArgumentException, (, Token, ., name, (, node, .]
[., getType, (, ), ), ||, NodeUtil, ., isControlStructure, (, node, ), ), {, throw, new, IllegalArgumentException, (, Token, .]
[), {, throw, new, IllegalArgumentException, (, Token, ., name, (, node, ., getType, (, ), ), +, " nodes are not supported.", ), ;]
[., isControlStructure, (, node, ), ), {, throw, new, IllegalArgumentException, (, Token, ., name, (, node, ., getType, (, )]
[), ), {, throw, new, IllegalArgumentException, (, Token, ., name, (, node, ., getType, (, ), ), +, " nodes are not supported.", )]
[;, }, if, (, node, ., isFunction, (, ), ), {, return, false, ;, }, if, (, node, ., isHook]
[), ;, }, if, (, node, ., isFunction, (, ), ), {, return, false, ;, }, if, (, node, .]
[+, " nodes are not supported.", ), ;, }, if, (, node, ., isFunction, (, ), ), {, return, false, ;, }, if, (]
[., name, (, node, ., getType, (, ), ), +, " nodes are not supported.", ), ;, }, if, (, node, ., isFunction, (]
[), +, " nodes are not supported.", ), ;, }, if, (, node, ., isFunction, (, ), ), {, return, false, ;, }, if]
[., getType, (, ), ), +, " nodes are not supported.", ), ;, }, if, (, node, ., isFunction, (, ), ), {, return]
[), ;, }, if, (, node, ., isFunction, (, ), ), {, return, false, ;, }, if, (, node, .]
[), {, return, false, ;, }, if, (, node, ., isHook, (, ), ), {, return, processHook, (, node, )]
[., isFunction, (, ), ), {, return, false, ;, }, if, (, node, ., isHook, (, ), ), {, return]
[;, }, if, (, node, ., isHook, (, ), ), {, return, processHook, (, node, ), ;, }, if, (]
[), {, return, processHook, (, node, ), ;, }, if, (, (, node, ., isAnd, (, ), ), ||, (]
[., isHook, (, ), ), {, return, processHook, (, node, ), ;, }, if, (, (, node, ., isAnd, (]
[;, }, if, (, (, node, ., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), )]
[), ;, }, if, (, (, node, ., isAnd, (, ), ), ||, (, node, ., isOr, (, ), )]
[), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (, node, ,, compiler, )]
[||, (, node, ., isOr, (, ), ), ), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (, !]
[), ||, (, node, ., isOr, (, ), ), ), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (]
[., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ), {, return, processShortCircuitExpression, (, node, )]
[), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (, node, ,, compiler, )]
[), ), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (, node, ,, compiler]
[., isOr, (, ), ), ), {, return, processShortCircuitExpression, (, node, ), ;, }, if, (, !, NodeUtil, ., nodeTypeMayHaveSideEffects]
[;, }, if, (, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (, node, ,, compiler, ), ), {, return, true, ;, }, else]
[), ;, }, if, (, !, NodeUtil, ., nodeTypeMayHaveSideEffects, (, node, ,, compiler, ), ), {, return, true, ;, }]
[), {, return, true, ;, }, else, {, if, (, node, ., isCall, (, ), ), {, return, processFunctionCall, (]
[), {, return, true, ;, }, else, {, if, (, node, ., isCall, (, ), ), {, return, processFunctionCall, (]
[., nodeTypeMayHaveSideEffects, (, node, ,, compiler, ), ), {, return, true, ;, }, else, {, if, (, node, ., isCall]
[,, compiler, ), ), {, return, true, ;, }, else, {, if, (, node, ., isCall, (, ), ), {]
[), ), {, return, true, ;, }, else, {, if, (, node, ., isCall, (, ), ), {, return, processFunctionCall]
[;, }, else, {, if, (, node, ., isCall, (, ), ), {, return, processFunctionCall, (, node, ), ;, }]
[), {, return, processFunctionCall, (, node, ), ;, }, else, if, (, node, ., isNew, (, ), ), {, return]
[., isCall, (, ), ), {, return, processFunctionCall, (, node, ), ;, }, else, if, (, node, ., isNew, (]
[;, }, else, if, (, node, ., isNew, (, ), ), {, return, processConstructorCall, (, node, ), ;, }, else]
[), ;, }, else, if, (, node, ., isNew, (, ), ), {, return, processConstructorCall, (, node, ), ;, }]
[), {, return, processConstructorCall, (, node, ), ;, }, else, {, accumulator, ., keepSubTree, (, node, ), ;, return, false]
[., isNew, (, ), ), {, return, processConstructorCall, (, node, ), ;, }, else, {, accumulator, ., keepSubTree, (, node]
[;, }, else, {, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (]
[), ;, }, else, {, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression]
[;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (, (, node]
[., keepSubTree, (, node, ), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions]
[), ;, return, false, ;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (, (]
[;, }, }, }, boolean, processShortCircuitExpression, (, Node, node, ), {, Preconditions, ., checkArgument, (, (, node, ., isAnd, (]
[;, Node, left, =, node, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, if]
[., checkArgument, (, (, node, ., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s"]
[,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, left, =, node, .]
[||, (, node, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, node, ., getType, (, )]
[), ||, (, node, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, node, ., getType, (]
[., isAnd, (, ), ), ||, (, node, ., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (]
[,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, left, =, node, .]
[), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, left, =, node]
[., isOr, (, ), ), ,, "Expected: AND or OR, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;]
[,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, left, =, node, ., getFirstChild, (]
[), ;, Node, left, =, node, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;]
[., name, (, node, ., getType, (, ), ), ), ;, Node, left, =, node, ., getFirstChild, (, ), ;]
[), ), ;, Node, left, =, node, ., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, )]
[., getType, (, ), ), ), ;, Node, left, =, node, ., getFirstChild, (, ), ;, Node, right, =, left]
[;, Node, right, =, left, ., getNext, (, ), ;, if, (, NodeUtil, ., mayHaveSideEffects, (, right, ,, compiler, )]
[., getFirstChild, (, ), ;, Node, right, =, left, ., getNext, (, ), ;, if, (, NodeUtil, ., mayHaveSideEffects, (]
[;, if, (, NodeUtil, ., mayHaveSideEffects, (, right, ,, compiler, ), ), {, accumulator, ., keepSimplifiedShortCircuitExpression, (, node, ), ;]
[., getNext, (, ), ;, if, (, NodeUtil, ., mayHaveSideEffects, (, right, ,, compiler, ), ), {, accumulator, ., keepSimplifiedShortCircuitExpression]
[), {, accumulator, ., keepSimplifiedShortCircuitExpression, (, node, ), ;, return, false, ;, }, else, {, return, true, ;, }, }]
[., mayHaveSideEffects, (, right, ,, compiler, ), ), {, accumulator, ., keepSimplifiedShortCircuitExpression, (, node, ), ;, return, false, ;, }]
[,, compiler, ), ), {, accumulator, ., keepSimplifiedShortCircuitExpression, (, node, ), ;, return, false, ;, }, else, {, return, true]
[), ), {, accumulator, ., keepSimplifiedShortCircuitExpression, (, node, ), ;, return, false, ;, }, else, {, return, true, ;, }]
[;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processHook, (, Node, node, ), {, Preconditions]
[., keepSimplifiedShortCircuitExpression, (, node, ), ;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processHook, (]
[), ;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processHook, (, Node, node, ), {]
[;, }, else, {, return, true, ;, }, }, boolean, processHook, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[;, }, }, boolean, processHook, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isHook, (, ), ,]
[;, Node, condition, =, node, ., getFirstChild, (, ), ;, Node, ifBranch, =, condition, ., getNext, (, ), ;, Node]
[., checkArgument, (, node, ., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, node, ., getType, (, )]
[,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, condition, =, node, .]
[., isHook, (, ), ,, "Expected: HOOK, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node]
[,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, condition, =, node, ., getFirstChild, (]
[), ;, Node, condition, =, node, ., getFirstChild, (, ), ;, Node, ifBranch, =, condition, ., getNext, (, ), ;]
[., name, (, node, ., getType, (, ), ), ), ;, Node, condition, =, node, ., getFirstChild, (, ), ;]
[), ), ;, Node, condition, =, node, ., getFirstChild, (, ), ;, Node, ifBranch, =, condition, ., getNext, (, )]
[., getType, (, ), ), ), ;, Node, condition, =, node, ., getFirstChild, (, ), ;, Node, ifBranch, =, condition]
[;, Node, ifBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =, ifBranch, ., getNext, (, ), ;, boolean]
[., getFirstChild, (, ), ;, Node, ifBranch, =, condition, ., getNext, (, ), ;, Node, elseBranch, =, ifBranch, ., getNext]
[;, Node, elseBranch, =, ifBranch, ., getNext, (, ), ;, boolean, thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, ifBranch, ,, compiler]
[., getNext, (, ), ;, Node, elseBranch, =, ifBranch, ., getNext, (, ), ;, boolean, thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects]
[;, boolean, thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, ifBranch, ,, compiler, ), ;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (]
[., getNext, (, ), ;, boolean, thenHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, ifBranch, ,, compiler, ), ;, boolean, elseHasSideEffects, =]
[;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {]
[., mayHaveSideEffects, (, ifBranch, ,, compiler, ), ;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;]
[,, compiler, ), ;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||]
[), ;, boolean, elseHasSideEffects, =, NodeUtil, ., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, )]
[;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,, elseHasSideEffects, ), ;, return]
[., mayHaveSideEffects, (, elseBranch, ,, compiler, ), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, accumulator, ., keepSimplifiedHookExpression, (, node]
[,, compiler, ), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,, elseHasSideEffects]
[), ;, if, (, thenHasSideEffects, ||, elseHasSideEffects, ), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,, elseHasSideEffects, ), ;]
[), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,, elseHasSideEffects, ), ;, return, false, ;, }, else, {, return]
[||, elseHasSideEffects, ), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,, elseHasSideEffects, ), ;, return, false, ;, }, else]
[), {, accumulator, ., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,, elseHasSideEffects, ), ;, return, false, ;, }, else, {, return]
[;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processFunctionCall, (, Node, node, ), {, Preconditions]
[., keepSimplifiedHookExpression, (, node, ,, thenHasSideEffects, ,, elseHasSideEffects, ), ;, return, false, ;, }, else, {, return, true, ;, }]
[,, thenHasSideEffects, ,, elseHasSideEffects, ), ;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processFunctionCall, (]
[,, elseHasSideEffects, ), ;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processFunctionCall, (, Node, node]
[), ;, return, false, ;, }, else, {, return, true, ;, }, }, boolean, processFunctionCall, (, Node, node, ), {]
[;, }, else, {, return, true, ;, }, }, boolean, processFunctionCall, (, Node, node, ), {, Preconditions, ., checkArgument, (]
[;, }, }, boolean, processFunctionCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isCall, (, ), ,]
[;, Node, functionName, =, node, ., getFirstChild, (, ), ;, if, (, functionName, ., isName, (, ), ||, functionName, .]
[., checkArgument, (, node, ., isCall, (, ), ,, "Expected: CALL, Got: %s", ,, Token, ., name, (, node, ., getType, (, )]
[,, "Expected: CALL, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, functionName, =, node, .]
[., isCall, (, ), ,, "Expected: CALL, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node]
[,, Token, ., name, (, node, ., getType, (, ), ), ), ;, Node, functionName, =, node, ., getFirstChild, (]
[), ;, Node, functionName, =, node, ., getFirstChild, (, ), ;, if, (, functionName, ., isName, (, ), ||, functionName]
[., name, (, node, ., getType, (, ), ), ), ;, Node, functionName, =, node, ., getFirstChild, (, ), ;]
[), ), ;, Node, functionName, =, node, ., getFirstChild, (, ), ;, if, (, functionName, ., isName, (, ), ||]
[., getType, (, ), ), ), ;, Node, functionName, =, node, ., getFirstChild, (, ), ;, if, (, functionName, .]
[;, if, (, functionName, ., isName, (, ), ||, functionName, ., isGetProp, (, ), ), {, if, (, !, accumulator]
[., getFirstChild, (, ), ;, if, (, functionName, ., isName, (, ), ||, functionName, ., isGetProp, (, ), ), {]
[), {, if, (, !, accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (, node, ), ), {, return, true, ;]
[||, functionName, ., isGetProp, (, ), ), {, if, (, !, accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (, node]
[., isName, (, ), ||, functionName, ., isGetProp, (, ), ), {, if, (, !, accumulator, ., classDefiningCallsHaveSideEffects, (, )]
[), {, if, (, !, accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (, node, ), ), {, return, true, ;]
[., isGetProp, (, ), ), {, if, (, !, accumulator, ., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (, node, ), )]
[), {, return, true, ;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node, ), ), {, return, true]
[&&, isClassDefiningCall, (, node, ), ), {, return, true, ;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node]
[&&, isClassDefiningCall, (, node, ), ), {, return, true, ;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node]
[., classDefiningCallsHaveSideEffects, (, ), &&, isClassDefiningCall, (, node, ), ), {, return, true, ;, }, }, if, (, !, NodeUtil]
[), {, return, true, ;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node, ), ), {, return, true]
[), ), {, return, true, ;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node, ), ), {, return]
[;, }, }, if, (, !, NodeUtil, ., functionCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, .]
[), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, boolean, processConstructorCall, (]
[), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, boolean, processConstructorCall, (]
[., functionCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false]
[), ), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, boolean, processConstructorCall]
[;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, boolean, processConstructorCall, (, Node, node, ), {]
[;, return, false, ;, }, boolean, processConstructorCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isNew, (]
[., keepSubTree, (, node, ), ;, return, false, ;, }, boolean, processConstructorCall, (, Node, node, ), {, Preconditions, ., checkArgument]
[), ;, return, false, ;, }, boolean, processConstructorCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isNew]
[;, }, boolean, processConstructorCall, (, Node, node, ), {, Preconditions, ., checkArgument, (, node, ., isNew, (, ), ,, "Expected: NEW, Got: %s"]
[;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, ., keepSubTree, (]
[., checkArgument, (, node, ., isNew, (, ), ,, "Expected: NEW, Got: %s", ,, Token, ., name, (, node, ., getType, (, )]
[,, "Expected: NEW, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, if, (, !, NodeUtil, .]
[., isNew, (, ), ,, "Expected: NEW, Got: %s", ,, Token, ., name, (, node, ., getType, (, ), ), ), ;, if]
[,, Token, ., name, (, node, ., getType, (, ), ), ), ;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (]
[), ;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, ., keepSubTree]
[., name, (, node, ., getType, (, ), ), ), ;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (, node, )]
[), ), ;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, .]
[., getType, (, ), ), ), ;, if, (, !, NodeUtil, ., constructorCallHasSideEffects, (, node, ), ), {, return, true]
[), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, @, Override, public]
[), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, @, Override, public]
[., constructorCallHasSideEffects, (, node, ), ), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false]
[), ), {, return, true, ;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, @, Override]
[;, }, accumulator, ., keepSubTree, (, node, ), ;, return, false, ;, }, @, Override, public, void, visit, (, NodeTraversal]
[;, return, false, ;, }, @, Override, public, void, visit, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, )]
[., keepSubTree, (, node, ), ;, return, false, ;, }, @, Override, public, void, visit, (, NodeTraversal, traversal, ,, Node]
[), ;, return, false, ;, }, @, Override, public, void, visit, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent]
[;, }, @, Override, public, void, visit, (, NodeTraversal, traversal, ,, Node, node, ,, Node, parent, ), {, }, }]
